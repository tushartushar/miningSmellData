Implementation smell,Namespace,Class,File,Method,Description
Long Method,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,MapToDotNetValue,The method has 155 lines of code.
Long Method,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ReadBsonType,The method has 207 lines of code.
Long Method,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The method has 147 lines of code.
Long Method,MongoDB.Bson.IO,JsonScanner,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonScanner.cs,GetNumberToken,The method has 266 lines of code.
Long Method,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetCollectionSerializer,The method has 134 lines of code.
Long Method,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,Freeze,The method has 138 lines of code.
Long Method,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,DeserializeClass,The method has 171 lines of code.
Complex Method,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,TryParse,Cyclomatic complexity of the method is 12
Complex Method,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,TryParse,Cyclomatic complexity of the method is 8
Complex Method,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,MapToBsonValue,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,TryMapToBsonValue,Cyclomatic complexity of the method is 10
Complex Method,MongoDB.Bson.IO,InputBufferChunkSource,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\InputBufferChunkSource.cs,InputBufferChunkSource,Cyclomatic complexity of the method is 8
Complex Method,MongoDB.Bson.IO,OutputBufferChunkSource,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\OutputBufferChunkSource.cs,OutputBufferChunkSource,Cyclomatic complexity of the method is 8
Complex Method,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ReadBsonType,Cyclomatic complexity of the method is 14
Complex Method,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ReadEndArray,Cyclomatic complexity of the method is 8
Complex Method,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ReadEndDocument,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetSerializer,Cyclomatic complexity of the method is 8
Complex Method,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetCollectionSerializer,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,Freeze,Cyclomatic complexity of the method is 18
Complex Method,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,DeserializeClass,Cyclomatic complexity of the method is 17
Complex Method,MongoDB.Bson.Serialization,BsonSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonSerializer.cs,LookupActualType,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Bson.Serialization,TypeMappingSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\TypeMappingSerializationProvider.cs,RegisterMapping,Cyclomatic complexity of the method is 8
Complex Method,MongoDB.Bson.Serialization,TypeNameDiscriminator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\TypeNameDiscriminator.cs,GetActualType,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Bson.Serialization,TypeNameDiscriminator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\TypeNameDiscriminator.cs,GetDiscriminator,Cyclomatic complexity of the method is 10
Complex Method,MongoDB.Bson.Serialization.Conventions,ImmutableTypeClassMapConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\ImmutableTypeClassMapConvention.cs,Apply,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Bson.Serialization.Serializers,ThreeDimensionalArraySerializer<TItem>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ThreeDimensionalArraySerializer.cs,DeserializeValue,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Bson.Serialization.Serializers,TupleSerializer<T1;T2;T3;T4;T5;T6;T7>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TupleSerializers.cs,TupleSerializer,Cyclomatic complexity of the method is 8
Complex Method,MongoDB.Bson.Serialization.Serializers,TupleSerializer<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TupleSerializers.cs,TupleSerializer,Cyclomatic complexity of the method is 9
Long Parameter List,MongoDB.Bson,BsonExtensionMethods,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonExtensionMethods.cs,ToBson,The method has 5 parameters. Parameters: obj' serializer' writerSettings' configurator' args
Long Parameter List,MongoDB.Bson,BsonExtensionMethods,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonExtensionMethods.cs,ToBson,The method has 6 parameters. Parameters: obj' nominalType' writerSettings' serializer' configurator' args
Long Parameter List,MongoDB.Bson,BsonExtensionMethods,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonExtensionMethods.cs,ToBsonDocument,The method has 5 parameters. Parameters: obj' nominalType' serializer' configurator' args
Long Parameter List,MongoDB.Bson,BsonExtensionMethods,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonExtensionMethods.cs,ToJson,The method has 5 parameters. Parameters: obj' writerSettings' serializer' configurator' args
Long Parameter List,MongoDB.Bson,BsonExtensionMethods,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonExtensionMethods.cs,ToJson,The method has 6 parameters. Parameters: obj' nominalType' writerSettings' serializer' configurator' args
Long Parameter List,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The method has 5 parameters. Parameters: bytes' timestamp' machine' pid' increment
Long Parameter List,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The method has 5 parameters. Parameters: bytes' offset' a' b' c
Long Parameter List,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,MongoDB.Bson.IO,BsonDocumentReaderBookmark,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonDocumentReaderBookmark.cs,BsonDocumentReaderBookmark,The method has 5 parameters. Parameters: state' currentBsonType' currentName' context' currentValue
Long Parameter List,MongoDB.Bson.IO,BsonDocumentReaderContext,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonDocumentReaderContext.cs,BsonDocumentReaderContext,The method has 5 parameters. Parameters: parentContext' contextType' document' array' index
Long Parameter List,MongoDB.Bson.IO,JsonReaderBookmark,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReaderBookmark.cs,JsonReaderBookmark,The method has 8 parameters. Parameters: state' currentBsonType' currentName' context' currentToken' currentValue' pushedToken' position
Long Parameter List,MongoDB.Bson.IO,BsonBinaryReaderBookmark,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReaderBookmark.cs,BsonBinaryReaderBookmark,The method has 5 parameters. Parameters: state' currentBsonType' currentName' context' position
Long Parameter List,MongoDB.Bson.Serialization,BsonSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonSerializer.cs,Serialize,The method has 5 parameters. Parameters: bsonWriter' nominalType' value' configurator' args
Long Parameter List,MongoDB.Bson.Serialization.Serializers,TupleSerializer<T1;T2;T3;T4;T5>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TupleSerializers.cs,TupleSerializer,The method has 5 parameters. Parameters: item1Serializer' item2Serializer' item3Serializer' item4Serializer' item5Serializer
Long Parameter List,MongoDB.Bson.Serialization.Serializers,TupleSerializer<T1;T2;T3;T4;T5;T6>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TupleSerializers.cs,TupleSerializer,The method has 6 parameters. Parameters: item1Serializer' item2Serializer' item3Serializer' item4Serializer' item5Serializer' item6Serializer
Long Parameter List,MongoDB.Bson.Serialization.Serializers,TupleSerializer<T1;T2;T3;T4;T5;T6;T7>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TupleSerializers.cs,TupleSerializer,The method has 7 parameters. Parameters: item1Serializer' item2Serializer' item3Serializer' item4Serializer' item5Serializer' item6Serializer' item7Serializer
Long Parameter List,MongoDB.Bson.Serialization.Serializers,TupleSerializer<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TupleSerializers.cs,TupleSerializer,The method has 8 parameters. Parameters: item1Serializer' item2Serializer' item3Serializer' item4Serializer' item5Serializer' item6Serializer' item7Serializer' restSerializer
Long Identifier,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ClampOrRound,The length of the parameter numberOfTrailingZeroesToRemove is 30.
Long Identifier,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ClampOrRound,The length of the parameter numberOfTrailingZeroesToRemove is 30.
Long Identifier,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToStringWithoutExponentialNotation,The length of the parameter minimumCoefficientStringLength is 30.
Long Identifier,MongoDB.Bson,BsonDefaults,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonDefaults.cs,,The length of the parameter __dynamicArraySerializerWasSet is 30.
Long Identifier,MongoDB.Bson,BsonDefaults,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonDefaults.cs,,The length of the parameter __dynamicDocumentSerializerWasSet is 33.
Long Identifier,MongoDB.Bson,BsonConstants,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonConstants.cs,,The length of the parameter __dateTimeMaxValueMillisecondsSinceEpoch is 40.
Long Identifier,MongoDB.Bson,BsonConstants,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonConstants.cs,,The length of the parameter __dateTimeMinValueMillisecondsSinceEpoch is 40.
Long Identifier,MongoDB.Bson.IO,OutputBufferChunkSource,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\OutputBufferChunkSource.cs,,The length of the parameter DefaultInitialUnpooledChunkSize is 31.
Long Identifier,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,,The length of the parameter __variableLengthIso8601Formats is 30.
Long Identifier,MongoDB.Bson.IO,BsonBinaryReaderSettings,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReaderSettings.cs,,The length of the parameter _fixOldDateTimeMaxValueOnInput is 30.
Long Identifier,MongoDB.Bson.IO,BsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonWriter.cs,,The length of the parameter _childElementNameValidatorFactory is 33.
Long Identifier,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetSerializer,The length of the parameter twoDimensionalArraySerializerDefinition is 39.
Long Identifier,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetSerializer,The length of the parameter threeDimensionalArraySerializerDefinition is 41.
Long Identifier,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetCollectionSerializer,The length of the parameter implementedGenericDictionaryInterface is 37.
Long Identifier,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetCollectionSerializer,The length of the parameter implementedGenericEnumerableInterface is 37.
Long Identifier,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetCollectionSerializer,The length of the parameter implementedGenericSetInterface is 30.
Long Identifier,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetCollectionSerializer,The length of the parameter implementedDictionaryInterface is 30.
Long Identifier,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetCollectionSerializer,The length of the parameter implementedEnumerableInterface is 30.
Long Identifier,MongoDB.Bson.Serialization,BsonSerializerRegistry,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonSerializerRegistry.cs,CreateSerializer,The length of the parameter registryAwareSerializationProvider is 34.
Long Identifier,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,SetIgnoreExtraElementsIsInherited,The length of the parameter ignoreExtraElementsIsInherited is 30.
Long Identifier,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,,The length of the parameter __getUninitializedObjectMethodInfo is 34.
Long Identifier,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,,The length of the parameter _ignoreExtraElementsIsInherited is 31.
Long Identifier,MongoDB.Bson.Serialization,BsonMemberMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonMemberMap.cs,GetSerializer,The length of the parameter csharpNullSerializerDefinition is 30.
Long Identifier,MongoDB.Bson.Serialization,BsonSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonSerializer.cs,,The length of the parameter __typeMappingSerializationProvider is 34.
Long Identifier,MongoDB.Bson.Serialization,BsonSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonSerializer.cs,,The length of the parameter __typesWithRegisteredKnownTypes is 31.
Long Identifier,MongoDB.Bson.Serialization.Attributes,BsonDictionaryOptionsAttribute,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Attributes\BsonDictionaryOptionsAttribute.cs,Apply,The length of the parameter dictionaryRepresentationConfigurable is 36.
Long Identifier,MongoDB.Bson.Serialization.Attributes,BsonRepresentationAttribute,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Attributes\BsonRepresentationAttribute.cs,Apply,The length of the parameter dictionaryRepresentationConfigurable is 36.
Long Identifier,MongoDB.Bson.Serialization.Conventions,EnumRepresentationConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\EnumRepresentationConvention.cs,Apply,The length of the parameter representationConfigurableSerializer is 36.
Long Identifier,MongoDB.Bson.Serialization.Conventions,EnumRepresentationConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\EnumRepresentationConvention.cs,Apply,The length of the parameter childSerializerConfigurableSerializer is 37.
Long Identifier,MongoDB.Bson.Serialization.Conventions,EnumRepresentationConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\EnumRepresentationConvention.cs,Apply,The length of the parameter representationConfigurableChildSerializer is 41.
Long Statement,MongoDB.Bson,BsonExtensionMethods,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonExtensionMethods.cs,ToBson,The length of the statement  "                var message = string.Format("Serializer type {0} value type does not match document types {1}."' serializer.GetType().FullName' nominalType.FullName); " is 150.
Long Statement,MongoDB.Bson,BsonExtensionMethods,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonExtensionMethods.cs,ToBsonDocument,The length of the statement  "                var message = string.Format("Serializer type {0} value type does not match document types {1}."' serializer.GetType().FullName' nominalType.FullName); " is 150.
Long Statement,MongoDB.Bson,BsonExtensionMethods,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonExtensionMethods.cs,ToJson,The length of the statement  "                var message = string.Format("Serializer type {0} value type does not match document types {1}."' serializer.GetType().FullName' nominalType.FullName); " is 150.
Long Statement,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToInt16,The length of the statement  "                    return Decimal128.IsNegative(d) ? (value == maxNegativeValue ? short.MinValue : (short )(-(short)value)) : (short)value; " is 120.
Long Statement,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,TryParse,The length of the statement  "                significandString = significandString.Substring(0' decimalPointIndex) + significandString.Substring(decimalPointIndex + 1); " is 123.
Long Statement,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapExponentToDecimal128BiasedExponent,The length of the statement  "            // internally we use a different bias than IEEE so that a Decimal128 struct filled with zero bytes is a true Decimal128 zero " is 124.
Long Statement,MongoDB.Bson,Flags,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,IsSecondForm,The length of the statement  "                return secondFormLeadingBits >= Flags.SecondFormLeadingBitsMin & secondFormLeadingBits <= Flags.SecondFormLeadingBitsMax; " is 121.
Long Statement,MongoDB.Bson,BsonDateTime,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDateTime.cs,ToString,The length of the statement  "                return BsonUtils.ToDateTimeFromMillisecondsSinceEpoch(_millisecondsSinceEpoch).ToString("yyyy-MM-ddTHH:mm:ss.FFFFFFFK"); " is 120.
Long Statement,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The length of the statement  "                throw new ArgumentOutOfRangeException("machine"' "The machine value must be between 0 and 16777215 (it must fit in 3 bytes)."); " is 127.
Long Statement,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The length of the statement  "                throw new ArgumentOutOfRangeException("increment"' "The increment value must be between 0 and 16777215 (it must fit in 3 bytes)."); " is 131.
Long Statement,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,GetTimestampFromDateTime,The length of the statement  "            var secondsSinceEpoch = (long)Math.Floor((BsonUtils.ToUniversalTime(timestamp) - BsonConstants.UnixEpoch).TotalSeconds); " is 120.
Long Statement,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,MapToDotNetValue,The length of the statement  "                        var message = string.Format("A BsonArray can't be mapped to a {0}."' BsonUtils.GetFriendlyTypeName(options.MapBsonArrayTo)); " is 124.
Long Statement,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,MapToDotNetValue,The length of the statement  "                    else if (bsonBinaryData.SubType == BsonBinarySubType.UuidLegacy || bsonBinaryData.SubType == BsonBinarySubType.UuidStandard) " is 124.
Long Statement,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,MapToDotNetValue,The length of the statement  "                        var message = string.Format("A BsonDocument can't be mapped to a {0}."' BsonUtils.GetFriendlyTypeName(options.MapBsonArrayTo)); " is 127.
Long Statement,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,Convert,The length of the statement  "                case Conversion.BsonJavaScriptToBsonJavaScriptWithScope: return new BsonJavaScriptWithScope(((BsonJavaScript)value).Code' new BsonDocument()); " is 142.
Long Statement,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,Convert,The length of the statement  "                case Conversion.Decimal128ToBsonBoolean: var d128 = (Decimal128)value; return (BsonBoolean)(!(Decimal128.IsNaN(d128) || d128 == Decimal128.Zero)); " is 146.
Long Statement,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,Convert,The length of the statement  "                    var dt = DateTime.ParseExact((string)value' formats' null' DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal); " is 126.
Long Statement,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,AddRange,The length of the statement  "                    throw new ArgumentOutOfRangeException("dictionary"' "One or more keys in the dictionary passed to BsonDocument.AddRange is not a string."); " is 139.
Long Statement,MongoDB.Bson.IO,MultiChunkBuffer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\MultiChunkBuffer.cs,ExpandCapacity,The length of the statement  "                throw new InvalidOperationException("Capacity cannot be expanded because this buffer was created without specifying a chunk source."); " is 134.
Long Statement,MongoDB.Bson.IO,BsonDocumentWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonDocumentWriter.cs,WriteStartDocument,The length of the statement  "            if (State != BsonWriterState.Initial && State != BsonWriterState.Value && State != BsonWriterState.ScopeDocument && State != BsonWriterState.Done) " is 146.
Long Statement,MongoDB.Bson.IO,BsonDocumentWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonDocumentWriter.cs,WriteStartDocument,The length of the statement  "                ThrowInvalidState("WriteStartDocument"' BsonWriterState.Initial' BsonWriterState.Value' BsonWriterState.ScopeDocument' BsonWriterState.Done); " is 141.
Long Statement,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,GetBookmark,The length of the statement  "            return new JsonReaderBookmark(State' CurrentBsonType' CurrentName' _context' _currentToken' _currentValue' _pushedToken' _buffer.Position); " is 139.
Long Statement,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseISODateTimeConstructor,The length of the statement  "            var utcDateTime = DateTime.ParseExact(value' formats' null' DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal); " is 127.
Long Statement,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeExtendedJson,The length of the statement  "                else if (millisecondsSinceEpochToken.Type == JsonTokenType.Int32 || millisecondsSinceEpochToken.Type == JsonTokenType.Int64) " is 124.
Long Statement,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeExtendedJson,The length of the statement  "                    var message = string.Format("JSON reader expected an integer or a string for {{ $date : {{ $numberLong : ... }} }} but found a '{0}'."' valueToken.Lexeme); " is 155.
Long Statement,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeExtendedJson,The length of the statement  "                var message = string.Format("JSON reader expected an ISO 8601 string' an integer' or {{ $numberLong : ... }} for $date but found a '{0}'."' valueToken.Lexeme); " is 159.
Long Statement,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The length of the statement  "                            var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o")); " is 122.
Long Statement,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The length of the statement  "                    var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString); " is 137.
Long Statement,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseUUIDConstructor,The length of the statement  "            var subType = (guidRepresentation == GuidRepresentation.Standard) ? BsonBinarySubType.UuidStandard : BsonBinarySubType.UuidLegacy; " is 130.
Long Statement,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,VerifyString,The length of the statement  "            if ((token.Type != JsonTokenType.String && token.Type != JsonTokenType.UnquotedString) || token.StringValue != expectedString) " is 126.
Long Statement,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,ReadBsonType,The length of the statement  "                    var message = ex.Message.Substring(0' periodIndex) + $" for fieldname \"{dottedElementName}\"" + ex.Message.Substring(periodIndex); " is 131.
Long Statement,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,ReadSize,The length of the statement  "                var message = string.Format("Size {0} is not valid because it is larger than MaxDocumentSize {1}."' size' _settings.MaxDocumentSize); " is 133.
Long Statement,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,WriteBinaryData,The length of the statement  "                    _textWriter.Write("{{ \"$binary\" : \"{0}\"' \"$type\" : \"{1}\" }}"' Convert.ToBase64String(bytes)' ((int)subType).ToString("x2")); " is 132.
Long Statement,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,WriteRegularExpression,The length of the statement  "                    _textWriter.Write("{{ \"$regex\" : \"{0}\"' \"$options\" : \"{1}\" }}"' EscapedString(pattern)' EscapedString(options)); " is 120.
Long Statement,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The length of the statement  "                var message = string.Format("GuidRepresentation for binary subtype UuidStandard must be Standard' not {0}."' guidRepresentation); " is 129.
Long Statement,MongoDB.Bson.IO,BsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonWriter.cs,WriteStartArray,The length of the statement  "                throw new BsonSerializationException("Maximum serialization depth exceeded (does the object being serialized have a circular reference?)."); " is 140.
Long Statement,MongoDB.Bson.IO,BsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonWriter.cs,WriteStartDocument,The length of the statement  "                throw new BsonSerializationException("Maximum serialization depth exceeded (does the object being serialized have a circular reference?)."); " is 140.
Long Statement,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteBinaryData,The length of the statement  "                        var expectedSubType = (Settings.GuidRepresentation == GuidRepresentation.Standard) ? BsonBinarySubType.UuidStandard : BsonBinarySubType.UuidLegacy; " is 147.
Long Statement,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteBinaryData,The length of the statement  "                                "The GuidRepresentation for the writer is {0}' which requires the the guidRepresentation argument to also be {0}' not {1}."' " is 124.
Long Statement,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteRawBsonDocument,The length of the statement  "            if (State != BsonWriterState.Initial && State != BsonWriterState.Value && State != BsonWriterState.ScopeDocument && State != BsonWriterState.Done) " is 146.
Long Statement,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteRawBsonDocument,The length of the statement  "                ThrowInvalidState("WriteRawBsonDocument"' BsonWriterState.Initial' BsonWriterState.Value' BsonWriterState.ScopeDocument' BsonWriterState.Done); " is 143.
Long Statement,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteStartDocument,The length of the statement  "            if (State != BsonWriterState.Initial && State != BsonWriterState.Value && State != BsonWriterState.ScopeDocument && State != BsonWriterState.Done) " is 146.
Long Statement,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteStartDocument,The length of the statement  "                ThrowInvalidState("WriteStartDocument"' BsonWriterState.Initial' BsonWriterState.Value' BsonWriterState.ScopeDocument' BsonWriterState.Done); " is 141.
Long Statement,MongoDB.Bson.Serialization,BsonCreatorMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonCreatorMap.cs,Freeze,The length of the statement  "                        throw new BsonSerializationException($"Creator map for class {_classMap.ClassType.FullName} has {expectedArgumentsCount} arguments' not {_arguments.Count}."); " is 158.
Long Statement,MongoDB.Bson.Serialization,BsonCreatorMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonCreatorMap.cs,Freeze,The length of the statement  "                        throw new BsonSerializationException($"Creator map for class {_classMap.ClassType.FullName} has {expectedArgumentsCount} arguments' but none are configured."); " is 159.
Long Statement,MongoDB.Bson.Serialization,BsonCreatorMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonCreatorMap.cs,SetArguments,The length of the statement  "                throw new ArgumentException($"Creator map for class {_classMap.ClassType.FullName} has {expectedArgumentsCount} arguments' not {argumentsList.Count}."' nameof(arguments)); " is 171.
Long Statement,MongoDB.Bson.Serialization,BsonCreatorMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonCreatorMap.cs,SetArguments,The length of the statement  "                    var message = string.Format("Class '{0}' does not have a member named '{1}'."' _classMap.ClassType.FullName' argumentName); " is 123.
Long Statement,MongoDB.Bson.Serialization,BsonCreatorMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonCreatorMap.cs,SetArguments,The length of the statement  "                    var message = string.Format("Class '{0}' has more than one member named '{1}'."' _classMap.ClassType.FullName' argumentName); " is 125.
Long Statement,MongoDB.Bson.Serialization,Builder,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonDeserializationContext.cs,Build,The length of the statement  "                return new BsonDeserializationContext(_reader' _allowDuplicateElementNames' _dynamicArraySerializer' _dynamicDocumentSerializer); " is 129.
Long Statement,MongoDB.Bson.Serialization,CreatorMapDelegateCompiler,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CreatorMapDelegateCompiler.cs,VisitParameter,The length of the statement  "                throw new BsonSerializationException("The only operations allowed on the prototype parameter are accessing a field or property."); " is 130.
Long Statement,MongoDB.Bson.Serialization,BsonSerializerRegistry,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonSerializerRegistry.cs,RegisterSerializer,The length of the statement  "                var message = string.Format("A serializer cannot be registered for type {0} because it is a subclass of BsonValue."' BsonUtils.GetFriendlyTypeName(type)); " is 154.
Long Statement,MongoDB.Bson.Serialization,BsonSerializerRegistry,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonSerializerRegistry.cs,RegisterSerializer,The length of the statement  "                var message = string.Format("There is already a serializer registered for type {0}."' BsonUtils.GetFriendlyTypeName(type)); " is 123.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,Freeze,The length of the statement  "                        _declaredMemberMaps = _declaredMemberMaps.OrderBy(m => m.Order).ToList(); // we're counting on OrderBy being a stable sort " is 122.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,Freeze,The length of the statement  "                                        fieldOrProperty' memberMap.MemberName' _classType.FullName' memberMap.ElementName' conflictingFieldOrProperty' conflictingMemberMap.MemberName); " is 144.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,Freeze,The length of the statement  "                                        "The {0} '{1}' of type '{2}' cannot use element name '{3}' because it is already being used by {4} '{5}' of type '{6}'."' " is 121.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,Freeze,The length of the statement  "                                        fieldOrProperty' memberMap.MemberName' _classType.FullName' memberMap.ElementName' conflictingFieldOrProperty' conflictingMemberMap.MemberName' conflictingType.FullName); " is 170.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,MapField,The length of the statement  "            var fieldInfo = _classType.GetTypeInfo().GetField(fieldName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 159.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,MapProperty,The length of the statement  "            var propertyInfo = _classType.GetTypeInfo().GetProperty(propertyName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 168.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,MapProperty,The length of the statement  "                var message = string.Format("The class '{0}' does not have a property named '{1}'."' _classType.FullName' propertyName); " is 120.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,SetExtraElementsMember,The length of the statement  "            if (memberMap.MemberType != typeof(BsonDocument) && !typeof(IDictionary<string' object>).GetTypeInfo().IsAssignableFrom(memberMap.MemberType)) " is 142.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,SetExtraElementsMember,The length of the statement  "                var message = string.Format("Type of ExtraElements member must be BsonDocument or implement IDictionary<string' object>."); " is 123.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,AddKnownType,The length of the statement  "                string message = string.Format("Class {0} cannot be assigned to Class {1}.  Ensure that known types are derived from the mapped class."' type.FullName' _classType.FullName); " is 173.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,UnmapField,The length of the statement  "            var fieldInfo = _classType.GetTypeInfo().GetField(fieldName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 159.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,UnmapProperty,The length of the statement  "            var propertyInfo = _classType.GetTypeInfo().GetProperty(propertyName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly); " is 168.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,UnmapProperty,The length of the statement  "                var message = string.Format("The class '{0}' does not have a property named '{1}'."' _classType.FullName' propertyName); " is 120.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,GetShouldSerializeMethod,The length of the statement  "                var lambdaExpression = Expression.Lambda<Func<object' bool>>(Expression.Call(Expression.Convert(objParameter' _classType)' shouldSerializeMethodInfo)' objParameter); " is 165.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,ThrowFrozenException,The length of the statement  "            var message = string.Format("Class map for {0} has been frozen and no further changes are allowed."' _classType.FullName); " is 122.
Long Statement,MongoDB.Bson.Serialization,BsonClassMap<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMap.cs,FindPropertyImplementation,The length of the statement  "            var explicitlyImplementedPropertyName = $"{interfacePropertyInfo.DeclaringType.FullName}.{interfacePropertyInfo.Name}".Replace("+"' "."); " is 137.
Long Statement,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,DeserializeClass,The length of the statement  "                var memberMapBlock = ~memberMapBitArray[bitArrayIndex]; // notice that bits are flipped so 1's are now the missing elements " is 123.
Long Statement,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,DeserializeMemberValue,The length of the statement  "                    memberMap.MemberName' (memberMap.MemberInfo is FieldInfo) ? "field" : "property"' memberMap.ClassMap.ClassType.FullName' ex.Message); " is 133.
Long Statement,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,ShouldSerializeDiscriminator,The length of the statement  "            return (nominalType != _classMap.ClassType || _classMap.DiscriminatorIsRequired || _classMap.HasRootClass) && !_classMap.IsAnonymous; " is 133.
Long Statement,MongoDB.Bson.Serialization,BsonMemberMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonMemberMap.cs,SetIgnoreIfDefault,The length of the statement  "                throw new InvalidOperationException("IgnoreIfDefault and IgnoreIfNull are mutually exclusive. Choose one or the other."); " is 121.
Long Statement,MongoDB.Bson.Serialization,BsonMemberMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonMemberMap.cs,SetIgnoreIfNull,The length of the statement  "                throw new InvalidOperationException("IgnoreIfDefault and IgnoreIfNull are mutually exclusive. Choose one or the other."); " is 121.
Long Statement,MongoDB.Bson.Serialization,BsonMemberMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonMemberMap.cs,SetSerializer,The length of the statement  "                var message = string.Format("Value type of serializer is {0} and does not match member type {1}."' serializer.ValueType.FullName' _memberType.FullName); " is 152.
Long Statement,MongoDB.Bson.Serialization,BsonMemberMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonMemberMap.cs,GetFieldSetter,The length of the statement  "                    "The field '{0} {1}' of class '{2}' is readonly. To avoid this exception' call IsReadOnly to ensure that setting a value is allowed."' " is 134.
Long Statement,MongoDB.Bson.Serialization,BsonMemberMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonMemberMap.cs,GetPropertySetter,The length of the statement  "                    "The property '{0} {1}' of class '{2}' has no 'set' accessor. To avoid this exception' call IsReadOnly to ensure that setting a value is allowed."' " is 147.
Long Statement,MongoDB.Bson.Serialization,BsonMemberMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonMemberMap.cs,ThrowFrozenException,The length of the statement  "            var message = string.Format("Member map for {0}.{1} has been frozen and no further changes are allowed."' _classMap.ClassType.FullName' _memberInfo.Name); " is 154.
Long Statement,MongoDB.Bson.Serialization,BsonSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonSerializer.cs,RegisterDiscriminator,The length of the statement  "                var message = string.Format("Discriminators can only be registered for classes' not for interface {0}."' type.FullName); " is 120.
Long Statement,MongoDB.Bson.Serialization,BsonSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonSerializer.cs,EnsureKnownTypesAreRegistered,The length of the statement  "                    var knownTypesAttribute = nominalType.GetTypeInfo().GetCustomAttributes(typeof(BsonKnownTypesAttribute)' false).ToArray(); " is 122.
Long Statement,MongoDB.Bson.Serialization,TypeMappingSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\TypeMappingSerializationProvider.cs,RegisterMapping,The length of the statement  "                var message = string.Format("There is already a serializer mapping registered for type {0}."' BsonUtils.GetFriendlyTypeName(type)); " is 131.
Long Statement,MongoDB.Bson.Serialization.Attributes,BsonRepresentationAttribute,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Attributes\BsonRepresentationAttribute.cs,Apply,The length of the statement  "                    var dictionaryRepresentation = (_representation == BsonType.Array) ? DictionaryRepresentation.ArrayOfArrays: DictionaryRepresentation.Document; " is 143.
Long Statement,MongoDB.Bson.Serialization.Attributes,BsonSerializerAttribute,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Attributes\BsonSerializerAttribute.cs,CreateSerializer,The length of the statement  "                var message = "Cannot create a serializer because the serializer type is an open generic type and the type to serialize is not generic."; " is 137.
Long Statement,MongoDB.Bson.Serialization.Conventions,AttributeConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\AttributeConventionPack.cs,Apply,The length of the statement  "                foreach (var attribute in classMap.ClassType.GetTypeInfo().GetCustomAttributes(inherit: false).OfType<IBsonClassMapAttribute>()) " is 128.
Long Statement,MongoDB.Bson.Serialization.Conventions,AttributeConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\AttributeConventionPack.cs,PostProcess,The length of the statement  "                foreach (var attribute in classMap.ClassType.GetTypeInfo().GetCustomAttributes(inherit: false).OfType<IBsonPostProcessingAttribute>()) " is 134.
Long Statement,MongoDB.Bson.Serialization.Conventions,AttributeConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\AttributeConventionPack.cs,OptInMembersWithBsonCreatorMapModifierAttribute,The length of the statement  "                foreach (var constructorInfo in classMap.ClassType.GetTypeInfo().GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)) " is 179.
Long Statement,MongoDB.Bson.Serialization.Conventions,AttributeConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\AttributeConventionPack.cs,OptInMembersWithBsonCreatorMapModifierAttribute,The length of the statement  "                foreach (var methodInfo in classMap.ClassType.GetTypeInfo().GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)) " is 167.
Long Statement,MongoDB.Bson.Serialization.Conventions,AttributeConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\AttributeConventionPack.cs,OptInMembersWithBsonMemberMapModifierAttribute,The length of the statement  "                foreach (var fieldInfo in classMap.ClassType.GetTypeInfo().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)) " is 167.
Long Statement,MongoDB.Bson.Serialization.Conventions,AttributeConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\AttributeConventionPack.cs,OptInMembersWithBsonMemberMapModifierAttribute,The length of the statement  "                foreach (var propertyInfo in classMap.ClassType.GetTypeInfo().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)) " is 174.
Long Statement,MongoDB.Bson.Serialization.Conventions,AttributeConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\AttributeConventionPack.cs,IgnoreMembersWithBsonIgnoreAttribute,The length of the statement  "                    var ignoreAttribute = (BsonIgnoreAttribute)memberMap.MemberInfo.GetCustomAttributes(inherit: false).OfType<BsonIgnoreAttribute>().FirstOrDefault(); " is 147.
Long Statement,MongoDB.Bson.Serialization.Conventions,NamedExtraElementsMemberConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\NamedExtraElementsMemberConvention.cs,Apply,The length of the statement  "                    if (memberType != null && (memberType == typeof(BsonDocument) || typeof(IDictionary<string' object>).GetTypeInfo().IsAssignableFrom(memberType))) " is 145.
Long Statement,MongoDB.Bson.Serialization.Conventions,ObjectDiscriminatorConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\ObjectDiscriminatorConvention.cs,GetActualType,The length of the statement  "                // Type.IsAssignableFrom is extremely expensive' always perform a direct type check before calling Type.IsAssignableFrom " is 120.
Long Statement,MongoDB.Bson.Serialization.Conventions,ObjectDiscriminatorConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\ObjectDiscriminatorConvention.cs,GetActualType,The length of the statement  "                if (primitiveType != null && (primitiveType == nominalType || nominalType.GetTypeInfo().IsAssignableFrom(primitiveType))) " is 121.
Long Statement,MongoDB.Bson.Serialization.Conventions,EnumRepresentationConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\EnumRepresentationConvention.cs,EnsureRepresentationIsValidForEnums,The length of the statement  "            throw new ArgumentException("Enums can only be represented as String' Int32' Int64 or the type of the enum"' "representation"); " is 127.
Long Statement,MongoDB.Bson.Serialization.IdGenerators,BsonBinaryDataGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\BsonBinaryDataGuidGenerator.cs,IsEmpty,The length of the statement  "                throw new ArgumentOutOfRangeException("id"' "The binary sub type of the id value passed to the BsonBinaryDataGuidGenerator IsEmpty method is not UuidLegacy or UuidStandard."); " is 175.
Long Statement,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The length of the statement  "            // note: Guids generated by CombGuidGenerator are only considered ascending by SQL Server which compares Guids in an unusual way " is 128.
Long Statement,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The length of the statement  "            var timeTicks = (int)(timestamp.TimeOfDay.Ticks * 300 / TimeSpan.TicksPerSecond); // convert from .NET resolution to SQL Server resolution " is 138.
Long Statement,MongoDB.Bson.Serialization.Options,RepresentationConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Options\RepresentationConverter.cs,ToDecimal,The length of the statement  "                try { decimalValue = (decimal)value; } catch (OverflowException) { decimalValue = Decimal128.IsNegative(value) ? decimal.MinValue : decimal.MaxValue; } " is 151.
Long Statement,MongoDB.Bson.Serialization.Options,RepresentationConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Options\RepresentationConverter.cs,ToDouble,The length of the statement  "                try { doubleValue = (double)value; } catch (OverflowException) { doubleValue = Decimal128.IsNegative(value) ? double.MinValue : double.MaxValue; } " is 146.
Long Statement,MongoDB.Bson.Serialization.Options,RepresentationConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Options\RepresentationConverter.cs,ToInt16,The length of the statement  "                try { shortValue = (short)value; } catch (OverflowException) { shortValue = Decimal128.IsNegative(value) ? short.MinValue : short.MaxValue; } " is 141.
Long Statement,MongoDB.Bson.Serialization.Options,RepresentationConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Options\RepresentationConverter.cs,ToInt32,The length of the statement  "                try { intValue = (int)value; } catch (OverflowException) { intValue = Decimal128.IsNegative(value) ? int.MinValue : int.MaxValue; } " is 131.
Long Statement,MongoDB.Bson.Serialization.Options,RepresentationConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Options\RepresentationConverter.cs,ToInt64,The length of the statement  "                try { longValue = (long)value; } catch (OverflowException) { longValue = Decimal128.IsNegative(value) ? long.MinValue : long.MaxValue; } " is 136.
Long Statement,MongoDB.Bson.Serialization.Options,RepresentationConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Options\RepresentationConverter.cs,ToSingle,The length of the statement  "                try { floatValue = (float)value; } catch (OverflowException) { floatValue = Decimal128.IsNegative(value) ? float.MinValue : float.MaxValue; } " is 141.
Long Statement,MongoDB.Bson.Serialization.Options,RepresentationConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Options\RepresentationConverter.cs,ToUInt16,The length of the statement  "                try { ushortValue = (ushort)value; } catch (OverflowException) { ushortValue = Decimal128.IsNegative(value) ? ushort.MinValue : ushort.MaxValue; } " is 146.
Long Statement,MongoDB.Bson.Serialization.Options,RepresentationConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Options\RepresentationConverter.cs,ToUInt32,The length of the statement  "                try { uintValue = (uint)value; } catch (OverflowException) { uintValue = Decimal128.IsNegative(value) ? uint.MinValue : uint.MaxValue; } " is 136.
Long Statement,MongoDB.Bson.Serialization.Options,RepresentationConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Options\RepresentationConverter.cs,ToUInt64,The length of the statement  "                try { ulongValue = (ulong)value; } catch (OverflowException) { ulongValue = Decimal128.IsNegative(value) ? ulong.MinValue : ulong.MaxValue; } " is 141.
Long Statement,MongoDB.Bson.Serialization.Serializers,BsonBinaryDataSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonBinaryDataSerializer.cs,SerializeValue,The length of the statement  "                        subType = (writerGuidRepresentation == GuidRepresentation.Standard) ? BsonBinarySubType.UuidStandard : BsonBinarySubType.UuidLegacy; " is 132.
Long Statement,MongoDB.Bson.Serialization.Serializers,ElementAppendingSerializer<TDocument>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ElementAppendingSerializer.cs,Serialize,The length of the statement  "            var elementAppendingContext = BsonSerializationContext.CreateRoot(elementAppendingWriter' builder => ConfigureElementAppendingContext(builder' context)); " is 153.
Long Statement,MongoDB.Bson.Serialization.Serializers,BsonDocumentSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonDocumentSerializer.cs,GetDocumentId,The length of the statement  "                    if (idBinaryData != null && (idBinaryData.SubType == BsonBinarySubType.UuidLegacy || idBinaryData.SubType == BsonBinarySubType.UuidStandard)) " is 141.
Long Statement,MongoDB.Bson.Serialization.Serializers,BsonValueSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonValueSerializer.cs,SerializeValue,The length of the statement  "                case BsonType.JavaScriptWithScope: BsonJavaScriptWithScopeSerializer.Instance.Serialize(context' (BsonJavaScriptWithScope)value); break; " is 136.
Long Statement,MongoDB.Bson.Serialization.Serializers,BsonValueSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonValueSerializer.cs,SerializeValue,The length of the statement  "                case BsonType.RegularExpression: BsonRegularExpressionSerializer.Instance.Serialize(context' (BsonRegularExpression)value); break; " is 130.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithDictionaryRepresentation,The length of the statement  "                return new DictionaryInterfaceImplementerSerializer<TDictionary>(dictionaryRepresentation' KeySerializer' ValueSerializer); " is 123.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithDictionaryRepresentation,The length of the statement  "            if (dictionaryRepresentation == DictionaryRepresentation && keySerializer == KeySerializer && valueSerializer == ValueSerializer) " is 129.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithDictionaryRepresentation,The length of the statement  "                return new DictionaryInterfaceImplementerSerializer<TDictionary>(dictionaryRepresentation' keySerializer' valueSerializer); " is 123.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithKeySerializer,The length of the statement  "                return new DictionaryInterfaceImplementerSerializer<TDictionary>(DictionaryRepresentation' keySerializer' ValueSerializer); " is 123.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithValueSerializer,The length of the statement  "                return new DictionaryInterfaceImplementerSerializer<TDictionary>(DictionaryRepresentation' KeySerializer' valueSerializer); " is 123.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary;TKey;TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithDictionaryRepresentation,The length of the statement  "                return new DictionaryInterfaceImplementerSerializer<TDictionary' TKey' TValue>(dictionaryRepresentation' KeySerializer' ValueSerializer); " is 137.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary;TKey;TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithDictionaryRepresentation,The length of the statement  "            if (dictionaryRepresentation == DictionaryRepresentation && keySerializer == KeySerializer && valueSerializer == ValueSerializer) " is 129.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary;TKey;TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithDictionaryRepresentation,The length of the statement  "                return new DictionaryInterfaceImplementerSerializer<TDictionary' TKey' TValue>(dictionaryRepresentation' keySerializer' valueSerializer); " is 137.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary;TKey;TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithKeySerializer,The length of the statement  "                return new DictionaryInterfaceImplementerSerializer<TDictionary' TKey' TValue>(DictionaryRepresentation' keySerializer' ValueSerializer); " is 137.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionaryInterfaceImplementerSerializer<TDictionary;TKey;TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionaryInterfaceImplementerSerializer.cs,WithValueSerializer,The length of the statement  "                return new DictionaryInterfaceImplementerSerializer<TDictionary' TKey' TValue>(DictionaryRepresentation' KeySerializer' valueSerializer); " is 137.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionarySerializerBase<TDictionary>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionarySerializerBase.cs,SerializeKeyString,The length of the statement  "                throw new BsonSerializationException("When using DictionaryRepresentation.Document key values must serialize as strings."); " is 123.
Long Statement,MongoDB.Bson.Serialization.Serializers,DictionarySerializerBase<TDictionary;TKey;TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionarySerializerBase.cs,SerializeKeyString,The length of the statement  "                throw new BsonSerializationException("When using DictionaryRepresentation.Document key values must serialize as strings."); " is 123.
Long Statement,MongoDB.Bson.Serialization.Serializers,DiscriminatedInterfaceSerializer<TInterface>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DiscriminatedInterfaceSerializer.cs,Deserialize,The length of the statement  "                    var message = string.Format("Unable to determine actual type of object to deserialize for interface type {0}."' _interfaceType.FullName); " is 137.
Long Statement,MongoDB.Bson.Serialization.Serializers,DynamicDocumentBaseSerializer<T>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DynamicDocumentBaseSerializer.cs,Deserialize,The length of the statement  "                    message = string.Format("Cannot deserialize a '{0}' from BsonType '{1}'."' BsonUtils.GetFriendlyTypeName(typeof(T))' bsonType); " is 127.
Long Statement,MongoDB.Bson.Serialization.Serializers,GuidSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\GuidSerializer.cs,Deserialize,The length of the statement  "                        throw new BsonSerializationException("GuidSerializer cannot deserialize a Guid when GuidRepresentation is Unspecified."); " is 121.
Long Statement,MongoDB.Bson.Serialization.Serializers,GuidSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\GuidSerializer.cs,Serialize,The length of the statement  "                    var subType = (writerGuidRepresentation == GuidRepresentation.Standard) ? BsonBinarySubType.UuidStandard : BsonBinarySubType.UuidLegacy; " is 136.
Long Statement,MongoDB.Bson.Serialization.Serializers,ThreeDimensionalArraySerializer<TItem>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ThreeDimensionalArraySerializer.cs,DeserializeValue,The length of the statement  "                    var message = string.Format("Middle list {0} is of length {1} but should be of length {2}."' i' middleList.Count' length2); " is 123.
Long Statement,MongoDB.Bson.Serialization.Serializers,ThreeDimensionalArraySerializer<TItem>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ThreeDimensionalArraySerializer.cs,DeserializeValue,The length of the statement  "                        var message = string.Format("Inner list {0} is of length {1} but should be of length {2}."' j' innerList.Count' length3); " is 121.
Long Statement,MongoDB.Bson.Serialization.Serializers,TimeSpanSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TimeSpanSerializer.cs,FromDouble,The length of the statement  "                return TimeSpan.FromTicks((long)(value * TicksPerUnit(units))); // multiply first then cast to preserve fractional part of value " is 128.
Long Statement,MongoDB.Bson.Serialization.Serializers,TimeSpanSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TimeSpanSerializer.cs,ToDouble,The length of the statement  "                return (double)timeSpan.Ticks / (double)TicksPerUnit(units); // cast first then divide to preserve fractional part of result " is 124.
Long Statement,MongoDB.Bson.Serialization.Serializers,TwoDimensionalArraySerializer<TItem>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TwoDimensionalArraySerializer.cs,DeserializeValue,The length of the statement  "                    var message = string.Format("Inner list {0} is of length {1} but should be of length {2}."' i' innerList.Count' length2); " is 121.
Complex Conditional,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,TryParse,The conditional expression  "s.Equals("Inf"' StringComparison.OrdinalIgnoreCase) || s.Equals("Infinity"' StringComparison.OrdinalIgnoreCase) ||                      s.Equals("+Inf"' StringComparison.OrdinalIgnoreCase) || s.Equals("+Infinity"' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,MongoDB.Bson.IO,BsonDocumentWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonDocumentWriter.cs,WriteStartDocument,The conditional expression  "State != BsonWriterState.Initial && State != BsonWriterState.Value && State != BsonWriterState.ScopeDocument && State != BsonWriterState.Done"  is complex.
Complex Conditional,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteRawBsonDocument,The conditional expression  "State != BsonWriterState.Initial && State != BsonWriterState.Value && State != BsonWriterState.ScopeDocument && State != BsonWriterState.Done"  is complex.
Complex Conditional,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteStartDocument,The conditional expression  "State != BsonWriterState.Initial && State != BsonWriterState.Value && State != BsonWriterState.ScopeDocument && State != BsonWriterState.Done"  is complex.
Complex Conditional,MongoDB.Bson.Serialization,BsonClassMapSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonClassMapSerializationProvider.cs,GetSerializer,The conditional expression  "(typeInfo.IsClass || (typeInfo.IsValueType && !typeInfo.IsPrimitive)) &&                  !typeof(Array).GetTypeInfo().IsAssignableFrom(type) &&                  !typeof(Enum).GetTypeInfo().IsAssignableFrom(type)"  is complex.
Complex Conditional,MongoDB.Bson.Serialization.Conventions,EnumRepresentationConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\EnumRepresentationConvention.cs,EnsureRepresentationIsValidForEnums,The conditional expression  "representation == 0 ||                  representation == BsonType.String ||                  representation == BsonType.Int32 ||                  representation == BsonType.Int64"  is complex.
Virtual Method Call from Constructor,MongoDB.Bson,BsonArray,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonArray.cs,BsonArray,The constructor "BsonArray" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonArray,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonArray.cs,BsonArray,The constructor "BsonArray" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonArray,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonArray.cs,BsonArray,The constructor "BsonArray" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonArray,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonArray.cs,BsonArray,The constructor "BsonArray" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonArray,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonArray.cs,BsonArray,The constructor "BsonArray" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonArray,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonArray.cs,BsonArray,The constructor "BsonArray" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonArray,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonArray.cs,BsonArray,The constructor "BsonArray" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonArray,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonArray.cs,BsonArray,The constructor "BsonArray" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonArray,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonArray.cs,BsonArray,The constructor "BsonArray" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "Add".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "Add".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "Add".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "Add".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "AddRange".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "Add".
Virtual Method Call from Constructor,MongoDB.Bson,BsonDocument,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDocument.cs,BsonDocument,The constructor "BsonDocument" calls a virtual method "Add".
Empty Catch Block,MongoDB.Bson.IO,BsonDocumentReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonDocumentReader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,MongoDB.Bson.IO,BsonDocumentWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonDocumentWriter.cs,Dispose,The method has an empty catch block.
Empty Catch Block,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,Dispose,The method has an empty catch block.
Empty Catch Block,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,Dispose,The method has an empty catch block.
Magic Number,MongoDB.Shared,Hasher,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Shared\Hasher.cs,Hasher,The following statement contains a magic number: _hashCode = 17;
Magic Number,MongoDB.Shared,Hasher,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Shared\Hasher.cs,Hash,The following statement contains a magic number: _hashCode = 37 * _hashCode + obj.GetHashCode();
Magic Number,MongoDB.Shared,Hasher,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Shared\Hasher.cs,Hash,The following statement contains a magic number: _hashCode = 37 * _hashCode + obj.GetHashCode();
Magic Number,MongoDB.Shared,Hasher,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Shared\Hasher.cs,Hash,The following statement contains a magic number: _hashCode = 37 * _hashCode + obj.GetHashCode();
Magic Number,MongoDB.Shared,Hasher,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Shared\Hasher.cs,Hash,The following statement contains a magic number: _hashCode = 37 * _hashCode + ((obj == null) ? -1 : obj.Value.GetHashCode());
Magic Number,MongoDB.Shared,Hasher,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Shared\Hasher.cs,Hash,The following statement contains a magic number: _hashCode = 37 * _hashCode + ((obj == null) ? -1 : obj.GetHashCode());
Magic Number,MongoDB.Shared,Hasher,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Shared\Hasher.cs,HashElements,The following statement contains a magic number: if (sequence == null)              {                  _hashCode = 37 * _hashCode + -1;              }              else              {                  foreach (var value in sequence)                  {                      _hashCode = 37 * _hashCode + ((value == null) ? -1 : value.GetHashCode());                  }              }
Magic Number,MongoDB.Shared,Hasher,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Shared\Hasher.cs,HashElements,The following statement contains a magic number: if (sequence == null)              {                  _hashCode = 37 * _hashCode + -1;              }              else              {                  foreach (var value in sequence)                  {                      _hashCode = 37 * _hashCode + ((value == null) ? -1 : value.GetHashCode());                  }              }
Magic Number,MongoDB.Shared,Hasher,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Shared\Hasher.cs,HashStructElements,The following statement contains a magic number: foreach (var value in sequence)              {                  _hashCode = 37 * _hashCode + value.GetHashCode();              }
Magic Number,MongoDB.Bson,BsonDecimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDecimal128.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonDecimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDecimal128.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonDecimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDecimal128.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _value.GetHashCode();
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,GetExponent,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  return MapDecimal128BiasedExponentToExponent((short)((d._highBits & Flags.FirstFormExponentBits) >> 49));              }              else if (Flags.IsSecondForm(d._highBits))              {                  return MapDecimal128BiasedExponentToExponent((short)((d._highBits & Flags.SecondFormExponentBits) >> 47));              }              else              {                  throw new InvalidOperationException("GetExponent cannot be called for Infinity or NaN.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,GetExponent,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  return MapDecimal128BiasedExponentToExponent((short)((d._highBits & Flags.FirstFormExponentBits) >> 49));              }              else if (Flags.IsSecondForm(d._highBits))              {                  return MapDecimal128BiasedExponentToExponent((short)((d._highBits & Flags.SecondFormExponentBits) >> 47));              }              else              {                  throw new InvalidOperationException("GetExponent cannot be called for Infinity or NaN.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToDecimal,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  if (Decimal128.IsZero(d))                  {                      return decimal.Zero;                  }                  else if (Decimal128.Compare(d' __minDecimalValue) < 0 || Decimal128.Compare(d' __maxDecimalValue) > 0)                  {                      throw new OverflowException("Value is too large or too small to be converted to a Decimal.");                  }                    var isNegative = Decimal128.IsNegative(d);                  var exponent = Decimal128.GetExponent(d);                  var significand = Decimal128.GetSignificand(d);                    // decimal significand must fit in 96 bits                  while ((significand.High >> 32) != 0)                  {                      uint remainder; // ignored                      significand = UInt128.Divide(significand' 10' out remainder);                      exponent += 1;                  }                    // decimal exponents must be between 0 and -28                  if (exponent > 0)                  {                      // bring exponent within range                      while (exponent > 0)                      {                          significand = UInt128.Multiply(significand' (uint)10);                          exponent -= 1;                      }                  }                  else if (exponent < -28)                  {                      // check if exponent is too far out of range to possibly be brought within range                      if (exponent < -56)                      {                          return decimal.Zero;                      }                        // bring exponent within range                      while (exponent < -28)                      {                          uint remainder; // ignored                          significand = UInt128.Divide(significand' (uint)10' out remainder);                          exponent += 1;                      }                        if (significand.Equals(UInt128.Zero))                      {                          return decimal.Zero;                      }                  }                    var lo = (int)significand.Low;                  var mid = (int)(significand.Low >> 32);                  var hi = (int)significand.High;                  var scale = (byte)(-exponent);                    return new decimal(lo' mid' hi' isNegative' scale);              }              else if (Flags.IsSecondForm(d._highBits))              {                  return Decimal.Zero;              }              else              {                  throw new OverflowException("Infinity or NaN cannot be converted to Decimal.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToDecimal,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  if (Decimal128.IsZero(d))                  {                      return decimal.Zero;                  }                  else if (Decimal128.Compare(d' __minDecimalValue) < 0 || Decimal128.Compare(d' __maxDecimalValue) > 0)                  {                      throw new OverflowException("Value is too large or too small to be converted to a Decimal.");                  }                    var isNegative = Decimal128.IsNegative(d);                  var exponent = Decimal128.GetExponent(d);                  var significand = Decimal128.GetSignificand(d);                    // decimal significand must fit in 96 bits                  while ((significand.High >> 32) != 0)                  {                      uint remainder; // ignored                      significand = UInt128.Divide(significand' 10' out remainder);                      exponent += 1;                  }                    // decimal exponents must be between 0 and -28                  if (exponent > 0)                  {                      // bring exponent within range                      while (exponent > 0)                      {                          significand = UInt128.Multiply(significand' (uint)10);                          exponent -= 1;                      }                  }                  else if (exponent < -28)                  {                      // check if exponent is too far out of range to possibly be brought within range                      if (exponent < -56)                      {                          return decimal.Zero;                      }                        // bring exponent within range                      while (exponent < -28)                      {                          uint remainder; // ignored                          significand = UInt128.Divide(significand' (uint)10' out remainder);                          exponent += 1;                      }                        if (significand.Equals(UInt128.Zero))                      {                          return decimal.Zero;                      }                  }                    var lo = (int)significand.Low;                  var mid = (int)(significand.Low >> 32);                  var hi = (int)significand.High;                  var scale = (byte)(-exponent);                    return new decimal(lo' mid' hi' isNegative' scale);              }              else if (Flags.IsSecondForm(d._highBits))              {                  return Decimal.Zero;              }              else              {                  throw new OverflowException("Infinity or NaN cannot be converted to Decimal.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToDecimal,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  if (Decimal128.IsZero(d))                  {                      return decimal.Zero;                  }                  else if (Decimal128.Compare(d' __minDecimalValue) < 0 || Decimal128.Compare(d' __maxDecimalValue) > 0)                  {                      throw new OverflowException("Value is too large or too small to be converted to a Decimal.");                  }                    var isNegative = Decimal128.IsNegative(d);                  var exponent = Decimal128.GetExponent(d);                  var significand = Decimal128.GetSignificand(d);                    // decimal significand must fit in 96 bits                  while ((significand.High >> 32) != 0)                  {                      uint remainder; // ignored                      significand = UInt128.Divide(significand' 10' out remainder);                      exponent += 1;                  }                    // decimal exponents must be between 0 and -28                  if (exponent > 0)                  {                      // bring exponent within range                      while (exponent > 0)                      {                          significand = UInt128.Multiply(significand' (uint)10);                          exponent -= 1;                      }                  }                  else if (exponent < -28)                  {                      // check if exponent is too far out of range to possibly be brought within range                      if (exponent < -56)                      {                          return decimal.Zero;                      }                        // bring exponent within range                      while (exponent < -28)                      {                          uint remainder; // ignored                          significand = UInt128.Divide(significand' (uint)10' out remainder);                          exponent += 1;                      }                        if (significand.Equals(UInt128.Zero))                      {                          return decimal.Zero;                      }                  }                    var lo = (int)significand.Low;                  var mid = (int)(significand.Low >> 32);                  var hi = (int)significand.High;                  var scale = (byte)(-exponent);                    return new decimal(lo' mid' hi' isNegative' scale);              }              else if (Flags.IsSecondForm(d._highBits))              {                  return Decimal.Zero;              }              else              {                  throw new OverflowException("Infinity or NaN cannot be converted to Decimal.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToDecimal,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  if (Decimal128.IsZero(d))                  {                      return decimal.Zero;                  }                  else if (Decimal128.Compare(d' __minDecimalValue) < 0 || Decimal128.Compare(d' __maxDecimalValue) > 0)                  {                      throw new OverflowException("Value is too large or too small to be converted to a Decimal.");                  }                    var isNegative = Decimal128.IsNegative(d);                  var exponent = Decimal128.GetExponent(d);                  var significand = Decimal128.GetSignificand(d);                    // decimal significand must fit in 96 bits                  while ((significand.High >> 32) != 0)                  {                      uint remainder; // ignored                      significand = UInt128.Divide(significand' 10' out remainder);                      exponent += 1;                  }                    // decimal exponents must be between 0 and -28                  if (exponent > 0)                  {                      // bring exponent within range                      while (exponent > 0)                      {                          significand = UInt128.Multiply(significand' (uint)10);                          exponent -= 1;                      }                  }                  else if (exponent < -28)                  {                      // check if exponent is too far out of range to possibly be brought within range                      if (exponent < -56)                      {                          return decimal.Zero;                      }                        // bring exponent within range                      while (exponent < -28)                      {                          uint remainder; // ignored                          significand = UInt128.Divide(significand' (uint)10' out remainder);                          exponent += 1;                      }                        if (significand.Equals(UInt128.Zero))                      {                          return decimal.Zero;                      }                  }                    var lo = (int)significand.Low;                  var mid = (int)(significand.Low >> 32);                  var hi = (int)significand.High;                  var scale = (byte)(-exponent);                    return new decimal(lo' mid' hi' isNegative' scale);              }              else if (Flags.IsSecondForm(d._highBits))              {                  return Decimal.Zero;              }              else              {                  throw new OverflowException("Infinity or NaN cannot be converted to Decimal.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToDecimal,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  if (Decimal128.IsZero(d))                  {                      return decimal.Zero;                  }                  else if (Decimal128.Compare(d' __minDecimalValue) < 0 || Decimal128.Compare(d' __maxDecimalValue) > 0)                  {                      throw new OverflowException("Value is too large or too small to be converted to a Decimal.");                  }                    var isNegative = Decimal128.IsNegative(d);                  var exponent = Decimal128.GetExponent(d);                  var significand = Decimal128.GetSignificand(d);                    // decimal significand must fit in 96 bits                  while ((significand.High >> 32) != 0)                  {                      uint remainder; // ignored                      significand = UInt128.Divide(significand' 10' out remainder);                      exponent += 1;                  }                    // decimal exponents must be between 0 and -28                  if (exponent > 0)                  {                      // bring exponent within range                      while (exponent > 0)                      {                          significand = UInt128.Multiply(significand' (uint)10);                          exponent -= 1;                      }                  }                  else if (exponent < -28)                  {                      // check if exponent is too far out of range to possibly be brought within range                      if (exponent < -56)                      {                          return decimal.Zero;                      }                        // bring exponent within range                      while (exponent < -28)                      {                          uint remainder; // ignored                          significand = UInt128.Divide(significand' (uint)10' out remainder);                          exponent += 1;                      }                        if (significand.Equals(UInt128.Zero))                      {                          return decimal.Zero;                      }                  }                    var lo = (int)significand.Low;                  var mid = (int)(significand.Low >> 32);                  var hi = (int)significand.High;                  var scale = (byte)(-exponent);                    return new decimal(lo' mid' hi' isNegative' scale);              }              else if (Flags.IsSecondForm(d._highBits))              {                  return Decimal.Zero;              }              else              {                  throw new OverflowException("Infinity or NaN cannot be converted to Decimal.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToDecimal,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  if (Decimal128.IsZero(d))                  {                      return decimal.Zero;                  }                  else if (Decimal128.Compare(d' __minDecimalValue) < 0 || Decimal128.Compare(d' __maxDecimalValue) > 0)                  {                      throw new OverflowException("Value is too large or too small to be converted to a Decimal.");                  }                    var isNegative = Decimal128.IsNegative(d);                  var exponent = Decimal128.GetExponent(d);                  var significand = Decimal128.GetSignificand(d);                    // decimal significand must fit in 96 bits                  while ((significand.High >> 32) != 0)                  {                      uint remainder; // ignored                      significand = UInt128.Divide(significand' 10' out remainder);                      exponent += 1;                  }                    // decimal exponents must be between 0 and -28                  if (exponent > 0)                  {                      // bring exponent within range                      while (exponent > 0)                      {                          significand = UInt128.Multiply(significand' (uint)10);                          exponent -= 1;                      }                  }                  else if (exponent < -28)                  {                      // check if exponent is too far out of range to possibly be brought within range                      if (exponent < -56)                      {                          return decimal.Zero;                      }                        // bring exponent within range                      while (exponent < -28)                      {                          uint remainder; // ignored                          significand = UInt128.Divide(significand' (uint)10' out remainder);                          exponent += 1;                      }                        if (significand.Equals(UInt128.Zero))                      {                          return decimal.Zero;                      }                  }                    var lo = (int)significand.Low;                  var mid = (int)(significand.Low >> 32);                  var hi = (int)significand.High;                  var scale = (byte)(-exponent);                    return new decimal(lo' mid' hi' isNegative' scale);              }              else if (Flags.IsSecondForm(d._highBits))              {                  return Decimal.Zero;              }              else              {                  throw new OverflowException("Infinity or NaN cannot be converted to Decimal.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToDecimal,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  if (Decimal128.IsZero(d))                  {                      return decimal.Zero;                  }                  else if (Decimal128.Compare(d' __minDecimalValue) < 0 || Decimal128.Compare(d' __maxDecimalValue) > 0)                  {                      throw new OverflowException("Value is too large or too small to be converted to a Decimal.");                  }                    var isNegative = Decimal128.IsNegative(d);                  var exponent = Decimal128.GetExponent(d);                  var significand = Decimal128.GetSignificand(d);                    // decimal significand must fit in 96 bits                  while ((significand.High >> 32) != 0)                  {                      uint remainder; // ignored                      significand = UInt128.Divide(significand' 10' out remainder);                      exponent += 1;                  }                    // decimal exponents must be between 0 and -28                  if (exponent > 0)                  {                      // bring exponent within range                      while (exponent > 0)                      {                          significand = UInt128.Multiply(significand' (uint)10);                          exponent -= 1;                      }                  }                  else if (exponent < -28)                  {                      // check if exponent is too far out of range to possibly be brought within range                      if (exponent < -56)                      {                          return decimal.Zero;                      }                        // bring exponent within range                      while (exponent < -28)                      {                          uint remainder; // ignored                          significand = UInt128.Divide(significand' (uint)10' out remainder);                          exponent += 1;                      }                        if (significand.Equals(UInt128.Zero))                      {                          return decimal.Zero;                      }                  }                    var lo = (int)significand.Low;                  var mid = (int)(significand.Low >> 32);                  var hi = (int)significand.High;                  var scale = (byte)(-exponent);                    return new decimal(lo' mid' hi' isNegative' scale);              }              else if (Flags.IsSecondForm(d._highBits))              {                  return Decimal.Zero;              }              else              {                  throw new OverflowException("Infinity or NaN cannot be converted to Decimal.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToDecimal,The following statement contains a magic number: if (Flags.IsFirstForm(d._highBits))              {                  if (Decimal128.IsZero(d))                  {                      return decimal.Zero;                  }                  else if (Decimal128.Compare(d' __minDecimalValue) < 0 || Decimal128.Compare(d' __maxDecimalValue) > 0)                  {                      throw new OverflowException("Value is too large or too small to be converted to a Decimal.");                  }                    var isNegative = Decimal128.IsNegative(d);                  var exponent = Decimal128.GetExponent(d);                  var significand = Decimal128.GetSignificand(d);                    // decimal significand must fit in 96 bits                  while ((significand.High >> 32) != 0)                  {                      uint remainder; // ignored                      significand = UInt128.Divide(significand' 10' out remainder);                      exponent += 1;                  }                    // decimal exponents must be between 0 and -28                  if (exponent > 0)                  {                      // bring exponent within range                      while (exponent > 0)                      {                          significand = UInt128.Multiply(significand' (uint)10);                          exponent -= 1;                      }                  }                  else if (exponent < -28)                  {                      // check if exponent is too far out of range to possibly be brought within range                      if (exponent < -56)                      {                          return decimal.Zero;                      }                        // bring exponent within range                      while (exponent < -28)                      {                          uint remainder; // ignored                          significand = UInt128.Divide(significand' (uint)10' out remainder);                          exponent += 1;                      }                        if (significand.Equals(UInt128.Zero))                      {                          return decimal.Zero;                      }                  }                    var lo = (int)significand.Low;                  var mid = (int)(significand.Low >> 32);                  var hi = (int)significand.High;                  var scale = (byte)(-exponent);                    return new decimal(lo' mid' hi' isNegative' scale);              }              else if (Flags.IsSecondForm(d._highBits))              {                  return Decimal.Zero;              }              else              {                  throw new OverflowException("Infinity or NaN cannot be converted to Decimal.");              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,TryParse,The following statement contains a magic number: if (significandString.Length > 34)              {                  result = default(Decimal128);                  return false;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ClampOrRound,The following statement contains a magic number: if (exponent > __exponentMax)              {                  if (significandString == "0")                  {                      // since significand is zero simply use the largest possible exponent                      exponent = __exponentMax;                  }                  else                  {                      // use clamping to bring the exponent into range                      var numberOfTrailingZeroesToAdd = exponent - __exponentMax;                      var digitsAvailable = 34 - significandString.Length;                      if (numberOfTrailingZeroesToAdd <= digitsAvailable)                      {                          exponent = __exponentMax;                          significandString = significandString + new string('0'' numberOfTrailingZeroesToAdd);                      }                  }              }              else if (exponent < __exponentMin)              {                  if (significandString == "0")                  {                      // since significand is zero simply use the smallest possible exponent                      exponent = __exponentMin;                  }                  else                  {                      // use exact rounding to bring the exponent into range                      var numberOfTrailingZeroesToRemove = __exponentMin - exponent;                      if (numberOfTrailingZeroesToRemove < significandString.Length)                      {                          var trailingDigits = significandString.Substring(significandString.Length - numberOfTrailingZeroesToRemove);                          if (Regex.IsMatch(trailingDigits' "^0+$"))                          {                              exponent = __exponentMin;                              significandString = significandString.Substring(0' significandString.Length - numberOfTrailingZeroesToRemove);                          }                      }                  }              }              else if (significandString.Length > 34)              {                  // use exact rounding to reduce significand to 34 digits                  var numberOfTrailingZeroesToRemove = significandString.Length - 34;                  if (exponent + numberOfTrailingZeroesToRemove <= __exponentMax)                  {                      var trailingDigits = significandString.Substring(significandString.Length - numberOfTrailingZeroesToRemove);                      if (Regex.IsMatch(trailingDigits' "^0+$"))                      {                          exponent += numberOfTrailingZeroesToRemove;                          significandString = significandString.Substring(0' significandString.Length - numberOfTrailingZeroesToRemove);                      }                  }              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ClampOrRound,The following statement contains a magic number: if (exponent > __exponentMax)              {                  if (significandString == "0")                  {                      // since significand is zero simply use the largest possible exponent                      exponent = __exponentMax;                  }                  else                  {                      // use clamping to bring the exponent into range                      var numberOfTrailingZeroesToAdd = exponent - __exponentMax;                      var digitsAvailable = 34 - significandString.Length;                      if (numberOfTrailingZeroesToAdd <= digitsAvailable)                      {                          exponent = __exponentMax;                          significandString = significandString + new string('0'' numberOfTrailingZeroesToAdd);                      }                  }              }              else if (exponent < __exponentMin)              {                  if (significandString == "0")                  {                      // since significand is zero simply use the smallest possible exponent                      exponent = __exponentMin;                  }                  else                  {                      // use exact rounding to bring the exponent into range                      var numberOfTrailingZeroesToRemove = __exponentMin - exponent;                      if (numberOfTrailingZeroesToRemove < significandString.Length)                      {                          var trailingDigits = significandString.Substring(significandString.Length - numberOfTrailingZeroesToRemove);                          if (Regex.IsMatch(trailingDigits' "^0+$"))                          {                              exponent = __exponentMin;                              significandString = significandString.Substring(0' significandString.Length - numberOfTrailingZeroesToRemove);                          }                      }                  }              }              else if (significandString.Length > 34)              {                  // use exact rounding to reduce significand to 34 digits                  var numberOfTrailingZeroesToRemove = significandString.Length - 34;                  if (exponent + numberOfTrailingZeroesToRemove <= __exponentMax)                  {                      var trailingDigits = significandString.Substring(significandString.Length - numberOfTrailingZeroesToRemove);                      if (Regex.IsMatch(trailingDigits' "^0+$"))                      {                          exponent += numberOfTrailingZeroesToRemove;                          significandString = significandString.Substring(0' significandString.Length - numberOfTrailingZeroesToRemove);                      }                  }              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ClampOrRound,The following statement contains a magic number: if (exponent > __exponentMax)              {                  if (significandString == "0")                  {                      // since significand is zero simply use the largest possible exponent                      exponent = __exponentMax;                  }                  else                  {                      // use clamping to bring the exponent into range                      var numberOfTrailingZeroesToAdd = exponent - __exponentMax;                      var digitsAvailable = 34 - significandString.Length;                      if (numberOfTrailingZeroesToAdd <= digitsAvailable)                      {                          exponent = __exponentMax;                          significandString = significandString + new string('0'' numberOfTrailingZeroesToAdd);                      }                  }              }              else if (exponent < __exponentMin)              {                  if (significandString == "0")                  {                      // since significand is zero simply use the smallest possible exponent                      exponent = __exponentMin;                  }                  else                  {                      // use exact rounding to bring the exponent into range                      var numberOfTrailingZeroesToRemove = __exponentMin - exponent;                      if (numberOfTrailingZeroesToRemove < significandString.Length)                      {                          var trailingDigits = significandString.Substring(significandString.Length - numberOfTrailingZeroesToRemove);                          if (Regex.IsMatch(trailingDigits' "^0+$"))                          {                              exponent = __exponentMin;                              significandString = significandString.Substring(0' significandString.Length - numberOfTrailingZeroesToRemove);                          }                      }                  }              }              else if (significandString.Length > 34)              {                  // use exact rounding to reduce significand to 34 digits                  var numberOfTrailingZeroesToRemove = significandString.Length - 34;                  if (exponent + numberOfTrailingZeroesToRemove <= __exponentMax)                  {                      var trailingDigits = significandString.Substring(significandString.Length - numberOfTrailingZeroesToRemove);                      if (Regex.IsMatch(trailingDigits' "^0+$"))                      {                          exponent += numberOfTrailingZeroesToRemove;                          significandString = significandString.Substring(0' significandString.Length - numberOfTrailingZeroesToRemove);                      }                  }              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,TryDecreaseExponent,The following statement contains a magic number: while (exponent > goal)              {                  var significandTimes10 = UInt128.Multiply(significand' (uint)10);                  if (significandTimes10.CompareTo(Decimal128.__maxSignificand) > 0)                  {                      break;                  }                  exponent -= 1;                  significand = significandTimes10;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,FromComponents,The following statement contains a magic number: var highBits = ((ulong)biasedExponent << 49) | significand.High;
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,TryIncreaseExponent,The following statement contains a magic number: while (exponent < goal)              {                  uint remainder;                  var significandDividedBy10 = UInt128.Divide(significand' (uint)10' out remainder);                  if (remainder != 0)                  {                      break;                  }                  exponent += 1;                  significand = significandDividedBy10;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapDecimal128BiasedExponentToExponent,The following statement contains a magic number: if (biasedExponent <= 6111)              {                  return biasedExponent;              }              else              {                  return (short)(biasedExponent - 12288);              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapDecimal128BiasedExponentToExponent,The following statement contains a magic number: if (biasedExponent <= 6111)              {                  return biasedExponent;              }              else              {                  return (short)(biasedExponent - 12288);              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapDecimal128HighBitsToIEEEHighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6111L << 49))                  {                      return highBits + (6176L << 49);                  }                  else                  {                      return highBits - (6112L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6111L << 47))                  {                      return highBits + (6176L << 47);                  }                  else                  {                      return highBits - (6112L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapDecimal128HighBitsToIEEEHighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6111L << 49))                  {                      return highBits + (6176L << 49);                  }                  else                  {                      return highBits - (6112L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6111L << 47))                  {                      return highBits + (6176L << 47);                  }                  else                  {                      return highBits - (6112L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapDecimal128HighBitsToIEEEHighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6111L << 49))                  {                      return highBits + (6176L << 49);                  }                  else                  {                      return highBits - (6112L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6111L << 47))                  {                      return highBits + (6176L << 47);                  }                  else                  {                      return highBits - (6112L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapDecimal128HighBitsToIEEEHighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6111L << 49))                  {                      return highBits + (6176L << 49);                  }                  else                  {                      return highBits - (6112L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6111L << 47))                  {                      return highBits + (6176L << 47);                  }                  else                  {                      return highBits - (6112L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapDecimal128HighBitsToIEEEHighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6111L << 49))                  {                      return highBits + (6176L << 49);                  }                  else                  {                      return highBits - (6112L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6111L << 47))                  {                      return highBits + (6176L << 47);                  }                  else                  {                      return highBits - (6112L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapDecimal128HighBitsToIEEEHighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6111L << 49))                  {                      return highBits + (6176L << 49);                  }                  else                  {                      return highBits - (6112L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6111L << 47))                  {                      return highBits + (6176L << 47);                  }                  else                  {                      return highBits - (6112L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapExponentToDecimal128BiasedExponent,The following statement contains a magic number: if (exponent >= 0)              {                  return exponent;              }              else              {                  return (short)(exponent + 12288);              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapIEEEHighBitsToDecimal128HighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6175L << 49))                  {                      return highBits + (6112L << 49);                  }                  else                  {                      return highBits - (6176L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6175L << 47))                  {                      return highBits + (6112L << 47);                  }                  else                  {                      return highBits - (6176L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapIEEEHighBitsToDecimal128HighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6175L << 49))                  {                      return highBits + (6112L << 49);                  }                  else                  {                      return highBits - (6176L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6175L << 47))                  {                      return highBits + (6112L << 47);                  }                  else                  {                      return highBits - (6176L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapIEEEHighBitsToDecimal128HighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6175L << 49))                  {                      return highBits + (6112L << 49);                  }                  else                  {                      return highBits - (6176L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6175L << 47))                  {                      return highBits + (6112L << 47);                  }                  else                  {                      return highBits - (6176L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapIEEEHighBitsToDecimal128HighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6175L << 49))                  {                      return highBits + (6112L << 49);                  }                  else                  {                      return highBits - (6176L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6175L << 47))                  {                      return highBits + (6112L << 47);                  }                  else                  {                      return highBits - (6176L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapIEEEHighBitsToDecimal128HighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6175L << 49))                  {                      return highBits + (6112L << 49);                  }                  else                  {                      return highBits - (6176L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6175L << 47))                  {                      return highBits + (6112L << 47);                  }                  else                  {                      return highBits - (6176L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,MapIEEEHighBitsToDecimal128HighBits,The following statement contains a magic number: if (Flags.IsFirstForm(highBits))              {                  var exponentBits = highBits & Flags.FirstFormExponentBits;                  if (exponentBits <= (6175L << 49))                  {                      return highBits + (6112L << 49);                  }                  else                  {                      return highBits - (6176L << 49);                  }              }              else if (Flags.IsSecondForm(highBits))              {                  var exponentBits = highBits & Flags.SecondFormExponentBits;                  if (exponentBits <= (6175L << 47))                  {                      return highBits + (6112L << 47);                  }                  else                  {                      return highBits - (6176L << 47);                  }              }              else              {                  return highBits;              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,Decimal128,The following statement contains a magic number: var isNegative = (bits[3] & 0x80000000) != 0;
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,Decimal128,The following statement contains a magic number: var scale = (short)((bits[3] & 0x00FF0000) >> 16);
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,Decimal128,The following statement contains a magic number: var scale = (short)((bits[3] & 0x00FF0000) >> 16);
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,Decimal128,The following statement contains a magic number: var significandHigh = (ulong)(uint)bits[2];
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,Decimal128,The following statement contains a magic number: var significandLow = ((ulong)(uint)bits[1] << 32) | (ulong)(uint)bits[0];
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,Decimal128,The following statement contains a magic number: _highBits = (isNegative ? Flags.SignBit : 0) | ((ulong)MapExponentToDecimal128BiasedExponent(exponent) << 49) | significandHigh;
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _highBits.GetHashCode();
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _lowBits.GetHashCode();
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ToString,The following statement contains a magic number: if (Flags.IsFirstForm(_highBits))              {                  var exponent = GetExponent(this);                  var significand = GetSignificand(this);                  var coefficientString = significand.ToString();                  var adjustedExponent = exponent + coefficientString.Length - 1;                    string result;                  if (exponent > 0 || adjustedExponent < -6)                  {                      result = ToStringWithExponentialNotation(coefficientString' adjustedExponent);                  }                  else                  {                      result = ToStringWithoutExponentialNotation(coefficientString' exponent);                  }                    if (Flags.IsNegative(_highBits))                  {                      result = "-" + result;                  }                    return result;              }              else if (Flags.IsSecondForm(_highBits))              {                  // invalid representation treated as zero                  var exponent = GetExponent(this);                  if (exponent == 0)                  {                      return Flags.IsNegative(_highBits) ? "-0" : "0";                  }                  else                  {                      var exponentString = exponent.ToString(NumberFormatInfo.InvariantInfo);                      if (exponent > 0)                      {                          exponentString = "+" + exponentString;                      }                      return (Flags.IsNegative(_highBits) ? "-0E" : "0E") + exponentString;                  }              }              else if (Flags.IsNegativeInfinity(_highBits))              {                  return "-Infinity";              }              else if (Flags.IsPositiveInfinity(_highBits))              {                  return "Infinity";              }              else              {                  return "NaN";              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,TryTruncateToUInt64,The following statement contains a magic number: if (exponent < 0)              {                  while (exponent < 0)                  {                      uint remainder; // ignored because we are truncating                      significand = UInt128.Divide(significand' (uint)10' out remainder);                      if (significand.Equals(UInt128.Zero))                      {                          value = 0;                          return true;                      }                      exponent += 1;                  }              }              else if (exponent > 0)              {                  while (exponent > 0)                  {                      significand = UInt128.Multiply(significand' (uint)10);                      if (significand.CompareTo(__maxSignificand) > 0)                      {                          value = 0;                          return false;                      }                      exponent -= 1;                  }              }
Magic Number,MongoDB.Bson,Decimal128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,TryTruncateToUInt64,The following statement contains a magic number: if (exponent < 0)              {                  while (exponent < 0)                  {                      uint remainder; // ignored because we are truncating                      significand = UInt128.Divide(significand' (uint)10' out remainder);                      if (significand.Equals(UInt128.Zero))                      {                          value = 0;                          return true;                      }                      exponent += 1;                  }              }              else if (exponent > 0)              {                  while (exponent > 0)                  {                      significand = UInt128.Multiply(significand' (uint)10);                      if (significand.CompareTo(__maxSignificand) > 0)                      {                          value = 0;                          return false;                      }                      exponent -= 1;                  }              }
Magic Number,MongoDB.Bson,Decimal128Comparer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\Decimal128.cs,ComparePositiveNumbers,The following statement contains a magic number: if (exponentDifference <= 66)                  {                      // we may or may not be able to make the exponents equal but we won't know until we try                      // but we do know we can't eliminate an exponent difference larger than 66                      if (xExponent < yExponent)                      {                          TryIncreaseExponent(ref xSignificand' ref xExponent' yExponent);                          TryDecreaseExponent(ref ySignificand' ref yExponent' xExponent);                      }                      else if (xExponent > yExponent)                      {                          TryDecreaseExponent(ref xSignificand' ref xExponent' yExponent);                          TryIncreaseExponent(ref ySignificand' ref yExponent' xExponent);                      }                  }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: if (bytes.Length != 16)              {                  var message = string.Format("Length of byte array must be 16' not {0}."' bytes.Length);                  throw new ArgumentException(message);              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,FromBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert byte array to Guid because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,GuidConverter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\GuidConverter.cs,ToBytes,The following statement contains a magic number: switch (representation)              {                  case GuidRepresentation.CSharpLegacy:                      if (!BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.JavaLegacy:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      Array.Reverse(bytes' 0' 8);                      Array.Reverse(bytes' 8' 8);                      break;                  case GuidRepresentation.PythonLegacy:                  case GuidRepresentation.Standard:                      if (BitConverter.IsLittleEndian)                      {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                  case GuidRepresentation.Unspecified:                      throw new InvalidOperationException("Unable to convert Guid to byte array because GuidRepresentation is Unspecified.");                  default:                      throw new BsonInternalException("Unexpected GuidRepresentation.");              }
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Divide,The following statement contains a magic number: var a = x.High >> 32;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Divide,The following statement contains a magic number: var c = x.Low >> 32;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Divide,The following statement contains a magic number: temp = ((temp % divisor) << 32) + b;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Divide,The following statement contains a magic number: temp = ((temp % divisor) << 32) + c;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Divide,The following statement contains a magic number: temp = ((temp % divisor) << 32) + d;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Divide,The following statement contains a magic number: var high = (a << 32) + b;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Divide,The following statement contains a magic number: var low = (c << 32) + d;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var a = x.High >> 32;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var c = x.Low >> 32;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: c = c * y + (d >> 32);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: b = b * y + (c >> 32);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: a = a * y + (b >> 32);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var low = (c << 32) + (d & 0xffffffff);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var high = (a << 32) + (b & 0xffffffff);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var a = x >> 32;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var c = y >> 32;
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var mid = (ad & 0xffffffff) + (bc & 0xffffffff) + (bd >> 32);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var high = ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var high = ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var high = ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,Multiply,The following statement contains a magic number: var low = (mid << 32) + (bd & 0xffffffff);
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,TryParse,The following statement contains a magic number: while (s.Length > 0)              {                  int fragmentSize = s.Length % 9;                  if (fragmentSize == 0)                  {                      fragmentSize = 9;                  }                  var fragmentString = s.Substring(0' fragmentSize);                    uint fragmentValue;                  if (!uint.TryParse(fragmentString' out fragmentValue))                  {                      value = default(UInt128);                      return false;                  }                    var combinedValue = UInt128.Multiply(value' (uint)1000000000);                  combinedValue = UInt128.Add(combinedValue' new UInt128(0' fragmentValue));                  if (UInt128.Compare(combinedValue' value) < 0)                  {                      // overflow means s represents a value larger than UInt128.MaxValue                      value = default(UInt128);                      return false;                  }                  value = combinedValue;                    s = s.Substring(fragmentSize);              }
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,TryParse,The following statement contains a magic number: while (s.Length > 0)              {                  int fragmentSize = s.Length % 9;                  if (fragmentSize == 0)                  {                      fragmentSize = 9;                  }                  var fragmentString = s.Substring(0' fragmentSize);                    uint fragmentValue;                  if (!uint.TryParse(fragmentString' out fragmentValue))                  {                      value = default(UInt128);                      return false;                  }                    var combinedValue = UInt128.Multiply(value' (uint)1000000000);                  combinedValue = UInt128.Add(combinedValue' new UInt128(0' fragmentValue));                  if (UInt128.Compare(combinedValue' value) < 0)                  {                      // overflow means s represents a value larger than UInt128.MaxValue                      value = default(UInt128);                      return false;                  }                  value = combinedValue;                    s = s.Substring(fragmentSize);              }
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,TryParse,The following statement contains a magic number: while (s.Length > 0)              {                  int fragmentSize = s.Length % 9;                  if (fragmentSize == 0)                  {                      fragmentSize = 9;                  }                  var fragmentString = s.Substring(0' fragmentSize);                    uint fragmentValue;                  if (!uint.TryParse(fragmentString' out fragmentValue))                  {                      value = default(UInt128);                      return false;                  }                    var combinedValue = UInt128.Multiply(value' (uint)1000000000);                  combinedValue = UInt128.Add(combinedValue' new UInt128(0' fragmentValue));                  if (UInt128.Compare(combinedValue' value) < 0)                  {                      // overflow means s represents a value larger than UInt128.MaxValue                      value = default(UInt128);                      return false;                  }                  value = combinedValue;                    s = s.Substring(fragmentSize);              }
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,GetHashCode,The following statement contains a magic number: return 37 * _high.GetHashCode() + _low.GetHashCode();
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,ToString,The following statement contains a magic number: while (true)              {                  // convert 9 decimal digits at a time to a string                  uint remainder;                  value = UInt128.Divide(value' (uint)1000000000' out remainder);                  var fragmentString = remainder.ToString(NumberFormatInfo.InvariantInfo);                    if (UInt128.Equals(value' UInt128.Zero))                  {                      if (builder == null)                      {                          return fragmentString; // values with 9 decimal digits or less don't need the builder                      }                      else                      {                          builder.Insert(0' fragmentString);                          return builder.ToString();                      }                  }                    if (builder == null)                  {                      builder = new StringBuilder(38);                  }                  builder.Insert(0' fragmentString);                  builder.Insert(0' "0"' 9 - fragmentString.Length);              }
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,ToString,The following statement contains a magic number: while (true)              {                  // convert 9 decimal digits at a time to a string                  uint remainder;                  value = UInt128.Divide(value' (uint)1000000000' out remainder);                  var fragmentString = remainder.ToString(NumberFormatInfo.InvariantInfo);                    if (UInt128.Equals(value' UInt128.Zero))                  {                      if (builder == null)                      {                          return fragmentString; // values with 9 decimal digits or less don't need the builder                      }                      else                      {                          builder.Insert(0' fragmentString);                          return builder.ToString();                      }                  }                    if (builder == null)                  {                      builder = new StringBuilder(38);                  }                  builder.Insert(0' fragmentString);                  builder.Insert(0' "0"' 9 - fragmentString.Length);              }
Magic Number,MongoDB.Bson,UInt128,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\UInt128.cs,ToString,The following statement contains a magic number: while (true)              {                  // convert 9 decimal digits at a time to a string                  uint remainder;                  value = UInt128.Divide(value' (uint)1000000000' out remainder);                  var fragmentString = remainder.ToString(NumberFormatInfo.InvariantInfo);                    if (UInt128.Equals(value' UInt128.Zero))                  {                      if (builder == null)                      {                          return fragmentString; // values with 9 decimal digits or less don't need the builder                      }                      else                      {                          builder.Insert(0' fragmentString);                          return builder.ToString();                      }                  }                    if (builder == null)                  {                      builder = new StringBuilder(38);                  }                  builder.Insert(0' fragmentString);                  builder.Insert(0' "0"' 9 - fragmentString.Length);              }
Magic Number,MongoDB.Bson,PowerOf2,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\PowerOf2.cs,RoundUpToPowerOf2,The following statement contains a magic number: n = n | (n >> 2);
Magic Number,MongoDB.Bson,PowerOf2,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\PowerOf2.cs,RoundUpToPowerOf2,The following statement contains a magic number: n = n | (n >> 4);
Magic Number,MongoDB.Bson,PowerOf2,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\PowerOf2.cs,RoundUpToPowerOf2,The following statement contains a magic number: n = n | (n >> 8);
Magic Number,MongoDB.Bson,PowerOf2,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\PowerOf2.cs,RoundUpToPowerOf2,The following statement contains a magic number: n = n | (n >> 16);
Magic Number,MongoDB.Bson,BsonBoolean,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonBoolean.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonBoolean,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonBoolean.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonBoolean,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonBoolean.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _value.GetHashCode();
Magic Number,MongoDB.Bson,BsonDateTime,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDateTime.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonDateTime,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDateTime.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonDateTime,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDateTime.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _millisecondsSinceEpoch.GetHashCode();
Magic Number,MongoDB.Bson,BsonInt64,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonInt64.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonInt64,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonInt64.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonInt64,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonInt64.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _value.GetHashCode();
Magic Number,MongoDB.Bson,BsonBinaryData,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonBinaryData.cs,BsonBinaryData,The following statement contains a magic number: if (subType == BsonBinarySubType.UuidStandard || subType == BsonBinarySubType.UuidLegacy)              {                  if (bytes.Length != 16)                  {                      var message = string.Format(                          "Length must be 16' not {0}' when subType is {1}."'                          bytes.Length' subType);                      throw new ArgumentException(message);                  }                  var expectedSubType = (guidRepresentation == GuidRepresentation.Standard) ? BsonBinarySubType.UuidStandard : BsonBinarySubType.UuidLegacy;                  if (subType != expectedSubType)                  {                      var message = string.Format(                          "SubType must be {0}' not {1}' when GuidRepresentation is {2}."'                          expectedSubType' subType' GuidRepresentation);                      throw new ArgumentException(message);                  }              }              else              {                  if (guidRepresentation != GuidRepresentation.Unspecified)                  {                      var message = string.Format(                          "GuidRepresentation must be Unspecified' not {0}' when SubType is not UuidStandard or UuidLegacy."'                          guidRepresentation);                      throw new ArgumentException(message);                  }              }
Magic Number,MongoDB.Bson,BsonBinaryData,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonBinaryData.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonBinaryData,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonBinaryData.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonBinaryData,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonBinaryData.cs,GetHashCode,The following statement contains a magic number: foreach (byte b in _bytes)              {                  hash = 37 * hash + b;              }
Magic Number,MongoDB.Bson,BsonBinaryData,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonBinaryData.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _subType.GetHashCode();
Magic Number,MongoDB.Bson,BsonJavaScriptWithScope,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonJavaScriptWithScope.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonJavaScriptWithScope,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonJavaScriptWithScope.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + base.GetHashCode();
Magic Number,MongoDB.Bson,BsonJavaScriptWithScope,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonJavaScriptWithScope.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _scope.GetHashCode();
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ObjectId,The following statement contains a magic number: if (bytes.Length != 12)              {                  throw new ArgumentException("Byte array must be 12 bytes long"' "bytes");              }
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ObjectId,The following statement contains a magic number: _b = (machine << 8) | (((int)pid >> 8) & 0xff);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ObjectId,The following statement contains a magic number: _b = (machine << 8) | (((int)pid >> 8) & 0xff);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ObjectId,The following statement contains a magic number: _c = ((int)pid << 24) | increment;
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: byte[] bytes = new byte[12];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[0] = (byte)(timestamp >> 24);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[1] = (byte)(timestamp >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[2] = (byte)(timestamp >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[2] = (byte)(timestamp >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[3] = (byte)(timestamp);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[4] = (byte)(machine >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[4] = (byte)(machine >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[5] = (byte)(machine >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[5] = (byte)(machine >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[6] = (byte)(machine);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[7] = (byte)(pid >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[7] = (byte)(pid >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[8] = (byte)(pid);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[9] = (byte)(increment >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[9] = (byte)(increment >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[10] = (byte)(increment >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[10] = (byte)(increment >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Pack,The following statement contains a magic number: bytes[11] = (byte)(increment);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,TryParse,The following statement contains a magic number: if (s != null && s.Length == 24)              {                  byte[] bytes;                  if (BsonUtils.TryParseHexString(s' out bytes))                  {                      objectId = new ObjectId(bytes);                      return true;                  }              }
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: if (bytes.Length != 12)              {                  throw new ArgumentOutOfRangeException("bytes"' "Byte array must be 12 bytes long.");              }
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: timestamp = (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: timestamp = (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: timestamp = (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: timestamp = (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: timestamp = (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: machine = (bytes[4] << 16) + (bytes[5] << 8) + bytes[6];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: machine = (bytes[4] << 16) + (bytes[5] << 8) + bytes[6];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: machine = (bytes[4] << 16) + (bytes[5] << 8) + bytes[6];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: machine = (bytes[4] << 16) + (bytes[5] << 8) + bytes[6];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: machine = (bytes[4] << 16) + (bytes[5] << 8) + bytes[6];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: pid = (short)((bytes[7] << 8) + bytes[8]);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: pid = (short)((bytes[7] << 8) + bytes[8]);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: pid = (short)((bytes[7] << 8) + bytes[8]);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: increment = (bytes[9] << 16) + (bytes[10] << 8) + bytes[11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: increment = (bytes[9] << 16) + (bytes[10] << 8) + bytes[11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: increment = (bytes[9] << 16) + (bytes[10] << 8) + bytes[11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: increment = (bytes[9] << 16) + (bytes[10] << 8) + bytes[11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,Unpack,The following statement contains a magic number: increment = (bytes[9] << 16) + (bytes[10] << 8) + bytes[11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: a = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: a = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: a = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: a = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: a = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: b = (bytes[offset + 4] << 24) | (bytes[offset + 5] << 16) | (bytes[offset + 6] << 8) | bytes[offset + 7];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: b = (bytes[offset + 4] << 24) | (bytes[offset + 5] << 16) | (bytes[offset + 6] << 8) | bytes[offset + 7];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: b = (bytes[offset + 4] << 24) | (bytes[offset + 5] << 16) | (bytes[offset + 6] << 8) | bytes[offset + 7];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: b = (bytes[offset + 4] << 24) | (bytes[offset + 5] << 16) | (bytes[offset + 6] << 8) | bytes[offset + 7];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: b = (bytes[offset + 4] << 24) | (bytes[offset + 5] << 16) | (bytes[offset + 6] << 8) | bytes[offset + 7];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: b = (bytes[offset + 4] << 24) | (bytes[offset + 5] << 16) | (bytes[offset + 6] << 8) | bytes[offset + 7];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: b = (bytes[offset + 4] << 24) | (bytes[offset + 5] << 16) | (bytes[offset + 6] << 8) | bytes[offset + 7];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: c = (bytes[offset + 8] << 24) | (bytes[offset + 9] << 16) | (bytes[offset + 10] << 8) | bytes[offset + 11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: c = (bytes[offset + 8] << 24) | (bytes[offset + 9] << 16) | (bytes[offset + 10] << 8) | bytes[offset + 11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: c = (bytes[offset + 8] << 24) | (bytes[offset + 9] << 16) | (bytes[offset + 10] << 8) | bytes[offset + 11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: c = (bytes[offset + 8] << 24) | (bytes[offset + 9] << 16) | (bytes[offset + 10] << 8) | bytes[offset + 11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: c = (bytes[offset + 8] << 24) | (bytes[offset + 9] << 16) | (bytes[offset + 10] << 8) | bytes[offset + 11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: c = (bytes[offset + 8] << 24) | (bytes[offset + 9] << 16) | (bytes[offset + 10] << 8) | bytes[offset + 11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,FromByteArray,The following statement contains a magic number: c = (bytes[offset + 8] << 24) | (bytes[offset + 9] << 16) | (bytes[offset + 10] << 8) | bytes[offset + 11];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _a.GetHashCode();
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _b.GetHashCode();
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _c.GetHashCode();
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: var bytes = new byte[12];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: if (offset + 12 > destination.Length)              {                  throw new ArgumentException("Not enough room in destination buffer."' "offset");              }
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 0] = (byte)(_a >> 24);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 1] = (byte)(_a >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 2] = (byte)(_a >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 2] = (byte)(_a >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 3] = (byte)(_a);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 4] = (byte)(_b >> 24);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 4] = (byte)(_b >> 24);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 5] = (byte)(_b >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 5] = (byte)(_b >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 6] = (byte)(_b >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 6] = (byte)(_b >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 7] = (byte)(_b);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 8] = (byte)(_c >> 24);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 8] = (byte)(_c >> 24);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 9] = (byte)(_c >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 9] = (byte)(_c >> 16);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 10] = (byte)(_c >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 10] = (byte)(_c >> 8);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToByteArray,The following statement contains a magic number: destination[offset + 11] = (byte)(_c);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: var c = new char[24];
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[0] = BsonUtils.ToHexChar((_a >> 28) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[1] = BsonUtils.ToHexChar((_a >> 24) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[2] = BsonUtils.ToHexChar((_a >> 20) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[2] = BsonUtils.ToHexChar((_a >> 20) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[3] = BsonUtils.ToHexChar((_a >> 16) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[3] = BsonUtils.ToHexChar((_a >> 16) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[4] = BsonUtils.ToHexChar((_a >> 12) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[4] = BsonUtils.ToHexChar((_a >> 12) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[5] = BsonUtils.ToHexChar((_a >> 8) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[5] = BsonUtils.ToHexChar((_a >> 8) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[6] = BsonUtils.ToHexChar((_a >> 4) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[6] = BsonUtils.ToHexChar((_a >> 4) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[7] = BsonUtils.ToHexChar(_a & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[8] = BsonUtils.ToHexChar((_b >> 28) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[8] = BsonUtils.ToHexChar((_b >> 28) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[9] = BsonUtils.ToHexChar((_b >> 24) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[9] = BsonUtils.ToHexChar((_b >> 24) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[10] = BsonUtils.ToHexChar((_b >> 20) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[10] = BsonUtils.ToHexChar((_b >> 20) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[11] = BsonUtils.ToHexChar((_b >> 16) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[11] = BsonUtils.ToHexChar((_b >> 16) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[12] = BsonUtils.ToHexChar((_b >> 12) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[12] = BsonUtils.ToHexChar((_b >> 12) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[13] = BsonUtils.ToHexChar((_b >> 8) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[13] = BsonUtils.ToHexChar((_b >> 8) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[14] = BsonUtils.ToHexChar((_b >> 4) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[14] = BsonUtils.ToHexChar((_b >> 4) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[15] = BsonUtils.ToHexChar(_b & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[16] = BsonUtils.ToHexChar((_c >> 28) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[16] = BsonUtils.ToHexChar((_c >> 28) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[17] = BsonUtils.ToHexChar((_c >> 24) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[17] = BsonUtils.ToHexChar((_c >> 24) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[18] = BsonUtils.ToHexChar((_c >> 20) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[18] = BsonUtils.ToHexChar((_c >> 20) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[19] = BsonUtils.ToHexChar((_c >> 16) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[19] = BsonUtils.ToHexChar((_c >> 16) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[20] = BsonUtils.ToHexChar((_c >> 12) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[20] = BsonUtils.ToHexChar((_c >> 12) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[21] = BsonUtils.ToHexChar((_c >> 8) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[21] = BsonUtils.ToHexChar((_c >> 8) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[22] = BsonUtils.ToHexChar((_c >> 4) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[22] = BsonUtils.ToHexChar((_c >> 4) & 0x0f);
Magic Number,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToString,The following statement contains a magic number: c[23] = BsonUtils.ToHexChar(_c & 0x0f);
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,GetFriendlyTypeName,The following statement contains a magic number: sb.Remove(sb.Length - 2' 2);
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,GetFriendlyTypeName,The following statement contains a magic number: sb.Remove(sb.Length - 2' 2);
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,ToDateTimeFromMillisecondsSinceEpoch,The following statement contains a magic number: if (millisecondsSinceEpoch == BsonConstants.DateTimeMaxValueMillisecondsSinceEpoch)              {                  return DateTime.SpecifyKind(DateTime.MaxValue' DateTimeKind.Utc);              }              else              {                  return BsonConstants.UnixEpoch.AddTicks(millisecondsSinceEpoch * 10000);              }
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,ToHexChar,The following statement contains a magic number: return (char)(value + (value < 10 ? '0' : 'a' - 10));
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,ToHexChar,The following statement contains a magic number: return (char)(value + (value < 10 ? '0' : 'a' - 10));
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,ToHexString,The following statement contains a magic number: var c = new char[length * 2];
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,ToHexString,The following statement contains a magic number: for (int i = 0' j = 0; i < length; i++)              {                  var b = bytes[i];                  c[j++] = ToHexChar(b >> 4);                  c[j++] = ToHexChar(b & 0x0f);              }
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,ToMillisecondsSinceEpoch,The following statement contains a magic number: return (utcDateTime - BsonConstants.UnixEpoch).Ticks / 10000;
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,TryParseHexString,The following statement contains a magic number: var buffer = new byte[(s.Length + 1) / 2];
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,TryParseHexString,The following statement contains a magic number: if ((s.Length % 2) == 1)              {                  // if s has an odd length assume an implied leading "0"                  int y;                  if (!TryParseHexChar(s[i++]' out y))                  {                      return false;                  }                  buffer[j++] = (byte)y;              }
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,TryParseHexString,The following statement contains a magic number: while (i < s.Length)              {                  int x' y;                  if (!TryParseHexChar(s[i++]' out x))                  {                      return false;                  }                  if (!TryParseHexChar(s[i++]' out y))                  {                      return false;                  }                  buffer[j++] = (byte)((x << 4) | y);              }
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,TryParseHexChar,The following statement contains a magic number: if (c >= 'a' && c <= 'f')              {                  value = 10 + (c - 'a');                  return true;              }
Magic Number,MongoDB.Bson,BsonUtils,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonUtils.cs,TryParseHexChar,The following statement contains a magic number: if (c >= 'A' && c <= 'F')              {                  value = 10 + (c - 'A');                  return true;              }
Magic Number,MongoDB.Bson,BsonDouble,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDouble.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonDouble,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDouble.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonDouble,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonDouble.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _value.GetHashCode();
Magic Number,MongoDB.Bson,BsonInt32,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonInt32.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonInt32,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonInt32.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonInt32,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonInt32.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _value.GetHashCode();
Magic Number,MongoDB.Bson,BsonString,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonString.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonString,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonString.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonString,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonString.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _value.GetHashCode();
Magic Number,MongoDB.Bson,BsonJavaScript,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonJavaScript.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonJavaScript,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonJavaScript.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonJavaScript,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonJavaScript.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _code.GetHashCode();
Magic Number,MongoDB.Bson,BsonTimestamp,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTimestamp.cs,BsonTimestamp,The following statement contains a magic number: _value = (long)(((ulong)(uint)timestamp << 32) | (ulong)(uint)increment);
Magic Number,MongoDB.Bson,BsonTimestamp,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTimestamp.cs,CompareTo,The following statement contains a magic number: if (otherDateTime != null)              {                  var seconds = (int)(otherDateTime.MillisecondsSinceEpoch / 1000);                  var otherTimestampValue = ((long)seconds) << 32;                  return _value.CompareTo(otherTimestampValue);              }
Magic Number,MongoDB.Bson,BsonTimestamp,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTimestamp.cs,CompareTo,The following statement contains a magic number: if (otherDateTime != null)              {                  var seconds = (int)(otherDateTime.MillisecondsSinceEpoch / 1000);                  var otherTimestampValue = ((long)seconds) << 32;                  return _value.CompareTo(otherTimestampValue);              }
Magic Number,MongoDB.Bson,BsonTimestamp,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTimestamp.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonTimestamp,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTimestamp.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonTimestamp,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTimestamp.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _value.GetHashCode();
Magic Number,MongoDB.Bson,BsonConstants,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonConstants.cs,BsonConstants,The following statement contains a magic number: __unixEpoch = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,MongoDB.Bson,BsonConstants,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonConstants.cs,BsonConstants,The following statement contains a magic number: __dateTimeMaxValueMillisecondsSinceEpoch = (DateTime.MaxValue - __unixEpoch).Ticks / 10000;
Magic Number,MongoDB.Bson,BsonConstants,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\BsonConstants.cs,BsonConstants,The following statement contains a magic number: __dateTimeMinValueMillisecondsSinceEpoch = (DateTime.MinValue - __unixEpoch).Ticks / 10000;
Magic Number,MongoDB.Bson,BsonElement,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonElement.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonElement,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonElement.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _name.GetHashCode();
Magic Number,MongoDB.Bson,BsonElement,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonElement.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _value.GetHashCode();
Magic Number,MongoDB.Bson,BsonObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonObjectId.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonObjectId.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonObjectId.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _value.GetHashCode();
Magic Number,MongoDB.Bson,BsonRegularExpression,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonRegularExpression.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,MongoDB.Bson,BsonRegularExpression,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonRegularExpression.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + BsonType.GetHashCode();
Magic Number,MongoDB.Bson,BsonRegularExpression,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonRegularExpression.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _pattern.GetHashCode();
Magic Number,MongoDB.Bson,BsonRegularExpression,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonRegularExpression.cs,GetHashCode,The following statement contains a magic number: hash = 37 * hash + _options.GetHashCode();
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: const int asciiZero = 48;
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: var a = (byte)(asciiZero + n % 10);
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: n = n / 10;
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: var b = (byte)(asciiZero + n % 10);
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: n = n / 10;
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: var c = (byte)(asciiZero + n % 10);
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: n = n / 10;
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: var d = (byte)(asciiZero + n % 10);
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: n = n / 10;
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: var e = (byte)(asciiZero + n % 10);
Magic Number,MongoDB.Bson.IO,ArrayElementNameAccelerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ArrayElementNameAccelerator.cs,CreateElementNameBytes,The following statement contains a magic number: n = n / 10;
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadCStringBytes,The following statement contains a magic number: var memoryStream = new MemoryStream(32);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadDouble,The following statement contains a magic number: this.ReadBytes(_temp' 0' 8);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadInt32,The following statement contains a magic number: this.ReadBytes(_temp' 0' 4);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadInt32,The following statement contains a magic number: return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadInt32,The following statement contains a magic number: return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadInt32,The following statement contains a magic number: return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadInt32,The following statement contains a magic number: return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadInt32,The following statement contains a magic number: return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadInt64,The following statement contains a magic number: this.ReadBytes(_temp' 0' 8);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,ReadObjectId,The following statement contains a magic number: this.ReadBytes(_temp' 0' 12);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,WriteDouble,The following statement contains a magic number: _stream.Write(bytes' 0' 8);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,WriteInt32,The following statement contains a magic number: _temp[1] = (byte)(value >> 8);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,WriteInt32,The following statement contains a magic number: _temp[2] = (byte)(value >> 16);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,WriteInt32,The following statement contains a magic number: _temp[2] = (byte)(value >> 16);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,WriteInt32,The following statement contains a magic number: _temp[3] = (byte)(value >> 24);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,WriteInt32,The following statement contains a magic number: _temp[3] = (byte)(value >> 24);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,WriteInt32,The following statement contains a magic number: _stream.Write(_temp' 0' 4);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,WriteInt64,The following statement contains a magic number: _stream.Write(bytes' 0' 8);
Magic Number,MongoDB.Bson.IO,BsonStreamAdapter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonStreamAdapter.cs,WriteObjectId,The following statement contains a magic number: _stream.Write(_temp' 0' 12);
Magic Number,MongoDB.Bson.IO,BsonTrieNode<TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonTrie.cs,AddChild,The following statement contains a magic number: if (_children != null)              {                  // add a new child to the existing _children                  var children = new BsonTrieNode<TValue>[_children.Length + 1];                  Array.Copy(_children' children' _children.Length);                  children[children.Length - 1] = child;                    var childrenIndexes = _childrenIndexes;                  var minChildKeyByte = _minChildKeyByte;                  var maxChildKeyByte = _minChildKeyByte + _childrenIndexes.Length - 1;                    // if new keyByte doesn't fall within existing min/max range expand the range                  if (child._keyByte < minChildKeyByte)                  {                      // grow the indexes on the min side                      minChildKeyByte = child._keyByte;                      childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                      var sizeDelta = childrenIndexes.Length - _childrenIndexes.Length;                      for (var i = 0; i < sizeDelta; i++)                      {                          childrenIndexes[i] = 255;                      }                      Array.Copy(_childrenIndexes' 0' childrenIndexes' sizeDelta' _childrenIndexes.Length);                  }                  else if (child._keyByte > maxChildKeyByte)                  {                      // grow the indexes on the max side                      maxChildKeyByte = child._keyByte;                      childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                      Array.Copy(_childrenIndexes' 0' childrenIndexes' 0' _childrenIndexes.Length);                      for (var i = _childrenIndexes.Length; i < childrenIndexes.Length; i++)                      {                          childrenIndexes[i] = 255;                      }                  }                  childrenIndexes[child._keyByte - minChildKeyByte] = (byte)(children.Length - 1);                    _children = children;                  _childrenIndexes = childrenIndexes;                  _minChildKeyByte = minChildKeyByte;              }              else if (_onlyChild != null)              {                  // switch from having an _onlyChild to having two _children                  var children = new BsonTrieNode<TValue>[2];                  children[0] = _onlyChild;                  children[1] = child;                    var minChildKeyByte = _onlyChild._keyByte;                  var maxChildKeyByte = child._keyByte;                  if (minChildKeyByte > maxChildKeyByte)                  {                      minChildKeyByte = child._keyByte;                      maxChildKeyByte = _onlyChild._keyByte;                  }                    var childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                  for (var i = 0; i < childrenIndexes.Length; i++)                  {                      childrenIndexes[i] = 255;                  }                  childrenIndexes[_onlyChild._keyByte - minChildKeyByte] = 0;                  childrenIndexes[child._keyByte - minChildKeyByte] = 1;                    _onlyChild = null;                  _children = children;                  _childrenIndexes = childrenIndexes;                  _minChildKeyByte = minChildKeyByte;              }              else              {                  _onlyChild = child;              }
Magic Number,MongoDB.Bson.IO,BsonTrieNode<TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonTrie.cs,AddChild,The following statement contains a magic number: if (_children != null)              {                  // add a new child to the existing _children                  var children = new BsonTrieNode<TValue>[_children.Length + 1];                  Array.Copy(_children' children' _children.Length);                  children[children.Length - 1] = child;                    var childrenIndexes = _childrenIndexes;                  var minChildKeyByte = _minChildKeyByte;                  var maxChildKeyByte = _minChildKeyByte + _childrenIndexes.Length - 1;                    // if new keyByte doesn't fall within existing min/max range expand the range                  if (child._keyByte < minChildKeyByte)                  {                      // grow the indexes on the min side                      minChildKeyByte = child._keyByte;                      childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                      var sizeDelta = childrenIndexes.Length - _childrenIndexes.Length;                      for (var i = 0; i < sizeDelta; i++)                      {                          childrenIndexes[i] = 255;                      }                      Array.Copy(_childrenIndexes' 0' childrenIndexes' sizeDelta' _childrenIndexes.Length);                  }                  else if (child._keyByte > maxChildKeyByte)                  {                      // grow the indexes on the max side                      maxChildKeyByte = child._keyByte;                      childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                      Array.Copy(_childrenIndexes' 0' childrenIndexes' 0' _childrenIndexes.Length);                      for (var i = _childrenIndexes.Length; i < childrenIndexes.Length; i++)                      {                          childrenIndexes[i] = 255;                      }                  }                  childrenIndexes[child._keyByte - minChildKeyByte] = (byte)(children.Length - 1);                    _children = children;                  _childrenIndexes = childrenIndexes;                  _minChildKeyByte = minChildKeyByte;              }              else if (_onlyChild != null)              {                  // switch from having an _onlyChild to having two _children                  var children = new BsonTrieNode<TValue>[2];                  children[0] = _onlyChild;                  children[1] = child;                    var minChildKeyByte = _onlyChild._keyByte;                  var maxChildKeyByte = child._keyByte;                  if (minChildKeyByte > maxChildKeyByte)                  {                      minChildKeyByte = child._keyByte;                      maxChildKeyByte = _onlyChild._keyByte;                  }                    var childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                  for (var i = 0; i < childrenIndexes.Length; i++)                  {                      childrenIndexes[i] = 255;                  }                  childrenIndexes[_onlyChild._keyByte - minChildKeyByte] = 0;                  childrenIndexes[child._keyByte - minChildKeyByte] = 1;                    _onlyChild = null;                  _children = children;                  _childrenIndexes = childrenIndexes;                  _minChildKeyByte = minChildKeyByte;              }              else              {                  _onlyChild = child;              }
Magic Number,MongoDB.Bson.IO,BsonTrieNode<TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonTrie.cs,AddChild,The following statement contains a magic number: if (_children != null)              {                  // add a new child to the existing _children                  var children = new BsonTrieNode<TValue>[_children.Length + 1];                  Array.Copy(_children' children' _children.Length);                  children[children.Length - 1] = child;                    var childrenIndexes = _childrenIndexes;                  var minChildKeyByte = _minChildKeyByte;                  var maxChildKeyByte = _minChildKeyByte + _childrenIndexes.Length - 1;                    // if new keyByte doesn't fall within existing min/max range expand the range                  if (child._keyByte < minChildKeyByte)                  {                      // grow the indexes on the min side                      minChildKeyByte = child._keyByte;                      childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                      var sizeDelta = childrenIndexes.Length - _childrenIndexes.Length;                      for (var i = 0; i < sizeDelta; i++)                      {                          childrenIndexes[i] = 255;                      }                      Array.Copy(_childrenIndexes' 0' childrenIndexes' sizeDelta' _childrenIndexes.Length);                  }                  else if (child._keyByte > maxChildKeyByte)                  {                      // grow the indexes on the max side                      maxChildKeyByte = child._keyByte;                      childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                      Array.Copy(_childrenIndexes' 0' childrenIndexes' 0' _childrenIndexes.Length);                      for (var i = _childrenIndexes.Length; i < childrenIndexes.Length; i++)                      {                          childrenIndexes[i] = 255;                      }                  }                  childrenIndexes[child._keyByte - minChildKeyByte] = (byte)(children.Length - 1);                    _children = children;                  _childrenIndexes = childrenIndexes;                  _minChildKeyByte = minChildKeyByte;              }              else if (_onlyChild != null)              {                  // switch from having an _onlyChild to having two _children                  var children = new BsonTrieNode<TValue>[2];                  children[0] = _onlyChild;                  children[1] = child;                    var minChildKeyByte = _onlyChild._keyByte;                  var maxChildKeyByte = child._keyByte;                  if (minChildKeyByte > maxChildKeyByte)                  {                      minChildKeyByte = child._keyByte;                      maxChildKeyByte = _onlyChild._keyByte;                  }                    var childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                  for (var i = 0; i < childrenIndexes.Length; i++)                  {                      childrenIndexes[i] = 255;                  }                  childrenIndexes[_onlyChild._keyByte - minChildKeyByte] = 0;                  childrenIndexes[child._keyByte - minChildKeyByte] = 1;                    _onlyChild = null;                  _children = children;                  _childrenIndexes = childrenIndexes;                  _minChildKeyByte = minChildKeyByte;              }              else              {                  _onlyChild = child;              }
Magic Number,MongoDB.Bson.IO,BsonTrieNode<TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonTrie.cs,AddChild,The following statement contains a magic number: if (_children != null)              {                  // add a new child to the existing _children                  var children = new BsonTrieNode<TValue>[_children.Length + 1];                  Array.Copy(_children' children' _children.Length);                  children[children.Length - 1] = child;                    var childrenIndexes = _childrenIndexes;                  var minChildKeyByte = _minChildKeyByte;                  var maxChildKeyByte = _minChildKeyByte + _childrenIndexes.Length - 1;                    // if new keyByte doesn't fall within existing min/max range expand the range                  if (child._keyByte < minChildKeyByte)                  {                      // grow the indexes on the min side                      minChildKeyByte = child._keyByte;                      childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                      var sizeDelta = childrenIndexes.Length - _childrenIndexes.Length;                      for (var i = 0; i < sizeDelta; i++)                      {                          childrenIndexes[i] = 255;                      }                      Array.Copy(_childrenIndexes' 0' childrenIndexes' sizeDelta' _childrenIndexes.Length);                  }                  else if (child._keyByte > maxChildKeyByte)                  {                      // grow the indexes on the max side                      maxChildKeyByte = child._keyByte;                      childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                      Array.Copy(_childrenIndexes' 0' childrenIndexes' 0' _childrenIndexes.Length);                      for (var i = _childrenIndexes.Length; i < childrenIndexes.Length; i++)                      {                          childrenIndexes[i] = 255;                      }                  }                  childrenIndexes[child._keyByte - minChildKeyByte] = (byte)(children.Length - 1);                    _children = children;                  _childrenIndexes = childrenIndexes;                  _minChildKeyByte = minChildKeyByte;              }              else if (_onlyChild != null)              {                  // switch from having an _onlyChild to having two _children                  var children = new BsonTrieNode<TValue>[2];                  children[0] = _onlyChild;                  children[1] = child;                    var minChildKeyByte = _onlyChild._keyByte;                  var maxChildKeyByte = child._keyByte;                  if (minChildKeyByte > maxChildKeyByte)                  {                      minChildKeyByte = child._keyByte;                      maxChildKeyByte = _onlyChild._keyByte;                  }                    var childrenIndexes = new byte[maxChildKeyByte - minChildKeyByte + 1];                  for (var i = 0; i < childrenIndexes.Length; i++)                  {                      childrenIndexes[i] = 255;                  }                  childrenIndexes[_onlyChild._keyByte - minChildKeyByte] = 0;                  childrenIndexes[child._keyByte - minChildKeyByte] = 1;                    _onlyChild = null;                  _children = children;                  _childrenIndexes = childrenIndexes;                  _minChildKeyByte = minChildKeyByte;              }              else              {                  _onlyChild = child;              }
Magic Number,MongoDB.Bson.IO,CStringUtf8Encoding,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\CStringUtf8Encoding.cs,GetBytes,The following statement contains a magic number: for (var charIndex = 0; charIndex < charLength; charIndex++)              {                  var c = (int)value[charIndex];                  if (c == 0)                  {                      throw new ArgumentException("A CString cannot contain null bytes."' "value");                  }                  else if (c <= 0x7f)                  {                      bytes[byteIndex++] = (byte)c;                  }                  else if (c <= 0x7ff)                  {                      var byte1 = 0xc0 | (c >> 6);                      var byte2 = 0x80 | (c & 0x3f);                      bytes[byteIndex++] = (byte)byte1;                      bytes[byteIndex++] = (byte)byte2;                  }                  else if (c <= 0xd7ff || c >= 0xe000)                  {                      var byte1 = 0xe0 | (c >> 12);                      var byte2 = 0x80 | ((c >> 6) & 0x3f);                      var byte3 = 0x80 | (c & 0x3f);                      bytes[byteIndex++] = (byte)byte1;                      bytes[byteIndex++] = (byte)byte2;                      bytes[byteIndex++] = (byte)byte3;                  }                  else                  {                      // let fallback encoding handle surrogate pairs                      var bytesWritten = fallbackEncoding.GetBytes(value' 0' value.Length' bytes' byteIndex);                      if (Array.IndexOf<byte>(bytes' 0' initialByteIndex' bytesWritten) != -1)                      {                          throw new ArgumentException("A CString cannot contain null bytes."' "value");                      }                      return bytesWritten;                  }              }
Magic Number,MongoDB.Bson.IO,CStringUtf8Encoding,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\CStringUtf8Encoding.cs,GetBytes,The following statement contains a magic number: for (var charIndex = 0; charIndex < charLength; charIndex++)              {                  var c = (int)value[charIndex];                  if (c == 0)                  {                      throw new ArgumentException("A CString cannot contain null bytes."' "value");                  }                  else if (c <= 0x7f)                  {                      bytes[byteIndex++] = (byte)c;                  }                  else if (c <= 0x7ff)                  {                      var byte1 = 0xc0 | (c >> 6);                      var byte2 = 0x80 | (c & 0x3f);                      bytes[byteIndex++] = (byte)byte1;                      bytes[byteIndex++] = (byte)byte2;                  }                  else if (c <= 0xd7ff || c >= 0xe000)                  {                      var byte1 = 0xe0 | (c >> 12);                      var byte2 = 0x80 | ((c >> 6) & 0x3f);                      var byte3 = 0x80 | (c & 0x3f);                      bytes[byteIndex++] = (byte)byte1;                      bytes[byteIndex++] = (byte)byte2;                      bytes[byteIndex++] = (byte)byte3;                  }                  else                  {                      // let fallback encoding handle surrogate pairs                      var bytesWritten = fallbackEncoding.GetBytes(value' 0' value.Length' bytes' byteIndex);                      if (Array.IndexOf<byte>(bytes' 0' initialByteIndex' bytesWritten) != -1)                      {                          throw new ArgumentException("A CString cannot contain null bytes."' "value");                      }                      return bytesWritten;                  }              }
Magic Number,MongoDB.Bson.IO,CStringUtf8Encoding,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\CStringUtf8Encoding.cs,GetBytes,The following statement contains a magic number: for (var charIndex = 0; charIndex < charLength; charIndex++)              {                  var c = (int)value[charIndex];                  if (c == 0)                  {                      throw new ArgumentException("A CString cannot contain null bytes."' "value");                  }                  else if (c <= 0x7f)                  {                      bytes[byteIndex++] = (byte)c;                  }                  else if (c <= 0x7ff)                  {                      var byte1 = 0xc0 | (c >> 6);                      var byte2 = 0x80 | (c & 0x3f);                      bytes[byteIndex++] = (byte)byte1;                      bytes[byteIndex++] = (byte)byte2;                  }                  else if (c <= 0xd7ff || c >= 0xe000)                  {                      var byte1 = 0xe0 | (c >> 12);                      var byte2 = 0x80 | ((c >> 6) & 0x3f);                      var byte3 = 0x80 | (c & 0x3f);                      bytes[byteIndex++] = (byte)byte1;                      bytes[byteIndex++] = (byte)byte2;                      bytes[byteIndex++] = (byte)byte3;                  }                  else                  {                      // let fallback encoding handle surrogate pairs                      var bytesWritten = fallbackEncoding.GetBytes(value' 0' value.Length' bytes' byteIndex);                      if (Array.IndexOf<byte>(bytes' 0' initialByteIndex' bytesWritten) != -1)                      {                          throw new ArgumentException("A CString cannot contain null bytes."' "value");                      }                      return bytesWritten;                  }              }
Magic Number,MongoDB.Bson.IO,CStringUtf8Encoding,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\CStringUtf8Encoding.cs,GetMaxByteCount,The following statement contains a magic number: return charCount * 3;
Magic Number,MongoDB.Bson.IO,InputBufferChunkSource,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\InputBufferChunkSource.cs,GetChunk,The following statement contains a magic number: if (powerOf2Size - requestedSize > _minChunkSize)              {                  powerOf2Size = powerOf2Size / 2;              }
Magic Number,MongoDB.Bson.IO,JsonBuffer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonBuffer.cs,JsonBuffer,The following statement contains a magic number: _buffer = new StringBuilder(256);
Magic Number,MongoDB.Bson.IO,JsonBuffer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonBuffer.cs,ResetBuffer,The following statement contains a magic number: var minimumTrimCount = 256;
Magic Number,MongoDB.Bson.IO,JsonBuffer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonBuffer.cs,ReadMoreIfAtEndOfBuffer,The following statement contains a magic number: if (_position >= _buffer.Length)              {                  if (_reader != null)                  {                      var blockSize = 1024; // TODO: make configurable?                      var block = new char[blockSize];                      var actualCount = _reader.ReadBlock(block' 0' blockSize);                        if (actualCount > 0)                      {                          _buffer.Append(block' 0' actualCount);                      }                  }              }
Magic Number,MongoDB.Bson.IO,ByteArrayBuffer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteArrayBuffer.cs,EnsureCapacity,The following statement contains a magic number: if (minimumCapacity > _bytes.Length)              {                  var powerOf2 = Math.Max(32' PowerOf2.RoundUpToPowerOf2(minimumCapacity));                  SetCapacity(powerOf2);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadDecimal128,The following statement contains a magic number: ThrowIfEndOfStream(16);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadDouble,The following statement contains a magic number: ThrowIfEndOfStream(8);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadDouble,The following statement contains a magic number: if (segment.Count >= 8)              {                  _position += 8;                  return BitConverter.ToDouble(segment.Array' segment.Offset);              }              else              {                  this.ReadBytes(_temp' 0' 8);                  return BitConverter.ToDouble(_temp' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadDouble,The following statement contains a magic number: if (segment.Count >= 8)              {                  _position += 8;                  return BitConverter.ToDouble(segment.Array' segment.Offset);              }              else              {                  this.ReadBytes(_temp' 0' 8);                  return BitConverter.ToDouble(_temp' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadDouble,The following statement contains a magic number: if (segment.Count >= 8)              {                  _position += 8;                  return BitConverter.ToDouble(segment.Array' segment.Offset);              }              else              {                  this.ReadBytes(_temp' 0' 8);                  return BitConverter.ToDouble(_temp' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: ThrowIfEndOfStream(4);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  _position += 4;                  var bytes = segment.Array;                  var offset = segment.Offset;                  return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);              }              else              {                  this.ReadBytes(_temp' 0' 4);                  return _temp[0] | (_temp[1] << 8) | (_temp[2] << 16) | (_temp[3] << 24);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt64,The following statement contains a magic number: ThrowIfEndOfStream(8);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt64,The following statement contains a magic number: if (segment.Count >= 8)              {                  _position += 8;                  return BitConverter.ToInt64(segment.Array' segment.Offset);              }              else              {                  this.ReadBytes(_temp' 0' 8);                  return BitConverter.ToInt64(_temp' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt64,The following statement contains a magic number: if (segment.Count >= 8)              {                  _position += 8;                  return BitConverter.ToInt64(segment.Array' segment.Offset);              }              else              {                  this.ReadBytes(_temp' 0' 8);                  return BitConverter.ToInt64(_temp' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadInt64,The following statement contains a magic number: if (segment.Count >= 8)              {                  _position += 8;                  return BitConverter.ToInt64(segment.Array' segment.Offset);              }              else              {                  this.ReadBytes(_temp' 0' 8);                  return BitConverter.ToInt64(_temp' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadObjectId,The following statement contains a magic number: ThrowIfEndOfStream(12);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadObjectId,The following statement contains a magic number: if (segment.Count >= 12)              {                  _position += 12;                  return new ObjectId(segment.Array' segment.Offset);              }              else              {                  this.ReadBytes(_temp' 0' 12);                  return new ObjectId(_temp' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadObjectId,The following statement contains a magic number: if (segment.Count >= 12)              {                  _position += 12;                  return new ObjectId(segment.Array' segment.Offset);              }              else              {                  this.ReadBytes(_temp' 0' 12);                  return new ObjectId(_temp' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadObjectId,The following statement contains a magic number: if (segment.Count >= 12)              {                  _position += 12;                  return new ObjectId(segment.Array' segment.Offset);              }              else              {                  this.ReadBytes(_temp' 0' 12);                  return new ObjectId(_temp' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,ReadSlice,The following statement contains a magic number: ThrowIfEndOfStream(length - 4);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteDouble,The following statement contains a magic number: PrepareToWrite(8);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteDouble,The following statement contains a magic number: _buffer.SetBytes(_position' bytes' 0' 8);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteDouble,The following statement contains a magic number: SetPositionAfterWrite(_position + 8);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: PrepareToWrite(4);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: if (segment.Count >= 4)              {                  segment.Array[segment.Offset] = (byte)value;                  segment.Array[segment.Offset + 1] = (byte)(value >> 8);                  segment.Array[segment.Offset + 2] = (byte)(value >> 16);                  segment.Array[segment.Offset + 3] = (byte)(value >> 24);              }              else              {                  _temp[0] = (byte)(value);                  _temp[1] = (byte)(value >> 8);                  _temp[2] = (byte)(value >> 16);                  _temp[3] = (byte)(value >> 24);                  _buffer.SetBytes(_position' _temp' 0' 4);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt32,The following statement contains a magic number: SetPositionAfterWrite(_position + 4);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt64,The following statement contains a magic number: PrepareToWrite(8);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt64,The following statement contains a magic number: _buffer.SetBytes(_position' bytes' 0' 8);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteInt64,The following statement contains a magic number: SetPositionAfterWrite(_position + 8);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteObjectId,The following statement contains a magic number: PrepareToWrite(12);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteObjectId,The following statement contains a magic number: if (segment.Count >= 12)              {                  value.ToByteArray(segment.Array' segment.Offset);              }              else              {                  var bytes = value.ToByteArray();                  _buffer.SetBytes(_position' bytes' 0' 12);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteObjectId,The following statement contains a magic number: if (segment.Count >= 12)              {                  value.ToByteArray(segment.Array' segment.Offset);              }              else              {                  var bytes = value.ToByteArray();                  _buffer.SetBytes(_position' bytes' 0' 12);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteObjectId,The following statement contains a magic number: SetPositionAfterWrite(_position + 12);
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: var maxLength = encoding.GetMaxByteCount(value.Length) + 5;
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: if (segment.Count >= maxLength)              {                  actualLength = encoding.GetBytes(value' 0' value.Length' segment.Array' segment.Offset + 4);                    var lengthPlusOne = actualLength + 1;                  segment.Array[segment.Offset] = (byte)lengthPlusOne;                  segment.Array[segment.Offset + 1] = (byte)(lengthPlusOne >> 8);                  segment.Array[segment.Offset + 2] = (byte)(lengthPlusOne >> 16);                  segment.Array[segment.Offset + 3] = (byte)(lengthPlusOne >> 24);                  segment.Array[segment.Offset + 4 + actualLength] = 0;              }              else              {                  byte[] bytes;                  if (maxLength <= _tempUtf8.Length)                  {                      bytes = _tempUtf8;                      actualLength = encoding.GetBytes(value' 0' value.Length' bytes' 0);                  }                  else                  {                      bytes = encoding.GetBytes(value);                      actualLength = bytes.Length;                  }                    var lengthPlusOneBytes = BitConverter.GetBytes(actualLength + 1);                    _buffer.SetBytes(_position' lengthPlusOneBytes' 0' 4);                  _buffer.SetBytes(_position + 4' bytes' 0' actualLength);                  _buffer.SetByte(_position + 4 + actualLength' 0);              }
Magic Number,MongoDB.Bson.IO,ByteBufferStream,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\ByteBufferStream.cs,WriteString,The following statement contains a magic number: SetPositionAfterWrite(_position + actualLength + 5);
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseBinDataExtendedJson,The following statement contains a magic number: if (subTypeToken.Type == JsonTokenType.String)              {                  subType = (BsonBinarySubType)Convert.ToInt32(subTypeToken.StringValue' 16);              }              else if (subTypeToken.Type == JsonTokenType.Int32 || subTypeToken.Type == JsonTokenType.Int64)              {                  subType = (BsonBinarySubType)subTypeToken.Int32Value;              }              else              {                  var message = string.Format("JSON reader expected a string or integer but found '{0}'."' subTypeToken.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseDateTimeConstructor,The following statement contains a magic number: if (token.Lexeme == ")")              {                  return new BsonDateTime(DateTime.UtcNow);              }              else if (token.Type == JsonTokenType.String)              {                  VerifyToken(")");                  var dateTimeString = token.StringValue;                  var dateTime = ParseJavaScriptDateTimeString(dateTimeString);                  return new BsonDateTime(dateTime);              }              else if (token.Type == JsonTokenType.Int32 || token.Type == JsonTokenType.Int64)              {                  var args = new List<long>();                  while (true)                  {                      args.Add(token.Int64Value);                      token = PopToken();                      if (token.Lexeme == ")")                      {                          break;                      }                      if (token.Lexeme != "'")                      {                          var message = string.Format("JSON reader expected a ''' or a ')' but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                      token = PopToken();                      if (token.Type != JsonTokenType.Int32 && token.Type != JsonTokenType.Int64)                      {                          var message = string.Format("JSON reader expected an integer but found '{0}'."' token.Lexeme);                          throw new FormatException(message);                      }                  }                  switch (args.Count)                  {                      case 1:                          return new BsonDateTime(args[0]);                      case 3:                      case 4:                      case 5:                      case 6:                      case 7:                          var year = (int)args[0];                          var month = (int)args[1] + 1; // JavaScript starts at 0 but .NET starts at 1                          var day = (int)args[2];                          var hours = (args.Count >= 4) ? (int)args[3] : 0;                          var minutes = (args.Count >= 5) ? (int)args[4] : 0;                          var seconds = (args.Count >= 6) ? (int)args[5] : 0;                          var milliseconds = (args.Count == 7) ? (int)args[6] : 0;                          var dateTime = new DateTime(year' month' day' hours' minutes' seconds' milliseconds' DateTimeKind.Utc);                          return new BsonDateTime(dateTime);                      default:                          var message = string.Format("JSON reader expected 1 or 3-7 integers but found {0}."' args.Count);                          throw new FormatException(message);                  }              }              else              {                  var message = string.Format("JSON reader expected an integer or a string but found '{0}'."' token.Lexeme);                  throw new FormatException(message);              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseJavaScriptDateTimeString,The following statement contains a magic number: if (DateTime.TryParse(dateTimeString' out dateTime))              {                  return dateTime;              }              else              {                  var rfc822DateTimePattern =                      @"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun))' )?" +                      @"(?<day>\d{1'2}) +" +                      @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +                      @"(?<year>\d{2}|\d{4}) " +                      @"(?<hour>\d{1'2}):" +                      @"(?<minutes>\d{1'2}):" +                      @"(?<seconds>\d{1'2}(.\d{1'7})?) " +                      @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$";                  var match = Regex.Match(dateTimeString' rfc822DateTimePattern);                  if (match.Success)                  {                      var day = int.Parse(match.Groups["day"].Value);                        int month;                      var monthName = match.Groups["monthName"].Value;                      switch (monthName)                      {                          case "Jan": month = 1; break;                          case "Feb": month = 2; break;                          case "Mar": month = 3; break;                          case "Apr": month = 4; break;                          case "May": month = 5; break;                          case "Jun": month = 6; break;                          case "Jul": month = 7; break;                          case "Aug": month = 8; break;                          case "Sep": month = 9; break;                          case "Oct": month = 10; break;                          case "Nov": month = 11; break;                          case "Dec": month = 12; break;                          default:                              var message = string.Format("\"{0}\" is not a valid RFC 822 month name."' monthName);                              throw new FormatException(message);                      }                        var yearString = match.Groups["year"].Value;                      int year = int.Parse(yearString);                      if (yearString.Length == 2)                      {                          year += 2000;                          if (year - DateTime.UtcNow.Year >= 19) { year -= 100; }                      }                        var hour = int.Parse(match.Groups["hour"].Value);                      var minutes = int.Parse(match.Groups["minutes"].Value);                      var secondsString = match.Groups["seconds"].Value;                      int seconds;                      double milliseconds;                      if (secondsString.IndexOf('.') != -1)                      {                          var timeSpan = TimeSpan.FromSeconds(double.Parse(secondsString));                          seconds = timeSpan.Seconds;                          milliseconds = timeSpan.TotalMilliseconds - seconds * 1000;                      }                      else                      {                          seconds = int.Parse(secondsString);                          milliseconds = 0;                      }                        dateTime = new DateTime(year' month' day' hour' minutes' seconds' DateTimeKind.Utc).AddMilliseconds(milliseconds);                        // check day of week before converting to UTC                      var dayOfWeekString = match.Groups["dayOfWeek"].Value;                      if (dayOfWeekString != "")                      {                          DayOfWeek dayOfWeek;                          switch (dayOfWeekString)                          {                              case "Mon": dayOfWeek = DayOfWeek.Monday; break;                              case "Tue": dayOfWeek = DayOfWeek.Tuesday; break;                              case "Wed": dayOfWeek = DayOfWeek.Wednesday; break;                              case "Thu": dayOfWeek = DayOfWeek.Thursday; break;                              case "Fri": dayOfWeek = DayOfWeek.Friday; break;                              case "Sat": dayOfWeek = DayOfWeek.Saturday; break;                              case "Sun": dayOfWeek = DayOfWeek.Sunday; break;                              default:                                  var message = string.Format("\"{0}\" is not a valid RFC 822 day name."' dayOfWeekString);                                  throw new FormatException(message);                          }                          if (dateTime.DayOfWeek != dayOfWeek)                          {                              var message = string.Format("\"{0}\" is not the right day of the week for {1}."' dayOfWeekString' dateTime.ToString("o"));                              throw new FormatException(message);                          }                      }                        TimeSpan offset;                      var zone = match.Groups["zone"].Value;                      switch (zone)                      {                          case "UT": case "GMT": case "Z": offset = TimeSpan.Zero; break;                          case "EST": offset = TimeSpan.FromHours(-5); break;                          case "EDT": offset = TimeSpan.FromHours(-4); break;                          case "CST": offset = TimeSpan.FromHours(-6); break;                          case "CDT": offset = TimeSpan.FromHours(-5); break;                          case "MST": offset = TimeSpan.FromHours(-7); break;                          case "MDT": offset = TimeSpan.FromHours(-6); break;                          case "PST": offset = TimeSpan.FromHours(-8); break;                          case "PDT": offset = TimeSpan.FromHours(-7); break;                          case "A": offset = TimeSpan.FromHours(-1); break;                          case "B": offset = TimeSpan.FromHours(-2); break;                          case "C": offset = TimeSpan.FromHours(-3); break;                          case "D": offset = TimeSpan.FromHours(-4); break;                          case "E": offset = TimeSpan.FromHours(-5); break;                          case "F": offset = TimeSpan.FromHours(-6); break;                          case "G": offset = TimeSpan.FromHours(-7); break;                          case "H": offset = TimeSpan.FromHours(-8); break;                          case "I": offset = TimeSpan.FromHours(-9); break;                          case "K": offset = TimeSpan.FromHours(-10); break;                          case "L": offset = TimeSpan.FromHours(-11); break;                          case "M": offset = TimeSpan.FromHours(-12); break;                          case "N": offset = TimeSpan.FromHours(1); break;                          case "O": offset = TimeSpan.FromHours(2); break;                          case "P": offset = TimeSpan.FromHours(3); break;                          case "Q": offset = TimeSpan.FromHours(4); break;                          case "R": offset = TimeSpan.FromHours(5); break;                          case "S": offset = TimeSpan.FromHours(6); break;                          case "T": offset = TimeSpan.FromHours(7); break;                          case "U": offset = TimeSpan.FromHours(8); break;                          case "V": offset = TimeSpan.FromHours(9); break;                          case "W": offset = TimeSpan.FromHours(10); break;                          case "X": offset = TimeSpan.FromHours(11); break;                          case "Y": offset = TimeSpan.FromHours(12); break;                          default:                              var offsetSign = zone.Substring(0);                              var offsetHours = zone.Substring(1' 2);                              var offsetMinutes = zone.Substring(3' 2);                              offset = TimeSpan.FromHours(int.Parse(offsetHours)) + TimeSpan.FromMinutes(int.Parse(offsetMinutes));                              if (offsetSign == "-")                              {                                  offset = -offset;                              }                              break;                      }                        return dateTime.Add(-offset);                  }                  else                  {                      var message = string.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript."' dateTimeString);                      throw new FormatException(message);                  }              }
Magic Number,MongoDB.Bson.IO,JsonScanner,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonScanner.cs,FormatMessage,The following statement contains a magic number: var maxLength = 20;
Magic Number,MongoDB.Bson.IO,JsonScanner,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonScanner.cs,GetStringToken,The following statement contains a magic number: while (true)              {                  var c = buffer.Read();                  switch (c)                  {                      case '\\':                          c = buffer.Read();                          switch (c)                          {                              case '\'': sb.Append('\''); break;                              case '"': sb.Append('"'); break;                              case '\\': sb.Append('\\'); break;                              case '/': sb.Append('/'); break;                              case 'b': sb.Append('\b'); break;                              case 'f': sb.Append('\f'); break;                              case 'n': sb.Append('\n'); break;                              case 'r': sb.Append('\r'); break;                              case 't': sb.Append('\t'); break;                              case 'u':                                  var u1 = buffer.Read();                                  var u2 = buffer.Read();                                  var u3 = buffer.Read();                                  var u4 = buffer.Read();                                  if (u4 != -1)                                  {                                      var hex = new string(new char[] { (char)u1' (char)u2' (char)u3' (char)u4 });                                      var n = Convert.ToInt32(hex' 16);                                      sb.Append((char)n);                                  }                                  break;                              default:                                  if (c != -1)                                  {                                      var message = string.Format("Invalid escape sequence in JSON string '\\{0}'."' (char)c);                                      throw new FormatException(message);                                  }                                  break;                          }                          break;                      default:                          if (c == quoteCharacter)                          {                              var lexeme = buffer.GetSubstring(start' buffer.Position - start);                              return new StringJsonToken(JsonTokenType.String' lexeme' sb.ToString());                          }                          if (c != -1)                          {                              sb.Append((char)c);                          }                          break;                  }                  if (c == -1)                  {                      throw new FormatException(FormatMessage("End of file in JSON string."' buffer' start));                  }              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,ReadBinaryData,The following statement contains a magic number: if (subType == BsonBinarySubType.OldBinary)              {                  // sub type OldBinary has two sizes (for historical reasons)                  int size2 = ReadSize();                  if (size2 != size - 4)                  {                      throw new FormatException("Binary sub type OldBinary has inconsistent sizes");                  }                  size = size2;                    if (_settings.FixOldBinarySubTypeOnInput)                  {                      subType = BsonBinarySubType.Binary; // replace obsolete OldBinary with new Binary sub type                  }              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,BsonBinaryReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryReader.cs,SkipValue,The following statement contains a magic number: switch (CurrentBsonType)              {                  case BsonType.Array: skip = ReadSize() - 4; break;                  case BsonType.Binary: skip = ReadSize() + 1; break;                  case BsonType.Boolean: skip = 1; break;                  case BsonType.DateTime: skip = 8; break;                  case BsonType.Document: skip = ReadSize() - 4; break;                  case BsonType.Decimal128: skip = 16; break;                  case BsonType.Double: skip = 8; break;                  case BsonType.Int32: skip = 4; break;                  case BsonType.Int64: skip = 8; break;                  case BsonType.JavaScript: skip = ReadSize(); break;                  case BsonType.JavaScriptWithScope: skip = ReadSize() - 4; break;                  case BsonType.MaxKey: skip = 0; break;                  case BsonType.MinKey: skip = 0; break;                  case BsonType.Null: skip = 0; break;                  case BsonType.ObjectId: skip = 12; break;                  case BsonType.RegularExpression: _bsonStream.SkipCString(); _bsonStream.SkipCString(); skip = 0; break;                  case BsonType.String: skip = ReadSize(); break;                  case BsonType.Symbol: skip = ReadSize(); break;                  case BsonType.Timestamp: skip = 8; break;                  case BsonType.Undefined: skip = 0; break;                  default: throw new BsonInternalException("Unexpected BsonType.");              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,WriteTimestamp,The following statement contains a magic number: var secondsSinceEpoch = (int)((value >> 32) & 0xffffffff);
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (bytes.Length != 16)              {                  var message = string.Format("Length of binary subtype {0} must be 16' not {1}."' subType' bytes.Length);                  throw new ArgumentException(message);              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (guidRepresentation == GuidRepresentation.Unspecified)              {                  var s = BsonUtils.ToHexString(bytes);                  var parts = new string[]                  {                      s.Substring(0' 8)'                      s.Substring(8' 4)'                      s.Substring(12' 4)'                      s.Substring(16' 4)'                      s.Substring(20' 12)                  };                  return string.Format("HexData({0}' \"{1}\")"' (int)subType' string.Join("-"' parts));              }              else              {                  string uuidConstructorName;                  switch (guidRepresentation)                  {                      case GuidRepresentation.CSharpLegacy: uuidConstructorName = "CSUUID"; break;                      case GuidRepresentation.JavaLegacy: uuidConstructorName = "JUUID"; break;                      case GuidRepresentation.PythonLegacy: uuidConstructorName = "PYUUID"; break;                      case GuidRepresentation.Standard: uuidConstructorName = "UUID"; break;                      default: throw new BsonInternalException("Unexpected GuidRepresentation");                  }                  var guid = GuidConverter.FromBytes(bytes' guidRepresentation);                  return string.Format("{0}(\"{1}\")"' uuidConstructorName' guid.ToString());              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (guidRepresentation == GuidRepresentation.Unspecified)              {                  var s = BsonUtils.ToHexString(bytes);                  var parts = new string[]                  {                      s.Substring(0' 8)'                      s.Substring(8' 4)'                      s.Substring(12' 4)'                      s.Substring(16' 4)'                      s.Substring(20' 12)                  };                  return string.Format("HexData({0}' \"{1}\")"' (int)subType' string.Join("-"' parts));              }              else              {                  string uuidConstructorName;                  switch (guidRepresentation)                  {                      case GuidRepresentation.CSharpLegacy: uuidConstructorName = "CSUUID"; break;                      case GuidRepresentation.JavaLegacy: uuidConstructorName = "JUUID"; break;                      case GuidRepresentation.PythonLegacy: uuidConstructorName = "PYUUID"; break;                      case GuidRepresentation.Standard: uuidConstructorName = "UUID"; break;                      default: throw new BsonInternalException("Unexpected GuidRepresentation");                  }                  var guid = GuidConverter.FromBytes(bytes' guidRepresentation);                  return string.Format("{0}(\"{1}\")"' uuidConstructorName' guid.ToString());              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (guidRepresentation == GuidRepresentation.Unspecified)              {                  var s = BsonUtils.ToHexString(bytes);                  var parts = new string[]                  {                      s.Substring(0' 8)'                      s.Substring(8' 4)'                      s.Substring(12' 4)'                      s.Substring(16' 4)'                      s.Substring(20' 12)                  };                  return string.Format("HexData({0}' \"{1}\")"' (int)subType' string.Join("-"' parts));              }              else              {                  string uuidConstructorName;                  switch (guidRepresentation)                  {                      case GuidRepresentation.CSharpLegacy: uuidConstructorName = "CSUUID"; break;                      case GuidRepresentation.JavaLegacy: uuidConstructorName = "JUUID"; break;                      case GuidRepresentation.PythonLegacy: uuidConstructorName = "PYUUID"; break;                      case GuidRepresentation.Standard: uuidConstructorName = "UUID"; break;                      default: throw new BsonInternalException("Unexpected GuidRepresentation");                  }                  var guid = GuidConverter.FromBytes(bytes' guidRepresentation);                  return string.Format("{0}(\"{1}\")"' uuidConstructorName' guid.ToString());              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (guidRepresentation == GuidRepresentation.Unspecified)              {                  var s = BsonUtils.ToHexString(bytes);                  var parts = new string[]                  {                      s.Substring(0' 8)'                      s.Substring(8' 4)'                      s.Substring(12' 4)'                      s.Substring(16' 4)'                      s.Substring(20' 12)                  };                  return string.Format("HexData({0}' \"{1}\")"' (int)subType' string.Join("-"' parts));              }              else              {                  string uuidConstructorName;                  switch (guidRepresentation)                  {                      case GuidRepresentation.CSharpLegacy: uuidConstructorName = "CSUUID"; break;                      case GuidRepresentation.JavaLegacy: uuidConstructorName = "JUUID"; break;                      case GuidRepresentation.PythonLegacy: uuidConstructorName = "PYUUID"; break;                      case GuidRepresentation.Standard: uuidConstructorName = "UUID"; break;                      default: throw new BsonInternalException("Unexpected GuidRepresentation");                  }                  var guid = GuidConverter.FromBytes(bytes' guidRepresentation);                  return string.Format("{0}(\"{1}\")"' uuidConstructorName' guid.ToString());              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (guidRepresentation == GuidRepresentation.Unspecified)              {                  var s = BsonUtils.ToHexString(bytes);                  var parts = new string[]                  {                      s.Substring(0' 8)'                      s.Substring(8' 4)'                      s.Substring(12' 4)'                      s.Substring(16' 4)'                      s.Substring(20' 12)                  };                  return string.Format("HexData({0}' \"{1}\")"' (int)subType' string.Join("-"' parts));              }              else              {                  string uuidConstructorName;                  switch (guidRepresentation)                  {                      case GuidRepresentation.CSharpLegacy: uuidConstructorName = "CSUUID"; break;                      case GuidRepresentation.JavaLegacy: uuidConstructorName = "JUUID"; break;                      case GuidRepresentation.PythonLegacy: uuidConstructorName = "PYUUID"; break;                      case GuidRepresentation.Standard: uuidConstructorName = "UUID"; break;                      default: throw new BsonInternalException("Unexpected GuidRepresentation");                  }                  var guid = GuidConverter.FromBytes(bytes' guidRepresentation);                  return string.Format("{0}(\"{1}\")"' uuidConstructorName' guid.ToString());              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (guidRepresentation == GuidRepresentation.Unspecified)              {                  var s = BsonUtils.ToHexString(bytes);                  var parts = new string[]                  {                      s.Substring(0' 8)'                      s.Substring(8' 4)'                      s.Substring(12' 4)'                      s.Substring(16' 4)'                      s.Substring(20' 12)                  };                  return string.Format("HexData({0}' \"{1}\")"' (int)subType' string.Join("-"' parts));              }              else              {                  string uuidConstructorName;                  switch (guidRepresentation)                  {                      case GuidRepresentation.CSharpLegacy: uuidConstructorName = "CSUUID"; break;                      case GuidRepresentation.JavaLegacy: uuidConstructorName = "JUUID"; break;                      case GuidRepresentation.PythonLegacy: uuidConstructorName = "PYUUID"; break;                      case GuidRepresentation.Standard: uuidConstructorName = "UUID"; break;                      default: throw new BsonInternalException("Unexpected GuidRepresentation");                  }                  var guid = GuidConverter.FromBytes(bytes' guidRepresentation);                  return string.Format("{0}(\"{1}\")"' uuidConstructorName' guid.ToString());              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (guidRepresentation == GuidRepresentation.Unspecified)              {                  var s = BsonUtils.ToHexString(bytes);                  var parts = new string[]                  {                      s.Substring(0' 8)'                      s.Substring(8' 4)'                      s.Substring(12' 4)'                      s.Substring(16' 4)'                      s.Substring(20' 12)                  };                  return string.Format("HexData({0}' \"{1}\")"' (int)subType' string.Join("-"' parts));              }              else              {                  string uuidConstructorName;                  switch (guidRepresentation)                  {                      case GuidRepresentation.CSharpLegacy: uuidConstructorName = "CSUUID"; break;                      case GuidRepresentation.JavaLegacy: uuidConstructorName = "JUUID"; break;                      case GuidRepresentation.PythonLegacy: uuidConstructorName = "PYUUID"; break;                      case GuidRepresentation.Standard: uuidConstructorName = "UUID"; break;                      default: throw new BsonInternalException("Unexpected GuidRepresentation");                  }                  var guid = GuidConverter.FromBytes(bytes' guidRepresentation);                  return string.Format("{0}(\"{1}\")"' uuidConstructorName' guid.ToString());              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (guidRepresentation == GuidRepresentation.Unspecified)              {                  var s = BsonUtils.ToHexString(bytes);                  var parts = new string[]                  {                      s.Substring(0' 8)'                      s.Substring(8' 4)'                      s.Substring(12' 4)'                      s.Substring(16' 4)'                      s.Substring(20' 12)                  };                  return string.Format("HexData({0}' \"{1}\")"' (int)subType' string.Join("-"' parts));              }              else              {                  string uuidConstructorName;                  switch (guidRepresentation)                  {                      case GuidRepresentation.CSharpLegacy: uuidConstructorName = "CSUUID"; break;                      case GuidRepresentation.JavaLegacy: uuidConstructorName = "JUUID"; break;                      case GuidRepresentation.PythonLegacy: uuidConstructorName = "PYUUID"; break;                      case GuidRepresentation.Standard: uuidConstructorName = "UUID"; break;                      default: throw new BsonInternalException("Unexpected GuidRepresentation");                  }                  var guid = GuidConverter.FromBytes(bytes' guidRepresentation);                  return string.Format("{0}(\"{1}\")"' uuidConstructorName' guid.ToString());              }
Magic Number,MongoDB.Bson.IO,JsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonWriter.cs,GuidToString,The following statement contains a magic number: if (guidRepresentation == GuidRepresentation.Unspecified)              {                  var s = BsonUtils.ToHexString(bytes);                  var parts = new string[]                  {                      s.Substring(0' 8)'                      s.Substring(8' 4)'                      s.Substring(12' 4)'                      s.Substring(16' 4)'                      s.Substring(20' 12)                  };                  return string.Format("HexData({0}' \"{1}\")"' (int)subType' string.Join("-"' parts));              }              else              {                  string uuidConstructorName;                  switch (guidRepresentation)                  {                      case GuidRepresentation.CSharpLegacy: uuidConstructorName = "CSUUID"; break;                      case GuidRepresentation.JavaLegacy: uuidConstructorName = "JUUID"; break;                      case GuidRepresentation.PythonLegacy: uuidConstructorName = "PYUUID"; break;                      case GuidRepresentation.Standard: uuidConstructorName = "UUID"; break;                      default: throw new BsonInternalException("Unexpected GuidRepresentation");                  }                  var guid = GuidConverter.FromBytes(bytes' guidRepresentation);                  return string.Format("{0}(\"{1}\")"' uuidConstructorName' guid.ToString());              }
Magic Number,MongoDB.Bson.IO,BsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonReader.cs,ReadRawBsonArray,The following statement contains a magic number: using (var memoryStream = new MemoryStream())              using (var bsonWriter = new BsonBinaryWriter(memoryStream' BsonBinaryWriterSettings.Defaults))              {                  var serializationContext = BsonSerializationContext.CreateRoot(bsonWriter);                  bsonWriter.WriteStartDocument();                  var startPosition = memoryStream.Position + 3; // just past BsonType' "x" and null byte                  bsonWriter.WriteName("x");                  BsonArraySerializer.Instance.Serialize(serializationContext' array);                  var endPosition = memoryStream.Position;                  bsonWriter.WriteEndDocument();                    byte[] memoryStreamBuffer;  #if NETSTANDARD1_5 || NETSTANDARD1_6                  memoryStreamBuffer = memoryStream.ToArray();  #else                  memoryStreamBuffer = memoryStream.GetBuffer();  #endif                  var buffer = new ByteArrayBuffer(memoryStreamBuffer' (int)memoryStream.Length' isReadOnly: true);                  return new ByteBufferSlice(buffer' (int)startPosition' (int)(endPosition - startPosition));              }
Magic Number,MongoDB.Bson.IO,BsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonWriter.cs,WriteRawBsonArray,The following statement contains a magic number: using (var chunkSource = new InputBufferChunkSource(BsonChunkPool.Default))              using (var buffer = new MultiChunkBuffer(chunkSource))              using (var stream = new ByteBufferStream(buffer))              {                  // wrap the array in a fake document so we can deserialize it                  var documentLength = slice.Length + 8;                  buffer.EnsureCapacity(documentLength);                  stream.WriteInt32(documentLength);                  stream.WriteBsonType(BsonType.Array);                  stream.WriteByte((byte)'x');                  stream.WriteByte(0);                  stream.WriteSlice(slice);                  stream.WriteByte(0);                  buffer.MakeReadOnly();                    stream.Position = 0;                  using (var reader = new BsonBinaryReader(stream' BsonBinaryReaderSettings.Defaults))                  {                      var deserializationContext = BsonDeserializationContext.CreateRoot(reader);                      reader.ReadStartDocument();                      reader.ReadName("x");                      var array = BsonArraySerializer.Instance.Deserialize(deserializationContext);                      reader.ReadEndDocument();                        var serializationContext = BsonSerializationContext.CreateRoot(this);                      BsonArraySerializer.Instance.Serialize(serializationContext' array);                  }              }
Magic Number,MongoDB.Bson.IO,BsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonWriter.cs,ThrowInvalidState,The following statement contains a magic number: if (_state == BsonWriterState.Initial || _state == BsonWriterState.ScopeDocument || _state == BsonWriterState.Done)              {                  if (!methodName.StartsWith("End"' StringComparison.Ordinal) && methodName != "WriteName")                  {                      var typeName = methodName.Substring(5);                      if (typeName.StartsWith("Start"' StringComparison.Ordinal))                      {                          typeName = typeName.Substring(5);                      }                      var article = "A";                      if (new char[] { 'A'' 'E'' 'I'' 'O'' 'U' }.Contains(typeName[0]))                      {                          article = "An";                      }                      message = string.Format(                          "{0} {1} value cannot be written to the root level of a BSON document."'                          article' typeName);                      throw new InvalidOperationException(message);                  }              }
Magic Number,MongoDB.Bson.IO,BsonWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonWriter.cs,ThrowInvalidState,The following statement contains a magic number: if (_state == BsonWriterState.Initial || _state == BsonWriterState.ScopeDocument || _state == BsonWriterState.Done)              {                  if (!methodName.StartsWith("End"' StringComparison.Ordinal) && methodName != "WriteName")                  {                      var typeName = methodName.Substring(5);                      if (typeName.StartsWith("Start"' StringComparison.Ordinal))                      {                          typeName = typeName.Substring(5);                      }                      var article = "A";                      if (new char[] { 'A'' 'E'' 'I'' 'O'' 'U' }.Contains(typeName[0]))                      {                          article = "An";                      }                      message = string.Format(                          "{0} {1} value cannot be written to the root level of a BSON document."'                          article' typeName);                      throw new InvalidOperationException(message);                  }              }
Magic Number,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteBinaryData,The following statement contains a magic number: if (subType == BsonBinarySubType.OldBinary)              {                  // sub type OldBinary has two sizes (for historical reasons)                  _bsonStream.WriteInt32(bytes.Length + 4);                  _bsonStream.WriteBinarySubType(subType);                  _bsonStream.WriteInt32(bytes.Length);              }              else              {                  _bsonStream.WriteInt32(bytes.Length);                  _bsonStream.WriteBinarySubType(subType);              }
Magic Number,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetSerializer,The following statement contains a magic number: if (type.IsArray)              {                  var elementType = type.GetElementType();                  switch (type.GetArrayRank())                  {                      case 1:                          var arraySerializerDefinition = typeof(ArraySerializer<>);                          return CreateGenericSerializer(arraySerializerDefinition' new[] { elementType }' serializerRegistry);                      case 2:                          var twoDimensionalArraySerializerDefinition = typeof(TwoDimensionalArraySerializer<>);                          return CreateGenericSerializer(twoDimensionalArraySerializerDefinition' new[] { elementType }' serializerRegistry);                      case 3:                          var threeDimensionalArraySerializerDefinition = typeof(ThreeDimensionalArraySerializer<>);                          return CreateGenericSerializer(threeDimensionalArraySerializerDefinition' new[] { elementType }' serializerRegistry);                      default:                          var message = string.Format("No serializer found for array for rank {0}."' type.GetArrayRank());                          throw new BsonSerializationException(message);                  }              }
Magic Number,MongoDB.Bson.Serialization,CollectionsSerializationProvider,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\CollectionsSerializationProvider.cs,GetSerializer,The following statement contains a magic number: if (type.IsArray)              {                  var elementType = type.GetElementType();                  switch (type.GetArrayRank())                  {                      case 1:                          var arraySerializerDefinition = typeof(ArraySerializer<>);                          return CreateGenericSerializer(arraySerializerDefinition' new[] { elementType }' serializerRegistry);                      case 2:                          var twoDimensionalArraySerializerDefinition = typeof(TwoDimensionalArraySerializer<>);                          return CreateGenericSerializer(twoDimensionalArraySerializerDefinition' new[] { elementType }' serializerRegistry);                      case 3:                          var threeDimensionalArraySerializerDefinition = typeof(ThreeDimensionalArraySerializer<>);                          return CreateGenericSerializer(threeDimensionalArraySerializerDefinition' new[] { elementType }' serializerRegistry);                      default:                          var message = string.Format("No serializer found for array for rank {0}."' type.GetArrayRank());                          throw new BsonSerializationException(message);                  }              }
Magic Number,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,DeserializeClass,The following statement contains a magic number: while (bsonReader.ReadBsonType() != BsonType.EndOfDocument)              {                  var trieDecoder = new TrieNameDecoder<int>(elementTrie);                  var elementName = bsonReader.ReadName(trieDecoder);                    if (trieDecoder.Found)                  {                      var memberMapIndex = trieDecoder.Value;                      var memberMap = allMemberMaps[memberMapIndex];                      if (memberMapIndex != extraElementsMemberMapIndex)                      {                          if (document != null)                          {                              if (memberMap.IsReadOnly)                              {                                  bsonReader.SkipValue();                              }                              else                              {                                  var value = DeserializeMemberValue(context' memberMap);                                  memberMap.Setter(document' value);                              }                          }                          else                          {                              var value = DeserializeMemberValue(context' memberMap);                              values[elementName] = value;                          }                      }                      else                      {                          if (document != null)                          {                              DeserializeExtraElementMember(context' document' elementName' memberMap);                          }                          else                          {                              DeserializeExtraElementValue(context' values' elementName' memberMap);                          }                      }                      memberMapBitArray[memberMapIndex >> 5] |= 1U << (memberMapIndex & 31);                  }                  else                  {                      if (elementName == discriminatorConvention.ElementName)                      {                          bsonReader.SkipValue(); // skip over discriminator                          continue;                      }                        if (extraElementsMemberMapIndex >= 0)                      {                          var extraElementsMemberMap = _classMap.ExtraElementsMemberMap;                          if (document != null)                          {                              DeserializeExtraElementMember(context' document' elementName' extraElementsMemberMap);                          }                          else                          {                              DeserializeExtraElementValue(context' values' elementName' extraElementsMemberMap);                          }                          memberMapBitArray[extraElementsMemberMapIndex >> 5] |= 1U << (extraElementsMemberMapIndex & 31);                      }                      else if (_classMap.IgnoreExtraElements)                      {                          bsonReader.SkipValue();                      }                      else                      {                          var message = string.Format(                              "Element '{0}' does not match any field or property of class {1}."'                              elementName' _classMap.ClassType.FullName);                          throw new FormatException(message);                      }                  }              }
Magic Number,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,DeserializeClass,The following statement contains a magic number: while (bsonReader.ReadBsonType() != BsonType.EndOfDocument)              {                  var trieDecoder = new TrieNameDecoder<int>(elementTrie);                  var elementName = bsonReader.ReadName(trieDecoder);                    if (trieDecoder.Found)                  {                      var memberMapIndex = trieDecoder.Value;                      var memberMap = allMemberMaps[memberMapIndex];                      if (memberMapIndex != extraElementsMemberMapIndex)                      {                          if (document != null)                          {                              if (memberMap.IsReadOnly)                              {                                  bsonReader.SkipValue();                              }                              else                              {                                  var value = DeserializeMemberValue(context' memberMap);                                  memberMap.Setter(document' value);                              }                          }                          else                          {                              var value = DeserializeMemberValue(context' memberMap);                              values[elementName] = value;                          }                      }                      else                      {                          if (document != null)                          {                              DeserializeExtraElementMember(context' document' elementName' memberMap);                          }                          else                          {                              DeserializeExtraElementValue(context' values' elementName' memberMap);                          }                      }                      memberMapBitArray[memberMapIndex >> 5] |= 1U << (memberMapIndex & 31);                  }                  else                  {                      if (elementName == discriminatorConvention.ElementName)                      {                          bsonReader.SkipValue(); // skip over discriminator                          continue;                      }                        if (extraElementsMemberMapIndex >= 0)                      {                          var extraElementsMemberMap = _classMap.ExtraElementsMemberMap;                          if (document != null)                          {                              DeserializeExtraElementMember(context' document' elementName' extraElementsMemberMap);                          }                          else                          {                              DeserializeExtraElementValue(context' values' elementName' extraElementsMemberMap);                          }                          memberMapBitArray[extraElementsMemberMapIndex >> 5] |= 1U << (extraElementsMemberMapIndex & 31);                      }                      else if (_classMap.IgnoreExtraElements)                      {                          bsonReader.SkipValue();                      }                      else                      {                          var message = string.Format(                              "Element '{0}' does not match any field or property of class {1}."'                              elementName' _classMap.ClassType.FullName);                          throw new FormatException(message);                      }                  }              }
Magic Number,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,DeserializeClass,The following statement contains a magic number: while (bsonReader.ReadBsonType() != BsonType.EndOfDocument)              {                  var trieDecoder = new TrieNameDecoder<int>(elementTrie);                  var elementName = bsonReader.ReadName(trieDecoder);                    if (trieDecoder.Found)                  {                      var memberMapIndex = trieDecoder.Value;                      var memberMap = allMemberMaps[memberMapIndex];                      if (memberMapIndex != extraElementsMemberMapIndex)                      {                          if (document != null)                          {                              if (memberMap.IsReadOnly)                              {                                  bsonReader.SkipValue();                              }                              else                              {                                  var value = DeserializeMemberValue(context' memberMap);                                  memberMap.Setter(document' value);                              }                          }                          else                          {                              var value = DeserializeMemberValue(context' memberMap);                              values[elementName] = value;                          }                      }                      else                      {                          if (document != null)                          {                              DeserializeExtraElementMember(context' document' elementName' memberMap);                          }                          else                          {                              DeserializeExtraElementValue(context' values' elementName' memberMap);                          }                      }                      memberMapBitArray[memberMapIndex >> 5] |= 1U << (memberMapIndex & 31);                  }                  else                  {                      if (elementName == discriminatorConvention.ElementName)                      {                          bsonReader.SkipValue(); // skip over discriminator                          continue;                      }                        if (extraElementsMemberMapIndex >= 0)                      {                          var extraElementsMemberMap = _classMap.ExtraElementsMemberMap;                          if (document != null)                          {                              DeserializeExtraElementMember(context' document' elementName' extraElementsMemberMap);                          }                          else                          {                              DeserializeExtraElementValue(context' values' elementName' extraElementsMemberMap);                          }                          memberMapBitArray[extraElementsMemberMapIndex >> 5] |= 1U << (extraElementsMemberMapIndex & 31);                      }                      else if (_classMap.IgnoreExtraElements)                      {                          bsonReader.SkipValue();                      }                      else                      {                          var message = string.Format(                              "Element '{0}' does not match any field or property of class {1}."'                              elementName' _classMap.ClassType.FullName);                          throw new FormatException(message);                      }                  }              }
Magic Number,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,DeserializeClass,The following statement contains a magic number: while (bsonReader.ReadBsonType() != BsonType.EndOfDocument)              {                  var trieDecoder = new TrieNameDecoder<int>(elementTrie);                  var elementName = bsonReader.ReadName(trieDecoder);                    if (trieDecoder.Found)                  {                      var memberMapIndex = trieDecoder.Value;                      var memberMap = allMemberMaps[memberMapIndex];                      if (memberMapIndex != extraElementsMemberMapIndex)                      {                          if (document != null)                          {                              if (memberMap.IsReadOnly)                              {                                  bsonReader.SkipValue();                              }                              else                              {                                  var value = DeserializeMemberValue(context' memberMap);                                  memberMap.Setter(document' value);                              }                          }                          else                          {                              var value = DeserializeMemberValue(context' memberMap);                              values[elementName] = value;                          }                      }                      else                      {                          if (document != null)                          {                              DeserializeExtraElementMember(context' document' elementName' memberMap);                          }                          else                          {                              DeserializeExtraElementValue(context' values' elementName' memberMap);                          }                      }                      memberMapBitArray[memberMapIndex >> 5] |= 1U << (memberMapIndex & 31);                  }                  else                  {                      if (elementName == discriminatorConvention.ElementName)                      {                          bsonReader.SkipValue(); // skip over discriminator                          continue;                      }                        if (extraElementsMemberMapIndex >= 0)                      {                          var extraElementsMemberMap = _classMap.ExtraElementsMemberMap;                          if (document != null)                          {                              DeserializeExtraElementMember(context' document' elementName' extraElementsMemberMap);                          }                          else                          {                              DeserializeExtraElementValue(context' values' elementName' extraElementsMemberMap);                          }                          memberMapBitArray[extraElementsMemberMapIndex >> 5] |= 1U << (extraElementsMemberMapIndex & 31);                      }                      else if (_classMap.IgnoreExtraElements)                      {                          bsonReader.SkipValue();                      }                      else                      {                          var message = string.Format(                              "Element '{0}' does not match any field or property of class {1}."'                              elementName' _classMap.ClassType.FullName);                          throw new FormatException(message);                      }                  }              }
Magic Number,MongoDB.Bson.Serialization,BsonClassMapSerializer<TClass>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,DeserializeClass,The following statement contains a magic number: for (var bitArrayIndex = 0; bitArrayIndex < memberMapBitArray.Length; ++bitArrayIndex)              {                  var memberMapIndex = bitArrayIndex << 5;                  var memberMapBlock = ~memberMapBitArray[bitArrayIndex]; // notice that bits are flipped so 1's are now the missing elements                    // work through this memberMapBlock of 32 elements                  while (true)                  {                      // examine missing elements (memberMapBlock is shifted right as we work through the block)                      for (; (memberMapBlock & 1) != 0; ++memberMapIndex' memberMapBlock >>= 1)                      {                          var memberMap = allMemberMaps[memberMapIndex];                          if (memberMap.IsReadOnly)                          {                              continue;                          }                            if (memberMap.IsRequired)                          {                              var fieldOrProperty = (memberMap.MemberInfo is FieldInfo) ? "field" : "property";                              var message = string.Format(                                  "Required element '{0}' for {1} '{2}' of class {3} is missing."'                                  memberMap.ElementName' fieldOrProperty' memberMap.MemberName' _classMap.ClassType.FullName);                              throw new FormatException(message);                          }                            if (document != null)                          {                              memberMap.ApplyDefaultValue(document);                          }                          else if (memberMap.IsDefaultValueSpecified && !memberMap.IsReadOnly)                          {                              values[memberMap.ElementName] = memberMap.DefaultValue;                          }                      }                        if (memberMapBlock == 0)                      {                          break;                      }                        // skip ahead to the next missing element                      var leastSignificantBit = FastMemberMapHelper.GetLeastSignificantBit(memberMapBlock);                      memberMapIndex += leastSignificantBit;                      memberMapBlock >>= leastSignificantBit;                  }              }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetBitArray,The following statement contains a magic number: var bitArrayOffset = memberCount & 31;
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetBitArray,The following statement contains a magic number: var bitArrayLength = memberCount >> 5;
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 65535) == 0)                  {                      bitBlock >>= 16;                      leastSignificantBit |= 16;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 65535) == 0)                  {                      bitBlock >>= 16;                      leastSignificantBit |= 16;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 65535) == 0)                  {                      bitBlock >>= 16;                      leastSignificantBit |= 16;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 255) == 0)                  {                      bitBlock >>= 8;                      leastSignificantBit |= 8;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 255) == 0)                  {                      bitBlock >>= 8;                      leastSignificantBit |= 8;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 255) == 0)                  {                      bitBlock >>= 8;                      leastSignificantBit |= 8;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 15) == 0)                  {                      bitBlock >>= 4;                      leastSignificantBit |= 4;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 15) == 0)                  {                      bitBlock >>= 4;                      leastSignificantBit |= 4;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 15) == 0)                  {                      bitBlock >>= 4;                      leastSignificantBit |= 4;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 3) == 0)                  {                      bitBlock >>= 2;                      leastSignificantBit |= 2;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 3) == 0)                  {                      bitBlock >>= 2;                      leastSignificantBit |= 2;                  }
Magic Number,MongoDB.Bson.Serialization,FastMemberMapHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BsonClassMapSerializer.cs,GetLeastSignificantBit,The following statement contains a magic number: if ((bitBlock & 3) == 0)                  {                      bitBlock >>= 2;                      leastSignificantBit |= 2;                  }
Magic Number,MongoDB.Bson.Serialization,TypeNameDiscriminator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\TypeNameDiscriminator.cs,TryParseGenericTypeName,The following statement contains a magic number: if (leftBracketIndex != -1)              {                  genericTypeDefinitionName = typeName.Substring(0' leftBracketIndex);                  var typeArgumentNamesString = typeName.Substring(leftBracketIndex + 1' typeName.Length - leftBracketIndex - 2);                  var typeArgumentNamesList = new List<string>();                  var startIndex = 0;                  var nestingLevel = 0;                  for (var index = 0; index < typeArgumentNamesString.Length; index++)                  {                      var c = typeArgumentNamesString[index];                      switch (c)                      {                          case '[':                              nestingLevel++;                              break;                          case ']':                              nestingLevel--;                              break;                          case ''':                              if (nestingLevel == 0)                              {                                  var typeArgumentName = typeArgumentNamesString.Substring(startIndex' index - startIndex);                                  typeArgumentNamesList.Add(typeArgumentName);                              }                              break;                      }                  }                  typeArgumentNamesList.Add(typeArgumentNamesString.Substring(startIndex));                  typeArgumentNames = typeArgumentNamesList.ToArray();                  return true;              }
Magic Number,MongoDB.Bson.Serialization.Conventions,AttributeConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\AttributeConventionPack.cs,Apply,The following statement contains a magic number: var groupings = attributes.GroupBy(a => (a is BsonSerializerAttribute) ? 1 : 2);
Magic Number,MongoDB.Bson.Serialization.Conventions,ConventionBase,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\ConventionBase.cs,GetName,The following statement contains a magic number: if (name.EndsWith("Convention"))              {                  return name.Substring(0' name.Length - 10);              }
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,AscendingGuidGenerator,The following statement contains a magic number: __machineProcessId = new byte[5]              {                  machineHash[0]'                  machineHash[1]'                  machineHash[2]'                  (byte)(processId >> 8)'                  (byte)(processId)              };
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,AscendingGuidGenerator,The following statement contains a magic number: __machineProcessId = new byte[5]              {                  machineHash[0]'                  machineHash[1]'                  machineHash[2]'                  (byte)(processId >> 8)'                  (byte)(processId)              };
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,AscendingGuidGenerator,The following statement contains a magic number: __machineProcessId = new byte[5]              {                  machineHash[0]'                  machineHash[1]'                  machineHash[2]'                  (byte)(processId >> 8)'                  (byte)(processId)              };
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,GenerateId,The following statement contains a magic number: var a = (int)(tickCount >> 32);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,GenerateId,The following statement contains a magic number: var b = (short)(tickCount >> 16);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,GenerateId,The following statement contains a magic number: var d = new byte[8];
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,GenerateId,The following statement contains a magic number: Array.Copy(machineProcessId' d' 5);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,GenerateId,The following statement contains a magic number: d[5] = (byte)(increment >> 16);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,GenerateId,The following statement contains a magic number: d[5] = (byte)(increment >> 16);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,GenerateId,The following statement contains a magic number: d[6] = (byte)(increment >> 8);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,GenerateId,The following statement contains a magic number: d[6] = (byte)(increment >> 8);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,AscendingGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\AscendingGuidGenerator.cs,GenerateId,The following statement contains a magic number: d[7] = (byte)(increment);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: var baseDate = new DateTime(1900' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: var timeTicks = (int)(timestamp.TimeOfDay.Ticks * 300 / TimeSpan.TicksPerSecond);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(days)' 0' bytes' 10' 2);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(days)' 0' bytes' 10' 2);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(timeTicks)' 0' bytes' 12' 4);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(timeTicks)' 0' bytes' 12' 4);
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  Array.Reverse(bytes' 10' 2);                  Array.Reverse(bytes' 12' 4);              }
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  Array.Reverse(bytes' 10' 2);                  Array.Reverse(bytes' 12' 4);              }
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  Array.Reverse(bytes' 10' 2);                  Array.Reverse(bytes' 12' 4);              }
Magic Number,MongoDB.Bson.Serialization.IdGenerators,CombGuidGenerator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\IdGenerators\CombGuidGenerator.cs,NewCombGuid,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  Array.Reverse(bytes' 10' 2);                  Array.Reverse(bytes' 12' 4);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,BitArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BitArraySerializer.cs,SerializeValue,The following statement contains a magic number: switch (_representation)              {                  case BsonType.Binary:                      if ((value.Length % 8) == 0)                      {                          bsonWriter.WriteBytes(GetBytes(value));                      }                      else                      {                          bsonWriter.WriteStartDocument();                          bsonWriter.WriteInt32("Length"' value.Length);                          bsonWriter.WriteBytes("Bytes"' GetBytes(value));                          bsonWriter.WriteEndDocument();                      }                      break;                    case BsonType.String:                      var sb = new StringBuilder(value.Length);                      for (int i = 0; i < value.Length; i++)                      {                          sb.Append(value[i] ? '1' : '0');                      }                      bsonWriter.WriteString(sb.ToString());                      break;                    default:                      var message = string.Format("'{0}' is not a valid BitArray representation."' _representation);                      throw new BsonSerializationException(message);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,BitArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BitArraySerializer.cs,GetBytes,The following statement contains a magic number: var bytes = new byte[(bitArray.Length + 7) / 8];
Magic Number,MongoDB.Bson.Serialization.Serializers,BitArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BitArraySerializer.cs,GetBytes,The following statement contains a magic number: var bytes = new byte[(bitArray.Length + 7) / 8];
Magic Number,MongoDB.Bson.Serialization.Serializers,BitArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BitArraySerializer.cs,GetBytes,The following statement contains a magic number: foreach (bool value in bitArray)              {                  if (value)                  {                      var index = i / 8;                      var bit = i % 8;                      bytes[index] |= (byte)(1 << bit);                  }                  i++;              }
Magic Number,MongoDB.Bson.Serialization.Serializers,BitArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BitArraySerializer.cs,GetBytes,The following statement contains a magic number: foreach (bool value in bitArray)              {                  if (value)                  {                      var index = i / 8;                      var bit = i % 8;                      bytes[index] |= (byte)(1 << bit);                  }                  i++;              }
Magic Number,MongoDB.Bson.Serialization.Serializers,SerializerHelper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\SerializerHelper.cs,SerializerHelper,The following statement contains a magic number: if (members.Length > 64)              {                  throw new ArgumentException("SerializerHelper supports a maximum of 64 members."' "members");              }
Magic Number,MongoDB.Bson.Serialization.Serializers,ByteArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ByteArraySerializer.cs,DeserializeValue,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Binary:                      return bsonReader.ReadBytes();                    case BsonType.String:                      var s = bsonReader.ReadString();                      if ((s.Length % 2) != 0)                      {                          s = "0" + s; // prepend a zero to make length even                      }                      var bytes = new byte[s.Length / 2];                      for (int i = 0; i < s.Length; i += 2)                      {                          var hex = s.Substring(i' 2);                          var b = byte.Parse(hex' NumberStyles.HexNumber);                          bytes[i / 2] = b;                      }                      return bytes;                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,ByteArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ByteArraySerializer.cs,DeserializeValue,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Binary:                      return bsonReader.ReadBytes();                    case BsonType.String:                      var s = bsonReader.ReadString();                      if ((s.Length % 2) != 0)                      {                          s = "0" + s; // prepend a zero to make length even                      }                      var bytes = new byte[s.Length / 2];                      for (int i = 0; i < s.Length; i += 2)                      {                          var hex = s.Substring(i' 2);                          var b = byte.Parse(hex' NumberStyles.HexNumber);                          bytes[i / 2] = b;                      }                      return bytes;                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,ByteArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ByteArraySerializer.cs,DeserializeValue,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Binary:                      return bsonReader.ReadBytes();                    case BsonType.String:                      var s = bsonReader.ReadString();                      if ((s.Length % 2) != 0)                      {                          s = "0" + s; // prepend a zero to make length even                      }                      var bytes = new byte[s.Length / 2];                      for (int i = 0; i < s.Length; i += 2)                      {                          var hex = s.Substring(i' 2);                          var b = byte.Parse(hex' NumberStyles.HexNumber);                          bytes[i / 2] = b;                      }                      return bytes;                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,ByteArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ByteArraySerializer.cs,DeserializeValue,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Binary:                      return bsonReader.ReadBytes();                    case BsonType.String:                      var s = bsonReader.ReadString();                      if ((s.Length % 2) != 0)                      {                          s = "0" + s; // prepend a zero to make length even                      }                      var bytes = new byte[s.Length / 2];                      for (int i = 0; i < s.Length; i += 2)                      {                          var hex = s.Substring(i' 2);                          var b = byte.Parse(hex' NumberStyles.HexNumber);                          bytes[i / 2] = b;                      }                      return bytes;                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,ByteArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ByteArraySerializer.cs,DeserializeValue,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Binary:                      return bsonReader.ReadBytes();                    case BsonType.String:                      var s = bsonReader.ReadString();                      if ((s.Length % 2) != 0)                      {                          s = "0" + s; // prepend a zero to make length even                      }                      var bytes = new byte[s.Length / 2];                      for (int i = 0; i < s.Length; i += 2)                      {                          var hex = s.Substring(i' 2);                          var b = byte.Parse(hex' NumberStyles.HexNumber);                          bytes[i / 2] = b;                      }                      return bytes;                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,DecimalSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DecimalSerializer.cs,Deserialize,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Array:                      var array = BsonArraySerializer.Instance.Deserialize(context);                      var bits = new int[4];                      bits[0] = array[0].AsInt32;                      bits[1] = array[1].AsInt32;                      bits[2] = array[2].AsInt32;                      bits[3] = array[3].AsInt32;                      return new decimal(bits);                    case BsonType.Decimal128:                      return _converter.ToDecimal(bsonReader.ReadDecimal128());                    case BsonType.Double:                      return _converter.ToDecimal(bsonReader.ReadDouble());                    case BsonType.Int32:                      return _converter.ToDecimal(bsonReader.ReadInt32());                    case BsonType.Int64:                      return _converter.ToDecimal(bsonReader.ReadInt64());                    case BsonType.String:                      return JsonConvert.ToDecimal(bsonReader.ReadString());                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,DecimalSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DecimalSerializer.cs,Deserialize,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Array:                      var array = BsonArraySerializer.Instance.Deserialize(context);                      var bits = new int[4];                      bits[0] = array[0].AsInt32;                      bits[1] = array[1].AsInt32;                      bits[2] = array[2].AsInt32;                      bits[3] = array[3].AsInt32;                      return new decimal(bits);                    case BsonType.Decimal128:                      return _converter.ToDecimal(bsonReader.ReadDecimal128());                    case BsonType.Double:                      return _converter.ToDecimal(bsonReader.ReadDouble());                    case BsonType.Int32:                      return _converter.ToDecimal(bsonReader.ReadInt32());                    case BsonType.Int64:                      return _converter.ToDecimal(bsonReader.ReadInt64());                    case BsonType.String:                      return JsonConvert.ToDecimal(bsonReader.ReadString());                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,DecimalSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DecimalSerializer.cs,Deserialize,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Array:                      var array = BsonArraySerializer.Instance.Deserialize(context);                      var bits = new int[4];                      bits[0] = array[0].AsInt32;                      bits[1] = array[1].AsInt32;                      bits[2] = array[2].AsInt32;                      bits[3] = array[3].AsInt32;                      return new decimal(bits);                    case BsonType.Decimal128:                      return _converter.ToDecimal(bsonReader.ReadDecimal128());                    case BsonType.Double:                      return _converter.ToDecimal(bsonReader.ReadDouble());                    case BsonType.Int32:                      return _converter.ToDecimal(bsonReader.ReadInt32());                    case BsonType.Int64:                      return _converter.ToDecimal(bsonReader.ReadInt64());                    case BsonType.String:                      return JsonConvert.ToDecimal(bsonReader.ReadString());                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,DecimalSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DecimalSerializer.cs,Deserialize,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Array:                      var array = BsonArraySerializer.Instance.Deserialize(context);                      var bits = new int[4];                      bits[0] = array[0].AsInt32;                      bits[1] = array[1].AsInt32;                      bits[2] = array[2].AsInt32;                      bits[3] = array[3].AsInt32;                      return new decimal(bits);                    case BsonType.Decimal128:                      return _converter.ToDecimal(bsonReader.ReadDecimal128());                    case BsonType.Double:                      return _converter.ToDecimal(bsonReader.ReadDouble());                    case BsonType.Int32:                      return _converter.ToDecimal(bsonReader.ReadInt32());                    case BsonType.Int64:                      return _converter.ToDecimal(bsonReader.ReadInt64());                    case BsonType.String:                      return JsonConvert.ToDecimal(bsonReader.ReadString());                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,DecimalSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DecimalSerializer.cs,Deserialize,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Array:                      var array = BsonArraySerializer.Instance.Deserialize(context);                      var bits = new int[4];                      bits[0] = array[0].AsInt32;                      bits[1] = array[1].AsInt32;                      bits[2] = array[2].AsInt32;                      bits[3] = array[3].AsInt32;                      return new decimal(bits);                    case BsonType.Decimal128:                      return _converter.ToDecimal(bsonReader.ReadDecimal128());                    case BsonType.Double:                      return _converter.ToDecimal(bsonReader.ReadDouble());                    case BsonType.Int32:                      return _converter.ToDecimal(bsonReader.ReadInt32());                    case BsonType.Int64:                      return _converter.ToDecimal(bsonReader.ReadInt64());                    case BsonType.String:                      return JsonConvert.ToDecimal(bsonReader.ReadString());                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,DecimalSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DecimalSerializer.cs,Serialize,The following statement contains a magic number: switch (_representation)              {                  case BsonType.Array:                      bsonWriter.WriteStartArray();                      var bits = Decimal.GetBits(value);                      bsonWriter.WriteInt32(bits[0]);                      bsonWriter.WriteInt32(bits[1]);                      bsonWriter.WriteInt32(bits[2]);                      bsonWriter.WriteInt32(bits[3]);                      bsonWriter.WriteEndArray();                      break;                    case BsonType.Decimal128:                      bsonWriter.WriteDecimal128(_converter.ToDecimal128(value));                      break;                    case BsonType.Double:                      bsonWriter.WriteDouble(_converter.ToDouble(value));                      break;                    case BsonType.Int32:                      bsonWriter.WriteInt32(_converter.ToInt32(value));                      break;                    case BsonType.Int64:                      bsonWriter.WriteInt64(_converter.ToInt64(value));                      break;                    case BsonType.String:                      bsonWriter.WriteString(JsonConvert.ToString(value));                      break;                    default:                      var message = string.Format("'{0}' is not a valid Decimal representation."' _representation);                      throw new BsonSerializationException(message);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,DecimalSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DecimalSerializer.cs,Serialize,The following statement contains a magic number: switch (_representation)              {                  case BsonType.Array:                      bsonWriter.WriteStartArray();                      var bits = Decimal.GetBits(value);                      bsonWriter.WriteInt32(bits[0]);                      bsonWriter.WriteInt32(bits[1]);                      bsonWriter.WriteInt32(bits[2]);                      bsonWriter.WriteInt32(bits[3]);                      bsonWriter.WriteEndArray();                      break;                    case BsonType.Decimal128:                      bsonWriter.WriteDecimal128(_converter.ToDecimal128(value));                      break;                    case BsonType.Double:                      bsonWriter.WriteDouble(_converter.ToDouble(value));                      break;                    case BsonType.Int32:                      bsonWriter.WriteInt32(_converter.ToInt32(value));                      break;                    case BsonType.Int64:                      bsonWriter.WriteInt64(_converter.ToInt64(value));                      break;                    case BsonType.String:                      bsonWriter.WriteString(JsonConvert.ToString(value));                      break;                    default:                      var message = string.Format("'{0}' is not a valid Decimal representation."' _representation);                      throw new BsonSerializationException(message);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,GuidSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\GuidSerializer.cs,Deserialize,The following statement contains a magic number: switch (bsonType)              {                  case BsonType.Binary:                      var binaryData = bsonReader.ReadBinaryData();                      var bytes = binaryData.Bytes;                      var subType = binaryData.SubType;                      var guidRepresentation = binaryData.GuidRepresentation;                      if (bytes.Length != 16)                      {                          message = string.Format("Expected length to be 16' not {0}."' bytes.Length);                          throw new FormatException(message);                      }                      if (subType != BsonBinarySubType.UuidStandard && subType != BsonBinarySubType.UuidLegacy)                      {                          message = string.Format("Expected binary sub type to be UuidStandard or UuidLegacy' not {0}."' subType);                          throw new FormatException(message);                      }                      if (guidRepresentation == GuidRepresentation.Unspecified)                      {                          throw new BsonSerializationException("GuidSerializer cannot deserialize a Guid when GuidRepresentation is Unspecified.");                      }                      return GuidConverter.FromBytes(bytes' guidRepresentation);                    case BsonType.String:                      return new Guid(bsonReader.ReadString());                    default:                      throw CreateCannotDeserializeFromBsonTypeException(bsonType);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,ThreeDimensionalArraySerializer<TItem>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ThreeDimensionalArraySerializer.cs,SerializeValue,The following statement contains a magic number: var length3 = value.GetLength(2);
Magic Number,MongoDB.Bson.Serialization.Serializers,TimeSpanSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TimeSpanSerializer.cs,FromDouble,The following statement contains a magic number: if (units == TimeSpanUnits.Nanoseconds)              {                  return TimeSpan.FromTicks((long)(value / 100.0)); // divide first then cast to reduce chance of overflow              }              else              {                  return TimeSpan.FromTicks((long)(value * TicksPerUnit(units))); // multiply first then cast to preserve fractional part of value              }
Magic Number,MongoDB.Bson.Serialization.Serializers,TimeSpanSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TimeSpanSerializer.cs,FromInt32,The following statement contains a magic number: if (units == TimeSpanUnits.Nanoseconds)              {                  return TimeSpan.FromTicks(value / 100);              }              else              {                  return TimeSpan.FromTicks(value * TicksPerUnit(units));              }
Magic Number,MongoDB.Bson.Serialization.Serializers,TimeSpanSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TimeSpanSerializer.cs,FromInt64,The following statement contains a magic number: if (units == TimeSpanUnits.Nanoseconds)              {                  return TimeSpan.FromTicks(value / 100);              }              else              {                  return TimeSpan.FromTicks(value * TicksPerUnit(units));              }
Magic Number,MongoDB.Bson.Serialization.Serializers,TimeSpanSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TimeSpanSerializer.cs,TicksPerUnit,The following statement contains a magic number: switch (units)              {                  case TimeSpanUnits.Days: return TimeSpan.TicksPerDay;                  case TimeSpanUnits.Hours: return TimeSpan.TicksPerHour;                  case TimeSpanUnits.Minutes: return TimeSpan.TicksPerMinute;                  case TimeSpanUnits.Seconds: return TimeSpan.TicksPerSecond;                  case TimeSpanUnits.Milliseconds: return TimeSpan.TicksPerMillisecond;                  case TimeSpanUnits.Microseconds: return TimeSpan.TicksPerMillisecond / 1000;                  case TimeSpanUnits.Ticks: return 1;                  default:                      var message = string.Format("Invalid TimeSpanUnits value: {0}."' units);                      throw new ArgumentException(message);              }
Magic Number,MongoDB.Bson.Serialization.Serializers,TimeSpanSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TimeSpanSerializer.cs,ToDouble,The following statement contains a magic number: if (units == TimeSpanUnits.Nanoseconds)              {                  return (double)(timeSpan.Ticks) * 100.0;              }              else              {                  return (double)timeSpan.Ticks / (double)TicksPerUnit(units); // cast first then divide to preserve fractional part of result              }
Magic Number,MongoDB.Bson.Serialization.Serializers,TimeSpanSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TimeSpanSerializer.cs,ToInt32,The following statement contains a magic number: if (units == TimeSpanUnits.Nanoseconds)              {                  return (int)(timeSpan.Ticks * 100);               }              else              {                  return (int)(timeSpan.Ticks / TicksPerUnit(units));              }
Magic Number,MongoDB.Bson.Serialization.Serializers,TimeSpanSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\TimeSpanSerializer.cs,ToInt64,The following statement contains a magic number: if (units == TimeSpanUnits.Nanoseconds)              {                  return timeSpan.Ticks * 100;              }              else              {                  return timeSpan.Ticks / TicksPerUnit(units);              }
Duplicate Code,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,MapToDotNetValue,The method contains a code clone-set at the following line numbers (starting from the method definition): ((78' 98)' (106' 126))
Missing Default,MongoDB.Bson,ObjectId,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\ObjectId.cs,ToType,The following switch statement is missing a default case: switch (Type.GetTypeCode(conversionType))              {                  case TypeCode.String:                      return ((IConvertible)this).ToString(provider);                  case TypeCode.Object:                      if (conversionType == typeof(object) || conversionType == typeof(ObjectId))                      {                          return this;                      }                      if (conversionType == typeof(BsonObjectId))                      {                          return new BsonObjectId(this);                      }                      if (conversionType == typeof(BsonString))                      {                          return new BsonString(((IConvertible)this).ToString(provider));                      }                      break;              }
Missing Default,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,MapToBsonValue,The following switch statement is missing a default case: switch (Type.GetTypeCode(valueType))                  {                      case TypeCode.Byte: value = (int)(byte)value; break;                      case TypeCode.Int16: value = (int)(short)value; break;                      case TypeCode.Int32: value = (int)value; break;                      case TypeCode.Int64: value = (long)value; break;                      case TypeCode.SByte: value = (int)(sbyte)value; break;                      case TypeCode.UInt16: value = (int)(ushort)value; break;                      case TypeCode.UInt32: value = (long)(uint)value; break;                      case TypeCode.UInt64: value = (long)(ulong)value; break;                  }
Missing Default,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,MapToBsonValue,The following switch statement is missing a default case: switch (bsonType)              {                  case BsonType.Array:                      if (value is IEnumerable)                      {                          return new BsonArray((IEnumerable)value);                      }                      break;                  case BsonType.Document:                      if (value is IEnumerable<KeyValuePair<string' object>>)                      {                          return new BsonDocument((IEnumerable<KeyValuePair<string' object>>)value);                      }                      if (value is IDictionary)                      {                          return new BsonDocument((IDictionary)value);                      }                      break;              }
Missing Default,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,TryMapToBsonValue,The following switch statement is missing a default case: switch (Type.GetTypeCode(valueType))                  {                      case TypeCode.Byte: value = (int)(byte)value; break;                      case TypeCode.Int16: value = (int)(short)value; break;                      case TypeCode.Int32: value = (int)value; break;                      case TypeCode.Int64: value = (long)value; break;                      case TypeCode.SByte: value = (int)(sbyte)value; break;                      case TypeCode.UInt16: value = (int)(ushort)value; break;                      case TypeCode.UInt32: value = (long)(uint)value; break;                      case TypeCode.UInt64: value = (long)(ulong)value; break;                  }
Missing Default,MongoDB.Bson,BsonTypeMapper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\ObjectModel\BsonTypeMapper.cs,Convert,The following switch statement is missing a default case: switch (conversion)              {                  // note: I expect this switch statement to be compiled using a jump table and therefore to be very efficient                  case Conversion.None: return (BsonValue)value;                  case Conversion.BoolToBsonBoolean: return (BsonBoolean)((bool)value);                  case Conversion.BsonJavaScriptToBsonJavaScriptWithScope: return new BsonJavaScriptWithScope(((BsonJavaScript)value).Code' new BsonDocument());                  case Conversion.BsonMaxKeyToBsonBoolean: return BsonBoolean.True;                  case Conversion.BsonMinKeyToBsonBoolean: return BsonBoolean.True;                  case Conversion.BsonNullToBsonBoolean: return BsonBoolean.False;                  case Conversion.BsonUndefinedToBsonBoolean: return BsonBoolean.False;                  case Conversion.ByteArrayToBsonBinary: return new BsonBinaryData((byte[])value);                  case Conversion.ByteArrayToBsonObjectId: return new BsonObjectId(new ObjectId((byte[])value));                  case Conversion.ByteToBsonBoolean: return (BsonBoolean)((byte)value != 0);                  case Conversion.ByteToBsonDecimal128: return (BsonDecimal128)(Decimal128)(byte)value;                  case Conversion.ByteToBsonDouble: return (BsonDouble)(double)(byte)value;                  case Conversion.ByteToBsonInt32: return (BsonInt32)(int)(byte)value;                  case Conversion.ByteToBsonInt64: return (BsonInt64)(long)(byte)value;                  case Conversion.CharToBsonBoolean: return (BsonBoolean)((char)value != 0);                  case Conversion.CharToBsonDecimal128: return (BsonDecimal128)(Decimal128)(char)value;                  case Conversion.CharToBsonDouble: return (BsonDouble)(double)(char)value;                  case Conversion.CharToBsonInt32: return (BsonInt32)(int)(char)value;                  case Conversion.CharToBsonInt64: return (BsonInt64)(long)(char)value;                  case Conversion.DateTimeOffsetToBsonDateTime: return new BsonDateTime(((DateTimeOffset)value).UtcDateTime);                  case Conversion.DateTimeToBsonDateTime: return new BsonDateTime((DateTime)value);                  case Conversion.DecimalToBsonBoolean: return (BsonBoolean)((decimal)value != 0M);                  case Conversion.DecimalToBsonDecimal128: return (BsonDecimal128)(Decimal128)(decimal)value;                  case Conversion.Decimal128ToBsonBoolean: var d128 = (Decimal128)value; return (BsonBoolean)(!(Decimal128.IsNaN(d128) || d128 == Decimal128.Zero));                  case Conversion.Decimal128ToBsonDecimal128: return (BsonDecimal128)(Decimal128)value;                  case Conversion.DoubleToBsonBoolean: var d = (double)value; return (BsonBoolean)(!(double.IsNaN(d) || d == 0.0));                  case Conversion.DoubleToBsonDecimal128: return (BsonDecimal128)(Decimal128)(double)value;                  case Conversion.DoubleToBsonDouble: return (BsonDouble)(double)value;                  case Conversion.GuidToBsonBinary: return new BsonBinaryData((Guid)value);                  case Conversion.Int16ToBsonBoolean: return (BsonBoolean)((short)value != 0);                  case Conversion.Int16ToBsonDecimal128: return (BsonDecimal128)(Decimal128)(short)value;                  case Conversion.Int16ToBsonDouble: return (BsonDouble)(double)(short)value;                  case Conversion.Int16ToBsonInt32: return (BsonInt32)(int)(short)value;                  case Conversion.Int16ToBsonInt64: return (BsonInt64)(long)(short)value;                  case Conversion.Int32ToBsonBoolean: return (BsonBoolean)((int)value != 0);                  case Conversion.Int32ToBsonDecimal128: return (BsonDecimal128)(Decimal128)(int)value;                  case Conversion.Int32ToBsonDouble: return (BsonDouble)(double)(int)value;                  case Conversion.Int32ToBsonInt32: return (BsonInt32)(int)value;                  case Conversion.Int32ToBsonInt64: return (BsonInt64)(long)(int)value;                  case Conversion.Int64ToBsonBoolean: return (BsonBoolean)((long)value != 0);                  case Conversion.Int64ToBsonDecimal128: return (BsonDecimal128)(Decimal128)(long)value;                  case Conversion.Int64ToBsonDouble: return (BsonDouble)(double)(long)value;                  case Conversion.Int64ToBsonTimestamp: return new BsonTimestamp((long)value);                  case Conversion.Int64ToBsonInt64: return (BsonInt64)(long)value;                  case Conversion.ObjectIdToBsonObjectId: return new BsonObjectId((ObjectId)value);                  case Conversion.RegexToBsonRegularExpression: return new BsonRegularExpression((Regex)value);                  case Conversion.SByteToBsonBoolean: return (BsonBoolean)((sbyte)value != 0);                  case Conversion.SByteToBsonDecimal128: return (BsonDecimal128)(Decimal128)(sbyte)value;                  case Conversion.SByteToBsonDouble: return (BsonDouble)(double)(sbyte)value;                  case Conversion.SByteToBsonInt32: return (BsonInt32)(int)(sbyte)value;                  case Conversion.SByteToBsonInt64: return (BsonInt64)(long)(sbyte)value;                  case Conversion.SingleToBsonBoolean: var f = (float)value; return (BsonBoolean)(!(float.IsNaN(f) || f == 0.0f));                  case Conversion.SingleToBsonDecimal128: return (BsonDecimal128)(Decimal128)(float)value;                  case Conversion.SingleToBsonDouble: return (BsonDouble)(double)(float)value;                  case Conversion.StringToBsonBoolean: return (BsonBoolean)((string)value != "");                  case Conversion.StringToBsonDateTime:                      var formats = new string[] { "yyyy-MM-ddK"' "yyyy-MM-ddTHH:mm:ssK"' "yyyy-MM-ddTHH:mm:ss.FFFFFFFK" };                      var dt = DateTime.ParseExact((string)value' formats' null' DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal);                      return new BsonDateTime(dt);                  case Conversion.StringToBsonDecimal128: return (BsonDecimal128)JsonConvert.ToDecimal128((string)value);                  case Conversion.StringToBsonDouble: return (BsonDouble)JsonConvert.ToDouble((string)value);                  case Conversion.StringToBsonInt32: return (BsonInt32)JsonConvert.ToInt32((string)value);                  case Conversion.StringToBsonInt64: return (BsonInt64)JsonConvert.ToInt64((string)value);                  case Conversion.StringToBsonJavaScript: return new BsonJavaScript((string)value);                  case Conversion.StringToBsonJavaScriptWithScope: return new BsonJavaScriptWithScope((string)value' new BsonDocument());                  case Conversion.StringToBsonObjectId: return new BsonObjectId(ObjectId.Parse((string)value));                  case Conversion.StringToBsonRegularExpression: return new BsonRegularExpression((string)value);                  case Conversion.StringToBsonString: return (BsonString)(string)value;                  case Conversion.StringToBsonSymbol: return BsonSymbolTable.Lookup((string)value);                  case Conversion.StringToBsonTimestamp: return new BsonTimestamp(JsonConvert.ToInt64((string)value));                  case Conversion.UInt16ToBsonBoolean: return (BsonValue)((ushort)value != 0);                  case Conversion.UInt16ToBsonDecimal128: return (BsonDecimal128)(Decimal128)(ushort)value;                  case Conversion.UInt16ToBsonDouble: return (BsonDouble)(double)(ushort)value;                  case Conversion.UInt16ToBsonInt32: return (BsonInt32)(int)(ushort)value;                  case Conversion.UInt16ToBsonInt64: return (BsonInt64)(long)(ushort)value;                  case Conversion.UInt32ToBsonBoolean: return (BsonBoolean)((uint)value != 0);                  case Conversion.UInt32ToBsonDecimal128: return (BsonDecimal128)(Decimal128)(uint)value;                  case Conversion.UInt32ToBsonDouble: return (BsonDouble)(double)(uint)value;                  case Conversion.UInt32ToBsonInt32: return (BsonInt32)(int)(uint)value;                  case Conversion.UInt32ToBsonInt64: return (BsonInt64)(long)(uint)value;                  case Conversion.UInt64ToBsonBoolean: return (BsonBoolean)((ulong)value != 0);                  case Conversion.UInt64ToBsonDecimal128: return (BsonDecimal128)(Decimal128)(ulong)value;                  case Conversion.UInt64ToBsonDouble: return (BsonDouble)(double)(ulong)value;                  case Conversion.UInt64ToBsonInt64: return (BsonInt64)(long)(ulong)value;                  case Conversion.UInt64ToBsonTimestamp: return new BsonTimestamp((long)(ulong)value);              }
Missing Default,MongoDB.Bson.IO,Utf8Helper,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\Utf8Helper.cs,DecodeUtf8String,The following switch statement is missing a default case: switch (count)              {                  // special case empty strings                  case 0:                      return "";                    // special case single character strings                  case 1:                      var byte1 = (int)bytes[index];                      if (byte1 < __asciiStringTable.Length)                      {                          return __asciiStringTable[byte1];                      }                      break;              }
Missing Default,MongoDB.Bson.IO,JsonReader,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonReader.cs,ParseExtendedJson,The following switch statement is missing a default case: switch (nameToken.StringValue)                  {                      case "$binary": _currentValue = ParseBinDataExtendedJson(); return BsonType.Binary;                      case "$code": return ParseJavaScriptExtendedJson(out _currentValue);                      case "$date": _currentValue = ParseDateTimeExtendedJson(); return BsonType.DateTime;                      case "$maxkey": case "$maxKey": _currentValue = ParseMaxKeyExtendedJson(); return BsonType.MaxKey;                      case "$minkey": case "$minKey": _currentValue = ParseMinKeyExtendedJson(); return BsonType.MinKey;                      case "$numberDecimal": _currentValue = ParseNumberDecimalExtendedJson(); return BsonType.Decimal128;                      case "$numberLong": _currentValue = ParseNumberLongExtendedJson(); return BsonType.Int64;                      case "$oid": _currentValue = ParseObjectIdExtendedJson(); return BsonType.ObjectId;                      case "$regex": _currentValue = ParseRegularExpressionExtendedJson(); return BsonType.RegularExpression;                      case "$symbol": _currentValue = ParseSymbolExtendedJson(); return BsonType.Symbol;                      case "$timestamp": _currentValue = ParseTimestampExtendedJson(); return BsonType.Timestamp;                      case "$undefined": _currentValue = ParseUndefinedExtendedJson(); return BsonType.Undefined;                  }
Missing Default,MongoDB.Bson.IO,JsonScanner,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonScanner.cs,GetNumberToken,The following switch statement is missing a default case: switch (state)                  {                      case NumberState.Done:                          buffer.UnRead(c);                          var lexeme = buffer.GetSubstring(start' buffer.Position - start);                          if (type == JsonTokenType.Double)                          {                              var value = JsonConvert.ToDouble(lexeme);                              return new DoubleJsonToken(lexeme' value);                          }                          else                          {                              var value = JsonConvert.ToInt64(lexeme);                              if (value < int.MinValue || value > int.MaxValue)                              {                                  return new Int64JsonToken(lexeme' value);                              }                              else                              {                                  return new Int32JsonToken(lexeme' (int)value);                              }                          }                      case NumberState.Invalid:                          throw new FormatException(FormatMessage("Invalid JSON number"' buffer' start));                  }
Missing Default,MongoDB.Bson.IO,JsonScanner,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\JsonScanner.cs,GetRegularExpressionToken,The following switch statement is missing a default case: switch (state)                  {                      case RegularExpressionState.Done:                          buffer.UnRead(c);                          var lexeme = buffer.GetSubstring(start' buffer.Position - start);                          var regex = new BsonRegularExpression(lexeme);                          return new RegularExpressionJsonToken(lexeme' regex);                      case RegularExpressionState.Invalid:                          throw new FormatException(FormatMessage("Invalid JSON regular expression"' buffer' start));                  }
Missing Default,MongoDB.Bson.IO,BsonBinaryWriter,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\IO\BsonBinaryWriter.cs,WriteBinaryData,The following switch statement is missing a default case: switch (subType)              {                  case BsonBinarySubType.OldBinary:                      if (Settings.FixOldBinarySubTypeOnOutput)                      {                          subType = BsonBinarySubType.Binary; // replace obsolete OldBinary with new Binary sub type                      }                      break;                  case BsonBinarySubType.UuidLegacy:                  case BsonBinarySubType.UuidStandard:                      if (Settings.GuidRepresentation != GuidRepresentation.Unspecified)                      {                          var expectedSubType = (Settings.GuidRepresentation == GuidRepresentation.Standard) ? BsonBinarySubType.UuidStandard : BsonBinarySubType.UuidLegacy;                          if (subType != expectedSubType)                          {                              var message = string.Format(                                  "The GuidRepresentation for the writer is {0}' which requires the subType argument to be {1}' not {2}."'                                  Settings.GuidRepresentation' expectedSubType' subType);                              throw new BsonSerializationException(message);                          }                          if (guidRepresentation != Settings.GuidRepresentation)                          {                              var message = string.Format(                                  "The GuidRepresentation for the writer is {0}' which requires the the guidRepresentation argument to also be {0}' not {1}."'                                  Settings.GuidRepresentation' guidRepresentation);                              throw new BsonSerializationException(message);                          }                      }                      break;              }
Missing Default,MongoDB.Bson.Serialization,BsonMemberMap,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\BsonMemberMap.cs,GetDefaultValue,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))              {                  case TypeCode.Empty:  #if NET45                  case TypeCode.DBNull:  #endif                  case TypeCode.String:                      break;                  case TypeCode.Object:                      if (typeInfo.IsValueType)                      {                          return Activator.CreateInstance(type);                      }                      break;                  case TypeCode.Boolean: return false;                  case TypeCode.Char: return '\0';                  case TypeCode.SByte: return (sbyte)0;                  case TypeCode.Byte: return (byte)0;                  case TypeCode.Int16: return (short)0;                  case TypeCode.UInt16: return (ushort)0;                  case TypeCode.Int32: return 0;                  case TypeCode.UInt32: return 0U;                  case TypeCode.Int64: return 0L;                  case TypeCode.UInt64: return 0UL;                  case TypeCode.Single: return 0F;                  case TypeCode.Double: return 0D;                  case TypeCode.Decimal: return 0M;                  case TypeCode.DateTime: return DateTime.MinValue;              }
Missing Default,MongoDB.Bson.Serialization,TypeNameDiscriminator,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\TypeNameDiscriminator.cs,TryParseGenericTypeName,The following switch statement is missing a default case: switch (c)                      {                          case '[':                              nestingLevel++;                              break;                          case ']':                              nestingLevel--;                              break;                          case ''':                              if (nestingLevel == 0)                              {                                  var typeArgumentName = typeArgumentNamesString.Substring(startIndex' index - startIndex);                                  typeArgumentNamesList.Add(typeArgumentName);                              }                              break;                      }
Missing Default,MongoDB.Bson.Serialization.Conventions,ObjectDiscriminatorConvention,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Conventions\ObjectDiscriminatorConvention.cs,GetActualType,The following switch statement is missing a default case: switch (bsonType)                  {                      case BsonType.Boolean: primitiveType = typeof(bool); break;                      case BsonType.Binary:                          var bookmark = bsonReader.GetBookmark();                          var binaryData = bsonReader.ReadBinaryData();                          var subType = binaryData.SubType;                          if (subType == BsonBinarySubType.UuidStandard || subType == BsonBinarySubType.UuidLegacy)                          {                              primitiveType = typeof(Guid);                          }                          bsonReader.ReturnToBookmark(bookmark);                          break;                      case BsonType.DateTime: primitiveType = typeof(DateTime); break;                      case BsonType.Decimal128: primitiveType = typeof(Decimal128); break;                      case BsonType.Double: primitiveType = typeof(double); break;                      case BsonType.Int32: primitiveType = typeof(int); break;                      case BsonType.Int64: primitiveType = typeof(long); break;                      case BsonType.ObjectId: primitiveType = typeof(ObjectId); break;                      case BsonType.String: primitiveType = typeof(string); break;                  }
Missing Default,MongoDB.Bson.Serialization.Serializers,BitArraySerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\BitArraySerializer.cs,DeserializeValue,The following switch statement is missing a default case: switch (flag)                          {                              case Flags.Length: length = _int32Serializer.Deserialize(context); break;                              case Flags.Bytes: bytes = bsonReader.ReadBytes(); break;                          }
Missing Default,MongoDB.Bson.Serialization.Serializers,DiscriminatedWrapperSerializer<TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DiscriminatedWrapperSerializer.cs,Deserialize,The following switch statement is missing a default case: switch (flag)                  {                      case Flags.Discriminator:                          bsonReader.SkipValue();                          break;                      case Flags.Value:                          var valueDeserializationArgs = new BsonDeserializationArgs { NominalType = actualType };                          value = (TValue)serializer.Deserialize(context' valueDeserializationArgs);                          break;                  }
Missing Default,MongoDB.Bson.Serialization.Serializers,CultureInfoSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\CultureInfoSerializer.cs,DeserializeValue,The following switch statement is missing a default case: switch (flag)                          {                              case Flags.Name: name = bsonReader.ReadString(); break;                              case Flags.UseUserOverride: useUserOverride = _booleanSerializer.Deserialize(context); break;                          }
Missing Default,MongoDB.Bson.Serialization.Serializers,DateTimeOffsetSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DateTimeOffsetSerializer.cs,Deserialize,The following switch statement is missing a default case: switch (flag)                          {                              case Flags.DateTime: bsonReader.SkipValue(); break; // ignore value                              case Flags.Ticks: ticks = _int64Serializer.Deserialize(context); break;                              case Flags.Offset: offset = TimeSpan.FromMinutes(_int32Serializer.Deserialize(context)); break;                          }
Missing Default,MongoDB.Bson.Serialization.Serializers,DateTimeSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DateTimeSerializer.cs,Deserialize,The following switch statement is missing a default case: switch (flag)                          {                              case Flags.DateTime: bsonReader.SkipValue(); break; // ignore value (use Ticks instead)                              case Flags.Ticks: value = new DateTime(_int64Serializer.Deserialize(context)' DateTimeKind.Utc); break;                          }
Missing Default,MongoDB.Bson.Serialization.Serializers,DateTimeSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DateTimeSerializer.cs,Deserialize,The following switch statement is missing a default case: switch (_kind)                  {                      case DateTimeKind.Local:                      case DateTimeKind.Unspecified:                          value = DateTime.SpecifyKind(BsonUtils.ToLocalTime(value)' _kind);                          break;                      case DateTimeKind.Utc:                          value = BsonUtils.ToUniversalTime(value);                          break;                  }
Missing Default,MongoDB.Bson.Serialization.Serializers,DictionarySerializerBase<TDictionary>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionarySerializerBase.cs,DeserializeArrayRepresentation,The following switch statement is missing a default case: switch (flag)                              {                                  case Flags.Key: key = _keySerializer.Deserialize(context); break;                                  case Flags.Value: value = _valueSerializer.Deserialize(context); break;                              }
Missing Default,MongoDB.Bson.Serialization.Serializers,DictionarySerializerBase<TDictionary;TKey;TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\DictionarySerializerBase.cs,DeserializeArrayRepresentation,The following switch statement is missing a default case: switch (flag)                              {                                  case Flags.Key: key = _lazyKeySerializer.Value.Deserialize(context); break;                                  case Flags.Value: value = _lazyValueSerializer.Value.Deserialize(context); break;                              }
Missing Default,MongoDB.Bson.Serialization.Serializers,KeyValuePairSerializer<TKey;TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\KeyValuePairSerializer.cs,TryGetMemberSerializationInfo,The following switch statement is missing a default case: switch (memberName)              {                  case "Key":                      serializationInfo = new BsonSerializationInfo("k"' _lazyKeySerializer.Value' _lazyKeySerializer.Value.ValueType);                      return true;                  case "Value":                      serializationInfo = new BsonSerializationInfo("v"' _lazyValueSerializer.Value' _lazyValueSerializer.Value.ValueType);                      return true;              }
Missing Default,MongoDB.Bson.Serialization.Serializers,KeyValuePairSerializer<TKey;TValue>,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\KeyValuePairSerializer.cs,DeserializeDocumentRepresentation,The following switch statement is missing a default case: switch (flag)                  {                      case Flags.Key: key = _lazyKeySerializer.Value.Deserialize(context); break;                      case Flags.Value: value = _lazyValueSerializer.Value.Deserialize(context); break;                  }
Missing Default,MongoDB.Bson.Serialization.Serializers,ObjectSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ObjectSerializer.cs,Serialize,The following switch statement is missing a default case: switch (Type.GetTypeCode(actualType))                          {                              case TypeCode.Boolean:                                  bsonWriter.WriteBoolean((bool)value);                                  return;                                case TypeCode.DateTime:                                  // TODO: is this right? will lose precision after round trip                                  var bsonDateTime = new BsonDateTime(BsonUtils.ToUniversalTime((DateTime)value));                                  bsonWriter.WriteDateTime(bsonDateTime.MillisecondsSinceEpoch);                                  return;                                case TypeCode.Double:                                  bsonWriter.WriteDouble((double)value);                                  return;                                case TypeCode.Int16:                                  // TODO: is this right? will change type to Int32 after round trip                                  bsonWriter.WriteInt32((short)value);                                  return;                                case TypeCode.Int32:                                  bsonWriter.WriteInt32((int)value);                                  return;                                case TypeCode.Int64:                                  bsonWriter.WriteInt64((long)value);                                  return;                                case TypeCode.Object:                                  if (actualType == typeof(Decimal128))                                  {                                      var decimal128 = (Decimal128)value;                                      bsonWriter.WriteDecimal128(decimal128);                                      return;                                  }                                  if (actualType == typeof(Guid))                                  {                                      var guid = (Guid)value;                                      var guidRepresentation = bsonWriter.Settings.GuidRepresentation;                                      var binaryData = new BsonBinaryData(guid' guidRepresentation);                                      bsonWriter.WriteBinaryData(binaryData);                                      return;                                  }                                  if (actualType == typeof(ObjectId))                                  {                                      bsonWriter.WriteObjectId((ObjectId)value);                                      return;                                  }                                  break;                                case TypeCode.String:                                  bsonWriter.WriteString((string)value);                                  return;                          }
Missing Default,MongoDB.Bson.Serialization.Serializers,ObjectSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\ObjectSerializer.cs,DeserializeDiscriminatedValue,The following switch statement is missing a default case: switch(type)                  {                      case BsonType.Document:                          if (context.DynamicDocumentSerializer != null)                          {                              return context.DynamicDocumentSerializer.Deserialize(context' args);                          }                          break;                  }
Missing Default,MongoDB.Bson.Serialization.Serializers,VersionSerializer,C:\repos\mongodb_mongo-csharp-driver\src\MongoDB.Bson\Serialization\Serializers\VersionSerializer.cs,DeserializeValue,The following switch statement is missing a default case: switch (flag)                          {                              case Flags.Major: major = _int32Serializer.Deserialize(context); break;                              case Flags.Minor: minor = _int32Serializer.Deserialize(context); break;                              case Flags.Build: build = _int32Serializer.Deserialize(context); break;                              case Flags.Revision: revision = _int32Serializer.Deserialize(context); break;                          }
