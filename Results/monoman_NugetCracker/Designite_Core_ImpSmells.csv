Implementation smell,Namespace,Class,File,Method,Description
Long Method,NuGet,RequestHelper,C:\repos\monoman_NugetCracker\Nuget\src\Core\Http\RequestHelper.cs,GetResponse,The method has 104 lines of code.
Complex Method,NuGet,ManifestVersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\ManifestVersionUtility.cs,VisitProperty,Cyclomatic complexity of the method is 8
Complex Method,NuGet,PackageSourceProvider,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageSource\PackageSourceProvider.cs,LoadPackageSources,Cyclomatic complexity of the method is 8
Complex Method,NuGet,PackageWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\PackageWalker.cs,Walk,Cyclomatic complexity of the method is 10
Complex Method,NuGet,ProjectSystemExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Extensions\ProjectSystemExtensions.cs,DeleteFiles,Cyclomatic complexity of the method is 8
Complex Method,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,ParseFrameworkName,Cyclomatic complexity of the method is 14
Complex Method,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,TryParseVersionSpec,Cyclomatic complexity of the method is 11
Complex Method,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,PrettyPrint,Cyclomatic complexity of the method is 9
Complex Method,NuGet.Runtime,BindingRedirectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\Runtime\BindingRedirectManager.cs,AddBindingRedirects,Cyclomatic complexity of the method is 9
Long Parameter List,NuGet,RequestHelper,C:\repos\monoman_NugetCracker\Nuget\src\Core\Http\RequestHelper.cs,GetResponse,The method has 5 parameters. Parameters: createRequest' prepareRequest' proxyCache' credentialCache' credentialProvider
Long Parameter List,NuGet,AggregateQuery<TVal>,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\AggregateQuery.cs,AggregateQuery,The method has 6 parameters. Parameters: queryables' equalityComparer' subQueries' expression' logger' ignoreInvalidRepositories
Long Parameter List,NuGet,PackageHelper,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\PackageHelper.cs,ResolvePackage,The method has 5 parameters. Parameters: sourceRepository' localRepository' packageId' version' allowPrereleaseVersions
Long Parameter List,NuGet,PackageHelper,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\PackageHelper.cs,ResolvePackage,The method has 6 parameters. Parameters: sourceRepository' localRepository' constraintProvider' packageId' version' allowPrereleaseVersions
Long Parameter List,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,UpdatePackageReference,The method has 5 parameters. Parameters: packageId' resolvePackage' updateDependencies' allowPrereleaseVersions' targetVersionSetExplicitly
Long Parameter List,NuGet,InstallWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\InstallWalker.cs,InstallWalker,The method has 5 parameters. Parameters: localRepository' sourceRepository' logger' ignoreDependencies' allowPrereleaseVersions
Long Parameter List,NuGet,InstallWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\InstallWalker.cs,InstallWalker,The method has 6 parameters. Parameters: localRepository' sourceRepository' constraintProvider' logger' ignoreDependencies' allowPrereleaseVersions
Long Parameter List,NuGet,UpdateWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\UpdateWalker.cs,UpdateWalker,The method has 7 parameters. Parameters: localRepository' sourceRepository' dependentsResolver' constraintProvider' logger' updateDependencies' allowPrereleaseVersions
Long Parameter List,NuGet,UninstallWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\UninstallWalker.cs,UninstallWalker,The method has 5 parameters. Parameters: repository' dependentsResolver' logger' removeDependencies' forceRemove
Long Parameter List,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,FindPackage,The method has 5 parameters. Parameters: repository' packageId' version' allowPrereleaseVersions' allowUnlisted
Long Parameter List,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,FindPackage,The method has 6 parameters. Parameters: repository' packageId' version' constraintProvider' allowPrereleaseVersions' allowUnlisted
Long Parameter List,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,FindPackage,The method has 6 parameters. Parameters: repository' packageId' versionSpec' constraintProvider' allowPrereleaseVersions' allowUnlisted
Long Parameter List,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,FindPackages,The method has 5 parameters. Parameters: repository' packageId' versionSpec' allowPrereleaseVersions' allowUnlisted
Long Parameter List,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,FindPackage,The method has 5 parameters. Parameters: repository' packageId' versionSpec' allowPrereleaseVersions' allowUnlisted
Long Parameter List,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,ResolveDependency,The method has 5 parameters. Parameters: repository' dependency' constraintProvider' allowPrereleaseVersions' preferListedPackages
Long Parameter List,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,ResolveDependencyCore,The method has 5 parameters. Parameters: repository' dependency' constraintProvider' allowPrereleaseVersions' preferListedPackages
Long Identifier,NuGet,ManifestReference,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\ManifestReference.cs,,The length of the parameter _referenceFileInvalidCharacters is 31.
Long Identifier,NuGet,PackageSourceProvider,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageSource\PackageSourceProvider.cs,,The length of the parameter DisabledPackageSourcesSectionName is 33.
Long Statement,NuGet,MetadataExtractor,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\AssemblyMetadataExtractor.cs,GetMetadata,The length of the statement  "                string assemblyInformationalVersion = GetAttributeValueOrDefault<AssemblyInformationalVersionAttribute>(assembly' a => a.InformationalVersion); " is 143.
Long Statement,NuGet,ManifestFile,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\ManifestFile.cs,Validate,The length of the statement  "                yield return new ValidationResult(String.Format(CultureInfo.CurrentCulture' NuGetResources.Manifest_SourceContainsInvalidCharacters' Source)); " is 142.
Long Statement,NuGet,ManifestFile,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\ManifestFile.cs,Validate,The length of the statement  "                yield return new ValidationResult(String.Format(CultureInfo.CurrentCulture' NuGetResources.Manifest_TargetContainsInvalidCharacters' Target)); " is 142.
Long Statement,NuGet,ManifestFile,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\ManifestFile.cs,Validate,The length of the statement  "                yield return new ValidationResult(String.Format(CultureInfo.CurrentCulture' NuGetResources.Manifest_ExcludeContainsInvalidCharacters' Exclude)); " is 144.
Long Statement,NuGet,ManifestReference,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\ManifestReference.cs,Validate,The length of the statement  "                yield return new ValidationResult(String.Format(CultureInfo.CurrentCulture' NuGetResources.Manifest_InvalidReferenceFile' File)); " is 129.
Long Statement,NuGet,ManifestSchemaUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\ManifestSchemaUtility.cs,GetSchemaNamespace,The length of the statement  "                throw new InvalidOperationException(String.Format(CultureInfo.CurrentCulture' NuGetResources.UnknownSchemaVersion' version)); " is 125.
Long Statement,NuGet,ManifestVersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\ManifestVersionUtility.cs,GetVersionPropertyVersion,The length of the statement  "            if (SemanticVersion.TryParse(metadata.Version' out semanticVersion) && !String.IsNullOrEmpty(semanticVersion.SpecialVersion)) " is 125.
Long Statement,NuGet,SettingsExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Extensions\SettingsExtensions.cs,GetDecryptedValue,The length of the statement  "            var decryptedByteArray = ProtectedData.Unprotect(encrpytedByteArray' StringToBytes(_entropy)' DataProtectionScope.CurrentUser); " is 127.
Long Statement,NuGet,SettingsExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Extensions\SettingsExtensions.cs,SetEncryptedValue,The length of the statement  "                var encryptedByteArray = ProtectedData.Protect(decryptedByteArray' StringToBytes(_entropy)' DataProtectionScope.CurrentUser); " is 125.
Long Statement,NuGet,MultipartWebRequest,C:\repos\monoman_NugetCracker\Nuget\src\Core\Http\MultipartWebRequest.cs,CreateMultipartRequest,The length of the statement  "                    string header = String.Format(CultureInfo.InvariantCulture' FileTemplate' boundary' file.FieldName' file.FieldName' file.ContentType); " is 134.
Long Statement,NuGet,SemanticVersion,C:\repos\monoman_NugetCracker\Nuget\src\Core\SemanticVersion.cs,Parse,The length of the statement  "                throw new ArgumentException(String.Format(CultureInfo.CurrentCulture' NuGetResources.InvalidVersionString' version)' "version"); " is 128.
Long Statement,NuGet,SemanticVersion,C:\repos\monoman_NugetCracker\Nuget\src\Core\SemanticVersion.cs,TryParseInternal,The length of the statement  "            semVer = new SemanticVersion(NormalizeVersionValue(versionValue)' match.Groups["Release"].Value.TrimStart('-')' version.Replace(" "' "")); " is 138.
Long Statement,NuGet,PackageServer,C:\repos\monoman_NugetCracker\Nuget\src\Core\Server\PackageServer.cs,EnsureSuccessfulResponse,The length of the statement  "                    throw new InvalidOperationException(String.Format(CultureInfo.CurrentCulture' NuGetResources.PackageServerError' httpResponse.StatusDescription' e.Message)' e); " is 160.
Long Statement,NuGet,PackageSourceProvider,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageSource\PackageSourceProvider.cs,LoadPackageSources,The length of the statement  "                IList<KeyValuePair<string' string>> disabledSourcesValues = _settingsManager.GetValues(DisabledPackageSourcesSectionName); " is 122.
Long Statement,NuGet,PackageSourceProviderExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageSource\PackageSourceProviderExtensions.cs,GetAggregate,The length of the statement  "            return new AggregateRepository(factory' provider.GetEnabledPackageSources().Select(s => s.Source)' ignoreFailingRepositories); " is 126.
Long Statement,NuGet,PackageSourceProviderExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageSource\PackageSourceProviderExtensions.cs,ResolveSource,The length of the statement  "                                  where source.Name.Equals(value' StringComparison.CurrentCultureIgnoreCase) || source.Source.Equals(value' StringComparison.OrdinalIgnoreCase) " is 141.
Long Statement,NuGet,AggregateQuery<TVal>,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\AggregateQuery.cs,CreateQuery,The length of the statement  "            return (IQueryable)ctor.Invoke(new object[] { _queryables' _equalityComparer' subQueries' expression' _logger' _ignoreFailures }); " is 130.
Long Statement,NuGet,AggregateRepository,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\AggregateRepository.cs,GetPackages,The length of the statement  "            // We need to follow this pattern in all AggregateRepository methods to ensure it suppresses exceptions that may occur if the Ignore flag is set.  Oh how I despise my code.  " is 172.
Long Statement,NuGet,AggregateRepository,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\AggregateRepository.cs,ResolveDependency,The length of the statement  "                Func<IPackageRepository' IPackage> resolveDependency = Wrap(r => r.ResolveDependency(dependency' constraintProvider' allowPrereleaseVersions' preferListedPackages)); " is 165.
Long Statement,NuGet,PackageReferenceFile,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageReferenceFile.cs,GetPackageReferences,The length of the statement  "                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture' NuGetResources.ReferenceFile_InvalidVersion' versionString' _path)); " is 141.
Long Statement,NuGet,PackageReferenceFile,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageReferenceFile.cs,GetPackageReferences,The length of the statement  "                        throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture' NuGetResources.ReferenceFile_InvalidVersion' versionConstraintString' _path)); " is 151.
Long Statement,NuGet,DataServiceContextWrapper,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\DataServiceContextWrapper.cs,ExtractSupportedProperties,The length of the statement  "            // The name is listed in the entity set listing as <EntitySet Name="Packages" EntityType="Gallery.Infrastructure.FeedModels.PublishedPackage" /> " is 144.
Long Statement,NuGet,Preprocessor,C:\repos\monoman_NugetCracker\Nuget\src\Core\FileModifiers\Preprocessor.cs,ReplaceToken,The length of the statement  "                throw new InvalidOperationException(String.Format(CultureInfo.CurrentCulture' NuGetResources.TokenHasNoValue' propertyName)); " is 125.
Long Statement,NuGet,PackageHelper,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\PackageHelper.cs,ResolvePackage,The length of the statement  "            return ResolvePackage(sourceRepository' localRepository' constraintProvider: NullConstraintProvider.Instance' packageId: packageId' version: version' allowPrereleaseVersions: allowPrereleaseVersions); " is 200.
Long Statement,NuGet,PackageHelper,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\PackageHelper.cs,ResolvePackage,The length of the statement  "                package = sourceRepository.FindPackage(packageId' version' constraintProvider' allowPrereleaseVersions' allowUnlisted: false); " is 126.
Long Statement,NuGet,PackageHelper,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\PackageHelper.cs,ResolvePackage,The length of the statement  "                    package = localRepository.FindPackage(package.Id' package.Version' allowPrereleaseVersions' allowUnlisted: true) ?? package; " is 124.
Long Statement,NuGet,PathValidator,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\PathValidator.cs,IsValidSource,The length of the statement  "            return PathValidator.IsValidLocalPath(source) || PathValidator.IsValidUncPath(source) || PathValidator.IsValidUrl(source); " is 122.
Long Statement,NuGet,PathValidator,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\PathValidator.cs,IsValidUrl,The length of the statement  "            // Make sure url starts with protocol:// because Uri.TryCreate() returns true for local and UNC paths even if badly formed. " is 123.
Long Statement,NuGet,PackageManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageManager.cs,InstallPackage,The length of the statement  "            IPackage package = PackageHelper.ResolvePackage(SourceRepository' LocalRepository' packageId' version' allowPrereleaseVersions); " is 128.
Long Statement,NuGet,PackageManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageManager.cs,UpdatePackage,The length of the statement  "            UpdatePackage(packageId' version: null' updateDependencies: updateDependencies' allowPrereleaseVersions: allowPrereleaseVersions); " is 130.
Long Statement,NuGet,PackageManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageManager.cs,UpdatePackage,The length of the statement  "            UpdatePackage(packageId' () => SourceRepository.FindPackage(packageId' versionSpec' allowPrereleaseVersions' allowUnlisted: false)' " is 131.
Long Statement,NuGet,PackageManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageManager.cs,UpdatePackage,The length of the statement  "            UpdatePackage(packageId' () => SourceRepository.FindPackage(packageId' version' allowPrereleaseVersions' allowUnlisted: false)' " is 127.
Long Statement,NuGet,PackageBuilder,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PackageBuilder.cs,ValidateDependencies,The length of the statement  "                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture' NuGetResources.Manifest_InvalidPrereleaseDependency' prereleaseDependency.ToString())); " is 160.
Long Statement,NuGet,PackageBuilder,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PackageBuilder.cs,ValidateReferenceAssemblies,The length of the statement  "                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture' NuGetResources.Manifest_InvalidReference' reference)); " is 127.
Long Statement,NuGet,PathResolver,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PathResolver.cs,WildcardToRegex,The length of the statement  "                .Replace(@"\*\*"' ".*") // For recursive wildcards that don't end in a slash e.g. **.txt would be treated as a .txt file at any depth " is 133.
Long Statement,NuGet,PathResolver,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PathResolver.cs,ResolveSearchPattern,The length of the statement  "            // Append the basePath to searchPattern and get the search regex. We need to do this because the search regex is matched from line start. " is 137.
Long Statement,NuGet,PathResolver,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PathResolver.cs,ResolveSearchPattern,The length of the statement  "            // This is a hack to prevent enumerating over the entire directory tree if the only wildcard characters are the ones in the file name.  " is 134.
Long Statement,NuGet,PathResolver,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PathResolver.cs,ResolveSearchPattern,The length of the statement  "            // Starting from the base path' enumerate over all files and match it using the wildcard expression provided by the user. " is 121.
Long Statement,NuGet,PathResolver,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PathResolver.cs,GetPathToEnumerateFrom,The length of the statement  "                // For paths without wildcard' we could either have base relative paths (such as lib\foo.dll) or paths outside the base path " is 124.
Long Statement,NuGet,PathResolver,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PathResolver.cs,ResolvePackagePath,The length of the statement  "            bool isRecursiveWildcardSearch = isWildcardSearch && searchPattern.IndexOf("**"' StringComparison.OrdinalIgnoreCase) != -1; " is 123.
Long Statement,NuGet,PathResolver,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PathResolver.cs,ResolvePackagePath,The length of the statement  "            else if (!isWildcardSearch && Path.GetExtension(searchPattern).Equals(Path.GetExtension(targetPath)' StringComparison.OrdinalIgnoreCase)) " is 137.
Long Statement,NuGet,Manifest,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\Manifest.cs,ValidateDependencies,The length of the statement  "                    throw new InvalidOperationException(String.Format(CultureInfo.CurrentCulture' NuGetResources.DuplicateDependenciesDefined' metadata.Id' dependency.Id)); " is 152.
Long Statement,NuGet,Manifest,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\Manifest.cs,ValidateDependencyVersion,The length of the statement  "                        throw new InvalidOperationException(String.Format(CultureInfo.CurrentCulture' NuGetResources.DependencyHasInvalidVersion' dependency.Id)); " is 138.
Long Statement,NuGet,Manifest,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\Manifest.cs,ValidateDependencyVersion,The length of the statement  "                        throw new InvalidOperationException(String.Format(CultureInfo.CurrentCulture' NuGetResources.DependencyHasInvalidVersion' dependency.Id)); " is 138.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,AddPackageReference,The length of the statement  "            IPackage package = PackageHelper.ResolvePackage(SourceRepository' LocalRepository' NullConstraintProvider.Instance' packageId' version' allowPrereleaseVersions); " is 161.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,Execute,The length of the statement  "                Logger.Log(MessageLevel.Info' NuGetResources.Log_ProjectAlreadyReferencesPackage' Project.ProjectName' package.GetFullName()); " is 126.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,Execute,The length of the statement  "                    Logger.Log(MessageLevel.Info' NuGetResources.Log_ProjectAlreadyReferencesPackage' Project.ProjectName' operation.Package.GetFullName()); " is 136.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,AddPackageReferenceToProject,The length of the statement  "            Logger.Log(MessageLevel.Info' NuGetResources.Log_SuccessfullyAddedPackageReference' package.GetFullName()' Project.ProjectName); " is 128.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,ExtractPackageFilesToProject,The length of the statement  "            IEnumerable<IPackageAssemblyReference> assemblyReferences = GetCompatibleItems(Project' package.AssemblyReferences' package.GetFullName()); " is 139.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,ExtractPackageFilesToProject,The length of the statement  "            IEnumerable<FrameworkAssemblyReference> frameworkReferences = Project.GetCompatibleItemsCore(package.FrameworkAssemblies); " is 122.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,RemovePackageReferenceFromProject,The length of the statement  "                                          from assemblyReference in assemblyReferences ?? Enumerable.Empty<IPackageAssemblyReference>() // This can happen if package installed left the project in a bad state " is 165.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,RemovePackageReferenceFromProject,The length of the statement  "            // Get the files and references for this package' that aren't in use by any other packages so we don't have to do reference counting " is 132.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,RemovePackageReferenceFromProject,The length of the statement  "            var assemblyReferencesToDelete = Project.GetCompatibleItemsCore(package.AssemblyReferences).Except(otherAssemblyReferences' PackageFileComparer.Default); " is 153.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,RemovePackageReferenceFromProject,The length of the statement  "            Logger.Log(MessageLevel.Info' NuGetResources.Log_SuccessfullyRemovedPackageReference' package.GetFullName()' Project.ProjectName); " is 130.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,UpdatePackageReference,The length of the statement  "                () => SourceRepository.FindPackage(packageId' versionSpec' ConstraintProvider' allowPrereleaseVersions' allowUnlisted: false)' " is 126.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,UpdatePackageReference,The length of the statement  "            UpdatePackageReference(packageId' () => SourceRepository.FindPackage(packageId' version' ConstraintProvider' allowPrereleaseVersions' allowUnlisted: false)' updateDependencies' allowPrereleaseVersions' targetVersionSetExplicitly: version != null); " is 247.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,UpdatePackageReference,The length of the statement  "            // the condition (allowPrereleaseVersions || targetVersionSetExplicitly || oldPackage.IsReleaseVersion() || !package.IsReleaseVersion() || oldPackage.Version < package.Version) " is 176.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,UpdatePackageReference,The length of the statement  "                (allowPrereleaseVersions || targetVersionSetExplicitly || oldPackage.IsReleaseVersion() || !package.IsReleaseVersion() || oldPackage.Version < package.Version)) " is 160.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,UpdatePackageReference,The length of the statement  "                Logger.Log(MessageLevel.Info' NuGetResources.Log_UpdatingPackages' package.Id' oldPackage.Version' package.Version' Project.ProjectName); " is 137.
Long Statement,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,UpdatePackageReference,The length of the statement  "                    Logger.Log(MessageLevel.Info' NuGetResources.Log_ApplyingConstraints' packageId' VersionUtility.PrettyPrint(constraint)' ConstraintProvider.Source); " is 148.
Long Statement,NuGet,DataServicePackageRepository,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\DataServicePackageRepository.cs,Search,The length of the statement  "                searchParameters.Add("includePrerelease"' allowPrereleaseVersions.ToString(CultureInfo.InvariantCulture).ToLowerInvariant()); " is 125.
Long Statement,NuGet,ClosureEvaluator,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\ClosureEvaluator.cs,GetValue,The length of the statement  "                Debug.Assert(evalMethodInfo != null' "Eval method cannot be found. Please add and Eval(FieldInfo info' object value) to " + parentType.FullName); " is 145.
Long Statement,NuGet,PackageDownloader,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\PackageDownloader.cs,DownloadPackage,The length of the statement  "            string operation = String.Format(CultureInfo.CurrentCulture' NuGetResources.DownloadProgressStatus' package.Id' package.Version); " is 129.
Long Statement,NuGet,ZipPackage,C:\repos\monoman_NugetCracker\Nuget\src\Core\Packages\ZipPackage.cs,EnsureManifest,The length of the statement  "                PackageRelationship relationshipType = package.GetRelationshipsByType(Constants.PackageRelationshipNamespace + PackageBuilder.ManifestRelationType).SingleOrDefault(); " is 166.
Long Statement,NuGet,ZipPackage,C:\repos\monoman_NugetCracker\Nuget\src\Core\Packages\ZipPackage.cs,EnsureManifest,The length of the statement  "                    IEnumerable<string> references = (manifest.Metadata.References ?? Enumerable.Empty<ManifestReference>()).Select(c => c.File); " is 125.
Long Statement,NuGet,PackageWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\PackageWalker.cs,Walk,The length of the statement  "                    IPackage resolvedDependency = Marker.ResolveDependency(dependency' AllowPrereleaseVersions' preferListedPackages: false) ?? " is 123.
Long Statement,NuGet,InstallWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\InstallWalker.cs,TryUpdate,The length of the statement  "                // B 1.5 or B 2.0. In order to achieve this' we add a constraint for version of B 1.0.1 so we stay within those bounds for B. " is 125.
Long Statement,NuGet,InstallWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\InstallWalker.cs,ResolveDependency,The length of the statement  "            IPackage package = Repository.ResolveDependency(dependency' ConstraintProvider' allowPrereleaseVersions: true' preferListedPackages: false); " is 140.
Long Statement,NuGet,InstallWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\InstallWalker.cs,ResolveDependency,The length of the statement  "            IPackage sourcePackage = SourceRepository.ResolveDependency(dependency' ConstraintProvider' AllowPrereleaseVersions' preferListedPackages: true); " is 145.
Long Statement,NuGet,InstallWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\InstallWalker.cs,OnDependencyResolveError,The length of the statement  "                message = String.Format(CultureInfo.CurrentCulture' NuGetResources.AdditonalConstraintsDefined' dependency.Id' VersionUtility.PrettyPrint(spec)' ConstraintProvider.Source); " is 172.
Long Statement,NuGet,InstallWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\InstallWalker.cs,CreatePackageConflictException,The length of the statement  "                       NuGetResources.ConflictErrorWithDependent' package.GetFullName()' resolvedPackage.GetFullName()' dependents.Single().Id)); " is 122.
Long Statement,NuGet,UninstallWalker,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageWalker\UninstallWalker.cs,WarnRemovingPackageBreaksDependents,The length of the statement  "            Logger.Log(MessageLevel.Warning' NuGetResources.Warning_UninstallingPackageWillBreakDependents' package.GetFullName()' String.Join("' "' dependents.Select(d => d.GetFullName()))); " is 179.
Long Statement,NuGet,PackageReferenceRepository,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageReferenceRepository.cs,GetConstraint,The length of the statement  "            PackageReference reference = _packageReferenceFile.GetPackageReferences().FirstOrDefault(p => p.Id.Equals(packageId' StringComparison.OrdinalIgnoreCase)); " is 154.
Long Statement,NuGet,PackageExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Extensions\PackageExtensions.cs,GetFiles,The length of the statement  "            return package.GetFiles().Where(file => file.Path.StartsWith(directory + Path.DirectorySeparatorChar' StringComparison.OrdinalIgnoreCase)); " is 139.
Long Statement,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,FindPackage,The length of the statement  "            // Default allow pre release versions to true here because the caller typically wants to find all packages in this scenario for e.g when checking if a  " is 150.
Long Statement,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,FindPackage,The length of the statement  "            return FindPackage(repository' packageId' version' NullConstraintProvider.Instance' allowPrereleaseVersions: true' allowUnlisted: true); " is 136.
Long Statement,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,FindPackage,The length of the statement  "            return FindPackage(repository' packageId' version' NullConstraintProvider.Instance' allowPrereleaseVersions' allowUnlisted); " is 124.
Long Statement,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,Search,The length of the statement  "            return Search(repository' searchTerm' targetFrameworks: Enumerable.Empty<string>()' allowPrereleaseVersions: allowPrereleaseVersions); " is 134.
Long Statement,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,ResolveDependency,The length of the statement  "            return ResolveDependency(repository' dependency' constraintProvider: null' allowPrereleaseVersions: allowPrereleaseVersions' preferListedPackages: preferListedPackages); " is 169.
Long Statement,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,ResolveDependency,The length of the statement  "                return dependencyResolver.ResolveDependency(dependency' constraintProvider' allowPrereleaseVersions' preferListedPackages); " is 123.
Long Statement,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,ResolveDependency,The length of the statement  "            return ResolveDependencyCore(repository' dependency' constraintProvider' allowPrereleaseVersions' preferListedPackages); " is 120.
Long Statement,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,GetCompareExpression,The length of the statement  "            Expression toLowerExpression = Expression.Call(propertyExpression' typeof(string).GetMethod("ToLower"' Type.EmptyTypes)); " is 121.
Long Statement,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,ResolveSafeVersion,The length of the statement  "            // major and minor combination (we want to make some versioning assumptions that the 3rd number is a non-breaking bug fix). This is so that we get the closest version " is 166.
Long Statement,NuGet,FileSystemExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Extensions\FileSystemExtensions.cs,DeleteFiles,The length of the statement  "                var directoryFiles = directoryLookup.Contains(directory) ? directoryLookup[directory] : Enumerable.Empty<IPackageFile>(); " is 121.
Long Statement,NuGet,ProjectSystemExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Extensions\ProjectSystemExtensions.cs,DeleteFiles,The length of the statement  "            var directoryLookup = files.ToLookup(p => Path.GetDirectoryName(ResolveTargetPath(project' fileTransformers' p.Path' out transformer))); " is 136.
Long Statement,NuGet,ProjectSystemExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Extensions\ProjectSystemExtensions.cs,DeleteFiles,The length of the statement  "                var directoryFiles = directoryLookup.Contains(directory) ? directoryLookup[directory] : Enumerable.Empty<IPackageFile>(); " is 121.
Long Statement,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,ParseFrameworkName,The length of the statement  "                // We failed to parse the version string once more. So we need to decide if this is unsupported or if we use the default version. " is 129.
Long Statement,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,PrettyPrint,The length of the statement  "            if (versionSpec.MinVersion != null && versionSpec.IsMinInclusive && versionSpec.MaxVersion == null && !versionSpec.IsMaxInclusive) " is 130.
Long Statement,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,PrettyPrint,The length of the statement  "            if (versionSpec.MinVersion != null && versionSpec.MaxVersion != null && versionSpec.MinVersion == versionSpec.MaxVersion && versionSpec.IsMinInclusive && versionSpec.IsMaxInclusive) " is 181.
Long Statement,NuGet.Analysis.Rules,MisplacedAssemblyRule,C:\repos\monoman_NugetCracker\Nuget\src\Core\Analysis\Rules\MisplacedAssemblyRule.cs,Validate,The length of the statement  "                else if (!directory.StartsWith(Constants.LibDirectory + Path.DirectorySeparatorChar' StringComparison.OrdinalIgnoreCase)) " is 121.
Long Statement,NuGet.Analysis.Rules,NonAssemblyInsideLibRule,C:\repos\monoman_NugetCracker\Nuget\src\Core\Analysis\Rules\NonAssemblyInsideLibRule.cs,Validate,The length of the statement  "            var assembliesSet = new HashSet<string>(allLibFiles.Where(PackageUtility.IsAssembly)' StringComparer.OrdinalIgnoreCase); " is 120.
Long Statement,NuGet.Runtime,BindingRedirectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\Runtime\BindingRedirectManager.cs,AddBindingRedirects,The length of the statement  "                        // Since we have a binding element' the assembly binding node (parent node) must exist. We don't need to do anything more here. " is 127.
Complex Conditional,NuGet,VersionSpec,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionSpec.cs,ToString,The conditional expression  "MinVersion != null && IsMinInclusive && MaxVersion == null && !IsMaxInclusive"  is complex.
Complex Conditional,NuGet,VersionSpec,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionSpec.cs,ToString,The conditional expression  "MinVersion != null && MaxVersion != null && MinVersion == MaxVersion && IsMinInclusive && IsMaxInclusive"  is complex.
Complex Conditional,NuGet,ProjectManager,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectManager.cs,UpdatePackageReference,The conditional expression  "package != null &&                  oldPackage.Version != package.Version &&                  (allowPrereleaseVersions || targetVersionSetExplicitly || oldPackage.IsReleaseVersion() || !package.IsReleaseVersion() || oldPackage.Version < package.Version)"  is complex.
Complex Conditional,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,PrettyPrint,The conditional expression  "versionSpec.MinVersion != null && versionSpec.IsMinInclusive && versionSpec.MaxVersion == null && !versionSpec.IsMaxInclusive"  is complex.
Complex Conditional,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,PrettyPrint,The conditional expression  "versionSpec.MinVersion != null && versionSpec.MaxVersion != null && versionSpec.MinVersion == versionSpec.MaxVersion && versionSpec.IsMinInclusive && versionSpec.IsMaxInclusive"  is complex.
Complex Conditional,NuGet.Analysis.Rules,MisplacedScriptFileRule,C:\repos\monoman_NugetCracker\Nuget\src\Core\Analysis\Rules\MisplacedScriptFileRule.cs,Validate,The conditional expression  "!directory.Equals(Constants.ToolsDirectory' StringComparison.OrdinalIgnoreCase) ||                          !name.Equals("install"' StringComparison.OrdinalIgnoreCase) &&                          !name.Equals("uninstall"' StringComparison.OrdinalIgnoreCase) &&                          !name.Equals("init"' StringComparison.OrdinalIgnoreCase)"  is complex.
Empty Catch Block,NuGet,EnumerableExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Extensions\EnumerableExtensions.cs,SafeIterate,The method has an empty catch block.
Empty Catch Block,NuGet,PhysicalFileSystem,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectSystem\PhysicalFileSystem.cs,DeleteFile,The method has an empty catch block.
Empty Catch Block,NuGet,PhysicalFileSystem,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectSystem\PhysicalFileSystem.cs,DeleteDirectory,The method has an empty catch block.
Empty Catch Block,NuGet,PhysicalFileSystem,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectSystem\PhysicalFileSystem.cs,GetFiles,The method has an empty catch block.
Empty Catch Block,NuGet,PhysicalFileSystem,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectSystem\PhysicalFileSystem.cs,GetFiles,The method has an empty catch block.
Empty Catch Block,NuGet,PhysicalFileSystem,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectSystem\PhysicalFileSystem.cs,GetDirectories,The method has an empty catch block.
Empty Catch Block,NuGet,PhysicalFileSystem,C:\repos\monoman_NugetCracker\Nuget\src\Core\ProjectSystem\PhysicalFileSystem.cs,GetDirectories,The method has an empty catch block.
Empty Catch Block,NuGet,MachineCache,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\MachineCache.cs,Clear,The method has an empty catch block.
Empty Catch Block,NuGet,MachineCache,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\MachineCache.cs,Clear,The method has an empty catch block.
Empty Catch Block,NuGet,SharedPackageRepository,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\SharedPackageRepository.cs,GetStoreDocument,The method has an empty catch block.
Magic Number,NuGet,PackageBuilder,C:\repos\monoman_NugetCracker\Nuget\src\Core\Authoring\PackageBuilder.cs,ValidateSpecialVersionLength,The following statement contains a magic number: return version == null || version.SpecialVersion == null || version.SpecialVersion.Length <= 20;
Magic Number,NuGet,PackageSource,C:\repos\monoman_NugetCracker\Nuget\src\Core\PackageSource\PackageSource.cs,GetHashCode,The following statement contains a magic number: return Name.GetHashCode() * 3137 + Source.GetHashCode();
Magic Number,NuGet,DefaultPackagePathResolver,C:\repos\monoman_NugetCracker\Nuget\src\Core\Packages\DefaultPackagePathResolver.cs,DefaultPackagePathResolver,The following statement contains a magic number: if (!useSideBySidePaths)  				_fileSystem.AddFileWithCheck("ExcludeVersion"' (Stream st) => { st.WriteByte(49); st.Flush(); });
Magic Number,NuGet,HashCodeCombiner,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\HashCodeCombiner.cs,AddInt32,The following statement contains a magic number: _combinedHash64 = ((_combinedHash64 << 5) + _combinedHash64) ^ i;
Magic Number,NuGet,HttpClient,C:\repos\monoman_NugetCracker\Nuget\src\Core\Http\HttpClient.cs,DownloadData,The following statement contains a magic number: const int ChunkSize = 1024 * 4;
Magic Number,NuGet,HttpClient,C:\repos\monoman_NugetCracker\Nuget\src\Core\Http\HttpClient.cs,DownloadData,The following statement contains a magic number: const int ChunkSize = 1024 * 4;
Magic Number,NuGet,HttpClient,C:\repos\monoman_NugetCracker\Nuget\src\Core\Http\HttpClient.cs,DownloadData,The following statement contains a magic number: using (var response = GetResponse())              {                  // Total response length                  int length = (int)response.ContentLength;                  using (Stream stream = response.GetResponseStream())                  {                      // in some circumstances' the Content-Length response header is missing' resulting in                      // the ContentLength = -1. In which case' we copy the whole stream and do not report progress.                      if (length < 0)                      {                          using (var memoryStream = new MemoryStream())                          {                              stream.CopyTo(memoryStream' ChunkSize);                              buffer = memoryStream.ToArray();                          }                            // reporting fake progress as 100%                          OnProgressAvailable(100);                      }                      else                      {                          // We read the response stream chunk by chunk (each chunk is 4KB).                           // After reading each chunk' we report the progress based on the total number bytes read so far.                          int totalReadSoFar = 0;                          buffer = new byte[length];                          while (totalReadSoFar < length)                          {                              int bytesRead = stream.Read(buffer' totalReadSoFar' Math.Min(length - totalReadSoFar' ChunkSize));                              if (bytesRead == 0)                              {                                  break;                              }                              else                              {                                  totalReadSoFar += bytesRead;                                  OnProgressAvailable((totalReadSoFar * 100) / length);                              }                          }                      }                  }              }
Magic Number,NuGet,HttpClient,C:\repos\monoman_NugetCracker\Nuget\src\Core\Http\HttpClient.cs,DownloadData,The following statement contains a magic number: using (var response = GetResponse())              {                  // Total response length                  int length = (int)response.ContentLength;                  using (Stream stream = response.GetResponseStream())                  {                      // in some circumstances' the Content-Length response header is missing' resulting in                      // the ContentLength = -1. In which case' we copy the whole stream and do not report progress.                      if (length < 0)                      {                          using (var memoryStream = new MemoryStream())                          {                              stream.CopyTo(memoryStream' ChunkSize);                              buffer = memoryStream.ToArray();                          }                            // reporting fake progress as 100%                          OnProgressAvailable(100);                      }                      else                      {                          // We read the response stream chunk by chunk (each chunk is 4KB).                           // After reading each chunk' we report the progress based on the total number bytes read so far.                          int totalReadSoFar = 0;                          buffer = new byte[length];                          while (totalReadSoFar < length)                          {                              int bytesRead = stream.Read(buffer' totalReadSoFar' Math.Min(length - totalReadSoFar' ChunkSize));                              if (bytesRead == 0)                              {                                  break;                              }                              else                              {                                  totalReadSoFar += bytesRead;                                  OnProgressAvailable((totalReadSoFar * 100) / length);                              }                          }                      }                  }              }
Magic Number,NuGet,ZipPackageAssemblyReference,C:\repos\monoman_NugetCracker\Nuget\src\Core\Packages\ZipPackageAssemblyReference.cs,ZipPackageAssemblyReference,The following statement contains a magic number: string path = Path.Substring(3).Trim(System.IO.Path.DirectorySeparatorChar);
Magic Number,NuGet,PackageRepositoryExtensions,C:\repos\monoman_NugetCracker\Nuget\src\Core\Repositories\PackageRepositoryExtensions.cs,FindPackages,The following statement contains a magic number: const int batchSize = 10;
Magic Number,NuGet,Crc32,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\Crc32.cs,Calculate,The following statement contains a magic number: while (--length >= 0)              {                  crc32 = crcTable[(crc32 ^ buffer[offset++]) & 0xFF] ^ (crc32 >> 8);              }
Magic Number,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,ParseFrameworkName,The following statement contains a magic number: if (parts.Length > 2)              {                  throw new ArgumentException(NuGetResources.InvalidFrameworkNameFormat' "frameworkName");              }
Magic Number,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,ParseFrameworkName,The following statement contains a magic number: if (Int32.TryParse(versionPart' out versionNumber))              {                  // Remove the extra numbers                  if (versionPart.Length > 4)                  {                      versionPart = versionPart.Substring(0' 4);                  }                    // Make sure it has at least 2 digits so it parses as a valid version                  versionPart = versionPart.PadRight(2' '0');                  versionPart = String.Join("."' versionPart.Select(ch => ch.ToString()));              }
Magic Number,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,ParseFrameworkName,The following statement contains a magic number: if (Int32.TryParse(versionPart' out versionNumber))              {                  // Remove the extra numbers                  if (versionPart.Length > 4)                  {                      versionPart = versionPart.Substring(0' 4);                  }                    // Make sure it has at least 2 digits so it parses as a valid version                  versionPart = versionPart.PadRight(2' '0');                  versionPart = String.Join("."' versionPart.Select(ch => ch.ToString()));              }
Magic Number,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,ParseFrameworkName,The following statement contains a magic number: if (Int32.TryParse(versionPart' out versionNumber))              {                  // Remove the extra numbers                  if (versionPart.Length > 4)                  {                      versionPart = versionPart.Substring(0' 4);                  }                    // Make sure it has at least 2 digits so it parses as a valid version                  versionPart = versionPart.PadRight(2' '0');                  versionPart = String.Join("."' versionPart.Select(ch => ch.ToString()));              }
Magic Number,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,TryParseVersionSpec,The following statement contains a magic number: if (value.Length < 3)              {                  return false;              }
Magic Number,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,TryParseVersionSpec,The following statement contains a magic number: value = value.Substring(1' value.Length - 2);
Magic Number,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,TryParseVersionSpec,The following statement contains a magic number: if (parts.Length > 2)              {                  return false;              }              else if (parts.All(String.IsNullOrEmpty))              {                  // If all parts are empty' then neither of upper or lower bounds were specified. Version spec is of the format (']                  return false;              }
Magic Number,NuGet,VersionUtility,C:\repos\monoman_NugetCracker\Nuget\src\Core\Utility\VersionUtility.cs,TryParseVersionSpec,The following statement contains a magic number: string maxVersionString = (parts.Length == 2) ? parts[1] : parts[0];
Magic Number,NuGet.Analysis.Rules,InvalidFrameworkFolderRule,C:\repos\monoman_NugetCracker\Nuget\src\Core\Analysis\Rules\InvalidFrameworkFolderRule.cs,Validate,The following statement contains a magic number: foreach (var file in package.GetFiles())              {                  string path = file.Path;                  string[] parts = path.Split(Path.DirectorySeparatorChar);                  if (parts.Length >= 3 && parts[0].Equals(Constants.LibDirectory' StringComparison.OrdinalIgnoreCase))                  {                      set.Add(parts[1]);                  }              }
