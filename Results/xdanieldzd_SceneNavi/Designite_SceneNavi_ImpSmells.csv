Implementation smell,Namespace,Class,File,Method,Description
Long Method,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The method has 151 lines of code.
Long Method,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The method has 286 lines of code.
Long Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateSceneTree,The method has 79 lines of code.
Long Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openROMToolStripMenuItem_Click,The method has 69 lines of code.
Long Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RefreshCurrentData,The method has 132 lines of code.
Long Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,The method has 72 lines of code.
Long Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The method has 136 lines of code.
Long Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The method has 72 lines of code.
Long Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The method has 72 lines of code.
Long Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The method has 1688 lines of code.
Long Method,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeDataGridViews,The method has 82 lines of code.
Long Method,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The method has 130 lines of code.
Long Method,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The method has 72 lines of code.
Long Method,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The method has 74 lines of code.
Long Method,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The method has 113 lines of code.
Long Method,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The method has 107 lines of code.
Long Method,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The method has 89 lines of code.
Long Method,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The method has 76 lines of code.
Long Method,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The method has 88 lines of code.
Long Method,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,Convert,The method has 62 lines of code.
Long Method,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The method has 61 lines of code.
Long Method,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The method has 138 lines of code.
Long Method,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,PerformModeChanges,The method has 86 lines of code.
Long Method,SceneNavi.SimpleF3DEX2.CombinerEmulation,ArbCombineProgram,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\ArbCombineProgram.cs,ArbCombineProgram,The method has 405 lines of code.
Long Method,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The method has 346 lines of code.
Complex Method,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,Cyclomatic complexity of the method is 82
Complex Method,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,DrawGradient,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,DrawMarker,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorSlide,Cyclomatic complexity of the method is 13
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateSceneTree,Cyclomatic complexity of the method is 19
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,ParseStoreHeaders,Cyclomatic complexity of the method is 8
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateStatusString,Cyclomatic complexity of the method is 11
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RefreshCurrentData,Cyclomatic complexity of the method is 20
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,tvScenes_AfterSelect,Cyclomatic complexity of the method is 9
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,Cyclomatic complexity of the method is 11
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,Cyclomatic complexity of the method is 42
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderScene,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderMeshHeader,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,Cyclomatic complexity of the method is 25
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseDown,Cyclomatic complexity of the method is 15
Complex Method,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,Cyclomatic complexity of the method is 22
Complex Method,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeDataGridViews,Cyclomatic complexity of the method is 11
Complex Method,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellFormatting,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,Cyclomatic complexity of the method is 13
Complex Method,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,DownloadRtfFile,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,Cyclomatic complexity of the method is 64
Complex Method,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,RefreshActorPositionRotation,Cyclomatic complexity of the method is 9
Complex Method,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,Cyclomatic complexity of the method is 17
Complex Method,SceneNavi.Controls,HScrollBarEx,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\HScrollBarEx.cs,WndProc,Cyclomatic complexity of the method is 12
Complex Method,SceneNavi.Controls,ToolStripRadioButtonMenuItem,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\ToolStripRadioButtonMenuItem.cs,OnPaint,Cyclomatic complexity of the method is 9
Complex Method,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,Cyclomatic complexity of the method is 9
Complex Method,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,Cyclomatic complexity of the method is 12
Complex Method,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,CreateDisplayLists,Cyclomatic complexity of the method is 8
Complex Method,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderCube,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,Cyclomatic complexity of the method is 10
Complex Method,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,Cyclomatic complexity of the method is 9
Complex Method,SceneNavi.OpenGLHelpers,Initialization,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Initialization.cs,CreateViewportAndProjection,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,Cyclomatic complexity of the method is 11
Complex Method,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,Cyclomatic complexity of the method is 25
Complex Method,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,Cyclomatic complexity of the method is 11
Complex Method,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,Cyclomatic complexity of the method is 13
Complex Method,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindCodeFile,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,Cyclomatic complexity of the method is 10
Complex Method,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,Cyclomatic complexity of the method is 8
Complex Method,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,Cyclomatic complexity of the method is 10
Complex Method,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,Convert,Cyclomatic complexity of the method is 35
Complex Method,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,Cyclomatic complexity of the method is 17
Complex Method,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,Cyclomatic complexity of the method is 11
Complex Method,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,LoadTextures,Cyclomatic complexity of the method is 12
Complex Method,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,LoadTexture,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,Cyclomatic complexity of the method is 72
Complex Method,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,PerformModeChanges,Cyclomatic complexity of the method is 35
Complex Method,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,Cyclomatic complexity of the method is 7
Complex Method,SceneNavi.SimpleF3DEX2.CombinerEmulation,ArbCombineProgram,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\ArbCombineProgram.cs,ArbCombineProgram,Cyclomatic complexity of the method is 307
Complex Method,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,Cyclomatic complexity of the method is 264
Long Parameter List,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,MIPSEvaluator,The method has 5 parameters.
Long Parameter List,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ScaleRange,The method has 5 parameters.
Long Parameter List,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,Scale,The method has 5 parameters.
Long Parameter List,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,Scale,The method has 5 parameters.
Long Parameter List,SceneNavi,GUIHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\GUIHelpers.cs,LoadString,The method has 4 parameters.
Long Parameter List,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The method has 5 parameters.
Long Parameter List,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,ChangeBitInActor,The method has 4 parameters.
Long Parameter List,SceneNavi.Controls,ToolStripHintMenuItem,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\ToolStripHintMenuItem.cs,ToolStripHintMenuItem,The method has 4 parameters.
Long Parameter List,SceneNavi.Controls,ToolStripHintMenuItem,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\ToolStripHintMenuItem.cs,ToolStripHintMenuItem,The method has 4 parameters.
Long Parameter List,SceneNavi.Controls,ToolStripRadioButtonMenuItem,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\ToolStripRadioButtonMenuItem.cs,ToolStripRadioButtonMenuItem,The method has 4 parameters.
Long Parameter List,SceneNavi.Controls,ToolStripRadioButtonMenuItem,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\ToolStripRadioButtonMenuItem.cs,ToolStripRadioButtonMenuItem,The method has 4 parameters.
Long Parameter List,SceneNavi.HeaderCommands,Generic,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Generic.cs,Generic,The method has 4 parameters.
Long Parameter List,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The method has 4 parameters.
Long Parameter List,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,WorldToScreen,The method has 4 parameters.
Long Parameter List,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,ScreenToWorld,The method has 4 parameters.
Long Parameter List,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,UnProject,The method has 4 parameters.
Long Parameter List,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,Project,The method has 5 parameters.
Long Parameter List,SceneNavi.OpenGLHelpers,Initialization,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Initialization.cs,CreateViewportAndProjection,The method has 4 parameters.
Long Parameter List,SceneNavi.ROMHandler,HeaderLoader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\HeaderLoader.cs,HeaderLoader,The method has 5 parameters.
Long Parameter List,SceneNavi.ROMHandler,ObjectTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ObjectTableEntry.cs,ObjectTableEntry,The method has 4 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The method has 6 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The method has 8 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The method has 7 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The method has 6 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The method has 6 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The method has 6 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The method has 6 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The method has 6 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,Convert,The method has 9 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The method has 4 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The method has 4 parameters.
Long Parameter List,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,CreateShaders,The method has 5 parameters.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,DrawGradient,The length of the statement  "	using (LinearGradientBrush lgb = new LinearGradientBrush (e.ClipRectangle' startColor' gradientColor' LinearGradientMode.Horizontal)) { " is 135.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,DrawMarker,The length of the statement  "	using (Pen pen = new Pen ((colorComponent == ColorComponents.Alpha ? Color.Black : Color.FromArgb ((-orgValue + 255)' (-orgValue + 255)' (-orgValue + 255)))' 4.0f)) { " is 166.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 144.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 148.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.nudRed.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 142.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.nudGreen.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 144.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.nudBlue.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 143.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.nudAlpha.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 144.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.pbColorGradientAlpha.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 199.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.pbColorGradientAlpha.MouseDown += new System.Windows.Forms.MouseEventHandler (this.pbColorGradientAlpha_MouseDown); " is 120.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.pbColorGradientAlpha.MouseMove += new System.Windows.Forms.MouseEventHandler (this.pbColorGradientAlpha_MouseMove); " is 120.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.pbPreview.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 188.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.pbColorGradientBlue.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 198.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.pbColorGradientGreen.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 199.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.pbColorGradientGreen.MouseDown += new System.Windows.Forms.MouseEventHandler (this.pbColorGradientGreen_MouseDown); " is 120.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.pbColorGradientGreen.MouseMove += new System.Windows.Forms.MouseEventHandler (this.pbColorGradientGreen_MouseMove); " is 120.
Long Statement,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The length of the statement  "	this.pbColorGradientRed.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 197.
Long Statement,SceneNavi,Configuration,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Configuration.cs,PrepareConfig,The length of the statement  "	configPath = Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData)' System.Windows.Forms.Application.ProductName); " is 144.
Long Statement,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,FlattenMenu,The length of the statement  "	return coll.OfType<Controls.ToolStripHintMenuItem> ().Concat (coll.OfType<Controls.ToolStripHintMenuItem> ().SelectMany (x => FlattenMenu (x.DropDownItems))); " is 158.
Long Statement,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,SetCommonImageFilter,The length of the statement  "		separateFilters.Add (string.Format ("{0} Files ({1})|{1}"' codec.FormatDescription' codec.FilenameExtension.ToLowerInvariant ())); " is 130.
Long Statement,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,SetCommonImageFilter,The length of the statement  "	fileDialog.Filter = string.Format ("{0}|Image Files ({1})|{1}|All Files (*.*)|*.*"' string.Join ("|"' separateFilters)' imageExtensions.ToLowerInvariant ()); " is 157.
Long Statement,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,SetCommonImageFilter,The length of the statement  "		fileDialog.FilterIndex = (codecs.IndexOf (codecs.FirstOrDefault (x => x.FormatDescription.ToLowerInvariant ().Contains (defaultExtension.ToLowerInvariant ()))) + 1); " is 165.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,SetFormTitle,The length of the statement  "	string filenamePart = ((rom != null && rom.Loaded) ? string.Format (" - [{0}]"' Path.GetFileName (rom.Filename)) : string.Empty); " is 129.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,SetFormTitle,The length of the statement  "	string scenePart = (individualFileMode ? string.Format (" ({0})"' Path.GetFileName (Configuration.LastSceneFile)) : string.Empty); " is 130.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,Application_Idle,The length of the statement  "		bsiCamCoords.Text = string.Format (System.Globalization.CultureInfo.InvariantCulture' "Cam X: {0:00.000}' Y: {1:00.000}' Z: {2:00.000}"' camera.Pos.X' camera.Pos.Y' camera.Pos.Z); " is 179.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeMenuHelp,The length of the statement  "	/* Kinda buggy in practice (ex. with disabled menu items...) */foreach (SceneNavi.Controls.ToolStripHintMenuItem menuItem in menuStrip1.Items.FlattenMenu ().ToList ()) { " is 169.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateSceneTree,The length of the statement  "		root = new TreeNode (string.Format ("{0} ({1}' v1.{2}; {3} scenes)"' rom.Title' rom.GameID' rom.Version' rom.Scenes.Count)) { " is 125.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateSceneTree,The length of the statement  "				HeaderCommands.Rooms rooms = ste.GetSceneHeaders () [0].Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms; " is 158.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateSceneTree,The length of the statement  "					TreeNode sheadnode = new TreeNode ((de.Value == null ? string.Format ("Stage #{0}"' shead.Number) : (string)de.Value)) { " is 120.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateSceneTree,The length of the statement  "		HeaderCommands.Rooms rooms = tempScene.GetSceneHeaders () [0].Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms; " is 164.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openROMToolStripMenuItem_Click,The length of the statement  "                                //if (!((cmd.Data >> 56) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) && !(cmd is HeaderCommands.Actors) && !(cmd is HeaderCommands.Collision) &&" is 149.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openROMToolStripMenuItem_Click,The length of the statement  "                                //    !(cmd is HeaderCommands.MeshHeader) && !(cmd is HeaderCommands.Objects) && !(cmd is HeaderCommands.Rooms) && !(cmd is HeaderCommands.SpecialObjects) &&" is 157.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openROMToolStripMenuItem_Click,The length of the statement  "                                        //if (!((cmd.Data >> 56) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) && !(cmd is HeaderCommands.Actors) && !(cmd is HeaderCommands.Collision) &&" is 149.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openROMToolStripMenuItem_Click,The length of the statement  "                                        //    !(cmd is HeaderCommands.MeshHeader) && !(cmd is HeaderCommands.Objects) && !(cmd is HeaderCommands.Rooms) && !(cmd is HeaderCommands.SpecialObjects) &&" is 157.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openROMToolStripMenuItem_Click,The length of the statement  "		editDataTablesToolStripMenuItem.Enabled = saveToolStripMenuItem.Enabled = openSceneToolStripMenuItem.Enabled = rOMInformationToolStripMenuItem.Enabled = customGLControl.Enabled = rom.Loaded; " is 190.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openSceneToolStripMenuItem_Click,The length of the statement  "		if ((tempScene = (!rom.IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (rom' ofdOpenScene.FileName) : (ISceneTableEntry)new SceneTableEntryMajora (rom' ofdOpenScene.FileName))) != null) { " is 195.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,SaveAllData,The length of the statement  "		BinaryWriter bwScene = new BinaryWriter (File.Open (Configuration.LastSceneFile' FileMode.Open' FileAccess.ReadWrite' FileShare.ReadWrite)); " is 140.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,SaveAllData,The length of the statement  "		BinaryWriter bwRoom = new BinaryWriter (File.Open (Configuration.LastRoomFile' FileMode.Open' FileAccess.ReadWrite' FileShare.ReadWrite)); " is 138.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,SaveAllData,The length of the statement  "		/* Write to file */BinaryWriter bw = new BinaryWriter (File.Open (rom.Filename' FileMode.Open' FileAccess.ReadWrite' FileShare.ReadWrite)); " is 139.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,ParseStoreHeaders,The length of the statement  "			HeaderCommands.Rooms rooms = (hl.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms); " is 136.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,ParseStoreHeaders,The length of the statement  "		/* Now store all storeable commands */foreach (HeaderCommands.IStoreable hc in hl.Commands.Where (x => x is HeaderCommands.IStoreable)) " is 135.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateStatusString,The length of the statement  "			HeaderCommands.Rooms rooms = (currentScene.GetCurrentSceneHeader ().Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms); " is 171.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateStatusString,The length of the statement  "				infostrs.Add (string.Format ("{0} room{1}"' rooms.RoomInformation.Count' (rooms.RoomInformation.Count != 1 ? "s" : ""))); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateStatusString,The length of the statement  "		infostrs.Add (string.Format ("Ready{0}"' ((Configuration.ShownIntelWarning || Configuration.ShownExtensionWarning) ? " (limited combiner)" : string.Empty))); " is 157.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateStatusString,The length of the statement  "		infostrs.Add (string.Format ("{0} room actor{1}"' currentRoom.ActiveRoomActorData.ActorList.Count' (currentRoom.ActiveRoomActorData.ActorList.Count != 1 ? "s" : ""))); " is 167.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateStatusString,The length of the statement  "		infostrs.Add (string.Format ("{0} transition actor{1}"' currentScene.GetActiveTransitionData ().ActorList.Count' (currentScene.GetActiveTransitionData ().ActorList.Count != 1 ? "s" : ""))); " is 189.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateStatusString,The length of the statement  "		infostrs.Add (string.Format ("{0} spawn point{1}"' currentScene.GetActiveSpawnPointData ().ActorList.Count' (currentScene.GetActiveSpawnPointData ().ActorList.Count != 1 ? "s" : ""))); " is 184.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateStatusString,The length of the statement  "		infostrs.Add (string.Format ("{0} object{1}"' currentRoom.ActiveObjects.ObjectList.Count' (currentRoom.ActiveObjects.ObjectList.Count != 1 ? "s" : ""))); " is 153.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,CreateStatusString,The length of the statement  "		infostrs.Add (string.Format ("{0} path{1}"' currentScene.GetActiveWaypoints ().Paths.Count' (currentScene.GetActiveWaypoints ().Paths.Count != 1 ? "s" : ""))); " is 159.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RefreshCurrentData,The length of the statement  "			editAreaTitleCardToolStripMenuItem.Enabled = (!rom.IsMajora && steOcarina.LabelStartAddress != 0 && steOcarina.LabelEndAddress != 0); " is 133.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RefreshCurrentData,The length of the statement  "		HeaderCommands.Rooms rooms = (currentScene.GetCurrentSceneHeader ().Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms); " is 171.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RefreshCurrentData,The length of the statement  "					allMeshHeaders.Add (hl.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.MeshHeader) as HeaderCommands.MeshHeader); " is 136.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RefreshCurrentData,The length of the statement  "		cbCollisionPolys.Enabled = cbCollisionPolyTypes.Enabled = txtColPolyRawData.Enabled = nudColPolyType.Enabled = cbColPolyGroundTypes.Enabled = false; " is 148.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RefreshCurrentData,The length of the statement  "	if (currentScene != null && currentScene.GetActiveCollision () != null && currentScene.GetActiveCollision ().Waterboxes.Count > 0) { " is 132.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvObjects_CellParsing,The length of the statement  "			if (ushort.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) { " is 222.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,propertiesToolStripMenuItem_Click,The length of the statement  "		MessageBox.Show (string.Format ("Filename: {0}\nROM location: 0x{1:X} - 0x{2:X}\nScene headers: {3} headers"' ste.GetDMAFilename ()' ste.GetSceneStartAddress ()' ste.GetSceneEndAddress ()' ste.GetSceneHeaders ().Count)' "Scene Information"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 291.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,propertiesToolStripMenuItem_Click,The length of the statement  "		MessageBox.Show (string.Format ("Stage: {0}\nScene header: #{1} (0x{2:X})\n"' hp.Description' hp.SceneHeader.Number' hp.SceneHeader.Offset)' "Stage Information"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 212.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,propertiesToolStripMenuItem_Click,The length of the statement  "		MessageBox.Show (string.Format ("Filename: {0}\nROM location: 0x{1:X} - 0x{2:X}\nRoom headers: {3} headers"' ric.DMAFilename' ric.Start' ric.End' ric.Headers.Count)' "Room Information"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 236.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,The length of the statement  "	// ex.    bool hasActiveTexture = ((GraphicsContext.CurrentContext as IGraphicsContextInternal).GetAddress("glActiveTexture") != IntPtr.Zero); " is 142.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,The length of the statement  "	// might help with intel support? at least on more modern intel chipsets? dunno' whatever' might be something to do for the future " is 130.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,The length of the statement  "	/* Check for those damn Intel chips and their shitty drivers(?)' then disable combiner emulation if found. I'm sick of bug reports I can't fix because Intel is dumb. *//*if (Initialization.VendorIsIntel)" is 203.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,The length of the statement  "                        "Your graphics hardware has been detected as being Intel-based. Because of known problems with Intel hardware and proper OpenGL support' " +" is 140.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,The length of the statement  "                        "combiner emulation has been disabled and correct graphics rendering cannot be guaranteed."' "Intel Warning"' MessageBoxButtons.OK' MessageBoxIcon.Warning);" is 156.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,The length of the statement  "            *//* With Intel out of the way' check if all necessary GL extensions etc. are supported */supportsCreateShader = Initialization.SupportsFunction ("glCreateShader"); " is 164.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,The length of the statement  "		extErrorMessages.AppendLine ("Multitexturing is not supported. Combiner emulation has been disabled and correct graphics rendering cannot be guaranteed."); " is 155.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,StartupExtensionChecks,The length of the statement  "				sb.AppendFormat ("The following OpenGL Extension{0} not supported by your hardware:\n"' ((extMissAll.Count - 1) > 0 ? "s are" : " is")); " is 136.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,DisableCombiner,The length of the statement  "	if ((arb && currentCombinerType == CombinerTypes.ArbCombiner) || (glsl && currentCombinerType == CombinerTypes.GLSLCombiner)) " is 125.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,DisableCombiner,The length of the statement  "		if (tsmi.Tag is CombinerTypes && ((((CombinerTypes)tsmi.Tag) == CombinerTypes.ArbCombiner && arb) || (((CombinerTypes)tsmi.Tag) == CombinerTypes.GLSLCombiner && glsl))) { " is 170.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "						ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal); " is 193.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "				/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null) " is 129.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "						ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal); " is 203.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "				/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null) " is 128.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "						ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal); " is 203.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "				/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) { " is 123.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "					HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null); " is 191.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "						wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal); " is 149.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "						double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5); " is 156.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The length of the statement  "						double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5); " is 156.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderInit,The length of the statement  "	Initialization.CreateViewportAndProjection (Initialization.ProjectionTypes.Perspective' rect' 0.001f' (currentEnvSettings != null ? ((float)currentEnvSettings.DrawDistance / 50.0f) : 300.0f)); " is 192.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderScene,The length of the statement  "		/* Render all rooms */foreach (HeaderCommands.Rooms.RoomInfoClass ric in (currentScene.GetCurrentSceneHeader ().Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms).RoomInformation) { " is 233.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderScene,The length of the statement  "			HeaderCommands.MeshHeader mh = (ric.Headers [0].Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.MeshHeader) as HeaderCommands.MeshHeader); " is 161.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderMeshHeader,The length of the statement  "	if (mh.DLs == null || displayListsDirty || mh.CachedWithTextures != Configuration.RenderTextures || mh.CachedWithCombinerType != Configuration.CombinerType) { " is 158.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderTextOverlay,The length of the statement  "		glText.Print (string.Format (System.Globalization.CultureInfo.InvariantCulture' "{0:0.00} FPS"' fpsMonitor.Value)' new Vector2d (10.0' 10.0)' Color.FromArgb (128' Color.Black)); " is 177.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "	/* Room model triangles */if (currentRoom != null && currentRoom.ActiveMeshHeader != null && !Configuration.RenderCollision && currentRoom.ActiveMeshHeader.DLs.Count > 0 && currentRoom.ActiveMeshHeader.DLs [0].Triangles.Count > 0) { " is 232.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "	/* Rooms */if (allMeshHeaders != null && currentRoom == null && !Configuration.RenderCollision && allMeshHeaders.Count > 0 && allMeshHeaders [0].IsMoveable == moveable) " is 168.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "	/* Room actors */if (currentRoom != null && currentRoom.ActiveRoomActorData != null && Configuration.RenderRoomActors && currentRoom.ActiveRoomActorData.ActorList.Count > 0 && currentRoom.ActiveRoomActorData.ActorList [0].IsMoveable == moveable) " is 245.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "	/* Spawn points */if (currentScene.GetActiveSpawnPointData () != null && Configuration.RenderSpawnPoints && currentScene.GetActiveSpawnPointData ().ActorList.Count > 0 && currentScene.GetActiveSpawnPointData ().ActorList [0].IsMoveable == moveable) " is 248.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "	/* Transition actors */if (currentScene.GetActiveTransitionData () != null && Configuration.RenderTransitions && currentScene.GetActiveTransitionData ().ActorList.Count > 0 && currentScene.GetActiveTransitionData ().ActorList [0].IsMoveable == moveable) " is 253.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "	/* Waypoints */if (activePathHeader != null && activePathHeader.Points != null && Configuration.RenderPathWaypoints && activePathHeader.Points.Count > 0 && activePathHeader.Points [0].IsMoveable == moveable) " is 207.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "	/* Waterboxes */if (currentScene.GetActiveCollision () != null && Configuration.RenderWaterboxes && currentScene.GetActiveCollision ().Waterboxes.Count > 0 && currentScene.GetActiveCollision ().Waterboxes [0].IsMoveable == moveable) " is 232.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "	/* Collision polygons */if (currentScene.GetActiveCollision () != null && Configuration.RenderCollision && currentScene.GetActiveCollision ().Polygons.Count > 0 && currentScene.GetActiveCollision ().Polygons [0].IsMoveable == moveable) " is 235.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "			DataGridViewRow row = dgvPathWaypoints.Rows.OfType<DataGridViewRow> ().FirstOrDefault (xx => xx.DataBoundItem == picked as HeaderCommands.Waypoints.Waypoint); " is 158.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The length of the statement  "			tvScenes.SelectedNode = tvScenes.FlattenTree ().FirstOrDefault (xx => xx.Tag == ((picked as HeaderCommands.MeshHeader).Parent as HeaderCommands.Rooms.RoomInfoClass) && (xx.Parent.Tag as HeaderLoader.HeaderPair).SceneHeader.Number == currentScene.GetCurrentSceneHeader ().Number); " is 279.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseDown,The length of the statement  "		/* Object picking */if (Convert.ToBoolean (camera.ButtonsDown & MouseButtons.Left) || Convert.ToBoolean (camera.ButtonsDown & MouseButtons.Middle)) { " is 149.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseDown,The length of the statement  "						/* Determine what menu entries should be enabled */xAxisToolStripMenuItem.Enabled = !(ac.Definition.Items.FirstOrDefault (x => x.Usage == XMLActorDefinitionReader.Definition.Item.Usages.RotationX) == null); " is 206.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseDown,The length of the statement  "						yAxisToolStripMenuItem.Enabled = !(ac.Definition.Items.FirstOrDefault (x => x.Usage == XMLActorDefinitionReader.Definition.Item.Usages.RotationY) == null); " is 155.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseDown,The length of the statement  "						zAxisToolStripMenuItem.Enabled = !(ac.Definition.Items.FirstOrDefault (x => x.Usage == XMLActorDefinitionReader.Definition.Item.Usages.RotationZ) == null); " is 155.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseDown,The length of the statement  "						rotateToolStripMenuItem.Enabled = (xAxisToolStripMenuItem.Enabled || yAxisToolStripMenuItem.Enabled || zAxisToolStripMenuItem.Enabled); " is 135.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The length of the statement  "			if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) { " is 149.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The length of the statement  "				/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y)); " is 133.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The length of the statement  "	ColorPickerDialog cdlg = new ColorPickerDialog (Color.FromArgb (vertex.Colors [3]' vertex.Colors [0]' vertex.Colors [1]' vertex.Colors [2])); " is 141.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The length of the statement  "		// KLUDGE! Write to local room data HERE for rendering' write to ROM in SimpleF3DEX2.Vertex' the vertex.Store(...) below " is 120.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,cbTransitions_SelectedIndexChanged,The length of the statement  "		rooms = currentScene.GetCurrentSceneHeader ().Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms; " is 148.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvPathWaypoints_RowPostPaint,The length of the statement  "		e.Graphics.DrawString ((e.RowIndex + 1).ToString ()' e.InheritedRowStyle.Font' b' e.RowBounds.Location.X + 18' e.RowBounds.Location.Y + 4); " is 139.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvPathWaypoints_SelectionChanged,The length of the statement  "	HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null); " is 191.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,btnJumpToPolyType_Click,The length of the statement  "		cbCollisionPolyTypes.SelectedItem = (colPolyTypeDataBinding.List as List<HeaderCommands.Collision.PolygonType>).FirstOrDefault (x => x.Number == currentCollisionPolygon.PolygonType); " is 182.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RefreshColPolyTypeControls,The length of the statement  "	cbColPolyGroundTypes.SelectedItem = HeaderCommands.Collision.PolygonType.GroundTypes.FirstOrDefault (x => x.Value == currentColPolygonType.GroundTypeID); " is 153.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,txtColPolyRawData_TextChanged,The length of the statement  "	System.Globalization.NumberStyles ns = (txt.Text.StartsWith ("0x") ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer); " is 158.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,cbColPolyGroundTypes_SelectedIndexChanged,The length of the statement  "	currentColPolygonType.GroundTypeID = (((ComboBox)sender).SelectedItem as HeaderCommands.Collision.PolygonType.GroundType).Value; " is 128.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,cbWaterboxes_SelectedIndexChanged,The length of the statement  "		txtWaterboxPositionX.Enabled = txtWaterboxPositionY.Enabled = txtWaterboxPositionZ.Enabled = txtWaterboxSizeX.Enabled = txtWaterboxSizeZ.Enabled = txtWaterboxProperties.Enabled = !currentWaterbox.IsDummy; " is 204.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,ModifyCurrentWaterbox,The length of the statement  "		currentWaterbox.Position = new Vector3d (double.Parse (txtWaterboxPositionX.Text)' double.Parse (txtWaterboxPositionY.Text)' double.Parse (txtWaterboxPositionZ.Text)); " is 167.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,ModifyCurrentWaterbox,The length of the statement  "		currentWaterbox.RoomNumber = (ushort)(cbWaterboxRoom.SelectedItem as XMLActorDefinitionReader.Definition.Item.Option).Value; " is 124.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,ModifyCurrentWaterbox,The length of the statement  "			currentWaterbox.Properties = ushort.Parse (txtWaterboxProperties.Text.Substring (2)' System.Globalization.NumberStyles.HexNumber); " is 130.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,propertiesToolStripMenuItem1_Click,The length of the statement  "	vertexInfo.AppendFormat ("Colors: ({0}' {1}' {2}' {3})\n"' currentRoomVertex.Colors [0]' currentRoomVertex.Colors [1]' currentRoomVertex.Colors [2]' currentRoomVertex.Colors [3]); " is 179.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,propertiesToolStripMenuItem1_Click,The length of the statement  "	vertexInfo.AppendFormat ("Normals: ({0}' {1}' {2})\n"' currentRoomVertex.Normals [0]' currentRoomVertex.Normals [1]' currentRoomVertex.Normals [2]); " is 148.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,enableAntiAliasingToolStripMenuItem_Click,The length of the statement  "	if (MessageBox.Show (string.Format ("{0}abling anti-aliasing requires restarting SceneNavi.\n\nDo you want to restart the program now?"' (Configuration.EnableAntiAliasing ? "En" : "Dis"))' "Question"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == System.Windows.Forms.DialogResult.Yes) { " is 294.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,enableMipmapsToolStripMenuItem_Click,The length of the statement  "	/* Destroy' destroy! Kill all the display lists! ...or should I say "Exterminate!"? Then again' I'm not a Doctor Who fan... */foreach (HeaderLoader sh in rom.Scenes.SelectMany (x => x.GetSceneHeaders ())) { " is 206.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,enableMipmapsToolStripMenuItem_Click,The length of the statement  "		HeaderCommands.Rooms rooms = (sh.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms)) as HeaderCommands.Rooms; " is 136.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,enableMipmapsToolStripMenuItem_Click,The length of the statement  "			HeaderCommands.MeshHeader mh = (rh.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.MeshHeader)) as HeaderCommands.MeshHeader; " is 148.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,rOMInformationToolStripMenuItem_Click,The length of the statement  "	string info = string.Format (System.Globalization.CultureInfo.InvariantCulture' "{0} ({1}' v1.{2})' {3} MB ({4} Mbit)\n{5}\nCreated by {6}' built on {7:F}\n\nCode file at 0x{8:X} - 0x{9:X} ({10})\n- DMA table address: 0x{11:X}\n- File name table address: {12}\n" + "- Scene table address: {13}\n- Actor table address: {14}\n- Object table address: {15}\n- Entrance table address: {16}"' rom.Title' rom.GameID' rom.Version' (rom.Size / 0x100000)' (rom.Size / 0x20000)' (rom.HasZ64TablesHack ? "(uses 'z64tables' extended tables)\n" : "")' rom.Creator' rom.BuildDate' rom.Code.PStart' (rom.Code.IsCompressed ? rom.Code.PEnd : rom.Code.VEnd)' (rom.Code.IsCompressed ? "compressed" : "uncompressed")' rom.DMATableAddress' (rom.HasFileNameTable ? ("0x" + rom.FileNameTableAddress.ToString ("X")) : "none")' (rom.HasZ64TablesHack ? ("0x" + rom.SceneTableAddress.ToString ("X") + " (in ROM)") : ("0x" + rom.SceneTableAddress.ToString ("X")))' (rom.HasZ64TablesHack ? ("0x" + rom.ActorTableAddress.ToString ("X") + " (in ROM)") : ("0x" + rom.ActorTableAddress.ToString ("X")))' (rom.HasZ64TablesHack ? ("0x" + rom.ObjectTableAddress.ToString ("X") + " (in ROM)") : ("0x" + rom.ObjectTableAddress.ToString ("X")))' (rom.HasZ64TablesHack ? ("0x" + rom.EntranceTableAddress.ToString ("X") + " (in ROM)") : ("0x" + rom.EntranceTableAddress.ToString ("X")))); " is 1346.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openGLInformationToolStripMenuItem_Click,The length of the statement  "		oglInfoString.AppendFormat ("* {0}\t{1}\n"' extension.PadRight (40)' Initialization.CheckForExtension (extension) ? "supported" : "not supported"); " is 147.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,aboutToolStripMenuItem_Click,The length of the statement  "	string buildString = string.Format ("(Build: {0})"' linkerTimestamp.ToString ("MM/dd/yyyy HH:mm:ss UTCzzz"' System.Globalization.CultureInfo.InvariantCulture)); " is 160.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,aboutToolStripMenuItem_Click,The length of the statement  "	string yearString = (linkerTimestamp.Year == 2013 ? "2013" : string.Format ("2013-{0}"' linkerTimestamp.ToString ("yyyy"))); " is 124.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,aboutToolStripMenuItem_Click,The length of the statement  "	MessageBox.Show (string.Format ("{0} {1}\n\nScene/room actor editor for The Legend of Zelda: Ocarina of Time\n\nWritten {2} by xdaniel / http://magicstone.de/dzd/"' Program.AppNameVer' buildString' yearString)' string.Format ("About {0}"' Application.ProductName)' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 315.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager (typeof(MainForm)); " is 129.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.openROMToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O))); " is 142.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.saveToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.S))); " is 139.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.rOMInformationToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.I))); " is 149.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.editAreaTitleCardToolStripMenuItem.Click += new System.EventHandler (this.editAreaTitleCardToolStripMenuItem_Click); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.resetCameraPositionToolStripMenuItem.Click += new System.EventHandler (this.resetCameraPositionToolStripMenuItem_Click); " is 125.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.renderSpawnPointsToolStripMenuItem.Click += new System.EventHandler (this.renderSpawnPointsToolStripMenuItem_Click); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.renderTransitionsToolStripMenuItem.Click += new System.EventHandler (this.renderTransitionsToolStripMenuItem_Click); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.renderPathWaypointsToolStripMenuItem.Click += new System.EventHandler (this.renderPathWaypointsToolStripMenuItem_Click); " is 125.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.linkAllWaypointsInPathToolStripMenuItem.Click += new System.EventHandler (this.linkAllWaypointsInPathToolStripMenuItem_Click); " is 131.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.showWaterboxesPerRoomToolStripMenuItem.Click += new System.EventHandler (this.showWaterboxesPerRoomToolStripMenuItem_Click); " is 129.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.enableAntiAliasingToolStripMenuItem.Click += new System.EventHandler (this.enableAntiAliasingToolStripMenuItem_Click); " is 123.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.openGLInformationToolStripMenuItem.Click += new System.EventHandler (this.openGLInformationToolStripMenuItem_Click); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExSceneMeta.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 30F)); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExSceneMeta.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 20F)); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExSceneMeta.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 30F)); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExSceneMeta.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 20F)); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExRoomActors.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 35F)); " is 122.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExRoomActors.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 65F)); " is 122.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tableLayoutPanel1.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 40F)); " is 124.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tableLayoutPanel1.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 60F)); " is 124.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.dgvObjects.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler (this.dgvObjects_CellFormatting); " is 131.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.dgvObjects.CellParsing += new System.Windows.Forms.DataGridViewCellParsingEventHandler (this.dgvObjects_CellParsing); " is 122.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.dgvObjects.EditingControlShowing += new System.Windows.Forms.DataGridViewEditingControlShowingEventHandler (this.dgvObjects_EditingControlShowing); " is 152.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExSpawnPoints.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 35F)); " is 123.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExSpawnPoints.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 65F)); " is 123.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExTransitions.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 35F)); " is 123.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExTransitions.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 65F)); " is 123.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tableLayoutPanel2.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 100F)); " is 125.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tableLayoutPanel2.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Absolute' 20F)); " is 125.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.dgvPathWaypoints.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize; " is 122.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.dgvPathWaypoints.RowHeadersWidthSizeMode = System.Windows.Forms.DataGridViewRowHeadersWidthSizeMode.AutoSizeToAllHeaders; " is 126.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.dgvPathWaypoints.RowPostPaint += new System.Windows.Forms.DataGridViewRowPostPaintEventHandler (this.dgvPathWaypoints_RowPostPaint); " is 137.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExCollision.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 40F)); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExCollision.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 60F)); " is 121.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.cbCollisionPolyTypes.SelectedIndexChanged += new System.EventHandler (this.cbCollisionPolyTypes_SelectedIndexChanged); " is 123.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.cbColPolyGroundTypes.SelectedIndexChanged += new System.EventHandler (this.cbColPolyGroundTypes_SelectedIndexChanged); " is 123.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.txtColPolyRawData.Font = new System.Drawing.Font ("Courier New"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 156.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExWaterboxes.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 35F)); " is 122.
Long Statement,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The length of the statement  "	this.tlpExWaterboxes.ColumnStyles.Add (new System.Windows.Forms.ColumnStyle (System.Windows.Forms.SizeType.Percent' 65F)); " is 122.
Long Statement,SceneNavi,Program,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Program.cs,Main,The length of the statement  "                MessageBox.Show("Critical error occured: " + ex.GetType().FullName + " - " + ex.Message + "\nTarget site: " + ex.TargetSite' "Exception"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);" is 188.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeDataGridViews,The length of the statement  "	dgvEntranceTable.Columns ["SceneNumber"].ToolTipText = typeof(ROMHandler.EntranceTableEntry).GetDescription ("SceneNumber"); " is 124.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeDataGridViews,The length of the statement  "	dgvEntranceTable.Columns ["EntranceNumber"].ToolTipText = typeof(ROMHandler.EntranceTableEntry).GetDescription ("EntranceNumber"); " is 130.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeDataGridViews,The length of the statement  "		dgvSceneTable.Columns ["LabelStartAddress"].ToolTipText = typeof(ROMHandler.SceneTableEntryOcarina).GetDescription ("LabelStartAddress"); " is 137.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeDataGridViews,The length of the statement  "		dgvSceneTable.Columns ["LabelEndAddress"].ToolTipText = typeof(ROMHandler.SceneTableEntryOcarina).GetDescription ("LabelEndAddress"); " is 133.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeDataGridViews,The length of the statement  "		dgvSceneTable.Columns ["ConfigurationNo"].ToolTipText = typeof(ROMHandler.SceneTableEntryOcarina).GetDescription ("ConfigurationNo"); " is 133.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeDataGridViews,The length of the statement  "		dgvSceneTable.Columns ["PresumedPadding"].ToolTipText = typeof(ROMHandler.SceneTableEntryMajora).GetDescription ("PresumedPadding"); " is 132.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellFormatting,The length of the statement  "	if (dgv.Columns [e.ColumnIndex].Name == "Number" || dgv.Columns [e.ColumnIndex].Name == "SceneNumber" || dgv.Columns [e.ColumnIndex].Name == "EntranceNumber" || dgv.Columns [e.ColumnIndex].Name == "Variable" || dgv.Columns [e.ColumnIndex].Name == "Fade") { " is 256.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellFormatting,The length of the statement  "				e.Value = (dgv.Columns [e.ColumnIndex].Name == "Number" ? string.Format ("0x{0:X4}"' e.Value) : string.Format ("0x{0:X2}"' e.Value)); " is 133.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellParsing,The length of the statement  "	if (dgv.Columns [e.ColumnIndex].Name == "SceneNumber" || dgv.Columns [e.ColumnIndex].Name == "EntranceNumber" || dgv.Columns [e.ColumnIndex].Name == "Variable" || dgv.Columns [e.ColumnIndex].Name == "Fade") { " is 208.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellParsing,The length of the statement  "			if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) { " is 220.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellFormatting,The length of the statement  "	if (dgv.Columns [e.ColumnIndex].Name == "Number" || dgv.Columns [e.ColumnIndex].Name == "LabelStartAddress" || dgv.Columns [e.ColumnIndex].Name == "LabelEndAddress" || dgv.Columns [e.ColumnIndex].Name == "Unknown1" || dgv.Columns [e.ColumnIndex].Name == "ConfigurationNo" || dgv.Columns [e.ColumnIndex].Name == "Unknown3" || dgv.Columns [e.ColumnIndex].Name == "Unknown4" || dgv.Columns [e.ColumnIndex].Name == "Unknown2" || dgv.Columns [e.ColumnIndex].Name == "PresumedPadding") { " is 481.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The length of the statement  "	if (dgv.Columns [e.ColumnIndex].Name == "LabelStartAddress" || dgv.Columns [e.ColumnIndex].Name == "LabelEndAddress" || dgv.Columns [e.ColumnIndex].Name == "Unknown1" || dgv.Columns [e.ColumnIndex].Name == "ConfigurationNo" || dgv.Columns [e.ColumnIndex].Name == "Unknown3" || dgv.Columns [e.ColumnIndex].Name == "Unknown4" || dgv.Columns [e.ColumnIndex].Name == "Unknown2" || dgv.Columns [e.ColumnIndex].Name == "PresumedPadding") { " is 433.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The length of the statement  "				if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) { " is 220.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The length of the statement  "				if (uint.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) { " is 220.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.dgvEntranceTable.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize; " is 122.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.dgvEntranceTable.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler (this.dgvEntranceTable_CellFormatting); " is 143.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.dgvEntranceTable.CellParsing += new System.Windows.Forms.DataGridViewCellParsingEventHandler (this.dgvEntranceTable_CellParsing); " is 134.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.dgvEntranceTable.DataError += new System.Windows.Forms.DataGridViewDataErrorEventHandler (this.dgvEntranceTable_DataError); " is 128.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.dgvEntranceTable.EditingControlShowing += new System.Windows.Forms.DataGridViewEditingControlShowingEventHandler (this.dgvEntranceTable_EditingControlShowing); " is 164.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.tabControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 235.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.dgvSceneTable.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler (this.dgvSceneTable_CellFormatting); " is 137.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.dgvSceneTable.CellParsing += new System.Windows.Forms.DataGridViewCellParsingEventHandler (this.dgvSceneTable_CellParsing); " is 128.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.dgvSceneTable.DataError += new System.Windows.Forms.DataGridViewDataErrorEventHandler (this.dgvSceneTable_DataError); " is 122.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.dgvSceneTable.EditingControlShowing += new System.Windows.Forms.DataGridViewEditingControlShowingEventHandler (this.dgvSceneTable_EditingControlShowing); " is 158.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.btnClose.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 185.
Long Statement,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The length of the statement  "	this.label1.Text = "Warning: Make sure you know what you\'re doing! Invalid values could potentially c" + "ause game crashes' and prevent SceneNavi from ex. recognizing a scene!"; " is 179.
Long Statement,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,ReadImageFromROM,The length of the statement  "	SimpleF3DEX2.ImageHelper.IA8 (titleCardWidth' titleCardHeight' (titleCardWidth / 8)' ROM.Data' (int)Scene.LabelStartAddress' ref textureBuffer); " is 144.
Long Statement,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,pbTitleCard_Paint,The length of the statement  "	e.Graphics.DrawImage (output' new Rectangle (outputRect.X' outputRect.Y' outputRect.Width * 2' outputRect.Height * 2)' outputRect' GraphicsUnit.Pixel); " is 151.
Long Statement,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,ImportImage,The length of the statement  "		MessageBox.Show ("Selected image has wrong size; image cannot be used."' "Error"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 126.
Long Statement,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The length of the statement  "	this.btnClose.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The length of the statement  "	this.btnExport.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 145.
Long Statement,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The length of the statement  "	this.btnImport.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 145.
Long Statement,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,The length of the statement  "				finalStatusMsg = string.Format ("New version {0} is available!"' VersionManagement.CreateVersionString (remoteVersion)); " is 120.
Long Statement,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,The length of the statement  "				finalStatusMsg = string.Format ("You are already using the most recent version {0}.\n"' VersionManagement.CreateVersionString (localVersion)); " is 142.
Long Statement,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,The length of the statement  "		/* Web access failed */MessageBox.Show (wex.ToString ()' "Web Exception"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 124.
Long Statement,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,The length of the statement  "		/* General failure */MessageBox.Show (ex.ToString ()' "General Exception"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 125.
Long Statement,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The length of the statement  "	this.btnClose.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The length of the statement  "	this.lblStatus.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 147.
Long Statement,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The length of the statement  "	this.btnDownload.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 150.
Long Statement,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The length of the statement  "	this.rlblChangelog.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 237.
Long Statement,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,RemoteFileExists,The length of the statement  "	/* Trying to prevent huge delay on first WebRequest; see also App.config *//* http://social.msdn.microsoft.com/Forums/en-US/ncl/thread/14844bfe-ad5b-4e5a-b6ef-4ff9a1a770f8/" is 172.
Long Statement,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,ThrowVersionError,The length of the statement  "	throw new XMLActorDefinitionReaderException (string.Format ("Program version mismatch; expected {0}' found {1}. Please make sure your XML folder is up-to-date."' Application.ProductVersion' ProgramVersion)); " is 207.
Long Statement,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,RefreshActorPositionRotation,The length of the statement  "			if (item.Usage == Definition.Item.Usages.PositionX || item.Usage == Definition.Item.Usages.PositionY || item.Usage == Definition.Item.Usages.PositionZ || item.Usage == Definition.Item.Usages.RotationX || item.Usage == Definition.Item.Usages.RotationY || item.Usage == Definition.Item.Usages.RotationZ) { " is 303.
Long Statement,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The length of the statement  "		/* UGLY HACK -> for room number in transition actor with individual file mode... */if (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront) " is 191.
Long Statement,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The length of the statement  "			if (!individual && (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront) && (tag is List<HeaderCommands.Rooms.RoomInfoClass>)) { " is 180.
Long Statement,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The length of the statement  "				/* Item usage is room number in transition actor; get room listing from function tag */item.Options = new List<Definition.Item.Option> (); " is 138.
Long Statement,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The length of the statement  "				item.ControlType.GetProperty ("SelectedItem").SetValue (ctrl' item.Options.Find (x => x.Value == (Convert.ToUInt64 (val) & item.Mask))' null); " is 142.
Long Statement,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The length of the statement  "						/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer); " is 228.
Long Statement,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The length of the statement  "						/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2) " is 124.
Long Statement,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The length of the statement  "						/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text); " is 170.
Long Statement,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,CreateDisplayLists,The length of the statement  "	Program.Status.Message = string.Format ("Rendering room '{0}'..."' (this.Parent as HeaderCommands.Rooms.RoomInfoClass).Description); " is 132.
Long Statement,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,CreateDisplayLists,The length of the statement  "	/* Execute DLs once before creating GL lists' to cache textures & fragment programs beforehand */foreach (uint dl in DLAddresses) " is 129.
Long Statement,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,CreateDisplayLists,The length of the statement  "	/* Copy most recently rendered triangles - this mesh header's DL's - to triangle list */TriangleList = new List<SimpleF3DEX2.SimpleTriangle> (); " is 144.
Long Statement,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,CreateDisplayLists,The length of the statement  "	/* Now execute DLs again' with stuff already cached' which speeds everything up! */DLs = new List<OpenGLHelpers.DisplayListEx> (); " is 130.
Long Statement,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,CreateDisplayLists,The length of the statement  "	/* Finally' from the triangle list compiled before' create a simple display list for picking purposes */PickGLID = GL.GenLists (1); " is 131.
Long Statement,SceneNavi.OpenGLHelpers,TextPrinter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\TextPrinter.cs,Begin,The length of the statement  "	Initialization.CreateViewportAndProjection (Initialization.ProjectionTypes.Orthographic' glControl.ClientRectangle' 0.0f' 300.0f); " is 130.
Long Statement,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,GetDisplayList,The length of the statement  "	System.Reflection.PropertyInfo propinfo = tp.GetProperty (prop' System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); " is 186.
Long Statement,SceneNavi.OpenGLHelpers,Initialization,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Initialization.cs,CreateViewportAndProjection,The length of the statement  "		projectionMatrix = Matrix4.CreateOrthographicOffCenter (clientRectangle.Left' clientRectangle.Right' clientRectangle.Bottom' clientRectangle.Top' near' far); " is 157.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,IsValid,The length of the statement  "	return ((sceneStartAddress < ROM.Size) && (sceneEndAddress < ROM.Size) && ((sceneStartAddress & 0xF) == 0) && ((sceneEndAddress & 0xF) == 0) && (sceneEndAddress > sceneStartAddress) && (PresumedPadding == 0)); " is 209.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,IsAllZero,The length of the statement  "	return (sceneStartAddress == 0) && (sceneEndAddress == 0) && (Unknown1 == 0) && (Unknown2 == 0) && (Unknown3 == 0) && (Unknown4 == 0) && (PresumedPadding == 0); " is 160.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,GetActiveTransitionData,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Transitions) as HeaderCommands.Actors); " is 173.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,GetActiveSpawnPointData,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Spawns) as HeaderCommands.Actors); " is 168.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,GetActiveSpecialObjs,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.SpecialObjects) as HeaderCommands.SpecialObjects); " is 184.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,GetActiveWaypoints,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Waypoints) as HeaderCommands.Waypoints); " is 174.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,GetActiveCollision,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision); " is 174.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,GetActiveSettingsSoundScene,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.SettingsSoundScene) as HeaderCommands.SettingsSoundScene); " is 192.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,GetActiveEnvSettings,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.EnvironmentSettings) as HeaderCommands.EnvironmentSettings); " is 194.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The length of the statement  "	if (data [0] == (byte)HeaderLoader.CommandTypeIDs.SettingsSoundScene || data [0] == (byte)HeaderLoader.CommandTypeIDs.Rooms || BitConverter.ToUInt32 (data' 0) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) { " is 209.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The length of the statement  "		rooms = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms; " is 120.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The length of the statement  "		coll = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision; " is 127.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The length of the statement  "				uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF))); " is 124.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The length of the statement  "					/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms); " is 128.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The length of the statement  "					/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision); " is 146.
Long Statement,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The length of the statement  "		/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) { " is 187.
Long Statement,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The length of the statement  "		/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) { " is 218.
Long Statement,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The length of the statement  "		/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4)))); " is 126.
Long Statement,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The length of the statement  "			if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) { " is 157.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,IsValid,The length of the statement  "	return (sceneStartAddress < ROM.Size) && (sceneEndAddress < ROM.Size) && (LabelStartAddress < ROM.Size) && (LabelEndAddress < ROM.Size) && ((sceneStartAddress & 0xF) == 0) && ((sceneEndAddress & 0xF) == 0) && ((LabelStartAddress & 0xF) == 0) && ((LabelEndAddress & 0xF) == 0) && (sceneEndAddress > sceneStartAddress) && (((LabelStartAddress != 0) && (LabelEndAddress != 0) && (LabelEndAddress > LabelStartAddress) && (LabelEndAddress == LabelStartAddress + 0x2880 || LabelEndAddress == LabelStartAddress + 0x1B00)) || (LabelStartAddress == 0 && LabelEndAddress == 0)); " is 568.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,GetActiveTransitionData,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Transitions) as HeaderCommands.Actors); " is 173.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,GetActiveSpawnPointData,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Spawns) as HeaderCommands.Actors); " is 168.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,GetActiveSpecialObjs,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.SpecialObjects) as HeaderCommands.SpecialObjects); " is 184.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,GetActiveWaypoints,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Waypoints) as HeaderCommands.Waypoints); " is 174.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,GetActiveCollision,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision); " is 174.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,GetActiveSettingsSoundScene,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.SettingsSoundScene) as HeaderCommands.SettingsSoundScene); " is 192.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,GetActiveEnvSettings,The length of the statement  "	return (currentSceneHeader == null ? null : currentSceneHeader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.EnvironmentSettings) as HeaderCommands.EnvironmentSettings); " is 194.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The length of the statement  "	if (data [0] == (byte)HeaderLoader.CommandTypeIDs.SettingsSoundScene || data [0] == (byte)HeaderLoader.CommandTypeIDs.Rooms || BitConverter.ToUInt32 (data' 0) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) { " is 209.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The length of the statement  "		rooms = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms; " is 120.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The length of the statement  "		coll = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision; " is 127.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The length of the statement  "				uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF))); " is 124.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The length of the statement  "					/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms); " is 128.
Long Statement,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The length of the statement  "					/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision); " is 146.
Long Statement,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The length of the statement  "		if ((address & 0xFFFFFF) > ((byte[])SegmentMapping [(byte)(address >> 24)]).Length && ((byte[])SegmentMapping [(byte)(address >> 24)]).Length != 0) " is 147.
Long Statement,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The length of the statement  "			ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true)); " is 162.
Long Statement,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The length of the statement  "				ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true)); " is 161.
Long Statement,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The length of the statement  "			if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0) " is 127.
Long Statement,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The length of the statement  "			if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) { " is 132.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The length of the statement  "			/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) { " is 122.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The length of the statement  "				GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A); " is 126.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The length of the statement  "				GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A); " is 122.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The length of the statement  "			/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) { " is 135.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The length of the statement  "				/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4))); " is 168.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The length of the statement  "				/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null) " is 315.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The length of the statement  "	if ((Textures [activetex].Format == 0x40 || Textures [activetex].Format == 0x48 || Textures [activetex].Format == 0x50) && ((w0 [7] >> 24) == (byte)General.UcodeCmds.SETTIMG) || ((w0 [8] >> 24) == (byte)General.UcodeCmds.SETTIMG)) " is 230.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandVtx,The length of the statement  "		VertexBuffer [V0 + i] = new Vertex (ROM' (byte[])ROM.SegmentMapping [(byte)(w1 >> 24)]' (uint)(w1 + i * 16)' mtxstack.Peek ()); " is 127.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri1,The length of the statement  "		ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]])); " is 152.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri1,The length of the statement  "	LastTriList.Add (new SimpleTriangle (VertexBuffer [idxs [0]].Position' VertexBuffer [idxs [1]].Position' VertexBuffer [idxs [2]].Position)); " is 140.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The length of the statement  "			ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]])); " is 152.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The length of the statement  "			ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]])); " is 152.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The length of the statement  "	LastTriList.Add (new SimpleTriangle (VertexBuffer [idxs [0]].Position' VertexBuffer [idxs [1]].Position' VertexBuffer [idxs [2]].Position)); " is 140.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The length of the statement  "	LastTriList.Add (new SimpleTriangle (VertexBuffer [idxs [3]].Position' VertexBuffer [idxs [4]].Position' VertexBuffer [idxs [5]].Position)); " is 140.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The length of the statement  "	Matrix4d glmatrix = new Matrix4d (matrix [0]' matrix [1]' matrix [2]' matrix [3]' matrix [4]' matrix [5]' matrix [6]' matrix [7]' matrix [8]' matrix [9]' matrix [10]' matrix [11]' matrix [12]' matrix [13]' matrix [14]' matrix [15]); " is 232.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,The length of the statement  "	/* SetOtherMode_H *//* useless~ */switch ((General.OtherModeHShifts)(32 - General.ShiftR (w0' 8' 8) - (General.ShiftR (w0' 0' 8) + 1))) { " is 137.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The length of the statement  "	/* SetPrimColor */PrimColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f); " is 216.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The length of the statement  "		GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A); " is 126.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The length of the statement  "		/* Super-simple colorization faking */GL.Material (MaterialFace.FrontAndBack' MaterialParameter.Diffuse' new Color4 (PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A)); " is 170.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetEnvColor,The length of the statement  "	/* SetEnvColor */EnvColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f); " is 214.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetEnvColor,The length of the statement  "		GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A); " is 122.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CheckTextureCache,The length of the statement  "		if (cached.Tag == tag && cached.Format == Textures [tx].Format && cached.Address == Textures [tx].Address && cached.RealHeight == Textures [tx].RealHeight && cached.RealWidth == Textures [tx].RealWidth) " is 202.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,LoadTexture,The length of the statement  "		ImageHelper.Convert (Textures [tx].Format' segdata' (int)adr' ref texbuf' (int)Textures [tx].Width' (int)Textures [tx].Height' (int)Textures [tx].LineSize' (int)Textures [tx].Palette' palette); " is 193.
Long Statement,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,LoadTexture,The length of the statement  "	GL.TexImage2D (TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' (int)Textures [tx].RealWidth' (int)Textures [tx].RealHeight' 0' PixelFormat.Rgba' PixelType.UnsignedByte' texbuf); " is 183.
Long Statement,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The length of the statement  "		for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) { " is 127.
Long Statement,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The length of the statement  "				S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS; " is 226.
Long Statement,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The length of the statement  "				S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS; " is 182.
Long Statement,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The length of the statement  "				T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT; " is 226.
Long Statement,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The length of the statement  "				T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT; " is 182.
Long Statement,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLCombineManager,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLCombineManager.cs,BindCombiner,The length of the statement  "	GLSLShaders shader = shaderCache.FirstOrDefault (x => x.Mux0 == m0 && x.Mux1 == m1 && x.HasLightingEnabled == Convert.ToBoolean (F3DEX2.GeometryMode & (uint)General.GeometryMode.LIGHTING) && x.Textured == tex); " is 210.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,DisableCombiner,The conditional expression  "(arb && currentCombinerType == CombinerTypes.ArbCombiner) || (glsl && currentCombinerType == CombinerTypes.GLSLCombiner)"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,DisableCombiner,The conditional expression  "tsmi.Tag is CombinerTypes && ((((CombinerTypes)tsmi.Tag) == CombinerTypes.ArbCombiner && arb) || (((CombinerTypes)tsmi.Tag) == CombinerTypes.GLSLCombiner && glsl))"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderMeshHeader,The conditional expression  "mh.DLs == null || displayListsDirty || mh.CachedWithTextures != Configuration.RenderTextures || mh.CachedWithCombinerType != Configuration.CombinerType"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The conditional expression  "currentRoom != null && currentRoom.ActiveMeshHeader != null && !Configuration.RenderCollision && currentRoom.ActiveMeshHeader.DLs.Count > 0 && currentRoom.ActiveMeshHeader.DLs [0].Triangles.Count > 0"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The conditional expression  "allMeshHeaders != null && currentRoom == null && !Configuration.RenderCollision && allMeshHeaders.Count > 0 && allMeshHeaders [0].IsMoveable == moveable"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The conditional expression  "currentRoom != null && currentRoom.ActiveRoomActorData != null && Configuration.RenderRoomActors && currentRoom.ActiveRoomActorData.ActorList.Count > 0 && currentRoom.ActiveRoomActorData.ActorList [0].IsMoveable == moveable"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The conditional expression  "currentScene.GetActiveSpawnPointData () != null && Configuration.RenderSpawnPoints && currentScene.GetActiveSpawnPointData ().ActorList.Count > 0 && currentScene.GetActiveSpawnPointData ().ActorList [0].IsMoveable == moveable"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The conditional expression  "currentScene.GetActiveTransitionData () != null && Configuration.RenderTransitions && currentScene.GetActiveTransitionData ().ActorList.Count > 0 && currentScene.GetActiveTransitionData ().ActorList [0].IsMoveable == moveable"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The conditional expression  "activePathHeader != null && activePathHeader.Points != null && Configuration.RenderPathWaypoints && activePathHeader.Points.Count > 0 && activePathHeader.Points [0].IsMoveable == moveable"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The conditional expression  "currentScene.GetActiveCollision () != null && Configuration.RenderWaterboxes && currentScene.GetActiveCollision ().Waterboxes.Count > 0 && currentScene.GetActiveCollision ().Waterboxes [0].IsMoveable == moveable"  is complex.
Complex Conditional,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,TryPickObject,The conditional expression  "currentScene.GetActiveCollision () != null && Configuration.RenderCollision && currentScene.GetActiveCollision ().Polygons.Count > 0 && currentScene.GetActiveCollision ().Polygons [0].IsMoveable == moveable"  is complex.
Complex Conditional,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellFormatting,The conditional expression  "dgv.Columns [e.ColumnIndex].Name == "Number" || dgv.Columns [e.ColumnIndex].Name == "SceneNumber" || dgv.Columns [e.ColumnIndex].Name == "EntranceNumber" || dgv.Columns [e.ColumnIndex].Name == "Variable" || dgv.Columns [e.ColumnIndex].Name == "Fade""  is complex.
Complex Conditional,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellParsing,The conditional expression  "dgv.Columns [e.ColumnIndex].Name == "SceneNumber" || dgv.Columns [e.ColumnIndex].Name == "EntranceNumber" || dgv.Columns [e.ColumnIndex].Name == "Variable" || dgv.Columns [e.ColumnIndex].Name == "Fade""  is complex.
Complex Conditional,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellFormatting,The conditional expression  "dgv.Columns [e.ColumnIndex].Name == "Number" || dgv.Columns [e.ColumnIndex].Name == "LabelStartAddress" || dgv.Columns [e.ColumnIndex].Name == "LabelEndAddress" || dgv.Columns [e.ColumnIndex].Name == "Unknown1" || dgv.Columns [e.ColumnIndex].Name == "ConfigurationNo" || dgv.Columns [e.ColumnIndex].Name == "Unknown3" || dgv.Columns [e.ColumnIndex].Name == "Unknown4" || dgv.Columns [e.ColumnIndex].Name == "Unknown2" || dgv.Columns [e.ColumnIndex].Name == "PresumedPadding""  is complex.
Complex Conditional,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The conditional expression  "dgv.Columns [e.ColumnIndex].Name == "LabelStartAddress" || dgv.Columns [e.ColumnIndex].Name == "LabelEndAddress" || dgv.Columns [e.ColumnIndex].Name == "Unknown1" || dgv.Columns [e.ColumnIndex].Name == "ConfigurationNo" || dgv.Columns [e.ColumnIndex].Name == "Unknown3" || dgv.Columns [e.ColumnIndex].Name == "Unknown4" || dgv.Columns [e.ColumnIndex].Name == "Unknown2" || dgv.Columns [e.ColumnIndex].Name == "PresumedPadding""  is complex.
Complex Conditional,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,RefreshActorPositionRotation,The conditional expression  "item.Usage == Definition.Item.Usages.PositionX || item.Usage == Definition.Item.Usages.PositionY || item.Usage == Definition.Item.Usages.PositionZ || item.Usage == Definition.Item.Usages.RotationX || item.Usage == Definition.Item.Usages.RotationY || item.Usage == Definition.Item.Usages.RotationZ"  is complex.
Complex Conditional,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The conditional expression  "!individual && (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront) && (tag is List<HeaderCommands.Rooms.RoomInfoClass>)"  is complex.
Complex Conditional,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The conditional expression  "BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)"  is complex.
Complex Conditional,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The conditional expression  "(BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)"  is complex.
Complex Conditional,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The conditional expression  "(btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)"  is complex.
Complex Conditional,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The conditional expression  "hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)"  is complex.
Complex Conditional,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The conditional expression  "act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0"  is complex.
Complex Conditional,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The conditional expression  "(act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0"  is complex.
Complex Conditional,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The conditional expression  "obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0"  is complex.
Complex Conditional,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The conditional expression  "Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null"  is complex.
Complex Conditional,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The conditional expression  "(Textures [activetex].Format == 0x40 || Textures [activetex].Format == 0x48 || Textures [activetex].Format == 0x50) && ((w0 [7] >> 24) == (byte)General.UcodeCmds.SETTIMG) || ((w0 [8] >> 24) == (byte)General.UcodeCmds.SETTIMG)"  is complex.
Complex Conditional,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CheckTextureCache,The conditional expression  "cached.Tag == tag && cached.Format == Textures [tx].Format && cached.Address == Textures [tx].Address && cached.RealHeight == Textures [tx].RealHeight && cached.RealWidth == Textures [tx].RealWidth"  is complex.
Empty Catch Block,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvObjects_CellFormatting,The method has an empty catch block.
Empty Catch Block,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The method has an empty catch block.
Empty Catch Block,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellFormatting,The method has an empty catch block.
Empty Catch Block,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellFormatting,The method has an empty catch block.
Empty Catch Block,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The method has an empty catch block.
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,OP,The following statement contains a magic number: return ((x) << 26);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,OF,The following statement contains a magic number: return (((uint)(x) >> 2) & 0xFFFF);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,SA,The following statement contains a magic number: return (((x) & 0x1F) << 6);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,RD,The following statement contains a magic number: return (((x) & 0x1F) << 11);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,RT,The following statement contains a magic number: return (((x) & 0x1F) << 16);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,RS,The following statement contains a magic number: return (((x) & 0x1F) << 21);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,JT,The following statement contains a magic number: return (((uint)(x) >> 2) & 0x3FFFFFF);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,BREAK,The following statement contains a magic number: return ((code) << 6 | 0x0D);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,COP1,The following statement contains a magic number: return (OP (0x11) | (1 << 25) | ((cofun) & 0x1FFFFFF));  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,ERET,The following statement contains a magic number: return (OP (0x10) | 1 << 25 | 0x18);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,SYSCALL,The following statement contains a magic number: return ((code) << 6 | 0x0C);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TEQ,The following statement contains a magic number: return (OP (0x00) | RS (rs) | RT (rt) | ((code) & 0x3FF) << 6 | 0x34);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TGE,The following statement contains a magic number: return (OP (0x00) | RS (rs) | RT (rt) | ((code) & 0x3FF) << 6 | 0x34);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TGEU,The following statement contains a magic number: return (OP (0x00) | RS (rs) | RT (rt) | ((code) & 0x3FF) << 6 | 0x31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TLBP,The following statement contains a magic number: return (OP (0x10) | 1 << 25 | 0x08);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TLBR,The following statement contains a magic number: return (OP (0x10) | 1 << 25 | 0x01);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TLBWI,The following statement contains a magic number: return (OP (0x10) | 1 << 25 | 0x02);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TLBWR,The following statement contains a magic number: return (OP (0x10) | 1 << 25 | 0x06);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TLT,The following statement contains a magic number: return (OP (0x00) | RS (rs) | RT (rt) | ((code) & 0x3FF) << 6 | 0x32);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TLTU,The following statement contains a magic number: return (OP (0x00) | RS (rs) | RT (rt) | ((code) & 0x3FF) << 6 | 0x33);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,TNE,The following statement contains a magic number: return (OP (0x00) | RS (rs) | RT (rt) | ((code) & 0x3FF) << 6 | 0x36);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetRS,The following statement contains a magic number: return (uint)(uint)((word >> 21) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetRS,The following statement contains a magic number: return (uint)(uint)((word >> 21) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetRT,The following statement contains a magic number: return (uint)((word >> 16) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetRT,The following statement contains a magic number: return (uint)((word >> 16) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetRD,The following statement contains a magic number: return (uint)((word >> 11) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetRD,The following statement contains a magic number: return (uint)((word >> 11) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetSA,The following statement contains a magic number: return (uint)((word >> 6) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetSA,The following statement contains a magic number: return (uint)((word >> 6) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetFT,The following statement contains a magic number: return (uint)(uint)((word >> 21) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetFT,The following statement contains a magic number: return (uint)(uint)((word >> 21) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetFS,The following statement contains a magic number: return (uint)((word >> 16) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetFS,The following statement contains a magic number: return (uint)((word >> 16) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetFD,The following statement contains a magic number: return (uint)((word >> 11) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetFD,The following statement contains a magic number: return (uint)((word >> 11) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetBASE,The following statement contains a magic number: return (uint)((word >> 21) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetBASE,The following statement contains a magic number: return (uint)((word >> 21) & 31);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetOFFSET,The following statement contains a magic number: return ((short)((word & 0xFFFF)) * 4);  
Magic Number,SceneNavi.ActorRendering,MIPS,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPS.cs,GetTARGET,The following statement contains a magic number: return (uint)((word & 0x3FFFFFF) << 2);  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,MIPSEvaluator,The following statement contains a magic number: Registers = new uint[32];  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,MIPSEvaluator,The following statement contains a magic number: Stack = new uint[256 * MIPS.SafetyVal];  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,MIPSEvaluator,The following statement contains a magic number: StackPos = (int)(128 * MIPS.SafetyVal);  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,BeginEvaluation,The following statement contains a magic number: for (int i = 0; i < Sections.text.Length; i += 4) {  	Evaluate (Sections.text' i);  	Registers [0] = 0;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,BeginEvaluation,The following statement contains a magic number: i += 4
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode)((word >> 26) & 0x3F)) {  case MIPS.Opcode.JAL:  	target = MIPS.GetTARGET (word);  	Evaluate (words' pos + 4);  	ReportResult (target' pos);  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  	foreach (MemoryRegion mem in MemoryMap) {  		if (target > (mem.Address & 0xFFFFFF) && mem.Data.Length + (mem.Address & 0xFFFFFF) > target) {  			pos = (int)(target - (BaseAddress & 0xFFFFFF));  			break;  		}  	}  	break;  case MIPS.Opcode.SLLV:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetRS (word);  	break;  case MIPS.Opcode.ADDIU:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] + imm;  	if (MIPS.GetRT (word) == MIPS.GetRS (word) && MIPS.GetRT (word) == (uint)MIPS.Register.SP)  		StackPos += (short)imm;  	break;  case MIPS.Opcode.LUI:  	Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  	break;  case MIPS.Opcode.ANDI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] & MIPS.GetIMM (word);  	break;  case MIPS.Opcode.ORI:  	Registers [MIPS.GetRT (word)] = Registers [MIPS.GetRS (word)] | MIPS.GetIMM (word);  	break;  case MIPS.Opcode.SW:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP)  		Stack [StackPos + MIPS.GetIMM (word)] = Registers [MIPS.GetRT (word)];  	break;  /*             case MIPS.Opcode.LH:                 imm = MIPS.GetIMM(word);                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = (uint)Endian.SwapInt16(BitConverter.ToInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.LW:  	imm = MIPS.GetIMM (word);  	if ((imm & 0x8000) != 0)  		imm |= 0xFFFF0000;  	calcadr = imm + Registers [MIPS.GetRS (word)];  	if (MIPS.GetRS (word) == (uint)MIPS.Register.SP) {  		Registers [MIPS.GetRT (word)] = Stack [StackPos + imm];  		break;  	}  	foreach (MemoryRegion mem in MemoryMap) {  		if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr) {  			Registers [MIPS.GetRT (word)] = Endian.SwapUInt32 (BitConverter.ToUInt32 (mem.Data' (int)(calcadr - mem.Address)));  			break;  		}  	}  	break;  /*             case MIPS.Opcode.LHU:                 imm = MIPS.GetIMM(word);                 if ((imm & 0x8000) != 0) imm |= 0xFFFF0000; //????                 calcadr = imm + Registers[MIPS.GetRS(word)];                  if (MIPS.GetRS(word) == (uint)MIPS.Register.SP)                 {                     Registers[MIPS.GetRT(word)] = Stack[StackPos + imm];                     break;                 }                  foreach (MemoryRegion mem in MemoryMap)                 {                     if (calcadr > mem.Address && mem.Data.Length + mem.Address > calcadr)                     {                         Registers[MIPS.GetRT(word)] = Endian.SwapUInt16(BitConverter.ToUInt16(mem.Data' (int)(calcadr - mem.Address)));                         break;                     }                 }                 break;                 */case MIPS.Opcode.TYPE_R:  	{  		switch ((MIPS.Opcode_R)(word & 0x3F)) {  		case MIPS.Opcode_R.SLL:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.SRA:  		case MIPS.Opcode_R.SRL:  			/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  			break;  		case MIPS.Opcode_R.ADDU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.SUBU:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.AND:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.OR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.XOR:  			Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  			break;  		case MIPS.Opcode_R.JR:  			if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  				Array.Clear (Registers' 1' 15);  				Array.Clear (Registers' 24' 4);  				pos = (int)Registers [(int)MIPS.Register.RA];  			}  			break;  		default:  			break;  		}  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: Evaluate (words' pos + 4);  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: Array.Clear (Registers' 1' 15);  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: Array.Clear (Registers' 24' 4);  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: Array.Clear (Registers' 24' 4);  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: Registers [(int)MIPS.Register.RA] = (BaseAddress & 0xFFFFFF) + (uint)(pos + 4);  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: Registers [MIPS.GetRT (word)] = MIPS.GetIMM (word) << 16;  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode_R)(word & 0x3F)) {  case MIPS.Opcode_R.SLL:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  	break;  case MIPS.Opcode_R.SRA:  case MIPS.Opcode_R.SRL:  	/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  	break;  case MIPS.Opcode_R.ADDU:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.SUBU:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.AND:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.OR:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.XOR:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.JR:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  		Array.Clear (Registers' 1' 15);  		Array.Clear (Registers' 24' 4);  		pos = (int)Registers [(int)MIPS.Register.RA];  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode_R)(word & 0x3F)) {  case MIPS.Opcode_R.SLL:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  	break;  case MIPS.Opcode_R.SRA:  case MIPS.Opcode_R.SRL:  	/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  	break;  case MIPS.Opcode_R.ADDU:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.SUBU:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.AND:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.OR:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.XOR:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.JR:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  		Array.Clear (Registers' 1' 15);  		Array.Clear (Registers' 24' 4);  		pos = (int)Registers [(int)MIPS.Register.RA];  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: switch ((MIPS.Opcode_R)(word & 0x3F)) {  case MIPS.Opcode_R.SLL:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] << (int)MIPS.GetSA (word);  	break;  case MIPS.Opcode_R.SRA:  case MIPS.Opcode_R.SRL:  	/*test!*/Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] >> (int)MIPS.GetSA (word);  	break;  case MIPS.Opcode_R.ADDU:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] + Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.SUBU:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] - Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.AND:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] & Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.OR:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] | Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.XOR:  	Registers [MIPS.GetRD (word)] = Registers [MIPS.GetRT (word)] ^ Registers [MIPS.GetRS (word)];  	break;  case MIPS.Opcode_R.JR:  	if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  		Array.Clear (Registers' 1' 15);  		Array.Clear (Registers' 24' 4);  		pos = (int)Registers [(int)MIPS.Register.RA];  	}  	break;  default:  	break;  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	pos = (int)Registers [(int)MIPS.Register.RA];  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	pos = (int)Registers [(int)MIPS.Register.RA];  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: if (MIPS.GetRS (word) == (uint)MIPS.Register.RA) {  	Array.Clear (Registers' 1' 15);  	Array.Clear (Registers' 24' 4);  	pos = (int)Registers [(int)MIPS.Register.RA];  }  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: Array.Clear (Registers' 1' 15);  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: Array.Clear (Registers' 24' 4);  
Magic Number,SceneNavi.ActorRendering,MIPSEvaluator,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ActorRendering\MIPSEvaluator.cs,Evaluate,The following statement contains a magic number: Array.Clear (Registers' 24' 4);  
Magic Number,SceneNavi,AssemblyHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\AssemblyHelpers.cs,RetrieveLinkerTimestamp,The following statement contains a magic number: try {  	s = new System.IO.FileStream (filePath' System.IO.FileMode.Open' System.IO.FileAccess.Read);  	s.Read (b' 0' 2048);  } finally {  	if (s != null) {  		s.Close ();  	}  }  
Magic Number,SceneNavi,AssemblyHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\AssemblyHelpers.cs,RetrieveLinkerTimestamp,The following statement contains a magic number: s.Read (b' 0' 2048);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: if (localize) {  	btnOK.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 800' "OK");  	btnCancel.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 801' "Cancel");  	lblRed.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1049' "Red");  	lblGreen.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1042' "Green");  	lblBlue.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1052' "Blue");  }  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: if (localize) {  	btnOK.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 800' "OK");  	btnCancel.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 801' "Cancel");  	lblRed.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1049' "Red");  	lblGreen.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1042' "Green");  	lblBlue.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1052' "Blue");  }  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: if (localize) {  	btnOK.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 800' "OK");  	btnCancel.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 801' "Cancel");  	lblRed.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1049' "Red");  	lblGreen.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1042' "Green");  	lblBlue.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1052' "Blue");  }  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: if (localize) {  	btnOK.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 800' "OK");  	btnCancel.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 801' "Cancel");  	lblRed.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1049' "Red");  	lblGreen.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1042' "Green");  	lblBlue.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1052' "Blue");  }  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: if (localize) {  	btnOK.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 800' "OK");  	btnCancel.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 801' "Cancel");  	lblRed.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1049' "Red");  	lblGreen.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1042' "Green");  	lblBlue.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1052' "Blue");  }  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: btnOK.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 800' "OK");  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: btnCancel.Text = GUIHelpers.LoadLocalizedString ("user32.dll"' 801' "Cancel");  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: lblRed.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1049' "Red");  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: lblGreen.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1042' "Green");  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorPickerDialog,The following statement contains a magic number: lblBlue.Text = GUIHelpers.LoadLocalizedString ("comdlg32.dll"' 1052' "Blue");  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,DrawMarker,The following statement contains a magic number: using (Pen pen = new Pen ((colorComponent == ColorComponents.Alpha ? Color.Black : Color.FromArgb ((-orgValue + 255)' (-orgValue + 255)' (-orgValue + 255)))' 4.0f)) {  	pen.EndCap = LineCap.Custom;  	pen.CustomEndCap = new System.Drawing.Drawing2D.AdjustableArrowCap (4.0f' 5.5f' true);  	e.Graphics.DrawLine (pen' xpos' 0' xpos' control.ClientRectangle.Height);  }  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,DrawMarker,The following statement contains a magic number: using (Pen pen = new Pen ((colorComponent == ColorComponents.Alpha ? Color.Black : Color.FromArgb ((-orgValue + 255)' (-orgValue + 255)' (-orgValue + 255)))' 4.0f)) {  	pen.EndCap = LineCap.Custom;  	pen.CustomEndCap = new System.Drawing.Drawing2D.AdjustableArrowCap (4.0f' 5.5f' true);  	e.Graphics.DrawLine (pen' xpos' 0' xpos' control.ClientRectangle.Height);  }  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,DrawMarker,The following statement contains a magic number: using (Pen pen = new Pen ((colorComponent == ColorComponents.Alpha ? Color.Black : Color.FromArgb ((-orgValue + 255)' (-orgValue + 255)' (-orgValue + 255)))' 4.0f)) {  	pen.EndCap = LineCap.Custom;  	pen.CustomEndCap = new System.Drawing.Drawing2D.AdjustableArrowCap (4.0f' 5.5f' true);  	e.Graphics.DrawLine (pen' xpos' 0' xpos' control.ClientRectangle.Height);  }  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorSlide,The following statement contains a magic number: if (e.Button == System.Windows.Forms.MouseButtons.Left) {  	byte newValue = (byte)ScaleRange (xLocation' 0' control.ClientRectangle.Width' 0' 255);  	switch (colorComponent) {  	case ColorComponents.Red:  		Color = Color.FromArgb (color.A' newValue' color.G' color.B);  		break;  	case ColorComponents.Green:  		Color = Color.FromArgb (color.A' color.R' newValue' color.B);  		break;  	case ColorComponents.Blue:  		Color = Color.FromArgb (color.A' color.R' color.G' newValue);  		break;  	case ColorComponents.Alpha:  		Color = Color.FromArgb (newValue' color.R' color.G' color.B);  		break;  	}  }  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Location = new System.Drawing.Point (357' 167);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Location = new System.Drawing.Point (357' 167);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Size = new System.Drawing.Size (75' 23);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Size = new System.Drawing.Size (75' 23);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.TabIndex = 10;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (276' 167);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point (276' 167);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (75' 23);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size (75' 23);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 9;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblRed.Location = new System.Drawing.Point (12' 9);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblRed.Location = new System.Drawing.Point (12' 9);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblRed.Size = new System.Drawing.Size (53' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblRed.Size = new System.Drawing.Size (53' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblGreen.Location = new System.Drawing.Point (12' 35);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblGreen.Location = new System.Drawing.Point (12' 35);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblGreen.Size = new System.Drawing.Size (53' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblGreen.Size = new System.Drawing.Size (53' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblGreen.TabIndex = 2;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblBlue.Location = new System.Drawing.Point (12' 61);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblBlue.Location = new System.Drawing.Point (12' 61);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblBlue.Size = new System.Drawing.Size (53' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblBlue.Size = new System.Drawing.Size (53' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblBlue.TabIndex = 4;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblAlpha.Location = new System.Drawing.Point (12' 87);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblAlpha.Location = new System.Drawing.Point (12' 87);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblAlpha.Size = new System.Drawing.Size (53' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblAlpha.Size = new System.Drawing.Size (53' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblAlpha.TabIndex = 6;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (12' 116);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (12' 116);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (53' 40);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (53' 40);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 8;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudRed.Location = new System.Drawing.Point (389' 9);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudRed.Location = new System.Drawing.Point (389' 9);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudRed.Maximum = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudRed.Size = new System.Drawing.Size (43' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudRed.Size = new System.Drawing.Size (43' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudRed.Value = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudGreen.Location = new System.Drawing.Point (389' 35);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudGreen.Location = new System.Drawing.Point (389' 35);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudGreen.Maximum = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudGreen.Size = new System.Drawing.Size (43' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudGreen.Size = new System.Drawing.Size (43' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudGreen.TabIndex = 3;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudGreen.Value = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudBlue.Location = new System.Drawing.Point (389' 61);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudBlue.Location = new System.Drawing.Point (389' 61);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudBlue.Maximum = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudBlue.Size = new System.Drawing.Size (43' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudBlue.Size = new System.Drawing.Size (43' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudBlue.TabIndex = 5;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudBlue.Value = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudAlpha.Location = new System.Drawing.Point (389' 87);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudAlpha.Location = new System.Drawing.Point (389' 87);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudAlpha.Maximum = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudAlpha.Size = new System.Drawing.Size (43' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudAlpha.Size = new System.Drawing.Size (43' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudAlpha.TabIndex = 7;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.nudAlpha.Value = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientAlpha.Location = new System.Drawing.Point (72' 87);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientAlpha.Location = new System.Drawing.Point (72' 87);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientAlpha.Size = new System.Drawing.Size (311' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientAlpha.Size = new System.Drawing.Size (311' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientAlpha.TabIndex = 18;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbPreview.Location = new System.Drawing.Point (71' 116);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbPreview.Location = new System.Drawing.Point (71' 116);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbPreview.Margin = new System.Windows.Forms.Padding (3' 6' 3' 3);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbPreview.Margin = new System.Windows.Forms.Padding (3' 6' 3' 3);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbPreview.Margin = new System.Windows.Forms.Padding (3' 6' 3' 3);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbPreview.Margin = new System.Windows.Forms.Padding (3' 6' 3' 3);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbPreview.Size = new System.Drawing.Size (361' 40);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbPreview.Size = new System.Drawing.Size (361' 40);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbPreview.TabIndex = 16;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientBlue.Location = new System.Drawing.Point (72' 61);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientBlue.Location = new System.Drawing.Point (72' 61);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientBlue.Size = new System.Drawing.Size (311' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientBlue.Size = new System.Drawing.Size (311' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientBlue.TabIndex = 4;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientGreen.Location = new System.Drawing.Point (72' 35);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientGreen.Location = new System.Drawing.Point (72' 35);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientGreen.Size = new System.Drawing.Size (311' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientGreen.Size = new System.Drawing.Size (311' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientGreen.TabIndex = 3;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientRed.Location = new System.Drawing.Point (72' 9);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientRed.Location = new System.Drawing.Point (72' 9);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientRed.Size = new System.Drawing.Size (311' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientRed.Size = new System.Drawing.Size (311' 20);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.pbColorGradientRed.TabIndex = 2;  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (444' 202);  
Magic Number,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (444' 202);  
Magic Number,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,SwapRGBAToBGRA,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i += 4) {  	byte red = buffer [i];  	buffer [i] = buffer [i + 2];  	buffer [i + 2] = red;  }  
Magic Number,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,SwapRGBAToBGRA,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i += 4) {  	byte red = buffer [i];  	buffer [i] = buffer [i + 2];  	buffer [i + 2] = red;  }  
Magic Number,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,SwapRGBAToBGRA,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i += 4) {  	byte red = buffer [i];  	buffer [i] = buffer [i + 2];  	buffer [i + 2] = red;  }  
Magic Number,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,SwapRGBAToBGRA,The following statement contains a magic number: i += 4
Magic Number,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,SwapRGBAToBGRA,The following statement contains a magic number: buffer [i] = buffer [i + 2];  
Magic Number,SceneNavi,ExtensionMethods,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ExtensionMethods.cs,SwapRGBAToBGRA,The following statement contains a magic number: buffer [i + 2] = red;  
Magic Number,SceneNavi,GUIHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\GUIHelpers.cs,LoadLocalizedString,The following statement contains a magic number: if (libraryHandle != IntPtr.Zero) {  	StringBuilder sb = new StringBuilder (1024);  	int size = LoadString (libraryHandle' ident' sb' 1024);  	if (size > 0)  		return sb.ToString ();  }  
Magic Number,SceneNavi,GUIHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\GUIHelpers.cs,LoadLocalizedString,The following statement contains a magic number: if (libraryHandle != IntPtr.Zero) {  	StringBuilder sb = new StringBuilder (1024);  	int size = LoadString (libraryHandle' ident' sb' 1024);  	if (size > 0)  		return sb.ToString ();  }  
Magic Number,SceneNavi,Endian,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,SceneNavi,Endian,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,SceneNavi,Endian,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,SceneNavi,Endian,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvObjects_CellParsing,The following statement contains a magic number: if (dgv.Columns [e.ColumnIndex].Name == "Number") {  	if (e != null && e.Value != null && e.DesiredType.Equals (typeof(ushort))) {  		string str = (e.Value as string);  		bool ishex = str.StartsWith ("0x");  		ushort val = 0;  		if (ushort.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  			e.Value = val;  			e.ParsingApplied = true;  		}  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvObjects_CellParsing,The following statement contains a magic number: if (e != null && e.Value != null && e.DesiredType.Equals (typeof(ushort))) {  	string str = (e.Value as string);  	bool ishex = str.StartsWith ("0x");  	ushort val = 0;  	if (ushort.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  		e.Value = val;  		e.ParsingApplied = true;  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvObjects_CellParsing,The following statement contains a magic number: if (ushort.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  	e.Value = val;  	e.ParsingApplied = true;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Load,The following statement contains a magic number: oglSceneScale = 0.02;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: try {  	fpsMonitor.Update ();  	RenderInit (((GLControl)sender).ClientRectangle' Color.LightBlue);  	if (rom != null && rom.Loaded) {  		/* Scene/rooms */RenderScene ();  		/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		{  			/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  				foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  					ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  					ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  				foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  					ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  				/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  					GL.LineWidth (4.0f);  					GL.Color3 (0.25' 0.5' 1.0);  					GL.Begin (PrimitiveType.LineStrip);  					foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  						GL.Vertex3 (wp.X' wp.Y' wp.Z);  					GL.End ();  				}  				HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  			}  		/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  		GL.PopAttrib ();  		if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!collisionDirty && collisionDL != null) {  				collisionDL.Render ();  			} else {  				collisionDirty = false;  				if (collisionDL != null)  					collisionDL.Dispose ();  				collisionDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.DepthRange (0.0' 0.99999);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  					if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  						GL.Color4 (0.5' 0.5' 1.0' 0.5);  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						if (Configuration.RenderCollisionAsWhite)  							GL.Color4 (1.0' 1.0' 1.0' 0.5);  					} else {  						if (Configuration.RenderCollisionAsWhite)  							poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  						else  							poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  					}  				}  				GL.End ();  				GL.DepthRange (0.0' 0.99998);  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Color3 (Color.Black);  				GL.Begin (PrimitiveType.Triangles);  				foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				GL.End ();  				GL.PopAttrib ();  				collisionDL.End ();  			}  		}  		if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  			if (!waterboxesDirty && waterboxDL != null) {  				waterboxDL.Render ();  			} else {  				waterboxesDirty = false;  				if (waterboxDL != null)  					waterboxDL.Dispose ();  				waterboxDL = new DisplayList (ListMode.CompileAndExecute);  				GL.PushAttrib (AttribMask.AllAttribBits);  				GL.Disable (EnableCap.Texture2D);  				GL.Disable (EnableCap.Lighting);  				if (supportsGenProgramsARB)  					GL.Disable ((EnableCap)All.FragmentProgram);  				if (supportsCreateShader)  					GL.UseProgram (0);  				GL.Disable (EnableCap.CullFace);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					if (wb == currentWaterbox && cbWaterboxes.Visible)  						GL.Color4 (0.5' 1.0' 0.5' alpha);  					else  						GL.Color4 (0.0' 0.5' 1.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  				GL.LineWidth (2.0f);  				GL.Begin (PrimitiveType.Quads);  				foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  					double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  					GL.Color4 (0.0' 0.0' 0.0' alpha);  					wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  				GL.End ();  				GL.Enable (EnableCap.CullFace);  				GL.PopAttrib ();  				GL.Color4 (Color.White);  				waterboxDL.End ();  			}  		}  		if (currentRoomTriangle != null && !Configuration.RenderCollision) {  			currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		RenderTextOverlay ();  	}  	((GLControl)sender).SwapBuffers ();  } catch (EntryPointNotFoundException) {  	//  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (rom != null && rom.Loaded) {  	/* Scene/rooms */RenderScene ();  	/* Prepare for actors */GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	{  		/* Room actors */if (Configuration.RenderRoomActors && currentRoom != null && currentRoom.ActiveRoomActorData != null)  			foreach (HeaderCommands.Actors.Entry ac in currentRoom.ActiveRoomActorData.ActorList)  				ac.Render (ac == (cbActors.SelectedItem as HeaderCommands.Actors.Entry) && cbActors.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Spawn points */if (Configuration.RenderSpawnPoints && currentScene != null && currentScene.GetActiveSpawnPointData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveSpawnPointData ().ActorList)  				ac.Render (ac == (cbSpawnPoints.SelectedItem as HeaderCommands.Actors.Entry) && cbSpawnPoints.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Transitions */if (Configuration.RenderTransitions && currentScene != null && currentScene.GetActiveTransitionData () != null)  			foreach (HeaderCommands.Actors.Entry ac in currentScene.GetActiveTransitionData ().ActorList)  				ac.Render (ac == (cbTransitions.SelectedItem as HeaderCommands.Actors.Entry) && cbTransitions.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		/* Path waypoints */if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  			/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  				GL.LineWidth (4.0f);  				GL.Color3 (0.25' 0.5' 1.0);  				GL.Begin (PrimitiveType.LineStrip);  				foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  					GL.Vertex3 (wp.X' wp.Y' wp.Z);  				GL.End ();  			}  			HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  			foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  				wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  		}  	/* Collision *//* Waterboxes *//* Render selected room triangle overlay *//* 2D text overlay */}  	GL.PopAttrib ();  	if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!collisionDirty && collisionDL != null) {  			collisionDL.Render ();  		} else {  			collisionDirty = false;  			if (collisionDL != null)  				collisionDL.Dispose ();  			collisionDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.DepthRange (0.0' 0.99999);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  				if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  					GL.Color4 (0.5' 0.5' 1.0' 0.5);  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					if (Configuration.RenderCollisionAsWhite)  						GL.Color4 (1.0' 1.0' 1.0' 0.5);  				} else {  					if (Configuration.RenderCollisionAsWhite)  						poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  					else  						poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  				}  			}  			GL.End ();  			GL.DepthRange (0.0' 0.99998);  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Color3 (Color.Black);  			GL.Begin (PrimitiveType.Triangles);  			foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			GL.End ();  			GL.PopAttrib ();  			collisionDL.End ();  		}  	}  	if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  		if (!waterboxesDirty && waterboxDL != null) {  			waterboxDL.Render ();  		} else {  			waterboxesDirty = false;  			if (waterboxDL != null)  				waterboxDL.Dispose ();  			waterboxDL = new DisplayList (ListMode.CompileAndExecute);  			GL.PushAttrib (AttribMask.AllAttribBits);  			GL.Disable (EnableCap.Texture2D);  			GL.Disable (EnableCap.Lighting);  			if (supportsGenProgramsARB)  				GL.Disable ((EnableCap)All.FragmentProgram);  			if (supportsCreateShader)  				GL.UseProgram (0);  			GL.Disable (EnableCap.CullFace);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				if (wb == currentWaterbox && cbWaterboxes.Visible)  					GL.Color4 (0.5' 1.0' 0.5' alpha);  				else  					GL.Color4 (0.0' 0.5' 1.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  			GL.LineWidth (2.0f);  			GL.Begin (PrimitiveType.Quads);  			foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  				double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  				GL.Color4 (0.0' 0.0' 0.0' alpha);  				wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  			GL.End ();  			GL.Enable (EnableCap.CullFace);  			GL.PopAttrib ();  			GL.Color4 (Color.White);  			waterboxDL.End ();  		}  	}  	if (currentRoomTriangle != null && !Configuration.RenderCollision) {  		currentRoomTriangle.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	RenderTextOverlay ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  	/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  		GL.LineWidth (4.0f);  		GL.Color3 (0.25' 0.5' 1.0);  		GL.Begin (PrimitiveType.LineStrip);  		foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  			GL.Vertex3 (wp.X' wp.Y' wp.Z);  		GL.End ();  	}  	HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  	foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  		wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderPathWaypoints && activePathHeader != null && activePathHeader.Points != null) {  	/* Link waypoints? */if (Configuration.LinkAllWPinPath) {  		GL.LineWidth (4.0f);  		GL.Color3 (0.25' 0.5' 1.0);  		GL.Begin (PrimitiveType.LineStrip);  		foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  			GL.Vertex3 (wp.X' wp.Y' wp.Z);  		GL.End ();  	}  	HeaderCommands.Waypoints.Waypoint selwp = (dgvPathWaypoints.SelectedCells.Count != 0 ? dgvPathWaypoints.SelectedCells [0].OwningRow.DataBoundItem as HeaderCommands.Waypoints.Waypoint : null);  	foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  		wp.Render (wp == selwp && cbPathHeaders.Visible ? HeaderCommands.PickableObjectRenderType.Selected : HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.LinkAllWPinPath) {  	GL.LineWidth (4.0f);  	GL.Color3 (0.25' 0.5' 1.0);  	GL.Begin (PrimitiveType.LineStrip);  	foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  		GL.Vertex3 (wp.X' wp.Y' wp.Z);  	GL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.LinkAllWPinPath) {  	GL.LineWidth (4.0f);  	GL.Color3 (0.25' 0.5' 1.0);  	GL.Begin (PrimitiveType.LineStrip);  	foreach (HeaderCommands.Waypoints.Waypoint wp in activePathHeader.Points)  		GL.Vertex3 (wp.X' wp.Y' wp.Z);  	GL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color3 (0.25' 0.5' 1.0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color3 (0.25' 0.5' 1.0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!collisionDirty && collisionDL != null) {  		collisionDL.Render ();  	} else {  		collisionDirty = false;  		if (collisionDL != null)  			collisionDL.Dispose ();  		collisionDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.DepthRange (0.0' 0.99999);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  			if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  				GL.Color4 (0.5' 0.5' 1.0' 0.5);  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  			} else {  				if (Configuration.RenderCollisionAsWhite)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				else  					poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  		}  		GL.End ();  		GL.DepthRange (0.0' 0.99998);  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Color3 (Color.Black);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		GL.End ();  		GL.PopAttrib ();  		collisionDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!collisionDirty && collisionDL != null) {  		collisionDL.Render ();  	} else {  		collisionDirty = false;  		if (collisionDL != null)  			collisionDL.Dispose ();  		collisionDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.DepthRange (0.0' 0.99999);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  			if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  				GL.Color4 (0.5' 0.5' 1.0' 0.5);  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  			} else {  				if (Configuration.RenderCollisionAsWhite)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				else  					poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  		}  		GL.End ();  		GL.DepthRange (0.0' 0.99998);  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Color3 (Color.Black);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		GL.End ();  		GL.PopAttrib ();  		collisionDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!collisionDirty && collisionDL != null) {  		collisionDL.Render ();  	} else {  		collisionDirty = false;  		if (collisionDL != null)  			collisionDL.Dispose ();  		collisionDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.DepthRange (0.0' 0.99999);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  			if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  				GL.Color4 (0.5' 0.5' 1.0' 0.5);  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  			} else {  				if (Configuration.RenderCollisionAsWhite)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				else  					poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  		}  		GL.End ();  		GL.DepthRange (0.0' 0.99998);  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Color3 (Color.Black);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		GL.End ();  		GL.PopAttrib ();  		collisionDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!collisionDirty && collisionDL != null) {  		collisionDL.Render ();  	} else {  		collisionDirty = false;  		if (collisionDL != null)  			collisionDL.Dispose ();  		collisionDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.DepthRange (0.0' 0.99999);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  			if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  				GL.Color4 (0.5' 0.5' 1.0' 0.5);  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  			} else {  				if (Configuration.RenderCollisionAsWhite)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				else  					poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  		}  		GL.End ();  		GL.DepthRange (0.0' 0.99998);  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Color3 (Color.Black);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		GL.End ();  		GL.PopAttrib ();  		collisionDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!collisionDirty && collisionDL != null) {  		collisionDL.Render ();  	} else {  		collisionDirty = false;  		if (collisionDL != null)  			collisionDL.Dispose ();  		collisionDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.DepthRange (0.0' 0.99999);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  			if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  				GL.Color4 (0.5' 0.5' 1.0' 0.5);  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  			} else {  				if (Configuration.RenderCollisionAsWhite)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				else  					poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  		}  		GL.End ();  		GL.DepthRange (0.0' 0.99998);  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Color3 (Color.Black);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		GL.End ();  		GL.PopAttrib ();  		collisionDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!collisionDirty && collisionDL != null) {  		collisionDL.Render ();  	} else {  		collisionDirty = false;  		if (collisionDL != null)  			collisionDL.Dispose ();  		collisionDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.DepthRange (0.0' 0.99999);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  			if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  				GL.Color4 (0.5' 0.5' 1.0' 0.5);  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  			} else {  				if (Configuration.RenderCollisionAsWhite)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				else  					poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  		}  		GL.End ();  		GL.DepthRange (0.0' 0.99998);  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Color3 (Color.Black);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		GL.End ();  		GL.PopAttrib ();  		collisionDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderCollision && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!collisionDirty && collisionDL != null) {  		collisionDL.Render ();  	} else {  		collisionDirty = false;  		if (collisionDL != null)  			collisionDL.Dispose ();  		collisionDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.DepthRange (0.0' 0.99999);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  			if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  				GL.Color4 (0.5' 0.5' 1.0' 0.5);  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				if (Configuration.RenderCollisionAsWhite)  					GL.Color4 (1.0' 1.0' 1.0' 0.5);  			} else {  				if (Configuration.RenderCollisionAsWhite)  					poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  				else  					poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  			}  		}  		GL.End ();  		GL.DepthRange (0.0' 0.99998);  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Color3 (Color.Black);  		GL.Begin (PrimitiveType.Triangles);  		foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		GL.End ();  		GL.PopAttrib ();  		collisionDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!collisionDirty && collisionDL != null) {  	collisionDL.Render ();  } else {  	collisionDirty = false;  	if (collisionDL != null)  		collisionDL.Dispose ();  	collisionDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.DepthRange (0.0' 0.99999);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  		if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  			GL.Color4 (0.5' 0.5' 1.0' 0.5);  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  		} else {  			if (Configuration.RenderCollisionAsWhite)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			else  				poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  	}  	GL.End ();  	GL.DepthRange (0.0' 0.99998);  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Color3 (Color.Black);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	GL.End ();  	GL.PopAttrib ();  	collisionDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!collisionDirty && collisionDL != null) {  	collisionDL.Render ();  } else {  	collisionDirty = false;  	if (collisionDL != null)  		collisionDL.Dispose ();  	collisionDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.DepthRange (0.0' 0.99999);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  		if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  			GL.Color4 (0.5' 0.5' 1.0' 0.5);  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  		} else {  			if (Configuration.RenderCollisionAsWhite)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			else  				poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  	}  	GL.End ();  	GL.DepthRange (0.0' 0.99998);  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Color3 (Color.Black);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	GL.End ();  	GL.PopAttrib ();  	collisionDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!collisionDirty && collisionDL != null) {  	collisionDL.Render ();  } else {  	collisionDirty = false;  	if (collisionDL != null)  		collisionDL.Dispose ();  	collisionDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.DepthRange (0.0' 0.99999);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  		if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  			GL.Color4 (0.5' 0.5' 1.0' 0.5);  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  		} else {  			if (Configuration.RenderCollisionAsWhite)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			else  				poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  	}  	GL.End ();  	GL.DepthRange (0.0' 0.99998);  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Color3 (Color.Black);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	GL.End ();  	GL.PopAttrib ();  	collisionDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!collisionDirty && collisionDL != null) {  	collisionDL.Render ();  } else {  	collisionDirty = false;  	if (collisionDL != null)  		collisionDL.Dispose ();  	collisionDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.DepthRange (0.0' 0.99999);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  		if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  			GL.Color4 (0.5' 0.5' 1.0' 0.5);  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  		} else {  			if (Configuration.RenderCollisionAsWhite)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			else  				poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  	}  	GL.End ();  	GL.DepthRange (0.0' 0.99998);  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Color3 (Color.Black);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	GL.End ();  	GL.PopAttrib ();  	collisionDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!collisionDirty && collisionDL != null) {  	collisionDL.Render ();  } else {  	collisionDirty = false;  	if (collisionDL != null)  		collisionDL.Dispose ();  	collisionDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.DepthRange (0.0' 0.99999);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  		if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  			GL.Color4 (0.5' 0.5' 1.0' 0.5);  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  		} else {  			if (Configuration.RenderCollisionAsWhite)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			else  				poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  	}  	GL.End ();  	GL.DepthRange (0.0' 0.99998);  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Color3 (Color.Black);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	GL.End ();  	GL.PopAttrib ();  	collisionDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!collisionDirty && collisionDL != null) {  	collisionDL.Render ();  } else {  	collisionDirty = false;  	if (collisionDL != null)  		collisionDL.Dispose ();  	collisionDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.DepthRange (0.0' 0.99999);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  		if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  			GL.Color4 (0.5' 0.5' 1.0' 0.5);  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  		} else {  			if (Configuration.RenderCollisionAsWhite)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			else  				poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  	}  	GL.End ();  	GL.DepthRange (0.0' 0.99998);  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Color3 (Color.Black);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	GL.End ();  	GL.PopAttrib ();  	collisionDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!collisionDirty && collisionDL != null) {  	collisionDL.Render ();  } else {  	collisionDirty = false;  	if (collisionDL != null)  		collisionDL.Dispose ();  	collisionDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.DepthRange (0.0' 0.99999);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  		if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  			GL.Color4 (0.5' 0.5' 1.0' 0.5);  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			if (Configuration.RenderCollisionAsWhite)  				GL.Color4 (1.0' 1.0' 1.0' 0.5);  		} else {  			if (Configuration.RenderCollisionAsWhite)  				poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  			else  				poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  	}  	GL.End ();  	GL.DepthRange (0.0' 0.99998);  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Color3 (Color.Black);  	GL.Begin (PrimitiveType.Triangles);  	foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	GL.End ();  	GL.PopAttrib ();  	collisionDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.DepthRange (0.0' 0.99999);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderCollisionAsWhite)  	GL.Color4 (1.0' 1.0' 1.0' 0.5);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color4 (1.0' 1.0' 1.0' 0.5);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  	if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  		GL.Color4 (0.5' 0.5' 1.0' 0.5);  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  	} else {  		if (Configuration.RenderCollisionAsWhite)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		else  			poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  	if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  		GL.Color4 (0.5' 0.5' 1.0' 0.5);  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  	} else {  		if (Configuration.RenderCollisionAsWhite)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		else  			poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  	if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  		GL.Color4 (0.5' 0.5' 1.0' 0.5);  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  	} else {  		if (Configuration.RenderCollisionAsWhite)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		else  			poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Polygon poly in currentScene.GetActiveCollision ().Polygons) {  	if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  		GL.Color4 (0.5' 0.5' 1.0' 0.5);  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		if (Configuration.RenderCollisionAsWhite)  			GL.Color4 (1.0' 1.0' 1.0' 0.5);  	} else {  		if (Configuration.RenderCollisionAsWhite)  			poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  		else  			poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  	GL.Color4 (0.5' 0.5' 1.0' 0.5);  	poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  } else {  	if (Configuration.RenderCollisionAsWhite)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	else  		poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  	GL.Color4 (0.5' 0.5' 1.0' 0.5);  	poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  } else {  	if (Configuration.RenderCollisionAsWhite)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	else  		poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  	GL.Color4 (0.5' 0.5' 1.0' 0.5);  	poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  } else {  	if (Configuration.RenderCollisionAsWhite)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	else  		poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (poly == currentCollisionPolygon && cbCollisionPolys.Visible) {  	GL.Color4 (0.5' 0.5' 1.0' 0.5);  	poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	if (Configuration.RenderCollisionAsWhite)  		GL.Color4 (1.0' 1.0' 1.0' 0.5);  } else {  	if (Configuration.RenderCollisionAsWhite)  		poly.Render (HeaderCommands.PickableObjectRenderType.NoColor);  	else  		poly.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color4 (0.5' 0.5' 1.0' 0.5);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color4 (0.5' 0.5' 1.0' 0.5);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color4 (0.5' 0.5' 1.0' 0.5);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderCollisionAsWhite)  	GL.Color4 (1.0' 1.0' 1.0' 0.5);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color4 (1.0' 1.0' 1.0' 0.5);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.DepthRange (0.0' 0.99998);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!waterboxesDirty && waterboxDL != null) {  		waterboxDL.Render ();  	} else {  		waterboxesDirty = false;  		if (waterboxDL != null)  			waterboxDL.Dispose ();  		waterboxDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.Disable (EnableCap.CullFace);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			if (wb == currentWaterbox && cbWaterboxes.Visible)  				GL.Color4 (0.5' 1.0' 0.5' alpha);  			else  				GL.Color4 (0.0' 0.5' 1.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			GL.Color4 (0.0' 0.0' 0.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.Enable (EnableCap.CullFace);  		GL.PopAttrib ();  		GL.Color4 (Color.White);  		waterboxDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!waterboxesDirty && waterboxDL != null) {  		waterboxDL.Render ();  	} else {  		waterboxesDirty = false;  		if (waterboxDL != null)  			waterboxDL.Dispose ();  		waterboxDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.Disable (EnableCap.CullFace);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			if (wb == currentWaterbox && cbWaterboxes.Visible)  				GL.Color4 (0.5' 1.0' 0.5' alpha);  			else  				GL.Color4 (0.0' 0.5' 1.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			GL.Color4 (0.0' 0.0' 0.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.Enable (EnableCap.CullFace);  		GL.PopAttrib ();  		GL.Color4 (Color.White);  		waterboxDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!waterboxesDirty && waterboxDL != null) {  		waterboxDL.Render ();  	} else {  		waterboxesDirty = false;  		if (waterboxDL != null)  			waterboxDL.Dispose ();  		waterboxDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.Disable (EnableCap.CullFace);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			if (wb == currentWaterbox && cbWaterboxes.Visible)  				GL.Color4 (0.5' 1.0' 0.5' alpha);  			else  				GL.Color4 (0.0' 0.5' 1.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			GL.Color4 (0.0' 0.0' 0.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.Enable (EnableCap.CullFace);  		GL.PopAttrib ();  		GL.Color4 (Color.White);  		waterboxDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!waterboxesDirty && waterboxDL != null) {  		waterboxDL.Render ();  	} else {  		waterboxesDirty = false;  		if (waterboxDL != null)  			waterboxDL.Dispose ();  		waterboxDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.Disable (EnableCap.CullFace);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			if (wb == currentWaterbox && cbWaterboxes.Visible)  				GL.Color4 (0.5' 1.0' 0.5' alpha);  			else  				GL.Color4 (0.0' 0.5' 1.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			GL.Color4 (0.0' 0.0' 0.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.Enable (EnableCap.CullFace);  		GL.PopAttrib ();  		GL.Color4 (Color.White);  		waterboxDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!waterboxesDirty && waterboxDL != null) {  		waterboxDL.Render ();  	} else {  		waterboxesDirty = false;  		if (waterboxDL != null)  			waterboxDL.Dispose ();  		waterboxDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.Disable (EnableCap.CullFace);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			if (wb == currentWaterbox && cbWaterboxes.Visible)  				GL.Color4 (0.5' 1.0' 0.5' alpha);  			else  				GL.Color4 (0.0' 0.5' 1.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			GL.Color4 (0.0' 0.0' 0.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.Enable (EnableCap.CullFace);  		GL.PopAttrib ();  		GL.Color4 (Color.White);  		waterboxDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!waterboxesDirty && waterboxDL != null) {  		waterboxDL.Render ();  	} else {  		waterboxesDirty = false;  		if (waterboxDL != null)  			waterboxDL.Dispose ();  		waterboxDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.Disable (EnableCap.CullFace);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			if (wb == currentWaterbox && cbWaterboxes.Visible)  				GL.Color4 (0.5' 1.0' 0.5' alpha);  			else  				GL.Color4 (0.0' 0.5' 1.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			GL.Color4 (0.0' 0.0' 0.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.Enable (EnableCap.CullFace);  		GL.PopAttrib ();  		GL.Color4 (Color.White);  		waterboxDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (Configuration.RenderWaterboxes && currentScene != null && currentScene.GetActiveCollision () != null) {  	if (!waterboxesDirty && waterboxDL != null) {  		waterboxDL.Render ();  	} else {  		waterboxesDirty = false;  		if (waterboxDL != null)  			waterboxDL.Dispose ();  		waterboxDL = new DisplayList (ListMode.CompileAndExecute);  		GL.PushAttrib (AttribMask.AllAttribBits);  		GL.Disable (EnableCap.Texture2D);  		GL.Disable (EnableCap.Lighting);  		if (supportsGenProgramsARB)  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (supportsCreateShader)  			GL.UseProgram (0);  		GL.Disable (EnableCap.CullFace);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			if (wb == currentWaterbox && cbWaterboxes.Visible)  				GL.Color4 (0.5' 1.0' 0.5' alpha);  			else  				GL.Color4 (0.0' 0.5' 1.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  		GL.LineWidth (2.0f);  		GL.Begin (PrimitiveType.Quads);  		foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  			double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  			GL.Color4 (0.0' 0.0' 0.0' alpha);  			wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  		}  		GL.End ();  		GL.Enable (EnableCap.CullFace);  		GL.PopAttrib ();  		GL.Color4 (Color.White);  		waterboxDL.End ();  	}  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!waterboxesDirty && waterboxDL != null) {  	waterboxDL.Render ();  } else {  	waterboxesDirty = false;  	if (waterboxDL != null)  		waterboxDL.Dispose ();  	waterboxDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.Disable (EnableCap.CullFace);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		if (wb == currentWaterbox && cbWaterboxes.Visible)  			GL.Color4 (0.5' 1.0' 0.5' alpha);  		else  			GL.Color4 (0.0' 0.5' 1.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		GL.Color4 (0.0' 0.0' 0.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.Enable (EnableCap.CullFace);  	GL.PopAttrib ();  	GL.Color4 (Color.White);  	waterboxDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!waterboxesDirty && waterboxDL != null) {  	waterboxDL.Render ();  } else {  	waterboxesDirty = false;  	if (waterboxDL != null)  		waterboxDL.Dispose ();  	waterboxDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.Disable (EnableCap.CullFace);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		if (wb == currentWaterbox && cbWaterboxes.Visible)  			GL.Color4 (0.5' 1.0' 0.5' alpha);  		else  			GL.Color4 (0.0' 0.5' 1.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		GL.Color4 (0.0' 0.0' 0.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.Enable (EnableCap.CullFace);  	GL.PopAttrib ();  	GL.Color4 (Color.White);  	waterboxDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!waterboxesDirty && waterboxDL != null) {  	waterboxDL.Render ();  } else {  	waterboxesDirty = false;  	if (waterboxDL != null)  		waterboxDL.Dispose ();  	waterboxDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.Disable (EnableCap.CullFace);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		if (wb == currentWaterbox && cbWaterboxes.Visible)  			GL.Color4 (0.5' 1.0' 0.5' alpha);  		else  			GL.Color4 (0.0' 0.5' 1.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		GL.Color4 (0.0' 0.0' 0.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.Enable (EnableCap.CullFace);  	GL.PopAttrib ();  	GL.Color4 (Color.White);  	waterboxDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!waterboxesDirty && waterboxDL != null) {  	waterboxDL.Render ();  } else {  	waterboxesDirty = false;  	if (waterboxDL != null)  		waterboxDL.Dispose ();  	waterboxDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.Disable (EnableCap.CullFace);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		if (wb == currentWaterbox && cbWaterboxes.Visible)  			GL.Color4 (0.5' 1.0' 0.5' alpha);  		else  			GL.Color4 (0.0' 0.5' 1.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		GL.Color4 (0.0' 0.0' 0.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.Enable (EnableCap.CullFace);  	GL.PopAttrib ();  	GL.Color4 (Color.White);  	waterboxDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!waterboxesDirty && waterboxDL != null) {  	waterboxDL.Render ();  } else {  	waterboxesDirty = false;  	if (waterboxDL != null)  		waterboxDL.Dispose ();  	waterboxDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.Disable (EnableCap.CullFace);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		if (wb == currentWaterbox && cbWaterboxes.Visible)  			GL.Color4 (0.5' 1.0' 0.5' alpha);  		else  			GL.Color4 (0.0' 0.5' 1.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		GL.Color4 (0.0' 0.0' 0.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.Enable (EnableCap.CullFace);  	GL.PopAttrib ();  	GL.Color4 (Color.White);  	waterboxDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!waterboxesDirty && waterboxDL != null) {  	waterboxDL.Render ();  } else {  	waterboxesDirty = false;  	if (waterboxDL != null)  		waterboxDL.Dispose ();  	waterboxDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.Disable (EnableCap.CullFace);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		if (wb == currentWaterbox && cbWaterboxes.Visible)  			GL.Color4 (0.5' 1.0' 0.5' alpha);  		else  			GL.Color4 (0.0' 0.5' 1.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		GL.Color4 (0.0' 0.0' 0.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.Enable (EnableCap.CullFace);  	GL.PopAttrib ();  	GL.Color4 (Color.White);  	waterboxDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (!waterboxesDirty && waterboxDL != null) {  	waterboxDL.Render ();  } else {  	waterboxesDirty = false;  	if (waterboxDL != null)  		waterboxDL.Dispose ();  	waterboxDL = new DisplayList (ListMode.CompileAndExecute);  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (supportsGenProgramsARB)  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (supportsCreateShader)  		GL.UseProgram (0);  	GL.Disable (EnableCap.CullFace);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		if (wb == currentWaterbox && cbWaterboxes.Visible)  			GL.Color4 (0.5' 1.0' 0.5' alpha);  		else  			GL.Color4 (0.0' 0.5' 1.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.PolygonMode (MaterialFace.FrontAndBack' PolygonMode.Line);  	GL.LineWidth (2.0f);  	GL.Begin (PrimitiveType.Quads);  	foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  		double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  		GL.Color4 (0.0' 0.0' 0.0' alpha);  		wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  	}  	GL.End ();  	GL.Enable (EnableCap.CullFace);  	GL.PopAttrib ();  	GL.Color4 (Color.White);  	waterboxDL.End ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  	double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  	if (wb == currentWaterbox && cbWaterboxes.Visible)  		GL.Color4 (0.5' 1.0' 0.5' alpha);  	else  		GL.Color4 (0.0' 0.5' 1.0' alpha);  	wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  	double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  	if (wb == currentWaterbox && cbWaterboxes.Visible)  		GL.Color4 (0.5' 1.0' 0.5' alpha);  	else  		GL.Color4 (0.0' 0.5' 1.0' alpha);  	wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  	double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  	if (wb == currentWaterbox && cbWaterboxes.Visible)  		GL.Color4 (0.5' 1.0' 0.5' alpha);  	else  		GL.Color4 (0.0' 0.5' 1.0' alpha);  	wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  	double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  	if (wb == currentWaterbox && cbWaterboxes.Visible)  		GL.Color4 (0.5' 1.0' 0.5' alpha);  	else  		GL.Color4 (0.0' 0.5' 1.0' alpha);  	wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  	double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  	if (wb == currentWaterbox && cbWaterboxes.Visible)  		GL.Color4 (0.5' 1.0' 0.5' alpha);  	else  		GL.Color4 (0.0' 0.5' 1.0' alpha);  	wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (wb == currentWaterbox && cbWaterboxes.Visible)  	GL.Color4 (0.5' 1.0' 0.5' alpha);  else  	GL.Color4 (0.0' 0.5' 1.0' alpha);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (wb == currentWaterbox && cbWaterboxes.Visible)  	GL.Color4 (0.5' 1.0' 0.5' alpha);  else  	GL.Color4 (0.0' 0.5' 1.0' alpha);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: if (wb == currentWaterbox && cbWaterboxes.Visible)  	GL.Color4 (0.5' 1.0' 0.5' alpha);  else  	GL.Color4 (0.0' 0.5' 1.0' alpha);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color4 (0.5' 1.0' 0.5' alpha);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color4 (0.5' 1.0' 0.5' alpha);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: GL.Color4 (0.0' 0.5' 1.0' alpha);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  	double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  	GL.Color4 (0.0' 0.0' 0.0' alpha);  	wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_Paint,The following statement contains a magic number: foreach (HeaderCommands.Collision.Waterbox wb in currentScene.GetActiveCollision ().Waterboxes) {  	double alpha = ((Configuration.ShowWaterboxesPerRoom && currentRoom != null && (wb.RoomNumber != currentRoom.Number && wb.RoomNumber != 0x3F)) ? 0.1 : 0.5);  	GL.Color4 (0.0' 0.0' 0.0' alpha);  	wb.Render (HeaderCommands.PickableObjectRenderType.Normal);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderTextOverlay,The following statement contains a magic number: if (!Configuration.OGLVSync)  	glText.Print (string.Format (System.Globalization.CultureInfo.InvariantCulture' "{0:0.00} FPS"' fpsMonitor.Value)' new Vector2d (10.0' 10.0)' Color.FromArgb (128' Color.Black));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderTextOverlay,The following statement contains a magic number: if (!Configuration.OGLVSync)  	glText.Print (string.Format (System.Globalization.CultureInfo.InvariantCulture' "{0:0.00} FPS"' fpsMonitor.Value)' new Vector2d (10.0' 10.0)' Color.FromArgb (128' Color.Black));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderTextOverlay,The following statement contains a magic number: if (!Configuration.OGLVSync)  	glText.Print (string.Format (System.Globalization.CultureInfo.InvariantCulture' "{0:0.00} FPS"' fpsMonitor.Value)' new Vector2d (10.0' 10.0)' Color.FromArgb (128' Color.Black));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderTextOverlay,The following statement contains a magic number: glText.Print (string.Format (System.Globalization.CultureInfo.InvariantCulture' "{0:0.00} FPS"' fpsMonitor.Value)' new Vector2d (10.0' 10.0)' Color.FromArgb (128' Color.Black));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderTextOverlay,The following statement contains a magic number: glText.Print (string.Format (System.Globalization.CultureInfo.InvariantCulture' "{0:0.00} FPS"' fpsMonitor.Value)' new Vector2d (10.0' 10.0)' Color.FromArgb (128' Color.Black));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,RenderTextOverlay,The following statement contains a magic number: glText.Print (string.Format (System.Globalization.CultureInfo.InvariantCulture' "{0:0.00} FPS"' fpsMonitor.Value)' new Vector2d (10.0' 10.0)' Color.FromArgb (128' Color.Black));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,DoPicking,The following statement contains a magic number: GL.ReadPixels (x' viewport [3] - y' 1' 1' PixelFormat.Rgba' PixelType.UnsignedByte' pixel);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (pickedObject == null)  	camera.MouseMove (new Vector2d (e.X' e.Y));  else {  	// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  	/* Speed modifiers */double movemod = 3.0;  	if (keysDown [(ushort)Keys.Space])  		movemod = 8.0;  	else if (keysDown [(ushort)Keys.ShiftKey])  		movemod = 1.0;  	/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  	pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  	/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  		return;  	/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  	double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  	/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  	if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  		/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  		objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  		camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  		/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  		objpos.Y -= (pickObjDisplacement.Y);  		objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  		camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  		camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	}  	/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  	objpos.Y = Math.Round (objpos.Y' 0);  	objpos.Z = Math.Round (objpos.Z' 0);  	pickedObject.Position = objpos;  	/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  		foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  			for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  				dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  		}  	} else if (pickedObject is HeaderCommands.Actors.Entry) {  		HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  		if (actor.IsSpawnPoint)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  		else if (actor.IsTransitionActor)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  		else  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  	} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  		waterboxesDirty = true;  		RefreshWaterboxControls ();  	}  	pickObjLastPosition = pickObjPosition;  	((Control)sender).Focus ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (pickedObject == null)  	camera.MouseMove (new Vector2d (e.X' e.Y));  else {  	// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  	/* Speed modifiers */double movemod = 3.0;  	if (keysDown [(ushort)Keys.Space])  		movemod = 8.0;  	else if (keysDown [(ushort)Keys.ShiftKey])  		movemod = 1.0;  	/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  	pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  	/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  		return;  	/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  	double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  	/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  	if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  		/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  		objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  		camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  		/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  		objpos.Y -= (pickObjDisplacement.Y);  		objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  		camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  		camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	}  	/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  	objpos.Y = Math.Round (objpos.Y' 0);  	objpos.Z = Math.Round (objpos.Z' 0);  	pickedObject.Position = objpos;  	/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  		foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  			for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  				dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  		}  	} else if (pickedObject is HeaderCommands.Actors.Entry) {  		HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  		if (actor.IsSpawnPoint)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  		else if (actor.IsTransitionActor)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  		else  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  	} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  		waterboxesDirty = true;  		RefreshWaterboxControls ();  	}  	pickObjLastPosition = pickObjPosition;  	((Control)sender).Focus ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (pickedObject == null)  	camera.MouseMove (new Vector2d (e.X' e.Y));  else {  	// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  	/* Speed modifiers */double movemod = 3.0;  	if (keysDown [(ushort)Keys.Space])  		movemod = 8.0;  	else if (keysDown [(ushort)Keys.ShiftKey])  		movemod = 1.0;  	/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  	pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  	/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  		return;  	/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  	double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  	/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  	if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  		/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  		objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  		camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  		/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  		objpos.Y -= (pickObjDisplacement.Y);  		objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  		camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  		camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	}  	/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  	objpos.Y = Math.Round (objpos.Y' 0);  	objpos.Z = Math.Round (objpos.Z' 0);  	pickedObject.Position = objpos;  	/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  		foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  			for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  				dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  		}  	} else if (pickedObject is HeaderCommands.Actors.Entry) {  		HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  		if (actor.IsSpawnPoint)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  		else if (actor.IsTransitionActor)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  		else  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  	} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  		waterboxesDirty = true;  		RefreshWaterboxControls ();  	}  	pickObjLastPosition = pickObjPosition;  	((Control)sender).Focus ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (pickedObject == null)  	camera.MouseMove (new Vector2d (e.X' e.Y));  else {  	// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  	/* Speed modifiers */double movemod = 3.0;  	if (keysDown [(ushort)Keys.Space])  		movemod = 8.0;  	else if (keysDown [(ushort)Keys.ShiftKey])  		movemod = 1.0;  	/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  	pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  	/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  		return;  	/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  	double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  	/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  	if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  		/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  		objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  		camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  		/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  		objpos.Y -= (pickObjDisplacement.Y);  		objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  		camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  		camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	}  	/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  	objpos.Y = Math.Round (objpos.Y' 0);  	objpos.Z = Math.Round (objpos.Z' 0);  	pickedObject.Position = objpos;  	/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  		foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  			for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  				dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  		}  	} else if (pickedObject is HeaderCommands.Actors.Entry) {  		HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  		if (actor.IsSpawnPoint)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  		else if (actor.IsTransitionActor)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  		else  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  	} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  		waterboxesDirty = true;  		RefreshWaterboxControls ();  	}  	pickObjLastPosition = pickObjPosition;  	((Control)sender).Focus ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (pickedObject == null)  	camera.MouseMove (new Vector2d (e.X' e.Y));  else {  	// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  	/* Speed modifiers */double movemod = 3.0;  	if (keysDown [(ushort)Keys.Space])  		movemod = 8.0;  	else if (keysDown [(ushort)Keys.ShiftKey])  		movemod = 1.0;  	/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  	pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  	/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  		return;  	/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  	double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  	/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  	if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  		/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  		objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  		camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  		/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  		objpos.Y -= (pickObjDisplacement.Y);  		objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  		camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  		camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	}  	/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  	objpos.Y = Math.Round (objpos.Y' 0);  	objpos.Z = Math.Round (objpos.Z' 0);  	pickedObject.Position = objpos;  	/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  		foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  			for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  				dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  		}  	} else if (pickedObject is HeaderCommands.Actors.Entry) {  		HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  		if (actor.IsSpawnPoint)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  		else if (actor.IsTransitionActor)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  		else  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  	} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  		waterboxesDirty = true;  		RefreshWaterboxControls ();  	}  	pickObjLastPosition = pickObjPosition;  	((Control)sender).Focus ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (pickedObject == null)  	camera.MouseMove (new Vector2d (e.X' e.Y));  else {  	// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  	/* Speed modifiers */double movemod = 3.0;  	if (keysDown [(ushort)Keys.Space])  		movemod = 8.0;  	else if (keysDown [(ushort)Keys.ShiftKey])  		movemod = 1.0;  	/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  	pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  	/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  		return;  	/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  	double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  	/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  	if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  		/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  		objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  		camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  		/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  		objpos.Y -= (pickObjDisplacement.Y);  		objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  		camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  		camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	}  	/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  	objpos.Y = Math.Round (objpos.Y' 0);  	objpos.Z = Math.Round (objpos.Z' 0);  	pickedObject.Position = objpos;  	/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  		foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  			for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  				dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  		}  	} else if (pickedObject is HeaderCommands.Actors.Entry) {  		HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  		if (actor.IsSpawnPoint)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  		else if (actor.IsTransitionActor)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  		else  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  	} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  		waterboxesDirty = true;  		RefreshWaterboxControls ();  	}  	pickObjLastPosition = pickObjPosition;  	((Control)sender).Focus ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (pickedObject == null)  	camera.MouseMove (new Vector2d (e.X' e.Y));  else {  	// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  	/* Speed modifiers */double movemod = 3.0;  	if (keysDown [(ushort)Keys.Space])  		movemod = 8.0;  	else if (keysDown [(ushort)Keys.ShiftKey])  		movemod = 1.0;  	/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  	pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  	/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  		return;  	/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  	double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  	/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  	if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  		/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  		objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  		camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  		/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  		objpos.Y -= (pickObjDisplacement.Y);  		objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  		camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  		camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	}  	/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  	objpos.Y = Math.Round (objpos.Y' 0);  	objpos.Z = Math.Round (objpos.Z' 0);  	pickedObject.Position = objpos;  	/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  		foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  			for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  				dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  		}  	} else if (pickedObject is HeaderCommands.Actors.Entry) {  		HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  		if (actor.IsSpawnPoint)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  		else if (actor.IsTransitionActor)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  		else  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  	} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  		waterboxesDirty = true;  		RefreshWaterboxControls ();  	}  	pickObjLastPosition = pickObjPosition;  	((Control)sender).Focus ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (pickedObject == null)  	camera.MouseMove (new Vector2d (e.X' e.Y));  else {  	// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  	/* Speed modifiers */double movemod = 3.0;  	if (keysDown [(ushort)Keys.Space])  		movemod = 8.0;  	else if (keysDown [(ushort)Keys.ShiftKey])  		movemod = 1.0;  	/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  	pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  	/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  		return;  	/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  	double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  	/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  	if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  		/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  		objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  		camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  		/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  		objpos.Y -= (pickObjDisplacement.Y);  		objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  		camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  		camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	}  	/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  	objpos.Y = Math.Round (objpos.Y' 0);  	objpos.Z = Math.Round (objpos.Z' 0);  	pickedObject.Position = objpos;  	/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  		foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  			for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  				dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  		}  	} else if (pickedObject is HeaderCommands.Actors.Entry) {  		HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  		if (actor.IsSpawnPoint)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  		else if (actor.IsTransitionActor)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  		else  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  	} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  		waterboxesDirty = true;  		RefreshWaterboxControls ();  	}  	pickObjLastPosition = pickObjPosition;  	((Control)sender).Focus ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (pickedObject == null)  	camera.MouseMove (new Vector2d (e.X' e.Y));  else {  	// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  	/* Speed modifiers */double movemod = 3.0;  	if (keysDown [(ushort)Keys.Space])  		movemod = 8.0;  	else if (keysDown [(ushort)Keys.ShiftKey])  		movemod = 1.0;  	/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  	pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  	/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  		return;  	/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  	double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  	/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  	if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  		/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  		objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  		camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  		/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  		objpos.Y -= (pickObjDisplacement.Y);  		objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  		camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  		camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	}  	/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  	objpos.Y = Math.Round (objpos.Y' 0);  	objpos.Z = Math.Round (objpos.Z' 0);  	pickedObject.Position = objpos;  	/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  		foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  			for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  				dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  		}  	} else if (pickedObject is HeaderCommands.Actors.Entry) {  		HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  		if (actor.IsSpawnPoint)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  		else if (actor.IsTransitionActor)  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  		else  			XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  	} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  		waterboxesDirty = true;  		RefreshWaterboxControls ();  	}  	pickObjLastPosition = pickObjPosition;  	((Control)sender).Focus ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (keysDown [(ushort)Keys.Space])  	movemod = 8.0;  else if (keysDown [(ushort)Keys.ShiftKey])  	movemod = 1.0;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: movemod = 8.0;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  	/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  	objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  	camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  } else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  	/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  	objpos.Y -= (pickObjDisplacement.Y);  	objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  	camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  	camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  	/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  	objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  	camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  } else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  	/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  	objpos.Y -= (pickObjDisplacement.Y);  	objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  	camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  	camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  	/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  	objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  	camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  } else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  	/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  	objpos.Y -= (pickObjDisplacement.Y);  	objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  	camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  	camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  	/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  	objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  	camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  } else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  	/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  	objpos.Y -= (pickObjDisplacement.Y);  	objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  	camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  	camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  	/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  	objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  	camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  	camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  } else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  	/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  	objpos.Y -= (pickObjDisplacement.Y);  	objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  	camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  	camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  	/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  	objpos.Y -= (pickObjDisplacement.Y);  	objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  	camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  	camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  	/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  	objpos.Y -= (pickObjDisplacement.Y);  	objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  	camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  	camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  	/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  	objpos.Y -= (pickObjDisplacement.Y);  	objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  	camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  	camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  	camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following statement contains a magic number: camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: if (cdlg.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	vertex.Colors [0] = cdlg.Color.R;  	vertex.Colors [1] = cdlg.Color.G;  	vertex.Colors [2] = cdlg.Color.B;  	vertex.Colors [3] = cdlg.Color.A;  	// KLUDGE! Write to local room data HERE for rendering' write to ROM in SimpleF3DEX2.Vertex' the vertex.Store(...) below  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 12] = vertex.Colors [0];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 13] = vertex.Colors [1];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  	vertex.Store (individualFileMode ? null : rom.Data' (int)currentRoom.Start);  	displayListsDirty = true;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: if (cdlg.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	vertex.Colors [0] = cdlg.Color.R;  	vertex.Colors [1] = cdlg.Color.G;  	vertex.Colors [2] = cdlg.Color.B;  	vertex.Colors [3] = cdlg.Color.A;  	// KLUDGE! Write to local room data HERE for rendering' write to ROM in SimpleF3DEX2.Vertex' the vertex.Store(...) below  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 12] = vertex.Colors [0];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 13] = vertex.Colors [1];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  	vertex.Store (individualFileMode ? null : rom.Data' (int)currentRoom.Start);  	displayListsDirty = true;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: if (cdlg.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	vertex.Colors [0] = cdlg.Color.R;  	vertex.Colors [1] = cdlg.Color.G;  	vertex.Colors [2] = cdlg.Color.B;  	vertex.Colors [3] = cdlg.Color.A;  	// KLUDGE! Write to local room data HERE for rendering' write to ROM in SimpleF3DEX2.Vertex' the vertex.Store(...) below  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 12] = vertex.Colors [0];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 13] = vertex.Colors [1];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  	vertex.Store (individualFileMode ? null : rom.Data' (int)currentRoom.Start);  	displayListsDirty = true;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: if (cdlg.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	vertex.Colors [0] = cdlg.Color.R;  	vertex.Colors [1] = cdlg.Color.G;  	vertex.Colors [2] = cdlg.Color.B;  	vertex.Colors [3] = cdlg.Color.A;  	// KLUDGE! Write to local room data HERE for rendering' write to ROM in SimpleF3DEX2.Vertex' the vertex.Store(...) below  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 12] = vertex.Colors [0];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 13] = vertex.Colors [1];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  	vertex.Store (individualFileMode ? null : rom.Data' (int)currentRoom.Start);  	displayListsDirty = true;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: if (cdlg.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	vertex.Colors [0] = cdlg.Color.R;  	vertex.Colors [1] = cdlg.Color.G;  	vertex.Colors [2] = cdlg.Color.B;  	vertex.Colors [3] = cdlg.Color.A;  	// KLUDGE! Write to local room data HERE for rendering' write to ROM in SimpleF3DEX2.Vertex' the vertex.Store(...) below  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 12] = vertex.Colors [0];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 13] = vertex.Colors [1];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  	vertex.Store (individualFileMode ? null : rom.Data' (int)currentRoom.Start);  	displayListsDirty = true;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: if (cdlg.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	vertex.Colors [0] = cdlg.Color.R;  	vertex.Colors [1] = cdlg.Color.G;  	vertex.Colors [2] = cdlg.Color.B;  	vertex.Colors [3] = cdlg.Color.A;  	// KLUDGE! Write to local room data HERE for rendering' write to ROM in SimpleF3DEX2.Vertex' the vertex.Store(...) below  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 12] = vertex.Colors [0];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 13] = vertex.Colors [1];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  	vertex.Store (individualFileMode ? null : rom.Data' (int)currentRoom.Start);  	displayListsDirty = true;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: if (cdlg.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	vertex.Colors [0] = cdlg.Color.R;  	vertex.Colors [1] = cdlg.Color.G;  	vertex.Colors [2] = cdlg.Color.B;  	vertex.Colors [3] = cdlg.Color.A;  	// KLUDGE! Write to local room data HERE for rendering' write to ROM in SimpleF3DEX2.Vertex' the vertex.Store(...) below  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 12] = vertex.Colors [0];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 13] = vertex.Colors [1];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  	vertex.Store (individualFileMode ? null : rom.Data' (int)currentRoom.Start);  	displayListsDirty = true;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: if (cdlg.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  	vertex.Colors [0] = cdlg.Color.R;  	vertex.Colors [1] = cdlg.Color.G;  	vertex.Colors [2] = cdlg.Color.B;  	vertex.Colors [3] = cdlg.Color.A;  	// KLUDGE! Write to local room data HERE for rendering' write to ROM in SimpleF3DEX2.Vertex' the vertex.Store(...) below  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 12] = vertex.Colors [0];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 13] = vertex.Colors [1];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  	currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  	vertex.Store (individualFileMode ? null : rom.Data' (int)currentRoom.Start);  	displayListsDirty = true;  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: vertex.Colors [2] = cdlg.Color.B;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: vertex.Colors [3] = cdlg.Color.A;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: currentRoom.Data [(vertex.Address & 0xFFFFFF) + 12] = vertex.Colors [0];  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: currentRoom.Data [(vertex.Address & 0xFFFFFF) + 13] = vertex.Colors [1];  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: currentRoom.Data [(vertex.Address & 0xFFFFFF) + 14] = vertex.Colors [2];  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,EditVertexColor,The following statement contains a magic number: currentRoom.Data [(vertex.Address & 0xFFFFFF) + 15] = vertex.Colors [3];  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvPathWaypoints_RowPostPaint,The following statement contains a magic number: using (SolidBrush b = new SolidBrush (((DataGridView)sender).RowHeadersDefaultCellStyle.ForeColor)) {  	e.Graphics.DrawString ((e.RowIndex + 1).ToString ()' e.InheritedRowStyle.Font' b' e.RowBounds.Location.X + 18' e.RowBounds.Location.Y + 4);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvPathWaypoints_RowPostPaint,The following statement contains a magic number: using (SolidBrush b = new SolidBrush (((DataGridView)sender).RowHeadersDefaultCellStyle.ForeColor)) {  	e.Graphics.DrawString ((e.RowIndex + 1).ToString ()' e.InheritedRowStyle.Font' b' e.RowBounds.Location.X + 18' e.RowBounds.Location.Y + 4);  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvPathWaypoints_RowPostPaint,The following statement contains a magic number: e.Graphics.DrawString ((e.RowIndex + 1).ToString ()' e.InheritedRowStyle.Font' b' e.RowBounds.Location.X + 18' e.RowBounds.Location.Y + 4);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,dgvPathWaypoints_RowPostPaint,The following statement contains a magic number: e.Graphics.DrawString ((e.RowIndex + 1).ToString ()' e.InheritedRowStyle.Font' b' e.RowBounds.Location.X + 18' e.RowBounds.Location.Y + 4);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,ModifyCurrentWaterbox,The following statement contains a magic number: try {  	currentWaterbox.Position = new Vector3d (double.Parse (txtWaterboxPositionX.Text)' double.Parse (txtWaterboxPositionY.Text)' double.Parse (txtWaterboxPositionZ.Text));  	currentWaterbox.SizeXZ = new Vector2d (double.Parse (txtWaterboxSizeX.Text)' double.Parse (txtWaterboxSizeZ.Text));  	currentWaterbox.RoomNumber = (ushort)(cbWaterboxRoom.SelectedItem as XMLActorDefinitionReader.Definition.Item.Option).Value;  	if (txtWaterboxProperties.Text.StartsWith ("0x"))  		currentWaterbox.Properties = ushort.Parse (txtWaterboxProperties.Text.Substring (2)' System.Globalization.NumberStyles.HexNumber);  	else  		currentWaterbox.Properties = ushort.Parse (txtWaterboxProperties.Text);  	waterboxesDirty = true;  } catch (FormatException) {  	System.Media.SystemSounds.Hand.Play ();  }  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,ModifyCurrentWaterbox,The following statement contains a magic number: if (txtWaterboxProperties.Text.StartsWith ("0x"))  	currentWaterbox.Properties = ushort.Parse (txtWaterboxProperties.Text.Substring (2)' System.Globalization.NumberStyles.HexNumber);  else  	currentWaterbox.Properties = ushort.Parse (txtWaterboxProperties.Text);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,ModifyCurrentWaterbox,The following statement contains a magic number: currentWaterbox.Properties = ushort.Parse (txtWaterboxProperties.Text.Substring (2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,xPlus45DegreesToolStripMenuItem_Click,The following statement contains a magic number: RotatePickedObject (new Vector3d (8192.0' 0.0' 0.0));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,xMinus45DegreesToolStripMenuItem_Click,The following statement contains a magic number: RotatePickedObject (new Vector3d (-8192.0' 0.0' 0.0));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,yPlus45DegreesToolStripMenuItem_Click,The following statement contains a magic number: RotatePickedObject (new Vector3d (0.0' 8192.0' 0.0));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,yMinus45DegreesToolStripMenuItem_Click,The following statement contains a magic number: RotatePickedObject (new Vector3d (0.0' -8192.0' 0.0));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,zPlus45DegreesToolStripMenuItem_Click,The following statement contains a magic number: RotatePickedObject (new Vector3d (0.0' 0.0' 8192.0));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,zMinus45DegreesToolStripMenuItem_Click,The following statement contains a magic number: RotatePickedObject (new Vector3d (0.0' 0.0' -8192.0));  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,propertiesToolStripMenuItem1_Click,The following statement contains a magic number: vertexInfo.AppendFormat ("Colors: ({0}' {1}' {2}' {3})\n"' currentRoomVertex.Colors [0]' currentRoomVertex.Colors [1]' currentRoomVertex.Colors [2]' currentRoomVertex.Colors [3]);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,propertiesToolStripMenuItem1_Click,The following statement contains a magic number: vertexInfo.AppendFormat ("Colors: ({0}' {1}' {2}' {3})\n"' currentRoomVertex.Colors [0]' currentRoomVertex.Colors [1]' currentRoomVertex.Colors [2]' currentRoomVertex.Colors [3]);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,propertiesToolStripMenuItem1_Click,The following statement contains a magic number: vertexInfo.AppendFormat ("Normals: ({0}' {1}' {2})\n"' currentRoomVertex.Normals [0]' currentRoomVertex.Normals [1]' currentRoomVertex.Normals [2]);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openGLInformationToolStripMenuItem_Click,The following statement contains a magic number: foreach (string extension in allRequiredOglExtensions)  	oglInfoString.AppendFormat ("* {0}\t{1}\n"' extension.PadRight (40)' Initialization.CheckForExtension (extension) ? "supported" : "not supported");  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,openGLInformationToolStripMenuItem_Click,The following statement contains a magic number: oglInfoString.AppendFormat ("* {0}\t{1}\n"' extension.PadRight (40)' Initialization.CheckForExtension (extension) ? "supported" : "not supported");  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size (970' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size (970' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size (37' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size (37' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.openROMToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.openROMToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.openSceneToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.openSceneToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.saveToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.saveToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem9.Size = new System.Drawing.Size (203' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem9.Size = new System.Drawing.Size (203' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.closeSceneToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.closeSceneToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem1.Size = new System.Drawing.Size (203' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem1.Size = new System.Drawing.Size (203' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.rOMInformationToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.rOMInformationToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem2.Size = new System.Drawing.Size (203' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem2.Size = new System.Drawing.Size (203' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size (206' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.editToolStripMenuItem.Size = new System.Drawing.Size (39' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.editToolStripMenuItem.Size = new System.Drawing.Size (39' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.editDataTablesToolStripMenuItem.Size = new System.Drawing.Size (175' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.editDataTablesToolStripMenuItem.Size = new System.Drawing.Size (175' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.editAreaTitleCardToolStripMenuItem.Size = new System.Drawing.Size (175' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.editAreaTitleCardToolStripMenuItem.Size = new System.Drawing.Size (175' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolsToolStripMenuItem.Size = new System.Drawing.Size (48' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolsToolStripMenuItem.Size = new System.Drawing.Size (48' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.mouseModeToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.mouseModeToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.collisionHighlightToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.collisionHighlightToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.whiteToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.whiteToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.typebasedToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.typebasedToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem7.Size = new System.Drawing.Size (189' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem7.Size = new System.Drawing.Size (189' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.resetCameraPositionToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.resetCameraPositionToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.optionsToolStripMenuItem.Size = new System.Drawing.Size (61' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.optionsToolStripMenuItem.Size = new System.Drawing.Size (61' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderElementsToolStripMenuItem.Size = new System.Drawing.Size (162' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderElementsToolStripMenuItem.Size = new System.Drawing.Size (162' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderCollisionToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderCollisionToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem3.Size = new System.Drawing.Size (219' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem3.Size = new System.Drawing.Size (219' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderRoomActorsToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderRoomActorsToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderSpawnPointsToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderSpawnPointsToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderTransitionsToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderTransitionsToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderPathWaypointsToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderPathWaypointsToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderWaterboxesToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.renderWaterboxesToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem5.Size = new System.Drawing.Size (219' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem5.Size = new System.Drawing.Size (219' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.linkAllWaypointsInPathToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.linkAllWaypointsInPathToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.showWaterboxesPerRoomToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.showWaterboxesPerRoomToolStripMenuItem.Size = new System.Drawing.Size (222' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem4.Size = new System.Drawing.Size (159' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem4.Size = new System.Drawing.Size (159' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableTexturesToolStripMenuItem.Size = new System.Drawing.Size (162' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableTexturesToolStripMenuItem.Size = new System.Drawing.Size (162' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.combinerTypeToolStripMenuItem.Size = new System.Drawing.Size (162' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.combinerTypeToolStripMenuItem.Size = new System.Drawing.Size (162' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem10.Size = new System.Drawing.Size (159' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem10.Size = new System.Drawing.Size (159' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.openGLToolStripMenuItem.Size = new System.Drawing.Size (162' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.openGLToolStripMenuItem.Size = new System.Drawing.Size (162' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableVSyncToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableVSyncToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableMipmapsToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableMipmapsToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableAntiAliasingToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.enableAntiAliasingToolStripMenuItem.Size = new System.Drawing.Size (179' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size (44' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size (44' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.checkForUpdateToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.checkForUpdateToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem8.Size = new System.Drawing.Size (189' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem8.Size = new System.Drawing.Size (189' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.openGLInformationToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.openGLInformationToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point (0' 504);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size (970' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size (970' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.TabIndex = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiToolMode.Margin = new System.Windows.Forms.Padding (3' 3' 3' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiToolMode.Margin = new System.Windows.Forms.Padding (3' 3' 3' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiToolMode.Margin = new System.Windows.Forms.Padding (3' 3' 3' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiToolMode.Margin = new System.Windows.Forms.Padding (3' 3' 3' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiToolMode.Size = new System.Drawing.Size (160' 19);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiToolMode.Size = new System.Drawing.Size (160' 19);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.separatorStripItem1.Size = new System.Drawing.Size (6' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.separatorStripItem1.Size = new System.Drawing.Size (6' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tsslStatus.Size = new System.Drawing.Size (470' 19);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tsslStatus.Size = new System.Drawing.Size (470' 19);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.separatorStripItem2.Size = new System.Drawing.Size (6' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.separatorStripItem2.Size = new System.Drawing.Size (6' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiCamCoords.Margin = new System.Windows.Forms.Padding (3' 3' 3' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiCamCoords.Margin = new System.Windows.Forms.Padding (3' 3' 3' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiCamCoords.Margin = new System.Windows.Forms.Padding (3' 3' 3' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiCamCoords.Margin = new System.Windows.Forms.Padding (3' 3' 3' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiCamCoords.Size = new System.Drawing.Size (270' 19);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.bsiCamCoords.Size = new System.Drawing.Size (270' 19);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Location = new System.Drawing.Point (640' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Location = new System.Drawing.Point (640' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Size = new System.Drawing.Size (330' 480);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Size = new System.Drawing.Size (330' 480);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.TabIndex = 3;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpScenes.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpScenes.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpScenes.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpScenes.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpScenes.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tvScenes.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tvScenes.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tvScenes.Size = new System.Drawing.Size (316' 430);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tvScenes.Size = new System.Drawing.Size (316' 430);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSceneMetadata.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSceneMetadata.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSceneMetadata.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSceneMetadata.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSceneMetadata.TabIndex = 6;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSceneMeta.ColumnCount = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSceneMeta.Controls.Add (this.lblSceneMetaReverb' 0' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSceneMeta.Controls.Add (this.nudSceneMetaReverb' 1' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSceneMeta.Controls.Add (this.label1' 0' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSceneMeta.RowCount = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSceneMeta.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSceneMeta.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaNightSFX.Location = new System.Drawing.Point (99' 30);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaNightSFX.Location = new System.Drawing.Point (99' 30);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaNightSFX.Maximum = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaNightSFX.Size = new System.Drawing.Size (58' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaNightSFX.Size = new System.Drawing.Size (58' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaNightSFX.TabIndex = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSceneMeta.SetColumnSpan (this.cbSceneMetaBGM' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSceneMetaBGM.Location = new System.Drawing.Point (99' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSceneMetaBGM.Location = new System.Drawing.Point (99' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSceneMetaBGM.Size = new System.Drawing.Size (220' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSceneMetaBGM.Size = new System.Drawing.Size (220' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaBGM.Location = new System.Drawing.Point (3' 0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaBGM.Size = new System.Drawing.Size (90' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaBGM.Size = new System.Drawing.Size (90' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaReverb.Location = new System.Drawing.Point (3' 53);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaReverb.Location = new System.Drawing.Point (3' 53);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaReverb.Size = new System.Drawing.Size (90' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaReverb.Size = new System.Drawing.Size (90' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaReverb.TabIndex = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaReverb.Location = new System.Drawing.Point (99' 56);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaReverb.Location = new System.Drawing.Point (99' 56);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaReverb.Maximum = new decimal (new int[] {  	255'  	0'  	0'  	0  });  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaReverb.Size = new System.Drawing.Size (58' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaReverb.Size = new System.Drawing.Size (58' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudSceneMetaReverb.TabIndex = 3;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaNightSFX.Location = new System.Drawing.Point (3' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaNightSFX.Location = new System.Drawing.Point (3' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaNightSFX.Size = new System.Drawing.Size (90' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaNightSFX.Size = new System.Drawing.Size (90' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSceneMetaNightSFX.TabIndex = 5;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSceneMeta.SetColumnSpan (this.label1' 4);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (3' 79);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (3' 79);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (128' 13);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (128' 13);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 6;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpRoomActors.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpRoomActors.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpRoomActors.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpRoomActors.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpRoomActors.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExRoomActors.ColumnCount = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExRoomActors.Location = new System.Drawing.Point (3' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExRoomActors.Location = new System.Drawing.Point (3' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExRoomActors.Padding = new System.Windows.Forms.Padding (0' 6' 0' 0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExRoomActors.Size = new System.Drawing.Size (316' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExRoomActors.Size = new System.Drawing.Size (316' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbActors.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbActors.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbActors.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbActors.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbActors.TabIndex = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpObjects.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpObjects.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpObjects.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpObjects.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpObjects.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpObjects.TabIndex = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.ColumnCount = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.RowCount = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size (316' 430);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.Size = new System.Drawing.Size (316' 430);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSpecialObjs.Margin = new System.Windows.Forms.Padding (0' 0' 0' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSpecialObjs.Size = new System.Drawing.Size (126' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblSpecialObjs.Size = new System.Drawing.Size (126' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel1.SetColumnSpan (this.dgvObjects' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvObjects.Location = new System.Drawing.Point (0' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvObjects.Margin = new System.Windows.Forms.Padding (0' 3' 0' 0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvObjects.Size = new System.Drawing.Size (316' 403);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvObjects.Size = new System.Drawing.Size (316' 403);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvObjects.TabIndex = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpecialObjs.Location = new System.Drawing.Point (126' 0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpecialObjs.Margin = new System.Windows.Forms.Padding (0' 0' 0' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpecialObjs.Size = new System.Drawing.Size (190' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpecialObjs.Size = new System.Drawing.Size (190' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpecialObjs.TabIndex = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSpawnPoints.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSpawnPoints.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSpawnPoints.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSpawnPoints.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSpawnPoints.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSpawnPoints.TabIndex = 3;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSpawnPoints.ColumnCount = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSpawnPoints.Location = new System.Drawing.Point (3' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSpawnPoints.Location = new System.Drawing.Point (3' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSpawnPoints.Padding = new System.Windows.Forms.Padding (0' 6' 0' 0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSpawnPoints.Size = new System.Drawing.Size (316' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSpawnPoints.Size = new System.Drawing.Size (316' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExSpawnPoints.TabIndex = 3;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpawnPoints.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpawnPoints.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpawnPoints.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpawnPoints.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbSpawnPoints.TabIndex = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpTransitions.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpTransitions.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpTransitions.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpTransitions.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpTransitions.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpTransitions.TabIndex = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExTransitions.ColumnCount = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExTransitions.Location = new System.Drawing.Point (3' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExTransitions.Location = new System.Drawing.Point (3' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExTransitions.Padding = new System.Windows.Forms.Padding (0' 6' 0' 0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExTransitions.Size = new System.Drawing.Size (316' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExTransitions.Size = new System.Drawing.Size (316' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExTransitions.TabIndex = 3;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbTransitions.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbTransitions.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbTransitions.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbTransitions.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbTransitions.TabIndex = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaypoints.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaypoints.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaypoints.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaypoints.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaypoints.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaypoints.TabIndex = 5;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.RowCount = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Size = new System.Drawing.Size (316' 430);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.Size = new System.Drawing.Size (316' 430);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tableLayoutPanel2.TabIndex = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvPathWaypoints.Location = new System.Drawing.Point (0' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvPathWaypoints.Margin = new System.Windows.Forms.Padding (0' 3' 0' 0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvPathWaypoints.Size = new System.Drawing.Size (316' 403);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvPathWaypoints.Size = new System.Drawing.Size (316' 403);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvPathWaypoints.TabIndex = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbPathHeaders.Margin = new System.Windows.Forms.Padding (0' 0' 0' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbPathHeaders.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbPathHeaders.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbPathHeaders.TabIndex = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpCollision.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpCollision.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpCollision.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpCollision.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpCollision.TabIndex = 7;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.ColumnCount = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.label2' 0' 10);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.cbCollisionPolyTypes' 0' 7);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.cbCollisionPolys' 0' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.lblColPolyType' 0' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.nudColPolyType' 1' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.lblColPolyGroundType' 0' 9);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.cbColPolyGroundTypes' 1' 9);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.lblColPolyRawData' 0' 8);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.txtColPolyRawData' 1' 8);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.btnJumpToPolyType' 1' 4);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Controls.Add (this.lblCollisionPolyTypes' 0' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.RowCount = 11;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.SetColumnSpan (this.label2' 4);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point (3' 203);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point (3' 203);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size (128' 13);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size (128' 13);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 11;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.SetColumnSpan (this.cbCollisionPolyTypes' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbCollisionPolyTypes.Location = new System.Drawing.Point (3' 125);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbCollisionPolyTypes.Location = new System.Drawing.Point (3' 125);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbCollisionPolyTypes.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbCollisionPolyTypes.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbCollisionPolyTypes.TabIndex = 5;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExCollision.SetColumnSpan (this.cbCollisionPolys' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbCollisionPolys.Location = new System.Drawing.Point (3' 23);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbCollisionPolys.Location = new System.Drawing.Point (3' 23);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbCollisionPolys.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbCollisionPolys.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyType.Location = new System.Drawing.Point (3' 47);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyType.Location = new System.Drawing.Point (3' 47);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyType.Size = new System.Drawing.Size (122' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyType.Size = new System.Drawing.Size (122' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudColPolyType.Location = new System.Drawing.Point (131' 50);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudColPolyType.Location = new System.Drawing.Point (131' 50);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudColPolyType.Size = new System.Drawing.Size (188' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudColPolyType.Size = new System.Drawing.Size (188' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.nudColPolyType.TabIndex = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyGroundType.Location = new System.Drawing.Point (3' 176);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyGroundType.Location = new System.Drawing.Point (3' 176);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyGroundType.Size = new System.Drawing.Size (122' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyGroundType.Size = new System.Drawing.Size (122' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyGroundType.TabIndex = 3;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbColPolyGroundTypes.Location = new System.Drawing.Point (131' 179);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbColPolyGroundTypes.Location = new System.Drawing.Point (131' 179);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbColPolyGroundTypes.Size = new System.Drawing.Size (188' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbColPolyGroundTypes.Size = new System.Drawing.Size (188' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbColPolyGroundTypes.TabIndex = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyRawData.Location = new System.Drawing.Point (3' 149);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyRawData.Location = new System.Drawing.Point (3' 149);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyRawData.Size = new System.Drawing.Size (122' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyRawData.Size = new System.Drawing.Size (122' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblColPolyRawData.TabIndex = 6;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtColPolyRawData.Location = new System.Drawing.Point (131' 152);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtColPolyRawData.Location = new System.Drawing.Point (131' 152);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtColPolyRawData.Size = new System.Drawing.Size (188' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtColPolyRawData.Size = new System.Drawing.Size (188' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtColPolyRawData.TabIndex = 7;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnJumpToPolyType.Location = new System.Drawing.Point (131' 76);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnJumpToPolyType.Location = new System.Drawing.Point (131' 76);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnJumpToPolyType.Size = new System.Drawing.Size (188' 23);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnJumpToPolyType.Size = new System.Drawing.Size (188' 23);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.btnJumpToPolyType.TabIndex = 8;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolys.Location = new System.Drawing.Point (3' 7);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolys.Location = new System.Drawing.Point (3' 7);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolys.Size = new System.Drawing.Size (122' 13);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolys.Size = new System.Drawing.Size (122' 13);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolys.TabIndex = 9;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolyTypes.Location = new System.Drawing.Point (3' 109);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolyTypes.Location = new System.Drawing.Point (3' 109);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolyTypes.Size = new System.Drawing.Size (122' 13);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolyTypes.Size = new System.Drawing.Size (122' 13);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblCollisionPolyTypes.TabIndex = 10;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaterboxes.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaterboxes.Location = new System.Drawing.Point (4' 40);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaterboxes.Padding = new System.Windows.Forms.Padding (3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaterboxes.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaterboxes.Size = new System.Drawing.Size (322' 436);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tpWaterboxes.TabIndex = 8;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.ColumnCount = 2;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.lblWaterboxProperties' 0' 7);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.txtWaterboxProperties' 0' 7);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.lblWaterboxPositionY' 0' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.txtWaterboxPositionY' 1' 2);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.lblWaterboxPositionZ' 0' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.txtWaterboxPositionZ' 1' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.lblWaterboxSizeX' 0' 4);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.txtWaterboxSizeX' 1' 4);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.lblWaterboxSizeZ' 0' 5);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.txtWaterboxSizeZ' 1' 5);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.lblWaterboxRoom' 0' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Controls.Add (this.cbWaterboxRoom' 1' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Location = new System.Drawing.Point (3' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Location = new System.Drawing.Point (3' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Padding = new System.Windows.Forms.Padding (0' 6' 0' 0);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.RowCount = 8;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Size = new System.Drawing.Size (316' 189);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.Size = new System.Drawing.Size (316' 189);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.tlpExWaterboxes.TabIndex = 4;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxProperties.Location = new System.Drawing.Point (3' 163);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxProperties.Location = new System.Drawing.Point (3' 163);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxProperties.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxProperties.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxProperties.TabIndex = 13;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxProperties.Location = new System.Drawing.Point (113' 166);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxProperties.Location = new System.Drawing.Point (113' 166);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxProperties.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxProperties.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxProperties.TabIndex = 14;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionX.Location = new System.Drawing.Point (3' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionX.Location = new System.Drawing.Point (3' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionX.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionX.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionX.TabIndex = 5;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionX.Location = new System.Drawing.Point (113' 9);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionX.Location = new System.Drawing.Point (113' 9);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionX.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionX.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionX.TabIndex = 6;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionY.Location = new System.Drawing.Point (3' 32);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionY.Location = new System.Drawing.Point (3' 32);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionY.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionY.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionY.TabIndex = 5;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionY.Location = new System.Drawing.Point (113' 35);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionY.Location = new System.Drawing.Point (113' 35);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionY.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionY.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionY.TabIndex = 6;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionZ.Location = new System.Drawing.Point (3' 58);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionZ.Location = new System.Drawing.Point (3' 58);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionZ.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionZ.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxPositionZ.TabIndex = 5;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionZ.Location = new System.Drawing.Point (113' 61);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionZ.Location = new System.Drawing.Point (113' 61);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionZ.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionZ.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxPositionZ.TabIndex = 6;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeX.Location = new System.Drawing.Point (3' 84);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeX.Location = new System.Drawing.Point (3' 84);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeX.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeX.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeX.TabIndex = 7;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeX.Location = new System.Drawing.Point (113' 87);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeX.Location = new System.Drawing.Point (113' 87);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeX.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeX.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeX.TabIndex = 8;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeZ.Location = new System.Drawing.Point (3' 110);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeZ.Location = new System.Drawing.Point (3' 110);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeZ.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeZ.Size = new System.Drawing.Size (104' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxSizeZ.TabIndex = 9;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeZ.Location = new System.Drawing.Point (113' 113);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeZ.Location = new System.Drawing.Point (113' 113);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeZ.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeZ.Size = new System.Drawing.Size (200' 20);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.txtWaterboxSizeZ.TabIndex = 10;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxRoom.Location = new System.Drawing.Point (3' 136);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxRoom.Location = new System.Drawing.Point (3' 136);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxRoom.Size = new System.Drawing.Size (104' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxRoom.Size = new System.Drawing.Size (104' 27);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.lblWaterboxRoom.TabIndex = 11;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxRoom.Location = new System.Drawing.Point (113' 139);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxRoom.Location = new System.Drawing.Point (113' 139);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxRoom.Size = new System.Drawing.Size (200' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxRoom.Size = new System.Drawing.Size (200' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxRoom.TabIndex = 12;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxes.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxes.Location = new System.Drawing.Point (3' 3);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxes.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxes.Size = new System.Drawing.Size (316' 21);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cbWaterboxes.TabIndex = 3;  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmsMoveableObjectEdit.Size = new System.Drawing.Size (119' 54);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmsMoveableObjectEdit.Size = new System.Drawing.Size (119' 54);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.deselectToolStripMenuItem.Size = new System.Drawing.Size (118' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.deselectToolStripMenuItem.Size = new System.Drawing.Size (118' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem6.Size = new System.Drawing.Size (115' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem6.Size = new System.Drawing.Size (115' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.rotateToolStripMenuItem.Size = new System.Drawing.Size (118' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.rotateToolStripMenuItem.Size = new System.Drawing.Size (118' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.xAxisToolStripMenuItem.Size = new System.Drawing.Size (105' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.xAxisToolStripMenuItem.Size = new System.Drawing.Size (105' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.xPlus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.xPlus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.xMinus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.xMinus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.yAxisToolStripMenuItem.Size = new System.Drawing.Size (105' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.yAxisToolStripMenuItem.Size = new System.Drawing.Size (105' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.yPlus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.yPlus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.yMinus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.yMinus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zAxisToolStripMenuItem.Size = new System.Drawing.Size (105' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zAxisToolStripMenuItem.Size = new System.Drawing.Size (105' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zPlus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zPlus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zMinus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.zMinus45DegreesToolStripMenuItem.Size = new System.Drawing.Size (139' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmsSceneTree.Size = new System.Drawing.Size (128' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmsSceneTree.Size = new System.Drawing.Size (128' 26);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.propertiesToolStripMenuItem.Size = new System.Drawing.Size (127' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.propertiesToolStripMenuItem.Size = new System.Drawing.Size (127' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.customGLControl.Location = new System.Drawing.Point (0' 24);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.customGLControl.Size = new System.Drawing.Size (640' 480);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.customGLControl.Size = new System.Drawing.Size (640' 480);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmsVertexEdit.Size = new System.Drawing.Size (157' 54);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.cmsVertexEdit.Size = new System.Drawing.Size (157' 54);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.changeColorToolStripMenuItem.Size = new System.Drawing.Size (156' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.changeColorToolStripMenuItem.Size = new System.Drawing.Size (156' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem11.Size = new System.Drawing.Size (153' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem11.Size = new System.Drawing.Size (153' 6);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.propertiesToolStripMenuItem1.Size = new System.Drawing.Size (156' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.propertiesToolStripMenuItem1.Size = new System.Drawing.Size (156' 22);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (970' 528);  
Magic Number,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (970' 528);  
Magic Number,SceneNavi,Program,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Program.cs,Main,The following statement contains a magic number: if (Configuration.IsRestarting) {  	Configuration.IsRestarting = false;  	Thread.Sleep (3000);  }  
Magic Number,SceneNavi,Program,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Program.cs,Main,The following statement contains a magic number: Thread.Sleep (3000);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellParsing,The following statement contains a magic number: if (dgv.Columns [e.ColumnIndex].Name == "SceneNumber" || dgv.Columns [e.ColumnIndex].Name == "EntranceNumber" || dgv.Columns [e.ColumnIndex].Name == "Variable" || dgv.Columns [e.ColumnIndex].Name == "Fade") {  	if (e != null && e.Value != null && e.DesiredType.Equals (typeof(byte))) {  		string str = (e.Value as string);  		bool ishex = str.StartsWith ("0x");  		byte val = 0;  		if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  			e.Value = val;  			e.ParsingApplied = true;  		}  	}  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellParsing,The following statement contains a magic number: if (e != null && e.Value != null && e.DesiredType.Equals (typeof(byte))) {  	string str = (e.Value as string);  	bool ishex = str.StartsWith ("0x");  	byte val = 0;  	if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  		e.Value = val;  		e.ParsingApplied = true;  	}  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvEntranceTable_CellParsing,The following statement contains a magic number: if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  	e.Value = val;  	e.ParsingApplied = true;  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The following statement contains a magic number: if (dgv.Columns [e.ColumnIndex].Name == "LabelStartAddress" || dgv.Columns [e.ColumnIndex].Name == "LabelEndAddress" || dgv.Columns [e.ColumnIndex].Name == "Unknown1" || dgv.Columns [e.ColumnIndex].Name == "ConfigurationNo" || dgv.Columns [e.ColumnIndex].Name == "Unknown3" || dgv.Columns [e.ColumnIndex].Name == "Unknown4" || dgv.Columns [e.ColumnIndex].Name == "Unknown2" || dgv.Columns [e.ColumnIndex].Name == "PresumedPadding") {  	if (e != null && e.Value != null) {  		string str = (e.Value as string);  		bool ishex = str.StartsWith ("0x");  		if (e.DesiredType.Equals (typeof(byte))) {  			byte val = 0;  			if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  				e.Value = val;  				e.ParsingApplied = true;  			}  		} else if (e.DesiredType.Equals (typeof(uint))) {  			uint val = 0;  			if (uint.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  				e.Value = val;  				e.ParsingApplied = true;  			}  		}  	}  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The following statement contains a magic number: if (dgv.Columns [e.ColumnIndex].Name == "LabelStartAddress" || dgv.Columns [e.ColumnIndex].Name == "LabelEndAddress" || dgv.Columns [e.ColumnIndex].Name == "Unknown1" || dgv.Columns [e.ColumnIndex].Name == "ConfigurationNo" || dgv.Columns [e.ColumnIndex].Name == "Unknown3" || dgv.Columns [e.ColumnIndex].Name == "Unknown4" || dgv.Columns [e.ColumnIndex].Name == "Unknown2" || dgv.Columns [e.ColumnIndex].Name == "PresumedPadding") {  	if (e != null && e.Value != null) {  		string str = (e.Value as string);  		bool ishex = str.StartsWith ("0x");  		if (e.DesiredType.Equals (typeof(byte))) {  			byte val = 0;  			if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  				e.Value = val;  				e.ParsingApplied = true;  			}  		} else if (e.DesiredType.Equals (typeof(uint))) {  			uint val = 0;  			if (uint.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  				e.Value = val;  				e.ParsingApplied = true;  			}  		}  	}  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The following statement contains a magic number: if (e != null && e.Value != null) {  	string str = (e.Value as string);  	bool ishex = str.StartsWith ("0x");  	if (e.DesiredType.Equals (typeof(byte))) {  		byte val = 0;  		if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  			e.Value = val;  			e.ParsingApplied = true;  		}  	} else if (e.DesiredType.Equals (typeof(uint))) {  		uint val = 0;  		if (uint.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  			e.Value = val;  			e.ParsingApplied = true;  		}  	}  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The following statement contains a magic number: if (e != null && e.Value != null) {  	string str = (e.Value as string);  	bool ishex = str.StartsWith ("0x");  	if (e.DesiredType.Equals (typeof(byte))) {  		byte val = 0;  		if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  			e.Value = val;  			e.ParsingApplied = true;  		}  	} else if (e.DesiredType.Equals (typeof(uint))) {  		uint val = 0;  		if (uint.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  			e.Value = val;  			e.ParsingApplied = true;  		}  	}  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The following statement contains a magic number: if (e.DesiredType.Equals (typeof(byte))) {  	byte val = 0;  	if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  		e.Value = val;  		e.ParsingApplied = true;  	}  } else if (e.DesiredType.Equals (typeof(uint))) {  	uint val = 0;  	if (uint.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  		e.Value = val;  		e.ParsingApplied = true;  	}  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The following statement contains a magic number: if (e.DesiredType.Equals (typeof(byte))) {  	byte val = 0;  	if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  		e.Value = val;  		e.ParsingApplied = true;  	}  } else if (e.DesiredType.Equals (typeof(uint))) {  	uint val = 0;  	if (uint.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  		e.Value = val;  		e.ParsingApplied = true;  	}  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The following statement contains a magic number: if (byte.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  	e.Value = val;  	e.ParsingApplied = true;  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The following statement contains a magic number: if (e.DesiredType.Equals (typeof(uint))) {  	uint val = 0;  	if (uint.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  		e.Value = val;  		e.ParsingApplied = true;  	}  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,dgvSceneTable_CellParsing,The following statement contains a magic number: if (uint.TryParse ((ishex ? str.Substring (2) : str)' (ishex ? System.Globalization.NumberStyles.AllowHexSpecifier : System.Globalization.NumberStyles.None)' System.Globalization.CultureInfo.InvariantCulture' out val)) {  	e.Value = val;  	e.ParsingApplied = true;  }  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvEntranceTable.Size = new System.Drawing.Size (562' 390);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvEntranceTable.Size = new System.Drawing.Size (562' 390);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Location = new System.Drawing.Point (12' 45);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Location = new System.Drawing.Point (12' 45);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Size = new System.Drawing.Size (570' 416);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Size = new System.Drawing.Size (570' 416);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tpExitTable.Location = new System.Drawing.Point (4' 22);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tpExitTable.Location = new System.Drawing.Point (4' 22);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tpExitTable.Size = new System.Drawing.Size (562' 390);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tpExitTable.Size = new System.Drawing.Size (562' 390);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSceneTable.Location = new System.Drawing.Point (4' 22);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSceneTable.Location = new System.Drawing.Point (4' 22);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSceneTable.Size = new System.Drawing.Size (562' 390);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.tpSceneTable.Size = new System.Drawing.Size (562' 390);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvSceneTable.Size = new System.Drawing.Size (562' 390);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.dgvSceneTable.Size = new System.Drawing.Size (562' 390);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Location = new System.Drawing.Point (497' 467);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Location = new System.Drawing.Point (497' 467);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Size = new System.Drawing.Size (85' 23);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Size = new System.Drawing.Size (85' 23);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.TabIndex = 2;  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (13' 9);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (13' 9);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Padding = new System.Windows.Forms.Padding (0' 0' 0' 6);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (569' 33);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (569' 33);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (594' 502);  
Magic Number,SceneNavi,TableEditorForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TableEditorForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (594' 502);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,ReadImageFromROM,The following statement contains a magic number: SimpleF3DEX2.ImageHelper.IA8 (titleCardWidth' titleCardHeight' (titleCardWidth / 8)' ROM.Data' (int)Scene.LabelStartAddress' ref textureBuffer);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,ReadImageFromROM,The following statement contains a magic number: pbTitleCard.ClientSize = new Size (titleCardWidth * 2' titleCardHeight * 2);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,ReadImageFromROM,The following statement contains a magic number: pbTitleCard.ClientSize = new Size (titleCardWidth * 2' titleCardHeight * 2);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,pbTitleCard_Paint,The following statement contains a magic number: e.Graphics.DrawImage (output' new Rectangle (outputRect.X' outputRect.Y' outputRect.Width * 2' outputRect.Height * 2)' outputRect' GraphicsUnit.Pixel);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,pbTitleCard_Paint,The following statement contains a magic number: e.Graphics.DrawImage (output' new Rectangle (outputRect.X' outputRect.Y' outputRect.Width * 2' outputRect.Height * 2)' outputRect' GraphicsUnit.Pixel);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,ImportImage,The following statement contains a magic number: for (int y = 0; y < import.Height; y++) {  	for (int x = 0; x < import.Width; x++) {  		Color pixelColor = import.GetPixel (x' y);  		int intensity = (pixelColor.R + pixelColor.G + pixelColor.B) / 3;  		Color newColor = Color.FromArgb (pixelColor.A' intensity' intensity' intensity);  		import.SetPixel (x' y' newColor);  		byte packed = (byte)(((byte)intensity).Scale (0' 0xFF' 0' 0xF) << 4);  		packed |= (byte)(pixelColor.A.Scale (0' 0xFF' 0' 0xF));  		ROM.Data [offset] = packed;  		offset++;  	}  }  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,ImportImage,The following statement contains a magic number: for (int y = 0; y < import.Height; y++) {  	for (int x = 0; x < import.Width; x++) {  		Color pixelColor = import.GetPixel (x' y);  		int intensity = (pixelColor.R + pixelColor.G + pixelColor.B) / 3;  		Color newColor = Color.FromArgb (pixelColor.A' intensity' intensity' intensity);  		import.SetPixel (x' y' newColor);  		byte packed = (byte)(((byte)intensity).Scale (0' 0xFF' 0' 0xF) << 4);  		packed |= (byte)(pixelColor.A.Scale (0' 0xFF' 0' 0xF));  		ROM.Data [offset] = packed;  		offset++;  	}  }  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,ImportImage,The following statement contains a magic number: for (int x = 0; x < import.Width; x++) {  	Color pixelColor = import.GetPixel (x' y);  	int intensity = (pixelColor.R + pixelColor.G + pixelColor.B) / 3;  	Color newColor = Color.FromArgb (pixelColor.A' intensity' intensity' intensity);  	import.SetPixel (x' y' newColor);  	byte packed = (byte)(((byte)intensity).Scale (0' 0xFF' 0' 0xF) << 4);  	packed |= (byte)(pixelColor.A.Scale (0' 0xFF' 0' 0xF));  	ROM.Data [offset] = packed;  	offset++;  }  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,ImportImage,The following statement contains a magic number: for (int x = 0; x < import.Width; x++) {  	Color pixelColor = import.GetPixel (x' y);  	int intensity = (pixelColor.R + pixelColor.G + pixelColor.B) / 3;  	Color newColor = Color.FromArgb (pixelColor.A' intensity' intensity' intensity);  	import.SetPixel (x' y' newColor);  	byte packed = (byte)(((byte)intensity).Scale (0' 0xFF' 0' 0xF) << 4);  	packed |= (byte)(pixelColor.A.Scale (0' 0xFF' 0' 0xF));  	ROM.Data [offset] = packed;  	offset++;  }  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Location = new System.Drawing.Point (307' 187);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Location = new System.Drawing.Point (307' 187);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Size = new System.Drawing.Size (85' 23);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Size = new System.Drawing.Size (85' 23);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.TabIndex = 3;  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.pbTitleCard.Location = new System.Drawing.Point (12' 12);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.pbTitleCard.Location = new System.Drawing.Point (12' 12);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.pbTitleCard.Size = new System.Drawing.Size (288' 64);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.pbTitleCard.Size = new System.Drawing.Size (288' 64);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.pbTitleCard.TabIndex = 4;  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point (307' 12);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point (307' 12);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size (85' 23);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size (85' 23);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.TabIndex = 5;  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point (307' 41);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point (307' 41);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size (85' 23);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size (85' 23);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.TabIndex = 6;  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (404' 222);  
Magic Number,SceneNavi,TitleCardForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\TitleCardForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (404' 222);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,UpdateCheckDialog,The following statement contains a magic number: tmr.Interval = 2.0;  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,The following statement contains a magic number: try {  	if (VersionManagement.RemoteFileExists (Configuration.UpdateServer)) {  		this.UIThread (() => lblStatus.Text = "Version information found; downloading...");  		string[] updateInformation = VersionManagement.DownloadTextFile (Configuration.UpdateServer);  		remoteVersion = new Version (updateInformation [(int)updateTxtLines.NewVersionNumber]);  		updatePageUrl = updateInformation [(int)updateTxtLines.UpdatePageUrl];  		if (updateInformation.Length >= 2)  			releaseNotesUrl = updateInformation [(int)updateTxtLines.ReleaseNotesUrl];  		this.UIThread (() => VersionManagement.DownloadRtfFile (releaseNotesUrl' rlblChangelog));  		if (IsRemoteVersionNewer) {  			this.UIThread (() => btnDownload.Enabled = true);  			finalStatusMsg = string.Format ("New version {0} is available!"' VersionManagement.CreateVersionString (remoteVersion));  		} else {  			finalStatusMsg = string.Format ("You are already using the most recent version {0}.\n"' VersionManagement.CreateVersionString (localVersion));  		}  	} else  		finalStatusMsg = "Version information file not found found; please contact a developer.";  } catch (WebException wex) {  	/* Web access failed */MessageBox.Show (wex.ToString ()' "Web Exception"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  } catch (System.ComponentModel.Win32Exception w32ex) {  	/* Win32 exception' ex. no browser found */if (w32ex.ErrorCode == -2147467259)  		MessageBox.Show (w32ex.Message' "Process Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  } catch (Exception ex) {  	/* General failure */MessageBox.Show (ex.ToString ()' "General Exception"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  }  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,The following statement contains a magic number: try {  	if (VersionManagement.RemoteFileExists (Configuration.UpdateServer)) {  		this.UIThread (() => lblStatus.Text = "Version information found; downloading...");  		string[] updateInformation = VersionManagement.DownloadTextFile (Configuration.UpdateServer);  		remoteVersion = new Version (updateInformation [(int)updateTxtLines.NewVersionNumber]);  		updatePageUrl = updateInformation [(int)updateTxtLines.UpdatePageUrl];  		if (updateInformation.Length >= 2)  			releaseNotesUrl = updateInformation [(int)updateTxtLines.ReleaseNotesUrl];  		this.UIThread (() => VersionManagement.DownloadRtfFile (releaseNotesUrl' rlblChangelog));  		if (IsRemoteVersionNewer) {  			this.UIThread (() => btnDownload.Enabled = true);  			finalStatusMsg = string.Format ("New version {0} is available!"' VersionManagement.CreateVersionString (remoteVersion));  		} else {  			finalStatusMsg = string.Format ("You are already using the most recent version {0}.\n"' VersionManagement.CreateVersionString (localVersion));  		}  	} else  		finalStatusMsg = "Version information file not found found; please contact a developer.";  } catch (WebException wex) {  	/* Web access failed */MessageBox.Show (wex.ToString ()' "Web Exception"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  } catch (System.ComponentModel.Win32Exception w32ex) {  	/* Win32 exception' ex. no browser found */if (w32ex.ErrorCode == -2147467259)  		MessageBox.Show (w32ex.Message' "Process Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  } catch (Exception ex) {  	/* General failure */MessageBox.Show (ex.ToString ()' "General Exception"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  }  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,The following statement contains a magic number: if (VersionManagement.RemoteFileExists (Configuration.UpdateServer)) {  	this.UIThread (() => lblStatus.Text = "Version information found; downloading...");  	string[] updateInformation = VersionManagement.DownloadTextFile (Configuration.UpdateServer);  	remoteVersion = new Version (updateInformation [(int)updateTxtLines.NewVersionNumber]);  	updatePageUrl = updateInformation [(int)updateTxtLines.UpdatePageUrl];  	if (updateInformation.Length >= 2)  		releaseNotesUrl = updateInformation [(int)updateTxtLines.ReleaseNotesUrl];  	this.UIThread (() => VersionManagement.DownloadRtfFile (releaseNotesUrl' rlblChangelog));  	if (IsRemoteVersionNewer) {  		this.UIThread (() => btnDownload.Enabled = true);  		finalStatusMsg = string.Format ("New version {0} is available!"' VersionManagement.CreateVersionString (remoteVersion));  	} else {  		finalStatusMsg = string.Format ("You are already using the most recent version {0}.\n"' VersionManagement.CreateVersionString (localVersion));  	}  } else  	finalStatusMsg = "Version information file not found found; please contact a developer.";  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,The following statement contains a magic number: if (updateInformation.Length >= 2)  	releaseNotesUrl = updateInformation [(int)updateTxtLines.ReleaseNotesUrl];  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,tmr_Elapsed,The following statement contains a magic number: if (w32ex.ErrorCode == -2147467259)  	MessageBox.Show (w32ex.Message' "Process Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Location = new System.Drawing.Point (607' 387);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Location = new System.Drawing.Point (607' 387);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Size = new System.Drawing.Size (75' 23);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnClose.Size = new System.Drawing.Size (75' 23);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Location = new System.Drawing.Point (12' 392);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Location = new System.Drawing.Point (12' 392);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Size = new System.Drawing.Size (16' 13);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.Size = new System.Drawing.Size (16' 13);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.lblStatus.TabIndex = 2;  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnDownload.Location = new System.Drawing.Point (526' 387);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnDownload.Location = new System.Drawing.Point (526' 387);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnDownload.Size = new System.Drawing.Size (75' 23);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnDownload.Size = new System.Drawing.Size (75' 23);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnDownload.TabIndex = 3;  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.rlblChangelog.Location = new System.Drawing.Point (12' 12);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.rlblChangelog.Location = new System.Drawing.Point (12' 12);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.rlblChangelog.Size = new System.Drawing.Size (670' 369);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.rlblChangelog.Size = new System.Drawing.Size (670' 369);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (694' 422);  
Magic Number,SceneNavi,UpdateCheckDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\UpdateCheckDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (694' 422);  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: switch (ver.Build) {  case 0:  	/* Alpha build */sb.AppendFormat (" Alpha {0}"' (ver.Revision >> 8));  	break;  case 1:  	/* Beta build */sb.AppendFormat (" Beta {0}"' (ver.Revision >> 8));  	break;  case 2:  	/* Final release */if (ver.Revision != 0)  		sb.AppendFormat (".{0}"' (ver.Revision >> 8));  	break;  default:  	/* Invalid build type */throw new Exception ("Invalid Build value in given version");  }  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: switch (ver.Build) {  case 0:  	/* Alpha build */sb.AppendFormat (" Alpha {0}"' (ver.Revision >> 8));  	break;  case 1:  	/* Beta build */sb.AppendFormat (" Beta {0}"' (ver.Revision >> 8));  	break;  case 2:  	/* Final release */if (ver.Revision != 0)  		sb.AppendFormat (".{0}"' (ver.Revision >> 8));  	break;  default:  	/* Invalid build type */throw new Exception ("Invalid Build value in given version");  }  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: switch (ver.Build) {  case 0:  	/* Alpha build */sb.AppendFormat (" Alpha {0}"' (ver.Revision >> 8));  	break;  case 1:  	/* Beta build */sb.AppendFormat (" Beta {0}"' (ver.Revision >> 8));  	break;  case 2:  	/* Final release */if (ver.Revision != 0)  		sb.AppendFormat (".{0}"' (ver.Revision >> 8));  	break;  default:  	/* Invalid build type */throw new Exception ("Invalid Build value in given version");  }  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: switch (ver.Build) {  case 0:  	/* Alpha build */sb.AppendFormat (" Alpha {0}"' (ver.Revision >> 8));  	break;  case 1:  	/* Beta build */sb.AppendFormat (" Beta {0}"' (ver.Revision >> 8));  	break;  case 2:  	/* Final release */if (ver.Revision != 0)  		sb.AppendFormat (".{0}"' (ver.Revision >> 8));  	break;  default:  	/* Invalid build type */throw new Exception ("Invalid Build value in given version");  }  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: sb.AppendFormat (" Alpha {0}"' (ver.Revision >> 8));  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: sb.AppendFormat (" Beta {0}"' (ver.Revision >> 8));  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: if (ver.Revision != 0)  	sb.AppendFormat (".{0}"' (ver.Revision >> 8));  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: sb.AppendFormat (".{0}"' (ver.Revision >> 8));  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: if ((ver.Revision & 0xFF) != 0)  	sb.AppendFormat ("{0}"' (char)('a' + ((ver.Revision & 0xFF) - 1) % 26));  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,CreateVersionString,The following statement contains a magic number: sb.AppendFormat ("{0}"' (char)('a' + ((ver.Revision & 0xFF) - 1) % 26));  
Magic Number,SceneNavi,VersionManagement,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\VersionManagement.cs,RemoteFileExists,The following statement contains a magic number: request.Timeout = 1200;  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: foreach (string fn in XmlFiles) {  	Definition ndef = null;  	Definition.Item nitem = null;  	Definition.Item.Option nopt = null;  	OpenGLHelpers.DisplayList displaydl = null;  	OpenGLHelpers.DisplayList pickdl = null;  	XmlTextReader xml = new XmlTextReader (fn);  	while (xml.Read ()) {  		if (xml.NodeType == XmlNodeType.Element) {  			if (xml.Name == "ActorDatabase") {  				while (xml.MoveToNextAttribute ()) {  					if (xml.Name == "ProgramVersion") {  						ProgramVersion = Version.Parse (xml.Value);  						if (ProgramVersion != Version.Parse (Application.ProductVersion))  							ThrowVersionError ();  					}  				}  			} else if (xml.Name == "Definition") {  				if (ProgramVersion == new Version ())  					ThrowVersionError ();  				ndef = new Definition ();  				ndef.Items = new List<Definition.Item> ();  				while (xml.MoveToNextAttribute ()) {  					switch (xml.Name) {  					case "Number":  						if (xml.Value.StartsWith ("0x") == true)  							ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  						else  							ndef.Number = ushort.Parse (xml.Value);  						break;  					case "IsDefault":  						ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  						break;  					case "DisplayModel":  						displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  						if (displaydl != null)  							ndef.DisplayModel = displaydl;  						break;  					case "PickModel":  						pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  						if (pickdl != null)  							ndef.PickModel = pickdl;  						break;  					case "FrontOffset":  						ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  						break;  					}  				}  			} else if (xml.Name == "Item") {  				nitem = new Definition.Item ();  				while (xml.MoveToNextAttribute ()) {  					switch (xml.Name) {  					case "Index":  						nitem.Index = int.Parse (xml.Value);  						break;  					case "ValueType":  						nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  						break;  					case "DisplayStyle":  						nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  						break;  					case "Usage":  						nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  						break;  					case "Description":  						nitem.Description = xml.Value;  						break;  					case "Mask":  						if (xml.Value.StartsWith ("0x") == true)  							nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  						else  							nitem.Mask = UInt64.Parse (xml.Value);  						break;  					case "ControlType":  						nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  						break;  					}  				}  				ndef.Items.Add (nitem);  			} else if (xml.Name == "Option") {  				nopt = new Definition.Item.Option ();  				while (xml.MoveToNextAttribute ()) {  					switch (xml.Name) {  					case "Value":  						if (xml.Value.StartsWith ("0x") == true)  							nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  						else  							nopt.Value = UInt64.Parse (xml.Value);  						break;  					case "Description":  						nopt.Description = xml.Value;  						break;  					}  				}  				nitem.Options.Add (nopt);  			}  		} else if (xml.NodeType == XmlNodeType.EndElement) {  			if (xml.Name == "Definition") {  				if (displaydl != null && pickdl == null)  					ndef.PickModel = displaydl;  				Definitions.Add (ndef);  			}  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: foreach (string fn in XmlFiles) {  	Definition ndef = null;  	Definition.Item nitem = null;  	Definition.Item.Option nopt = null;  	OpenGLHelpers.DisplayList displaydl = null;  	OpenGLHelpers.DisplayList pickdl = null;  	XmlTextReader xml = new XmlTextReader (fn);  	while (xml.Read ()) {  		if (xml.NodeType == XmlNodeType.Element) {  			if (xml.Name == "ActorDatabase") {  				while (xml.MoveToNextAttribute ()) {  					if (xml.Name == "ProgramVersion") {  						ProgramVersion = Version.Parse (xml.Value);  						if (ProgramVersion != Version.Parse (Application.ProductVersion))  							ThrowVersionError ();  					}  				}  			} else if (xml.Name == "Definition") {  				if (ProgramVersion == new Version ())  					ThrowVersionError ();  				ndef = new Definition ();  				ndef.Items = new List<Definition.Item> ();  				while (xml.MoveToNextAttribute ()) {  					switch (xml.Name) {  					case "Number":  						if (xml.Value.StartsWith ("0x") == true)  							ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  						else  							ndef.Number = ushort.Parse (xml.Value);  						break;  					case "IsDefault":  						ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  						break;  					case "DisplayModel":  						displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  						if (displaydl != null)  							ndef.DisplayModel = displaydl;  						break;  					case "PickModel":  						pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  						if (pickdl != null)  							ndef.PickModel = pickdl;  						break;  					case "FrontOffset":  						ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  						break;  					}  				}  			} else if (xml.Name == "Item") {  				nitem = new Definition.Item ();  				while (xml.MoveToNextAttribute ()) {  					switch (xml.Name) {  					case "Index":  						nitem.Index = int.Parse (xml.Value);  						break;  					case "ValueType":  						nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  						break;  					case "DisplayStyle":  						nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  						break;  					case "Usage":  						nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  						break;  					case "Description":  						nitem.Description = xml.Value;  						break;  					case "Mask":  						if (xml.Value.StartsWith ("0x") == true)  							nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  						else  							nitem.Mask = UInt64.Parse (xml.Value);  						break;  					case "ControlType":  						nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  						break;  					}  				}  				ndef.Items.Add (nitem);  			} else if (xml.Name == "Option") {  				nopt = new Definition.Item.Option ();  				while (xml.MoveToNextAttribute ()) {  					switch (xml.Name) {  					case "Value":  						if (xml.Value.StartsWith ("0x") == true)  							nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  						else  							nopt.Value = UInt64.Parse (xml.Value);  						break;  					case "Description":  						nopt.Description = xml.Value;  						break;  					}  				}  				nitem.Options.Add (nopt);  			}  		} else if (xml.NodeType == XmlNodeType.EndElement) {  			if (xml.Name == "Definition") {  				if (displaydl != null && pickdl == null)  					ndef.PickModel = displaydl;  				Definitions.Add (ndef);  			}  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: foreach (string fn in XmlFiles) {  	Definition ndef = null;  	Definition.Item nitem = null;  	Definition.Item.Option nopt = null;  	OpenGLHelpers.DisplayList displaydl = null;  	OpenGLHelpers.DisplayList pickdl = null;  	XmlTextReader xml = new XmlTextReader (fn);  	while (xml.Read ()) {  		if (xml.NodeType == XmlNodeType.Element) {  			if (xml.Name == "ActorDatabase") {  				while (xml.MoveToNextAttribute ()) {  					if (xml.Name == "ProgramVersion") {  						ProgramVersion = Version.Parse (xml.Value);  						if (ProgramVersion != Version.Parse (Application.ProductVersion))  							ThrowVersionError ();  					}  				}  			} else if (xml.Name == "Definition") {  				if (ProgramVersion == new Version ())  					ThrowVersionError ();  				ndef = new Definition ();  				ndef.Items = new List<Definition.Item> ();  				while (xml.MoveToNextAttribute ()) {  					switch (xml.Name) {  					case "Number":  						if (xml.Value.StartsWith ("0x") == true)  							ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  						else  							ndef.Number = ushort.Parse (xml.Value);  						break;  					case "IsDefault":  						ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  						break;  					case "DisplayModel":  						displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  						if (displaydl != null)  							ndef.DisplayModel = displaydl;  						break;  					case "PickModel":  						pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  						if (pickdl != null)  							ndef.PickModel = pickdl;  						break;  					case "FrontOffset":  						ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  						break;  					}  				}  			} else if (xml.Name == "Item") {  				nitem = new Definition.Item ();  				while (xml.MoveToNextAttribute ()) {  					switch (xml.Name) {  					case "Index":  						nitem.Index = int.Parse (xml.Value);  						break;  					case "ValueType":  						nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  						break;  					case "DisplayStyle":  						nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  						break;  					case "Usage":  						nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  						break;  					case "Description":  						nitem.Description = xml.Value;  						break;  					case "Mask":  						if (xml.Value.StartsWith ("0x") == true)  							nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  						else  							nitem.Mask = UInt64.Parse (xml.Value);  						break;  					case "ControlType":  						nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  						break;  					}  				}  				ndef.Items.Add (nitem);  			} else if (xml.Name == "Option") {  				nopt = new Definition.Item.Option ();  				while (xml.MoveToNextAttribute ()) {  					switch (xml.Name) {  					case "Value":  						if (xml.Value.StartsWith ("0x") == true)  							nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  						else  							nopt.Value = UInt64.Parse (xml.Value);  						break;  					case "Description":  						nopt.Description = xml.Value;  						break;  					}  				}  				nitem.Options.Add (nopt);  			}  		} else if (xml.NodeType == XmlNodeType.EndElement) {  			if (xml.Name == "Definition") {  				if (displaydl != null && pickdl == null)  					ndef.PickModel = displaydl;  				Definitions.Add (ndef);  			}  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: while (xml.Read ()) {  	if (xml.NodeType == XmlNodeType.Element) {  		if (xml.Name == "ActorDatabase") {  			while (xml.MoveToNextAttribute ()) {  				if (xml.Name == "ProgramVersion") {  					ProgramVersion = Version.Parse (xml.Value);  					if (ProgramVersion != Version.Parse (Application.ProductVersion))  						ThrowVersionError ();  				}  			}  		} else if (xml.Name == "Definition") {  			if (ProgramVersion == new Version ())  				ThrowVersionError ();  			ndef = new Definition ();  			ndef.Items = new List<Definition.Item> ();  			while (xml.MoveToNextAttribute ()) {  				switch (xml.Name) {  				case "Number":  					if (xml.Value.StartsWith ("0x") == true)  						ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  					else  						ndef.Number = ushort.Parse (xml.Value);  					break;  				case "IsDefault":  					ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  					break;  				case "DisplayModel":  					displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  					if (displaydl != null)  						ndef.DisplayModel = displaydl;  					break;  				case "PickModel":  					pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  					if (pickdl != null)  						ndef.PickModel = pickdl;  					break;  				case "FrontOffset":  					ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  					break;  				}  			}  		} else if (xml.Name == "Item") {  			nitem = new Definition.Item ();  			while (xml.MoveToNextAttribute ()) {  				switch (xml.Name) {  				case "Index":  					nitem.Index = int.Parse (xml.Value);  					break;  				case "ValueType":  					nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  					break;  				case "DisplayStyle":  					nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  					break;  				case "Usage":  					nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  					break;  				case "Description":  					nitem.Description = xml.Value;  					break;  				case "Mask":  					if (xml.Value.StartsWith ("0x") == true)  						nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  					else  						nitem.Mask = UInt64.Parse (xml.Value);  					break;  				case "ControlType":  					nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  					break;  				}  			}  			ndef.Items.Add (nitem);  		} else if (xml.Name == "Option") {  			nopt = new Definition.Item.Option ();  			while (xml.MoveToNextAttribute ()) {  				switch (xml.Name) {  				case "Value":  					if (xml.Value.StartsWith ("0x") == true)  						nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  					else  						nopt.Value = UInt64.Parse (xml.Value);  					break;  				case "Description":  					nopt.Description = xml.Value;  					break;  				}  			}  			nitem.Options.Add (nopt);  		}  	} else if (xml.NodeType == XmlNodeType.EndElement) {  		if (xml.Name == "Definition") {  			if (displaydl != null && pickdl == null)  				ndef.PickModel = displaydl;  			Definitions.Add (ndef);  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: while (xml.Read ()) {  	if (xml.NodeType == XmlNodeType.Element) {  		if (xml.Name == "ActorDatabase") {  			while (xml.MoveToNextAttribute ()) {  				if (xml.Name == "ProgramVersion") {  					ProgramVersion = Version.Parse (xml.Value);  					if (ProgramVersion != Version.Parse (Application.ProductVersion))  						ThrowVersionError ();  				}  			}  		} else if (xml.Name == "Definition") {  			if (ProgramVersion == new Version ())  				ThrowVersionError ();  			ndef = new Definition ();  			ndef.Items = new List<Definition.Item> ();  			while (xml.MoveToNextAttribute ()) {  				switch (xml.Name) {  				case "Number":  					if (xml.Value.StartsWith ("0x") == true)  						ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  					else  						ndef.Number = ushort.Parse (xml.Value);  					break;  				case "IsDefault":  					ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  					break;  				case "DisplayModel":  					displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  					if (displaydl != null)  						ndef.DisplayModel = displaydl;  					break;  				case "PickModel":  					pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  					if (pickdl != null)  						ndef.PickModel = pickdl;  					break;  				case "FrontOffset":  					ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  					break;  				}  			}  		} else if (xml.Name == "Item") {  			nitem = new Definition.Item ();  			while (xml.MoveToNextAttribute ()) {  				switch (xml.Name) {  				case "Index":  					nitem.Index = int.Parse (xml.Value);  					break;  				case "ValueType":  					nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  					break;  				case "DisplayStyle":  					nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  					break;  				case "Usage":  					nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  					break;  				case "Description":  					nitem.Description = xml.Value;  					break;  				case "Mask":  					if (xml.Value.StartsWith ("0x") == true)  						nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  					else  						nitem.Mask = UInt64.Parse (xml.Value);  					break;  				case "ControlType":  					nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  					break;  				}  			}  			ndef.Items.Add (nitem);  		} else if (xml.Name == "Option") {  			nopt = new Definition.Item.Option ();  			while (xml.MoveToNextAttribute ()) {  				switch (xml.Name) {  				case "Value":  					if (xml.Value.StartsWith ("0x") == true)  						nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  					else  						nopt.Value = UInt64.Parse (xml.Value);  					break;  				case "Description":  					nopt.Description = xml.Value;  					break;  				}  			}  			nitem.Options.Add (nopt);  		}  	} else if (xml.NodeType == XmlNodeType.EndElement) {  		if (xml.Name == "Definition") {  			if (displaydl != null && pickdl == null)  				ndef.PickModel = displaydl;  			Definitions.Add (ndef);  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: while (xml.Read ()) {  	if (xml.NodeType == XmlNodeType.Element) {  		if (xml.Name == "ActorDatabase") {  			while (xml.MoveToNextAttribute ()) {  				if (xml.Name == "ProgramVersion") {  					ProgramVersion = Version.Parse (xml.Value);  					if (ProgramVersion != Version.Parse (Application.ProductVersion))  						ThrowVersionError ();  				}  			}  		} else if (xml.Name == "Definition") {  			if (ProgramVersion == new Version ())  				ThrowVersionError ();  			ndef = new Definition ();  			ndef.Items = new List<Definition.Item> ();  			while (xml.MoveToNextAttribute ()) {  				switch (xml.Name) {  				case "Number":  					if (xml.Value.StartsWith ("0x") == true)  						ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  					else  						ndef.Number = ushort.Parse (xml.Value);  					break;  				case "IsDefault":  					ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  					break;  				case "DisplayModel":  					displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  					if (displaydl != null)  						ndef.DisplayModel = displaydl;  					break;  				case "PickModel":  					pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  					if (pickdl != null)  						ndef.PickModel = pickdl;  					break;  				case "FrontOffset":  					ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  					break;  				}  			}  		} else if (xml.Name == "Item") {  			nitem = new Definition.Item ();  			while (xml.MoveToNextAttribute ()) {  				switch (xml.Name) {  				case "Index":  					nitem.Index = int.Parse (xml.Value);  					break;  				case "ValueType":  					nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  					break;  				case "DisplayStyle":  					nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  					break;  				case "Usage":  					nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  					break;  				case "Description":  					nitem.Description = xml.Value;  					break;  				case "Mask":  					if (xml.Value.StartsWith ("0x") == true)  						nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  					else  						nitem.Mask = UInt64.Parse (xml.Value);  					break;  				case "ControlType":  					nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  					break;  				}  			}  			ndef.Items.Add (nitem);  		} else if (xml.Name == "Option") {  			nopt = new Definition.Item.Option ();  			while (xml.MoveToNextAttribute ()) {  				switch (xml.Name) {  				case "Value":  					if (xml.Value.StartsWith ("0x") == true)  						nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  					else  						nopt.Value = UInt64.Parse (xml.Value);  					break;  				case "Description":  					nopt.Description = xml.Value;  					break;  				}  			}  			nitem.Options.Add (nopt);  		}  	} else if (xml.NodeType == XmlNodeType.EndElement) {  		if (xml.Name == "Definition") {  			if (displaydl != null && pickdl == null)  				ndef.PickModel = displaydl;  			Definitions.Add (ndef);  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.NodeType == XmlNodeType.Element) {  	if (xml.Name == "ActorDatabase") {  		while (xml.MoveToNextAttribute ()) {  			if (xml.Name == "ProgramVersion") {  				ProgramVersion = Version.Parse (xml.Value);  				if (ProgramVersion != Version.Parse (Application.ProductVersion))  					ThrowVersionError ();  			}  		}  	} else if (xml.Name == "Definition") {  		if (ProgramVersion == new Version ())  			ThrowVersionError ();  		ndef = new Definition ();  		ndef.Items = new List<Definition.Item> ();  		while (xml.MoveToNextAttribute ()) {  			switch (xml.Name) {  			case "Number":  				if (xml.Value.StartsWith ("0x") == true)  					ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  				else  					ndef.Number = ushort.Parse (xml.Value);  				break;  			case "IsDefault":  				ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  				break;  			case "DisplayModel":  				displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  				if (displaydl != null)  					ndef.DisplayModel = displaydl;  				break;  			case "PickModel":  				pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  				if (pickdl != null)  					ndef.PickModel = pickdl;  				break;  			case "FrontOffset":  				ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  				break;  			}  		}  	} else if (xml.Name == "Item") {  		nitem = new Definition.Item ();  		while (xml.MoveToNextAttribute ()) {  			switch (xml.Name) {  			case "Index":  				nitem.Index = int.Parse (xml.Value);  				break;  			case "ValueType":  				nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  				break;  			case "DisplayStyle":  				nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  				break;  			case "Usage":  				nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  				break;  			case "Description":  				nitem.Description = xml.Value;  				break;  			case "Mask":  				if (xml.Value.StartsWith ("0x") == true)  					nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  				else  					nitem.Mask = UInt64.Parse (xml.Value);  				break;  			case "ControlType":  				nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  				break;  			}  		}  		ndef.Items.Add (nitem);  	} else if (xml.Name == "Option") {  		nopt = new Definition.Item.Option ();  		while (xml.MoveToNextAttribute ()) {  			switch (xml.Name) {  			case "Value":  				if (xml.Value.StartsWith ("0x") == true)  					nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  				else  					nopt.Value = UInt64.Parse (xml.Value);  				break;  			case "Description":  				nopt.Description = xml.Value;  				break;  			}  		}  		nitem.Options.Add (nopt);  	}  } else if (xml.NodeType == XmlNodeType.EndElement) {  	if (xml.Name == "Definition") {  		if (displaydl != null && pickdl == null)  			ndef.PickModel = displaydl;  		Definitions.Add (ndef);  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.NodeType == XmlNodeType.Element) {  	if (xml.Name == "ActorDatabase") {  		while (xml.MoveToNextAttribute ()) {  			if (xml.Name == "ProgramVersion") {  				ProgramVersion = Version.Parse (xml.Value);  				if (ProgramVersion != Version.Parse (Application.ProductVersion))  					ThrowVersionError ();  			}  		}  	} else if (xml.Name == "Definition") {  		if (ProgramVersion == new Version ())  			ThrowVersionError ();  		ndef = new Definition ();  		ndef.Items = new List<Definition.Item> ();  		while (xml.MoveToNextAttribute ()) {  			switch (xml.Name) {  			case "Number":  				if (xml.Value.StartsWith ("0x") == true)  					ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  				else  					ndef.Number = ushort.Parse (xml.Value);  				break;  			case "IsDefault":  				ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  				break;  			case "DisplayModel":  				displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  				if (displaydl != null)  					ndef.DisplayModel = displaydl;  				break;  			case "PickModel":  				pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  				if (pickdl != null)  					ndef.PickModel = pickdl;  				break;  			case "FrontOffset":  				ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  				break;  			}  		}  	} else if (xml.Name == "Item") {  		nitem = new Definition.Item ();  		while (xml.MoveToNextAttribute ()) {  			switch (xml.Name) {  			case "Index":  				nitem.Index = int.Parse (xml.Value);  				break;  			case "ValueType":  				nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  				break;  			case "DisplayStyle":  				nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  				break;  			case "Usage":  				nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  				break;  			case "Description":  				nitem.Description = xml.Value;  				break;  			case "Mask":  				if (xml.Value.StartsWith ("0x") == true)  					nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  				else  					nitem.Mask = UInt64.Parse (xml.Value);  				break;  			case "ControlType":  				nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  				break;  			}  		}  		ndef.Items.Add (nitem);  	} else if (xml.Name == "Option") {  		nopt = new Definition.Item.Option ();  		while (xml.MoveToNextAttribute ()) {  			switch (xml.Name) {  			case "Value":  				if (xml.Value.StartsWith ("0x") == true)  					nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  				else  					nopt.Value = UInt64.Parse (xml.Value);  				break;  			case "Description":  				nopt.Description = xml.Value;  				break;  			}  		}  		nitem.Options.Add (nopt);  	}  } else if (xml.NodeType == XmlNodeType.EndElement) {  	if (xml.Name == "Definition") {  		if (displaydl != null && pickdl == null)  			ndef.PickModel = displaydl;  		Definitions.Add (ndef);  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.NodeType == XmlNodeType.Element) {  	if (xml.Name == "ActorDatabase") {  		while (xml.MoveToNextAttribute ()) {  			if (xml.Name == "ProgramVersion") {  				ProgramVersion = Version.Parse (xml.Value);  				if (ProgramVersion != Version.Parse (Application.ProductVersion))  					ThrowVersionError ();  			}  		}  	} else if (xml.Name == "Definition") {  		if (ProgramVersion == new Version ())  			ThrowVersionError ();  		ndef = new Definition ();  		ndef.Items = new List<Definition.Item> ();  		while (xml.MoveToNextAttribute ()) {  			switch (xml.Name) {  			case "Number":  				if (xml.Value.StartsWith ("0x") == true)  					ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  				else  					ndef.Number = ushort.Parse (xml.Value);  				break;  			case "IsDefault":  				ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  				break;  			case "DisplayModel":  				displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  				if (displaydl != null)  					ndef.DisplayModel = displaydl;  				break;  			case "PickModel":  				pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  				if (pickdl != null)  					ndef.PickModel = pickdl;  				break;  			case "FrontOffset":  				ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  				break;  			}  		}  	} else if (xml.Name == "Item") {  		nitem = new Definition.Item ();  		while (xml.MoveToNextAttribute ()) {  			switch (xml.Name) {  			case "Index":  				nitem.Index = int.Parse (xml.Value);  				break;  			case "ValueType":  				nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  				break;  			case "DisplayStyle":  				nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  				break;  			case "Usage":  				nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  				break;  			case "Description":  				nitem.Description = xml.Value;  				break;  			case "Mask":  				if (xml.Value.StartsWith ("0x") == true)  					nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  				else  					nitem.Mask = UInt64.Parse (xml.Value);  				break;  			case "ControlType":  				nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  				break;  			}  		}  		ndef.Items.Add (nitem);  	} else if (xml.Name == "Option") {  		nopt = new Definition.Item.Option ();  		while (xml.MoveToNextAttribute ()) {  			switch (xml.Name) {  			case "Value":  				if (xml.Value.StartsWith ("0x") == true)  					nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  				else  					nopt.Value = UInt64.Parse (xml.Value);  				break;  			case "Description":  				nopt.Description = xml.Value;  				break;  			}  		}  		nitem.Options.Add (nopt);  	}  } else if (xml.NodeType == XmlNodeType.EndElement) {  	if (xml.Name == "Definition") {  		if (displaydl != null && pickdl == null)  			ndef.PickModel = displaydl;  		Definitions.Add (ndef);  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Name == "ActorDatabase") {  	while (xml.MoveToNextAttribute ()) {  		if (xml.Name == "ProgramVersion") {  			ProgramVersion = Version.Parse (xml.Value);  			if (ProgramVersion != Version.Parse (Application.ProductVersion))  				ThrowVersionError ();  		}  	}  } else if (xml.Name == "Definition") {  	if (ProgramVersion == new Version ())  		ThrowVersionError ();  	ndef = new Definition ();  	ndef.Items = new List<Definition.Item> ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Number":  			if (xml.Value.StartsWith ("0x") == true)  				ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				ndef.Number = ushort.Parse (xml.Value);  			break;  		case "IsDefault":  			ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  			break;  		case "DisplayModel":  			displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (displaydl != null)  				ndef.DisplayModel = displaydl;  			break;  		case "PickModel":  			pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (pickdl != null)  				ndef.PickModel = pickdl;  			break;  		case "FrontOffset":  			ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  			break;  		}  	}  } else if (xml.Name == "Item") {  	nitem = new Definition.Item ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Index":  			nitem.Index = int.Parse (xml.Value);  			break;  		case "ValueType":  			nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		case "DisplayStyle":  			nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  			break;  		case "Usage":  			nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  			break;  		case "Description":  			nitem.Description = xml.Value;  			break;  		case "Mask":  			if (xml.Value.StartsWith ("0x") == true)  				nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nitem.Mask = UInt64.Parse (xml.Value);  			break;  		case "ControlType":  			nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		}  	}  	ndef.Items.Add (nitem);  } else if (xml.Name == "Option") {  	nopt = new Definition.Item.Option ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Value":  			if (xml.Value.StartsWith ("0x") == true)  				nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nopt.Value = UInt64.Parse (xml.Value);  			break;  		case "Description":  			nopt.Description = xml.Value;  			break;  		}  	}  	nitem.Options.Add (nopt);  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Name == "ActorDatabase") {  	while (xml.MoveToNextAttribute ()) {  		if (xml.Name == "ProgramVersion") {  			ProgramVersion = Version.Parse (xml.Value);  			if (ProgramVersion != Version.Parse (Application.ProductVersion))  				ThrowVersionError ();  		}  	}  } else if (xml.Name == "Definition") {  	if (ProgramVersion == new Version ())  		ThrowVersionError ();  	ndef = new Definition ();  	ndef.Items = new List<Definition.Item> ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Number":  			if (xml.Value.StartsWith ("0x") == true)  				ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				ndef.Number = ushort.Parse (xml.Value);  			break;  		case "IsDefault":  			ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  			break;  		case "DisplayModel":  			displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (displaydl != null)  				ndef.DisplayModel = displaydl;  			break;  		case "PickModel":  			pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (pickdl != null)  				ndef.PickModel = pickdl;  			break;  		case "FrontOffset":  			ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  			break;  		}  	}  } else if (xml.Name == "Item") {  	nitem = new Definition.Item ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Index":  			nitem.Index = int.Parse (xml.Value);  			break;  		case "ValueType":  			nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		case "DisplayStyle":  			nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  			break;  		case "Usage":  			nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  			break;  		case "Description":  			nitem.Description = xml.Value;  			break;  		case "Mask":  			if (xml.Value.StartsWith ("0x") == true)  				nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nitem.Mask = UInt64.Parse (xml.Value);  			break;  		case "ControlType":  			nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		}  	}  	ndef.Items.Add (nitem);  } else if (xml.Name == "Option") {  	nopt = new Definition.Item.Option ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Value":  			if (xml.Value.StartsWith ("0x") == true)  				nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nopt.Value = UInt64.Parse (xml.Value);  			break;  		case "Description":  			nopt.Description = xml.Value;  			break;  		}  	}  	nitem.Options.Add (nopt);  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Name == "ActorDatabase") {  	while (xml.MoveToNextAttribute ()) {  		if (xml.Name == "ProgramVersion") {  			ProgramVersion = Version.Parse (xml.Value);  			if (ProgramVersion != Version.Parse (Application.ProductVersion))  				ThrowVersionError ();  		}  	}  } else if (xml.Name == "Definition") {  	if (ProgramVersion == new Version ())  		ThrowVersionError ();  	ndef = new Definition ();  	ndef.Items = new List<Definition.Item> ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Number":  			if (xml.Value.StartsWith ("0x") == true)  				ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				ndef.Number = ushort.Parse (xml.Value);  			break;  		case "IsDefault":  			ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  			break;  		case "DisplayModel":  			displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (displaydl != null)  				ndef.DisplayModel = displaydl;  			break;  		case "PickModel":  			pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (pickdl != null)  				ndef.PickModel = pickdl;  			break;  		case "FrontOffset":  			ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  			break;  		}  	}  } else if (xml.Name == "Item") {  	nitem = new Definition.Item ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Index":  			nitem.Index = int.Parse (xml.Value);  			break;  		case "ValueType":  			nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		case "DisplayStyle":  			nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  			break;  		case "Usage":  			nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  			break;  		case "Description":  			nitem.Description = xml.Value;  			break;  		case "Mask":  			if (xml.Value.StartsWith ("0x") == true)  				nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nitem.Mask = UInt64.Parse (xml.Value);  			break;  		case "ControlType":  			nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		}  	}  	ndef.Items.Add (nitem);  } else if (xml.Name == "Option") {  	nopt = new Definition.Item.Option ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Value":  			if (xml.Value.StartsWith ("0x") == true)  				nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nopt.Value = UInt64.Parse (xml.Value);  			break;  		case "Description":  			nopt.Description = xml.Value;  			break;  		}  	}  	nitem.Options.Add (nopt);  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Name == "Definition") {  	if (ProgramVersion == new Version ())  		ThrowVersionError ();  	ndef = new Definition ();  	ndef.Items = new List<Definition.Item> ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Number":  			if (xml.Value.StartsWith ("0x") == true)  				ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				ndef.Number = ushort.Parse (xml.Value);  			break;  		case "IsDefault":  			ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  			break;  		case "DisplayModel":  			displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (displaydl != null)  				ndef.DisplayModel = displaydl;  			break;  		case "PickModel":  			pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (pickdl != null)  				ndef.PickModel = pickdl;  			break;  		case "FrontOffset":  			ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  			break;  		}  	}  } else if (xml.Name == "Item") {  	nitem = new Definition.Item ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Index":  			nitem.Index = int.Parse (xml.Value);  			break;  		case "ValueType":  			nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		case "DisplayStyle":  			nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  			break;  		case "Usage":  			nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  			break;  		case "Description":  			nitem.Description = xml.Value;  			break;  		case "Mask":  			if (xml.Value.StartsWith ("0x") == true)  				nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nitem.Mask = UInt64.Parse (xml.Value);  			break;  		case "ControlType":  			nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		}  	}  	ndef.Items.Add (nitem);  } else if (xml.Name == "Option") {  	nopt = new Definition.Item.Option ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Value":  			if (xml.Value.StartsWith ("0x") == true)  				nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nopt.Value = UInt64.Parse (xml.Value);  			break;  		case "Description":  			nopt.Description = xml.Value;  			break;  		}  	}  	nitem.Options.Add (nopt);  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Name == "Definition") {  	if (ProgramVersion == new Version ())  		ThrowVersionError ();  	ndef = new Definition ();  	ndef.Items = new List<Definition.Item> ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Number":  			if (xml.Value.StartsWith ("0x") == true)  				ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				ndef.Number = ushort.Parse (xml.Value);  			break;  		case "IsDefault":  			ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  			break;  		case "DisplayModel":  			displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (displaydl != null)  				ndef.DisplayModel = displaydl;  			break;  		case "PickModel":  			pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (pickdl != null)  				ndef.PickModel = pickdl;  			break;  		case "FrontOffset":  			ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  			break;  		}  	}  } else if (xml.Name == "Item") {  	nitem = new Definition.Item ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Index":  			nitem.Index = int.Parse (xml.Value);  			break;  		case "ValueType":  			nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		case "DisplayStyle":  			nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  			break;  		case "Usage":  			nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  			break;  		case "Description":  			nitem.Description = xml.Value;  			break;  		case "Mask":  			if (xml.Value.StartsWith ("0x") == true)  				nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nitem.Mask = UInt64.Parse (xml.Value);  			break;  		case "ControlType":  			nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		}  	}  	ndef.Items.Add (nitem);  } else if (xml.Name == "Option") {  	nopt = new Definition.Item.Option ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Value":  			if (xml.Value.StartsWith ("0x") == true)  				nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nopt.Value = UInt64.Parse (xml.Value);  			break;  		case "Description":  			nopt.Description = xml.Value;  			break;  		}  	}  	nitem.Options.Add (nopt);  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Name == "Definition") {  	if (ProgramVersion == new Version ())  		ThrowVersionError ();  	ndef = new Definition ();  	ndef.Items = new List<Definition.Item> ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Number":  			if (xml.Value.StartsWith ("0x") == true)  				ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				ndef.Number = ushort.Parse (xml.Value);  			break;  		case "IsDefault":  			ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  			break;  		case "DisplayModel":  			displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (displaydl != null)  				ndef.DisplayModel = displaydl;  			break;  		case "PickModel":  			pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  			if (pickdl != null)  				ndef.PickModel = pickdl;  			break;  		case "FrontOffset":  			ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  			break;  		}  	}  } else if (xml.Name == "Item") {  	nitem = new Definition.Item ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Index":  			nitem.Index = int.Parse (xml.Value);  			break;  		case "ValueType":  			nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		case "DisplayStyle":  			nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  			break;  		case "Usage":  			nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  			break;  		case "Description":  			nitem.Description = xml.Value;  			break;  		case "Mask":  			if (xml.Value.StartsWith ("0x") == true)  				nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nitem.Mask = UInt64.Parse (xml.Value);  			break;  		case "ControlType":  			nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		}  	}  	ndef.Items.Add (nitem);  } else if (xml.Name == "Option") {  	nopt = new Definition.Item.Option ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Value":  			if (xml.Value.StartsWith ("0x") == true)  				nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nopt.Value = UInt64.Parse (xml.Value);  			break;  		case "Description":  			nopt.Description = xml.Value;  			break;  		}  	}  	nitem.Options.Add (nopt);  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: while (xml.MoveToNextAttribute ()) {  	switch (xml.Name) {  	case "Number":  		if (xml.Value.StartsWith ("0x") == true)  			ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  		else  			ndef.Number = ushort.Parse (xml.Value);  		break;  	case "IsDefault":  		ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  		break;  	case "DisplayModel":  		displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  		if (displaydl != null)  			ndef.DisplayModel = displaydl;  		break;  	case "PickModel":  		pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  		if (pickdl != null)  			ndef.PickModel = pickdl;  		break;  	case "FrontOffset":  		ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  		break;  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: switch (xml.Name) {  case "Number":  	if (xml.Value.StartsWith ("0x") == true)  		ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  	else  		ndef.Number = ushort.Parse (xml.Value);  	break;  case "IsDefault":  	ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  	break;  case "DisplayModel":  	displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  	if (displaydl != null)  		ndef.DisplayModel = displaydl;  	break;  case "PickModel":  	pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  	if (pickdl != null)  		ndef.PickModel = pickdl;  	break;  case "FrontOffset":  	ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  	break;  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Value.StartsWith ("0x") == true)  	ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  else  	ndef.Number = ushort.Parse (xml.Value);  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Name == "Item") {  	nitem = new Definition.Item ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Index":  			nitem.Index = int.Parse (xml.Value);  			break;  		case "ValueType":  			nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		case "DisplayStyle":  			nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  			break;  		case "Usage":  			nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  			break;  		case "Description":  			nitem.Description = xml.Value;  			break;  		case "Mask":  			if (xml.Value.StartsWith ("0x") == true)  				nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nitem.Mask = UInt64.Parse (xml.Value);  			break;  		case "ControlType":  			nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		}  	}  	ndef.Items.Add (nitem);  } else if (xml.Name == "Option") {  	nopt = new Definition.Item.Option ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Value":  			if (xml.Value.StartsWith ("0x") == true)  				nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nopt.Value = UInt64.Parse (xml.Value);  			break;  		case "Description":  			nopt.Description = xml.Value;  			break;  		}  	}  	nitem.Options.Add (nopt);  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Name == "Item") {  	nitem = new Definition.Item ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Index":  			nitem.Index = int.Parse (xml.Value);  			break;  		case "ValueType":  			nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		case "DisplayStyle":  			nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  			break;  		case "Usage":  			nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  			break;  		case "Description":  			nitem.Description = xml.Value;  			break;  		case "Mask":  			if (xml.Value.StartsWith ("0x") == true)  				nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nitem.Mask = UInt64.Parse (xml.Value);  			break;  		case "ControlType":  			nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  			break;  		}  	}  	ndef.Items.Add (nitem);  } else if (xml.Name == "Option") {  	nopt = new Definition.Item.Option ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Value":  			if (xml.Value.StartsWith ("0x") == true)  				nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nopt.Value = UInt64.Parse (xml.Value);  			break;  		case "Description":  			nopt.Description = xml.Value;  			break;  		}  	}  	nitem.Options.Add (nopt);  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: while (xml.MoveToNextAttribute ()) {  	switch (xml.Name) {  	case "Index":  		nitem.Index = int.Parse (xml.Value);  		break;  	case "ValueType":  		nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  		break;  	case "DisplayStyle":  		nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  		break;  	case "Usage":  		nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  		break;  	case "Description":  		nitem.Description = xml.Value;  		break;  	case "Mask":  		if (xml.Value.StartsWith ("0x") == true)  			nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  		else  			nitem.Mask = UInt64.Parse (xml.Value);  		break;  	case "ControlType":  		nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  		break;  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: switch (xml.Name) {  case "Index":  	nitem.Index = int.Parse (xml.Value);  	break;  case "ValueType":  	nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  	break;  case "DisplayStyle":  	nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  	break;  case "Usage":  	nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  	break;  case "Description":  	nitem.Description = xml.Value;  	break;  case "Mask":  	if (xml.Value.StartsWith ("0x") == true)  		nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  	else  		nitem.Mask = UInt64.Parse (xml.Value);  	break;  case "ControlType":  	nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  	break;  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Value.StartsWith ("0x") == true)  	nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  else  	nitem.Mask = UInt64.Parse (xml.Value);  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Name == "Option") {  	nopt = new Definition.Item.Option ();  	while (xml.MoveToNextAttribute ()) {  		switch (xml.Name) {  		case "Value":  			if (xml.Value.StartsWith ("0x") == true)  				nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  			else  				nopt.Value = UInt64.Parse (xml.Value);  			break;  		case "Description":  			nopt.Description = xml.Value;  			break;  		}  	}  	nitem.Options.Add (nopt);  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: while (xml.MoveToNextAttribute ()) {  	switch (xml.Name) {  	case "Value":  		if (xml.Value.StartsWith ("0x") == true)  			nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  		else  			nopt.Value = UInt64.Parse (xml.Value);  		break;  	case "Description":  		nopt.Description = xml.Value;  		break;  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: switch (xml.Name) {  case "Value":  	if (xml.Value.StartsWith ("0x") == true)  		nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  	else  		nopt.Value = UInt64.Parse (xml.Value);  	break;  case "Description":  	nopt.Description = xml.Value;  	break;  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: if (xml.Value.StartsWith ("0x") == true)  	nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  else  	nopt.Value = UInt64.Parse (xml.Value);  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following statement contains a magic number: nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: tlpex.SetColumnSpan (desc' 2);  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: for (int i = 0; i < def.Items.Count; i++) {  	/* Get current item */Definition.Item item = def.Items [i];  	/* UGLY HACK -> for room number in transition actor with individual file mode... */if (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront)  		item.ControlType = (individual ? typeof(TextBox) : typeof(ComboBox));  	/* Get value' create control */object val = GetValueFromActor (item' ac);  	object ctrl = Activator.CreateInstance (item.ControlType);  	/* First ControlType check; ex. is label needed? */if (item.ControlType == typeof(CheckBox)) {  		/* Add control alone */tlpex.Controls.Add (ctrl as Control' 0' (i + 1));  	} else {  		/* Add label and control */Label lbl = new Label () {  			Text = string.Format ("{0}:"' item.Description)'  			TextAlign = ContentAlignment.MiddleLeft'  			Dock = DockStyle.Fill  		};  		tlpex.Controls.Add (lbl' 0' (i + 1));  		tlpex.Controls.Add (ctrl as Control' 1' (i + 1));  	}  	/* Set control properties */item.ControlType.GetProperty ("Dock").SetValue (ctrl' DockStyle.Fill' null);  	item.ControlType.GetProperty ("Tag").SetValue (ctrl' item' null);  	item.ControlType.GetProperty ("Name").SetValue (ctrl' item.Usage.ToString ()' null);  	/* ControlType-specific settings */if (item.ControlType == typeof(ComboBox)) {  		/* Set ComboBox */item.ControlType.GetProperty ("DropDownStyle").SetValue (ctrl' ComboBoxStyle.DropDownList' null);  		item.ControlType.GetProperty ("DisplayMember").SetValue (ctrl' "Description"' null);  		if (!individual && (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront) && (tag is List<HeaderCommands.Rooms.RoomInfoClass>)) {  			/* Item usage is room number in transition actor; get room listing from function tag */item.Options = new List<Definition.Item.Option> ();  			foreach (HeaderCommands.Rooms.RoomInfoClass ric in (tag as List<HeaderCommands.Rooms.RoomInfoClass>))  				item.Options.Add (new Definition.Item.Option () {  					Description = ric.Description'  					Value = ric.Number  				});  		}  		if (item.Options.Count > 0) {  			item.ControlType.GetProperty ("DataSource").SetValue (ctrl' item.Options' null);  			item.ControlType.GetProperty ("SelectedItem").SetValue (ctrl' item.Options.Find (x => x.Value == (Convert.ToUInt64 (val) & item.Mask))' null);  			(ctrl as ComboBox).SelectedIndexChanged += new EventHandler ((s' ex) => {  				SetValueInActor (item' ac' ((Definition.Item.Option)((ComboBox)s).SelectedItem).Value);  			});  		}  	} else if (item.ControlType == typeof(CheckBox)) {  		/* Set CheckBox */item.ControlType.GetProperty ("Checked").SetValue (ctrl' Convert.ToBoolean (val)' null);  		item.ControlType.GetProperty ("Text").SetValue (ctrl' item.Description' null);  		tlpex.SetColumnSpan (ctrl as Control' 2);  		(ctrl as CheckBox).CheckedChanged += new EventHandler ((s' ex) => {  			ChangeBitInActor (item' ac' item.Mask' ((CheckBox)s).Checked);  		});  	} else {  		/* Fallback */if (item.ControlType.GetProperty ("Text") != null) {  			string fstr = "{0}";  			switch (item.DisplayStyle) {  			case Definition.Item.DisplayStyles.Hexadecimal:  				fstr = "0x{0:X}";  				break;  			case Definition.Item.DisplayStyles.Decimal:  				fstr = "{0:D}";  				break;  			}  			item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  			(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  				object newval = Activator.CreateInstance (item.ValueType);  				System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  					typeof(string)'  					typeof(System.Globalization.NumberStyles)  				});  				if (mi != null) {  					/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  					/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  						return;  					/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  					/* Proper value string found? */if (valstr != null && valstr != "") {  						try {  							/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  								valstr'  								ns  							});  							/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  							if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  								numberchanged ();  						} catch (TargetInvocationException tiex) {  							if (tiex.InnerException is FormatException) {  								/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  						}  					}  				}  			});  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: for (int i = 0; i < def.Items.Count; i++) {  	/* Get current item */Definition.Item item = def.Items [i];  	/* UGLY HACK -> for room number in transition actor with individual file mode... */if (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront)  		item.ControlType = (individual ? typeof(TextBox) : typeof(ComboBox));  	/* Get value' create control */object val = GetValueFromActor (item' ac);  	object ctrl = Activator.CreateInstance (item.ControlType);  	/* First ControlType check; ex. is label needed? */if (item.ControlType == typeof(CheckBox)) {  		/* Add control alone */tlpex.Controls.Add (ctrl as Control' 0' (i + 1));  	} else {  		/* Add label and control */Label lbl = new Label () {  			Text = string.Format ("{0}:"' item.Description)'  			TextAlign = ContentAlignment.MiddleLeft'  			Dock = DockStyle.Fill  		};  		tlpex.Controls.Add (lbl' 0' (i + 1));  		tlpex.Controls.Add (ctrl as Control' 1' (i + 1));  	}  	/* Set control properties */item.ControlType.GetProperty ("Dock").SetValue (ctrl' DockStyle.Fill' null);  	item.ControlType.GetProperty ("Tag").SetValue (ctrl' item' null);  	item.ControlType.GetProperty ("Name").SetValue (ctrl' item.Usage.ToString ()' null);  	/* ControlType-specific settings */if (item.ControlType == typeof(ComboBox)) {  		/* Set ComboBox */item.ControlType.GetProperty ("DropDownStyle").SetValue (ctrl' ComboBoxStyle.DropDownList' null);  		item.ControlType.GetProperty ("DisplayMember").SetValue (ctrl' "Description"' null);  		if (!individual && (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront) && (tag is List<HeaderCommands.Rooms.RoomInfoClass>)) {  			/* Item usage is room number in transition actor; get room listing from function tag */item.Options = new List<Definition.Item.Option> ();  			foreach (HeaderCommands.Rooms.RoomInfoClass ric in (tag as List<HeaderCommands.Rooms.RoomInfoClass>))  				item.Options.Add (new Definition.Item.Option () {  					Description = ric.Description'  					Value = ric.Number  				});  		}  		if (item.Options.Count > 0) {  			item.ControlType.GetProperty ("DataSource").SetValue (ctrl' item.Options' null);  			item.ControlType.GetProperty ("SelectedItem").SetValue (ctrl' item.Options.Find (x => x.Value == (Convert.ToUInt64 (val) & item.Mask))' null);  			(ctrl as ComboBox).SelectedIndexChanged += new EventHandler ((s' ex) => {  				SetValueInActor (item' ac' ((Definition.Item.Option)((ComboBox)s).SelectedItem).Value);  			});  		}  	} else if (item.ControlType == typeof(CheckBox)) {  		/* Set CheckBox */item.ControlType.GetProperty ("Checked").SetValue (ctrl' Convert.ToBoolean (val)' null);  		item.ControlType.GetProperty ("Text").SetValue (ctrl' item.Description' null);  		tlpex.SetColumnSpan (ctrl as Control' 2);  		(ctrl as CheckBox).CheckedChanged += new EventHandler ((s' ex) => {  			ChangeBitInActor (item' ac' item.Mask' ((CheckBox)s).Checked);  		});  	} else {  		/* Fallback */if (item.ControlType.GetProperty ("Text") != null) {  			string fstr = "{0}";  			switch (item.DisplayStyle) {  			case Definition.Item.DisplayStyles.Hexadecimal:  				fstr = "0x{0:X}";  				break;  			case Definition.Item.DisplayStyles.Decimal:  				fstr = "{0:D}";  				break;  			}  			item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  			(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  				object newval = Activator.CreateInstance (item.ValueType);  				System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  					typeof(string)'  					typeof(System.Globalization.NumberStyles)  				});  				if (mi != null) {  					/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  					/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  						return;  					/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  					/* Proper value string found? */if (valstr != null && valstr != "") {  						try {  							/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  								valstr'  								ns  							});  							/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  							if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  								numberchanged ();  						} catch (TargetInvocationException tiex) {  							if (tiex.InnerException is FormatException) {  								/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  						}  					}  				}  			});  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: for (int i = 0; i < def.Items.Count; i++) {  	/* Get current item */Definition.Item item = def.Items [i];  	/* UGLY HACK -> for room number in transition actor with individual file mode... */if (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront)  		item.ControlType = (individual ? typeof(TextBox) : typeof(ComboBox));  	/* Get value' create control */object val = GetValueFromActor (item' ac);  	object ctrl = Activator.CreateInstance (item.ControlType);  	/* First ControlType check; ex. is label needed? */if (item.ControlType == typeof(CheckBox)) {  		/* Add control alone */tlpex.Controls.Add (ctrl as Control' 0' (i + 1));  	} else {  		/* Add label and control */Label lbl = new Label () {  			Text = string.Format ("{0}:"' item.Description)'  			TextAlign = ContentAlignment.MiddleLeft'  			Dock = DockStyle.Fill  		};  		tlpex.Controls.Add (lbl' 0' (i + 1));  		tlpex.Controls.Add (ctrl as Control' 1' (i + 1));  	}  	/* Set control properties */item.ControlType.GetProperty ("Dock").SetValue (ctrl' DockStyle.Fill' null);  	item.ControlType.GetProperty ("Tag").SetValue (ctrl' item' null);  	item.ControlType.GetProperty ("Name").SetValue (ctrl' item.Usage.ToString ()' null);  	/* ControlType-specific settings */if (item.ControlType == typeof(ComboBox)) {  		/* Set ComboBox */item.ControlType.GetProperty ("DropDownStyle").SetValue (ctrl' ComboBoxStyle.DropDownList' null);  		item.ControlType.GetProperty ("DisplayMember").SetValue (ctrl' "Description"' null);  		if (!individual && (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront) && (tag is List<HeaderCommands.Rooms.RoomInfoClass>)) {  			/* Item usage is room number in transition actor; get room listing from function tag */item.Options = new List<Definition.Item.Option> ();  			foreach (HeaderCommands.Rooms.RoomInfoClass ric in (tag as List<HeaderCommands.Rooms.RoomInfoClass>))  				item.Options.Add (new Definition.Item.Option () {  					Description = ric.Description'  					Value = ric.Number  				});  		}  		if (item.Options.Count > 0) {  			item.ControlType.GetProperty ("DataSource").SetValue (ctrl' item.Options' null);  			item.ControlType.GetProperty ("SelectedItem").SetValue (ctrl' item.Options.Find (x => x.Value == (Convert.ToUInt64 (val) & item.Mask))' null);  			(ctrl as ComboBox).SelectedIndexChanged += new EventHandler ((s' ex) => {  				SetValueInActor (item' ac' ((Definition.Item.Option)((ComboBox)s).SelectedItem).Value);  			});  		}  	} else if (item.ControlType == typeof(CheckBox)) {  		/* Set CheckBox */item.ControlType.GetProperty ("Checked").SetValue (ctrl' Convert.ToBoolean (val)' null);  		item.ControlType.GetProperty ("Text").SetValue (ctrl' item.Description' null);  		tlpex.SetColumnSpan (ctrl as Control' 2);  		(ctrl as CheckBox).CheckedChanged += new EventHandler ((s' ex) => {  			ChangeBitInActor (item' ac' item.Mask' ((CheckBox)s).Checked);  		});  	} else {  		/* Fallback */if (item.ControlType.GetProperty ("Text") != null) {  			string fstr = "{0}";  			switch (item.DisplayStyle) {  			case Definition.Item.DisplayStyles.Hexadecimal:  				fstr = "0x{0:X}";  				break;  			case Definition.Item.DisplayStyles.Decimal:  				fstr = "{0:D}";  				break;  			}  			item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  			(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  				object newval = Activator.CreateInstance (item.ValueType);  				System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  					typeof(string)'  					typeof(System.Globalization.NumberStyles)  				});  				if (mi != null) {  					/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  					/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  						return;  					/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  					/* Proper value string found? */if (valstr != null && valstr != "") {  						try {  							/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  								valstr'  								ns  							});  							/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  							if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  								numberchanged ();  						} catch (TargetInvocationException tiex) {  							if (tiex.InnerException is FormatException) {  								/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  						}  					}  				}  			});  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (item.ControlType == typeof(ComboBox)) {  	/* Set ComboBox */item.ControlType.GetProperty ("DropDownStyle").SetValue (ctrl' ComboBoxStyle.DropDownList' null);  	item.ControlType.GetProperty ("DisplayMember").SetValue (ctrl' "Description"' null);  	if (!individual && (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront) && (tag is List<HeaderCommands.Rooms.RoomInfoClass>)) {  		/* Item usage is room number in transition actor; get room listing from function tag */item.Options = new List<Definition.Item.Option> ();  		foreach (HeaderCommands.Rooms.RoomInfoClass ric in (tag as List<HeaderCommands.Rooms.RoomInfoClass>))  			item.Options.Add (new Definition.Item.Option () {  				Description = ric.Description'  				Value = ric.Number  			});  	}  	if (item.Options.Count > 0) {  		item.ControlType.GetProperty ("DataSource").SetValue (ctrl' item.Options' null);  		item.ControlType.GetProperty ("SelectedItem").SetValue (ctrl' item.Options.Find (x => x.Value == (Convert.ToUInt64 (val) & item.Mask))' null);  		(ctrl as ComboBox).SelectedIndexChanged += new EventHandler ((s' ex) => {  			SetValueInActor (item' ac' ((Definition.Item.Option)((ComboBox)s).SelectedItem).Value);  		});  	}  } else if (item.ControlType == typeof(CheckBox)) {  	/* Set CheckBox */item.ControlType.GetProperty ("Checked").SetValue (ctrl' Convert.ToBoolean (val)' null);  	item.ControlType.GetProperty ("Text").SetValue (ctrl' item.Description' null);  	tlpex.SetColumnSpan (ctrl as Control' 2);  	(ctrl as CheckBox).CheckedChanged += new EventHandler ((s' ex) => {  		ChangeBitInActor (item' ac' item.Mask' ((CheckBox)s).Checked);  	});  } else {  	/* Fallback */if (item.ControlType.GetProperty ("Text") != null) {  		string fstr = "{0}";  		switch (item.DisplayStyle) {  		case Definition.Item.DisplayStyles.Hexadecimal:  			fstr = "0x{0:X}";  			break;  		case Definition.Item.DisplayStyles.Decimal:  			fstr = "{0:D}";  			break;  		}  		item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  		(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  			object newval = Activator.CreateInstance (item.ValueType);  			System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  				typeof(string)'  				typeof(System.Globalization.NumberStyles)  			});  			if (mi != null) {  				/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  				/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  					return;  				/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  				/* Proper value string found? */if (valstr != null && valstr != "") {  					try {  						/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  							valstr'  							ns  						});  						/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  						if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  							numberchanged ();  					} catch (TargetInvocationException tiex) {  						if (tiex.InnerException is FormatException) {  							/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  					}  				}  			}  		});  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (item.ControlType == typeof(ComboBox)) {  	/* Set ComboBox */item.ControlType.GetProperty ("DropDownStyle").SetValue (ctrl' ComboBoxStyle.DropDownList' null);  	item.ControlType.GetProperty ("DisplayMember").SetValue (ctrl' "Description"' null);  	if (!individual && (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront) && (tag is List<HeaderCommands.Rooms.RoomInfoClass>)) {  		/* Item usage is room number in transition actor; get room listing from function tag */item.Options = new List<Definition.Item.Option> ();  		foreach (HeaderCommands.Rooms.RoomInfoClass ric in (tag as List<HeaderCommands.Rooms.RoomInfoClass>))  			item.Options.Add (new Definition.Item.Option () {  				Description = ric.Description'  				Value = ric.Number  			});  	}  	if (item.Options.Count > 0) {  		item.ControlType.GetProperty ("DataSource").SetValue (ctrl' item.Options' null);  		item.ControlType.GetProperty ("SelectedItem").SetValue (ctrl' item.Options.Find (x => x.Value == (Convert.ToUInt64 (val) & item.Mask))' null);  		(ctrl as ComboBox).SelectedIndexChanged += new EventHandler ((s' ex) => {  			SetValueInActor (item' ac' ((Definition.Item.Option)((ComboBox)s).SelectedItem).Value);  		});  	}  } else if (item.ControlType == typeof(CheckBox)) {  	/* Set CheckBox */item.ControlType.GetProperty ("Checked").SetValue (ctrl' Convert.ToBoolean (val)' null);  	item.ControlType.GetProperty ("Text").SetValue (ctrl' item.Description' null);  	tlpex.SetColumnSpan (ctrl as Control' 2);  	(ctrl as CheckBox).CheckedChanged += new EventHandler ((s' ex) => {  		ChangeBitInActor (item' ac' item.Mask' ((CheckBox)s).Checked);  	});  } else {  	/* Fallback */if (item.ControlType.GetProperty ("Text") != null) {  		string fstr = "{0}";  		switch (item.DisplayStyle) {  		case Definition.Item.DisplayStyles.Hexadecimal:  			fstr = "0x{0:X}";  			break;  		case Definition.Item.DisplayStyles.Decimal:  			fstr = "{0:D}";  			break;  		}  		item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  		(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  			object newval = Activator.CreateInstance (item.ValueType);  			System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  				typeof(string)'  				typeof(System.Globalization.NumberStyles)  			});  			if (mi != null) {  				/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  				/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  					return;  				/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  				/* Proper value string found? */if (valstr != null && valstr != "") {  					try {  						/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  							valstr'  							ns  						});  						/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  						if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  							numberchanged ();  					} catch (TargetInvocationException tiex) {  						if (tiex.InnerException is FormatException) {  							/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  					}  				}  			}  		});  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (item.ControlType == typeof(ComboBox)) {  	/* Set ComboBox */item.ControlType.GetProperty ("DropDownStyle").SetValue (ctrl' ComboBoxStyle.DropDownList' null);  	item.ControlType.GetProperty ("DisplayMember").SetValue (ctrl' "Description"' null);  	if (!individual && (item.Usage == Definition.Item.Usages.NextRoomBack || item.Usage == Definition.Item.Usages.NextRoomFront) && (tag is List<HeaderCommands.Rooms.RoomInfoClass>)) {  		/* Item usage is room number in transition actor; get room listing from function tag */item.Options = new List<Definition.Item.Option> ();  		foreach (HeaderCommands.Rooms.RoomInfoClass ric in (tag as List<HeaderCommands.Rooms.RoomInfoClass>))  			item.Options.Add (new Definition.Item.Option () {  				Description = ric.Description'  				Value = ric.Number  			});  	}  	if (item.Options.Count > 0) {  		item.ControlType.GetProperty ("DataSource").SetValue (ctrl' item.Options' null);  		item.ControlType.GetProperty ("SelectedItem").SetValue (ctrl' item.Options.Find (x => x.Value == (Convert.ToUInt64 (val) & item.Mask))' null);  		(ctrl as ComboBox).SelectedIndexChanged += new EventHandler ((s' ex) => {  			SetValueInActor (item' ac' ((Definition.Item.Option)((ComboBox)s).SelectedItem).Value);  		});  	}  } else if (item.ControlType == typeof(CheckBox)) {  	/* Set CheckBox */item.ControlType.GetProperty ("Checked").SetValue (ctrl' Convert.ToBoolean (val)' null);  	item.ControlType.GetProperty ("Text").SetValue (ctrl' item.Description' null);  	tlpex.SetColumnSpan (ctrl as Control' 2);  	(ctrl as CheckBox).CheckedChanged += new EventHandler ((s' ex) => {  		ChangeBitInActor (item' ac' item.Mask' ((CheckBox)s).Checked);  	});  } else {  	/* Fallback */if (item.ControlType.GetProperty ("Text") != null) {  		string fstr = "{0}";  		switch (item.DisplayStyle) {  		case Definition.Item.DisplayStyles.Hexadecimal:  			fstr = "0x{0:X}";  			break;  		case Definition.Item.DisplayStyles.Decimal:  			fstr = "{0:D}";  			break;  		}  		item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  		(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  			object newval = Activator.CreateInstance (item.ValueType);  			System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  				typeof(string)'  				typeof(System.Globalization.NumberStyles)  			});  			if (mi != null) {  				/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  				/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  					return;  				/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  				/* Proper value string found? */if (valstr != null && valstr != "") {  					try {  						/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  							valstr'  							ns  						});  						/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  						if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  							numberchanged ();  					} catch (TargetInvocationException tiex) {  						if (tiex.InnerException is FormatException) {  							/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  					}  				}  			}  		});  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (item.ControlType == typeof(CheckBox)) {  	/* Set CheckBox */item.ControlType.GetProperty ("Checked").SetValue (ctrl' Convert.ToBoolean (val)' null);  	item.ControlType.GetProperty ("Text").SetValue (ctrl' item.Description' null);  	tlpex.SetColumnSpan (ctrl as Control' 2);  	(ctrl as CheckBox).CheckedChanged += new EventHandler ((s' ex) => {  		ChangeBitInActor (item' ac' item.Mask' ((CheckBox)s).Checked);  	});  } else {  	/* Fallback */if (item.ControlType.GetProperty ("Text") != null) {  		string fstr = "{0}";  		switch (item.DisplayStyle) {  		case Definition.Item.DisplayStyles.Hexadecimal:  			fstr = "0x{0:X}";  			break;  		case Definition.Item.DisplayStyles.Decimal:  			fstr = "{0:D}";  			break;  		}  		item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  		(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  			object newval = Activator.CreateInstance (item.ValueType);  			System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  				typeof(string)'  				typeof(System.Globalization.NumberStyles)  			});  			if (mi != null) {  				/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  				/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  					return;  				/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  				/* Proper value string found? */if (valstr != null && valstr != "") {  					try {  						/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  							valstr'  							ns  						});  						/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  						if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  							numberchanged ();  					} catch (TargetInvocationException tiex) {  						if (tiex.InnerException is FormatException) {  							/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  					}  				}  			}  		});  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (item.ControlType == typeof(CheckBox)) {  	/* Set CheckBox */item.ControlType.GetProperty ("Checked").SetValue (ctrl' Convert.ToBoolean (val)' null);  	item.ControlType.GetProperty ("Text").SetValue (ctrl' item.Description' null);  	tlpex.SetColumnSpan (ctrl as Control' 2);  	(ctrl as CheckBox).CheckedChanged += new EventHandler ((s' ex) => {  		ChangeBitInActor (item' ac' item.Mask' ((CheckBox)s).Checked);  	});  } else {  	/* Fallback */if (item.ControlType.GetProperty ("Text") != null) {  		string fstr = "{0}";  		switch (item.DisplayStyle) {  		case Definition.Item.DisplayStyles.Hexadecimal:  			fstr = "0x{0:X}";  			break;  		case Definition.Item.DisplayStyles.Decimal:  			fstr = "{0:D}";  			break;  		}  		item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  		(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  			object newval = Activator.CreateInstance (item.ValueType);  			System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  				typeof(string)'  				typeof(System.Globalization.NumberStyles)  			});  			if (mi != null) {  				/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  				/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  					return;  				/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  				/* Proper value string found? */if (valstr != null && valstr != "") {  					try {  						/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  							valstr'  							ns  						});  						/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  						if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  							numberchanged ();  					} catch (TargetInvocationException tiex) {  						if (tiex.InnerException is FormatException) {  							/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  					}  				}  			}  		});  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (item.ControlType == typeof(CheckBox)) {  	/* Set CheckBox */item.ControlType.GetProperty ("Checked").SetValue (ctrl' Convert.ToBoolean (val)' null);  	item.ControlType.GetProperty ("Text").SetValue (ctrl' item.Description' null);  	tlpex.SetColumnSpan (ctrl as Control' 2);  	(ctrl as CheckBox).CheckedChanged += new EventHandler ((s' ex) => {  		ChangeBitInActor (item' ac' item.Mask' ((CheckBox)s).Checked);  	});  } else {  	/* Fallback */if (item.ControlType.GetProperty ("Text") != null) {  		string fstr = "{0}";  		switch (item.DisplayStyle) {  		case Definition.Item.DisplayStyles.Hexadecimal:  			fstr = "0x{0:X}";  			break;  		case Definition.Item.DisplayStyles.Decimal:  			fstr = "{0:D}";  			break;  		}  		item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  		(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  			object newval = Activator.CreateInstance (item.ValueType);  			System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  				typeof(string)'  				typeof(System.Globalization.NumberStyles)  			});  			if (mi != null) {  				/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  				/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  					return;  				/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  				/* Proper value string found? */if (valstr != null && valstr != "") {  					try {  						/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  							valstr'  							ns  						});  						/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  						if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  							numberchanged ();  					} catch (TargetInvocationException tiex) {  						if (tiex.InnerException is FormatException) {  							/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  					}  				}  			}  		});  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: tlpex.SetColumnSpan (ctrl as Control' 2);  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (item.ControlType.GetProperty ("Text") != null) {  	string fstr = "{0}";  	switch (item.DisplayStyle) {  	case Definition.Item.DisplayStyles.Hexadecimal:  		fstr = "0x{0:X}";  		break;  	case Definition.Item.DisplayStyles.Decimal:  		fstr = "{0:D}";  		break;  	}  	item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  	(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  		object newval = Activator.CreateInstance (item.ValueType);  		System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  			typeof(string)'  			typeof(System.Globalization.NumberStyles)  		});  		if (mi != null) {  			/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  			/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  				return;  			/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  			/* Proper value string found? */if (valstr != null && valstr != "") {  				try {  					/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  						valstr'  						ns  					});  					/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  					if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  						numberchanged ();  				} catch (TargetInvocationException tiex) {  					if (tiex.InnerException is FormatException) {  						/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  				}  			}  		}  	});  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (item.ControlType.GetProperty ("Text") != null) {  	string fstr = "{0}";  	switch (item.DisplayStyle) {  	case Definition.Item.DisplayStyles.Hexadecimal:  		fstr = "0x{0:X}";  		break;  	case Definition.Item.DisplayStyles.Decimal:  		fstr = "{0:D}";  		break;  	}  	item.ControlType.GetProperty ("Text").SetValue (ctrl' string.Format (fstr' val)' null);  	(ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  		object newval = Activator.CreateInstance (item.ValueType);  		System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  			typeof(string)'  			typeof(System.Globalization.NumberStyles)  		});  		if (mi != null) {  			/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  			/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  				return;  			/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  			/* Proper value string found? */if (valstr != null && valstr != "") {  				try {  					/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  						valstr'  						ns  					});  					/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  					if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  						numberchanged ();  				} catch (TargetInvocationException tiex) {  					if (tiex.InnerException is FormatException) {  						/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  				}  			}  		}  	});  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: (ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  	object newval = Activator.CreateInstance (item.ValueType);  	System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  		typeof(string)'  		typeof(System.Globalization.NumberStyles)  	});  	if (mi != null) {  		/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  		/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  			return;  		/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  		/* Proper value string found? */if (valstr != null && valstr != "") {  			try {  				/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  					valstr'  					ns  				});  				/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  				if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  					numberchanged ();  			} catch (TargetInvocationException tiex) {  				if (tiex.InnerException is FormatException) {  					/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  			}  		}  	}  });  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: (ctrl as Control).TextChanged += new EventHandler ((s' ex) => {  	object newval = Activator.CreateInstance (item.ValueType);  	System.Reflection.MethodInfo mi = item.ValueType.GetMethod ("Parse"' new Type[] {  		typeof(string)'  		typeof(System.Globalization.NumberStyles)  	});  	if (mi != null) {  		/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  		/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  			return;  		/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  		/* Proper value string found? */if (valstr != null && valstr != "") {  			try {  				/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  					valstr'  					ns  				});  				/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  				if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  					numberchanged ();  			} catch (TargetInvocationException tiex) {  				if (tiex.InnerException is FormatException) {  					/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  			}  		}  	}  });  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (mi != null) {  	/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  	/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  		return;  	/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  	/* Proper value string found? */if (valstr != null && valstr != "") {  		try {  			/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  				valstr'  				ns  			});  			/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  			if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  				numberchanged ();  		} catch (TargetInvocationException tiex) {  			if (tiex.InnerException is FormatException) {  				/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (mi != null) {  	/* Determine NumberStyle to use */System.Globalization.NumberStyles ns = (item.DisplayStyle == Definition.Item.DisplayStyles.Hexadecimal ? System.Globalization.NumberStyles.HexNumber : System.Globalization.NumberStyles.Integer);  	/* Hex number; is text long enough? */if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  		return;  	/* Get value string' depending on NumberStyle */string valstr = (ns == System.Globalization.NumberStyles.HexNumber ? ((Control)s).Text.Substring (2) : ((Control)s).Text);  	/* Proper value string found? */if (valstr != null && valstr != "") {  		try {  			/* Invoke Parse function and get parsed value */newval = mi.Invoke (newval' new object[] {  				valstr'  				ns  			});  			/* Set new value in actor; if usage is ActorNumber' also do callback */SetValueInActor (item' ac' newval);  			if (item.Usage == Definition.Item.Usages.ActorNumber && numberchanged != null)  				numberchanged ();  		} catch (TargetInvocationException tiex) {  			if (tiex.InnerException is FormatException) {  				/* Ignore; happens with ex. malformed hex numbers (i.e. "0xx0") */}  		}  	}  }  
Magic Number,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following statement contains a magic number: if (ns == System.Globalization.NumberStyles.HexNumber && ((Control)s).Text.Length < 2)  	return;  
Magic Number,SceneNavi.Controls,HScrollBarEx,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\HScrollBarEx.cs,WndProc,The following statement contains a magic number: if (m.Msg == 8469) {  	switch ((uint)m.WParam) {  	case 2:  		// page up  		if (this.Value - this.ValLargeChange > 0) {  			this.Value -= this.ValLargeChange;  		} else {  			this.Value = 0;  		}  		break;  	case 3:  		// page down  		if (this.Value + this.LargeChange + this.ValLargeChange < this.Maximum) {  			this.Value += this.ValLargeChange;  		} else {  			this.Value = this.Maximum - this.LargeChange;  		}  		break;  	default:  		base.WndProc (ref m);  		break;  	}  } else {  	base.WndProc (ref m);  }  
Magic Number,SceneNavi.Controls,HScrollBarEx,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\HScrollBarEx.cs,WndProc,The following statement contains a magic number: if (m.Msg == 8469) {  	switch ((uint)m.WParam) {  	case 2:  		// page up  		if (this.Value - this.ValLargeChange > 0) {  			this.Value -= this.ValLargeChange;  		} else {  			this.Value = 0;  		}  		break;  	case 3:  		// page down  		if (this.Value + this.LargeChange + this.ValLargeChange < this.Maximum) {  			this.Value += this.ValLargeChange;  		} else {  			this.Value = this.Maximum - this.LargeChange;  		}  		break;  	default:  		base.WndProc (ref m);  		break;  	}  } else {  	base.WndProc (ref m);  }  
Magic Number,SceneNavi.Controls,HScrollBarEx,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\HScrollBarEx.cs,WndProc,The following statement contains a magic number: if (m.Msg == 8469) {  	switch ((uint)m.WParam) {  	case 2:  		// page up  		if (this.Value - this.ValLargeChange > 0) {  			this.Value -= this.ValLargeChange;  		} else {  			this.Value = 0;  		}  		break;  	case 3:  		// page down  		if (this.Value + this.LargeChange + this.ValLargeChange < this.Maximum) {  			this.Value += this.ValLargeChange;  		} else {  			this.Value = this.Maximum - this.LargeChange;  		}  		break;  	default:  		base.WndProc (ref m);  		break;  	}  } else {  	base.WndProc (ref m);  }  
Magic Number,SceneNavi.Controls,HScrollBarEx,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\HScrollBarEx.cs,WndProc,The following statement contains a magic number: switch ((uint)m.WParam) {  case 2:  	// page up  	if (this.Value - this.ValLargeChange > 0) {  		this.Value -= this.ValLargeChange;  	} else {  		this.Value = 0;  	}  	break;  case 3:  	// page down  	if (this.Value + this.LargeChange + this.ValLargeChange < this.Maximum) {  		this.Value += this.ValLargeChange;  	} else {  		this.Value = this.Maximum - this.LargeChange;  	}  	break;  default:  	base.WndProc (ref m);  	break;  }  
Magic Number,SceneNavi.Controls,HScrollBarEx,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\HScrollBarEx.cs,WndProc,The following statement contains a magic number: switch ((uint)m.WParam) {  case 2:  	// page up  	if (this.Value - this.ValLargeChange > 0) {  		this.Value -= this.ValLargeChange;  	} else {  		this.Value = 0;  	}  	break;  case 3:  	// page down  	if (this.Value + this.LargeChange + this.ValLargeChange < this.Maximum) {  		this.Value += this.ValLargeChange;  	} else {  		this.Value = this.Maximum - this.LargeChange;  	}  	break;  default:  	base.WndProc (ref m);  	break;  }  
Magic Number,SceneNavi.Controls,ListViewEx,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\ListViewEx.cs,OnHandleCreated,The following statement contains a magic number: if (Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major >= 6) {  	SetWindowTheme (this.Handle' "explorer"' null);  }  
Magic Number,SceneNavi.Controls,TreeViewEx,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\Controls\TreeViewEx.cs,OnHandleCreated,The following statement contains a magic number: if (Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major >= 6) {  	SetWindowTheme (this.Handle' "explorer"' null);  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: if (vertsegdata != null) {  	Vertices = new List<Vector3d> ();  	for (int i = 0; i < VertexCount; i++) {  		Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  	}  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: if (vertsegdata != null) {  	Vertices = new List<Vector3d> ();  	for (int i = 0; i < VertexCount; i++) {  		Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  	}  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: if (vertsegdata != null) {  	Vertices = new List<Vector3d> ();  	for (int i = 0; i < VertexCount; i++) {  		Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  	}  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: if (vertsegdata != null) {  	Vertices = new List<Vector3d> ();  	for (int i = 0; i < VertexCount; i++) {  		Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  	}  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: if (vertsegdata != null) {  	Vertices = new List<Vector3d> ();  	for (int i = 0; i < VertexCount; i++) {  		Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  	}  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: for (int i = 0; i < VertexCount; i++) {  	Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: for (int i = 0; i < VertexCount; i++) {  	Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: for (int i = 0; i < VertexCount; i++) {  	Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: for (int i = 0; i < VertexCount; i++) {  	Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: for (int i = 0; i < VertexCount; i++) {  	Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: Vertices.Add (new Vector3d (Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6)))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 2))' Endian.SwapInt16 (BitConverter.ToInt16 (vertsegdata' (int)(VertexArrayOffset & 0xFFFFFF) + (i * 6) + 4))));  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: if (ptlen > 0) {  	for (uint i = PolygonTypeOffset' j = 0; i < (uint)(PolygonTypeOffset + (ptlen & 0xFFFFFF)); i += 8' j++) {  		PolygonTypes.Add (new PolygonType (ROM' i' (int)j));  	}  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: for (uint i = PolygonTypeOffset' j = 0; i < (uint)(PolygonTypeOffset + (ptlen & 0xFFFFFF)); i += 8' j++) {  	PolygonTypes.Add (new PolygonType (ROM' i' (int)j));  }  
Magic Number,SceneNavi.HeaderCommands,Collision,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Collision.cs,Collision,The following statement contains a magic number: i += 8
Magic Number,SceneNavi.HeaderCommands,EnvironmentSettings,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\EnvironmentSettings.cs,EnvironmentSettings,The following statement contains a magic number: for (int i = 0; i < GetCountGeneric (); i++)  	EnvSettingList.Add (new Entry (ROM' (uint)(GetAddressGeneric () + i * 22)));  
Magic Number,SceneNavi.HeaderCommands,EnvironmentSettings,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\EnvironmentSettings.cs,EnvironmentSettings,The following statement contains a magic number: EnvSettingList.Add (new Entry (ROM' (uint)(GetAddressGeneric () + i * 22)));  
Magic Number,SceneNavi.HeaderCommands,SettingsSoundScene,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\SettingsSoundScene.cs,SettingsSoundScene,The following statement contains a magic number: Reverb = (byte)((this.Data >> 48) & 0xFF);  
Magic Number,SceneNavi.HeaderCommands,SettingsSoundScene,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\SettingsSoundScene.cs,SettingsSoundScene,The following statement contains a magic number: NightSfxID = (byte)((this.Data >> 8) & 0xFF);  
Magic Number,SceneNavi.HeaderCommands,SettingsSoundScene,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\SettingsSoundScene.cs,Store,The following statement contains a magic number: databuf [(int)(baseadr + (this.Offset & 0xFFFFFF) + 6)] = NightSfxID;  
Magic Number,SceneNavi.HeaderCommands,SettingsSoundScene,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\SettingsSoundScene.cs,Store,The following statement contains a magic number: databuf [(int)(baseadr + (this.Offset & 0xFFFFFF) + 7)] = TrackID;  
Magic Number,SceneNavi.HeaderCommands,Waypoints,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Waypoints.cs,Waypoints,The following statement contains a magic number: while (true) {  	PathHeader nph = new PathHeader (ROM' (uint)(GetAddressGeneric () + i * 8)' i);  	if (nph.Points == null)  		break;  	Paths.Add (nph);  	i++;  }  
Magic Number,SceneNavi.HeaderCommands,Waypoints,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Waypoints.cs,Store,The following statement contains a magic number: foreach (HeaderCommands.Waypoints.PathHeader path in this.Paths) {  	foreach (HeaderCommands.Waypoints.Waypoint wp in path.Points) {  		byte[] bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.X));  		Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF))' bytes.Length);  		bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.Y));  		Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 2)' bytes.Length);  		bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.Z));  		Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 4)' bytes.Length);  	}  }  
Magic Number,SceneNavi.HeaderCommands,Waypoints,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Waypoints.cs,Store,The following statement contains a magic number: foreach (HeaderCommands.Waypoints.PathHeader path in this.Paths) {  	foreach (HeaderCommands.Waypoints.Waypoint wp in path.Points) {  		byte[] bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.X));  		Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF))' bytes.Length);  		bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.Y));  		Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 2)' bytes.Length);  		bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.Z));  		Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 4)' bytes.Length);  	}  }  
Magic Number,SceneNavi.HeaderCommands,Waypoints,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Waypoints.cs,Store,The following statement contains a magic number: foreach (HeaderCommands.Waypoints.Waypoint wp in path.Points) {  	byte[] bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.X));  	Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF))' bytes.Length);  	bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.Y));  	Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 2)' bytes.Length);  	bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.Z));  	Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 4)' bytes.Length);  }  
Magic Number,SceneNavi.HeaderCommands,Waypoints,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Waypoints.cs,Store,The following statement contains a magic number: foreach (HeaderCommands.Waypoints.Waypoint wp in path.Points) {  	byte[] bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.X));  	Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF))' bytes.Length);  	bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.Y));  	Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 2)' bytes.Length);  	bytes = BitConverter.GetBytes (Endian.SwapInt16 ((short)wp.Z));  	Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 4)' bytes.Length);  }  
Magic Number,SceneNavi.HeaderCommands,Waypoints,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Waypoints.cs,Store,The following statement contains a magic number: Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 2)' bytes.Length);  
Magic Number,SceneNavi.HeaderCommands,Waypoints,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Waypoints.cs,Store,The following statement contains a magic number: Buffer.BlockCopy (bytes' 0' databuf' (int)(baseadr + (wp.Address & 0xFFFFFF) + 4)' bytes.Length);  
Magic Number,SceneNavi.HeaderCommands,SpecialObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\SpecialObjects.cs,Store,The following statement contains a magic number: Buffer.BlockCopy (objbytes' 0' databuf' (int)(baseadr + (this.Offset & 0xFFFFFF) + 6)' objbytes.Length);  
Magic Number,SceneNavi.HeaderCommands,Actors,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Actors.cs,Actors,The following statement contains a magic number: for (int i = 0; i < GetCountGeneric (); i++)  	ActorList.Add (new Entry (ROM' (uint)(GetAddressGeneric () + i * 16)' (i + 1)' (Command == HeaderLoader.CommandTypeIDs.Spawns)' (Command == HeaderLoader.CommandTypeIDs.Transitions)));  
Magic Number,SceneNavi.HeaderCommands,Actors,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Actors.cs,Actors,The following statement contains a magic number: ActorList.Add (new Entry (ROM' (uint)(GetAddressGeneric () + i * 16)' (i + 1)' (Command == HeaderLoader.CommandTypeIDs.Spawns)' (Command == HeaderLoader.CommandTypeIDs.Transitions)));  
Magic Number,SceneNavi.HeaderCommands,Generic,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Generic.cs,Generic,The following statement contains a magic number: ofs += 8;  
Magic Number,SceneNavi.HeaderCommands,Generic,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Generic.cs,GetCountGeneric,The following statement contains a magic number: return (int)((Data >> 48) & 0xFF);  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: DLTablePointer = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [seg])' (int)(adr + 4)));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: OtherDataPointer = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [seg])' (int)(adr + 8)));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: switch (Type) {  case 0x00: {  	for (int i = 0; i < Count; i++) {  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  	}  	break;  }  case 0x01: {  	for (int i = 0; i < Count; i++)  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  	break;  }  case 0x02: {  	for (int i = 0; i < Count; i++) {  		short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  		short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  		short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  		short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  		MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  		MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  		opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  		transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  	}  	break;  }  default:  	throw new Exception (string.Format ("Invalid mesh type 0x{0:X2}"' Type));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8)))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 8) + 4))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++)  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++)  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 4)))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	short s1 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16))));  	short s2 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 2)));  	short s3 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 4)));  	short s4 = Endian.SwapInt16 (BitConverter.ToInt16 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 6)));  	MaxClipBounds.Add (new Vector3d (s1' 0.0' s2));  	MinClipBounds.Add (new Vector3d (s3' 0.0' s4));  	opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  	transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: opaqueDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 8))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,MeshHeader,The following statement contains a magic number: transparentDLs.Add (Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)(DLTablePointer >> 24)])' (int)((DLTablePointer & 0xFFFFFF) + (i * 16) + 12))));  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,CreateDisplayLists,The following statement contains a magic number: foreach (SimpleF3DEX2.SimpleTriangle st in TriangleList) {  	GL.Vertex3 (st.Vertices [0]);  	GL.Vertex3 (st.Vertices [1]);  	GL.Vertex3 (st.Vertices [2]);  }  
Magic Number,SceneNavi.HeaderCommands,MeshHeader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\MeshHeader.cs,CreateDisplayLists,The following statement contains a magic number: GL.Vertex3 (st.Vertices [2]);  
Magic Number,SceneNavi.HeaderCommands,Objects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Objects.cs,Objects,The following statement contains a magic number: for (int i = 0; i < GetCountGeneric (); i++)  	ObjectList.Add (new Entry (ROM' (uint)(GetAddressGeneric () + i * 2)));  
Magic Number,SceneNavi.HeaderCommands,Objects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Objects.cs,Objects,The following statement contains a magic number: ObjectList.Add (new Entry (ROM' (uint)(GetAddressGeneric () + i * 2)));  
Magic Number,SceneNavi.HeaderCommands,Rooms,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Rooms.cs,Rooms,The following statement contains a magic number: for (int i = 0; i < GetCountGeneric (); i++) {  	RoomInfoClass roomadr = new RoomInfoClass (ROM' basecmd.Parent' i' Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [seg])' (int)((GetAddressGeneric () & 0xFFFFFF) + i * 8)))' Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [seg])' (int)((GetAddressGeneric () & 0xFFFFFF) + i * 8) + 4)));  	RoomInformation.Add (roomadr);  }  
Magic Number,SceneNavi.HeaderCommands,Rooms,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Rooms.cs,Rooms,The following statement contains a magic number: for (int i = 0; i < GetCountGeneric (); i++) {  	RoomInfoClass roomadr = new RoomInfoClass (ROM' basecmd.Parent' i' Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [seg])' (int)((GetAddressGeneric () & 0xFFFFFF) + i * 8)))' Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [seg])' (int)((GetAddressGeneric () & 0xFFFFFF) + i * 8) + 4)));  	RoomInformation.Add (roomadr);  }  
Magic Number,SceneNavi.HeaderCommands,Rooms,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\HeaderCommands\Rooms.cs,Rooms,The following statement contains a magic number: for (int i = 0; i < GetCountGeneric (); i++) {  	RoomInfoClass roomadr = new RoomInfoClass (ROM' basecmd.Parent' i' Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [seg])' (int)((GetAddressGeneric () & 0xFFFFFF) + i * 8)))' Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [seg])' (int)((GetAddressGeneric () & 0xFFFFFF) + i * 8) + 4)));  	RoomInformation.Add (roomadr);  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,MiscDrawingHelpers,The following statement contains a magic number: GL.TexImage2D (TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' 2' 2' 0' PixelFormat.Rgba' PixelType.UnsignedByte' texbuf);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,MiscDrawingHelpers,The following statement contains a magic number: GL.TexImage2D (TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' 2' 2' 0' PixelFormat.Rgba' PixelType.UnsignedByte' texbuf);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderCube,The following statement contains a magic number: if (color)  	GL.Color3 (0.5' 0.5' 0.5);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderCube,The following statement contains a magic number: if (color)  	GL.Color3 (0.5' 0.5' 0.5);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderCube,The following statement contains a magic number: if (color)  	GL.Color3 (0.5' 0.5' 0.5);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderCube,The following statement contains a magic number: GL.Color3 (0.5' 0.5' 0.5);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderCube,The following statement contains a magic number: GL.Color3 (0.5' 0.5' 0.5);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderCube,The following statement contains a magic number: GL.Color3 (0.5' 0.5' 0.5);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderNotchCircle,The following statement contains a magic number: for (int ii = 0; ii < segments; ii++) {  	if (ii == segments / 4)  		GL.Vertex2 (x' (y + 1.5));  	else  		GL.Vertex2 (x' y);  	t = x;  	x = c * x - s * y;  	y = s * t + c * y;  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderNotchCircle,The following statement contains a magic number: for (int ii = 0; ii < segments; ii++) {  	if (ii == segments / 4)  		GL.Vertex2 (x' (y + 1.5));  	else  		GL.Vertex2 (x' y);  	t = x;  	x = c * x - s * y;  	y = s * t + c * y;  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderNotchCircle,The following statement contains a magic number: if (ii == segments / 4)  	GL.Vertex2 (x' (y + 1.5));  else  	GL.Vertex2 (x' y);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderNotchCircle,The following statement contains a magic number: if (ii == segments / 4)  	GL.Vertex2 (x' (y + 1.5));  else  	GL.Vertex2 (x' y);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderNotchCircle,The following statement contains a magic number: GL.Vertex2 (x' (y + 1.5));  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderSphere,The following statement contains a magic number: if (n < 4 || r <= 0) {  	GL.Begin (PrimitiveType.Points);  	GL.Vertex3 (c);  	GL.End ();  	return;  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,RenderSphere,The following statement contains a magic number: for (j = 0; j < n / 2; j++) {  	theta1 = j * TWOPI / n - PID2;  	theta2 = (j + 1) * TWOPI / n - PID2;  	GL.Begin (PrimitiveType.QuadStrip);  	for (i = n; i >= 0; i--) {  		theta3 = i * TWOPI / n;  		e.X = Math.Cos (theta2) * Math.Cos (theta3);  		e.Y = Math.Sin (theta2);  		e.Z = Math.Cos (theta2) * Math.Sin (theta3);  		p.X = c.X + r * e.X;  		p.Y = c.Y + r * e.Y;  		p.Z = c.Z + r * e.Z;  		GL.Vertex3 (p);  		e.X = Math.Cos (theta1) * Math.Cos (theta3);  		e.Y = Math.Sin (theta1);  		e.Z = Math.Cos (theta1) * Math.Sin (theta3);  		p.X = c.X + r * e.X;  		p.Y = c.Y + r * e.Y;  		p.Z = c.Z + r * e.Z;  		GL.Vertex3 (p);  	}  	GL.End ();  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: v [2] = new Vector3d (mvMax.X' mvMax.Y' mvMin.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: v [3] = new Vector3d (mvMin.X' mvMax.Y' mvMin.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: v [4] = new Vector3d (mvMin.X' mvMin.Y' mvMax.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: v [5] = new Vector3d (mvMax.X' mvMin.Y' mvMax.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: v [6] = new Vector3d (mvMax.X' mvMax.Y' mvMax.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: v [7] = new Vector3d (mvMin.X' mvMax.Y' mvMax.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [2]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [2]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [3]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [3]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [4]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [5]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [5]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [6]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [6]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [7]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [7]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [4]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [4]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [5]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [2]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [6]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [3]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (v [7]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: Verts [2] = Min + new Vector3d (Distance.X' Distance.Y' 0);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: Verts [3] = Min + new Vector3d (0' Distance.Y' 0);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: Verts [4] = Min + new Vector3d (0' 0' Distance.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: Verts [5] = Min + new Vector3d (Distance.X' 0' Distance.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: Verts [6] = Min + new Vector3d (Distance.X' Distance.Y' Distance.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: Verts [7] = Min + new Vector3d (0' Distance.Y' Distance.Z);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int it = 0; it < 2; it++) {  	// TODO  fix loop thingy; some quads don't render!  	PrimitiveType loop = (it == 1 ? PrimitiveType.LineLoop : PrimitiveType.Quads);  	PrimitiveType norm = (it == 1 ? PrimitiveType.Lines : PrimitiveType.QuadStrip);  	Color4 col = (it == 1 ? Color4.Black : Color);  	GL.Color4 (col);  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i]);  	GL.End ();  	GL.Begin (norm);  	for (int i = 0; i < 4; i++) {  		GL.Vertex3 (Verts [i]);  		GL.Vertex3 (Verts [i + 4]);  	}  	GL.End ();  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i + 4]);  	GL.End ();  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int it = 0; it < 2; it++) {  	// TODO  fix loop thingy; some quads don't render!  	PrimitiveType loop = (it == 1 ? PrimitiveType.LineLoop : PrimitiveType.Quads);  	PrimitiveType norm = (it == 1 ? PrimitiveType.Lines : PrimitiveType.QuadStrip);  	Color4 col = (it == 1 ? Color4.Black : Color);  	GL.Color4 (col);  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i]);  	GL.End ();  	GL.Begin (norm);  	for (int i = 0; i < 4; i++) {  		GL.Vertex3 (Verts [i]);  		GL.Vertex3 (Verts [i + 4]);  	}  	GL.End ();  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i + 4]);  	GL.End ();  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int it = 0; it < 2; it++) {  	// TODO  fix loop thingy; some quads don't render!  	PrimitiveType loop = (it == 1 ? PrimitiveType.LineLoop : PrimitiveType.Quads);  	PrimitiveType norm = (it == 1 ? PrimitiveType.Lines : PrimitiveType.QuadStrip);  	Color4 col = (it == 1 ? Color4.Black : Color);  	GL.Color4 (col);  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i]);  	GL.End ();  	GL.Begin (norm);  	for (int i = 0; i < 4; i++) {  		GL.Vertex3 (Verts [i]);  		GL.Vertex3 (Verts [i + 4]);  	}  	GL.End ();  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i + 4]);  	GL.End ();  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int it = 0; it < 2; it++) {  	// TODO  fix loop thingy; some quads don't render!  	PrimitiveType loop = (it == 1 ? PrimitiveType.LineLoop : PrimitiveType.Quads);  	PrimitiveType norm = (it == 1 ? PrimitiveType.Lines : PrimitiveType.QuadStrip);  	Color4 col = (it == 1 ? Color4.Black : Color);  	GL.Color4 (col);  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i]);  	GL.End ();  	GL.Begin (norm);  	for (int i = 0; i < 4; i++) {  		GL.Vertex3 (Verts [i]);  		GL.Vertex3 (Verts [i + 4]);  	}  	GL.End ();  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i + 4]);  	GL.End ();  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int it = 0; it < 2; it++) {  	// TODO  fix loop thingy; some quads don't render!  	PrimitiveType loop = (it == 1 ? PrimitiveType.LineLoop : PrimitiveType.Quads);  	PrimitiveType norm = (it == 1 ? PrimitiveType.Lines : PrimitiveType.QuadStrip);  	Color4 col = (it == 1 ? Color4.Black : Color);  	GL.Color4 (col);  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i]);  	GL.End ();  	GL.Begin (norm);  	for (int i = 0; i < 4; i++) {  		GL.Vertex3 (Verts [i]);  		GL.Vertex3 (Verts [i + 4]);  	}  	GL.End ();  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i + 4]);  	GL.End ();  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int it = 0; it < 2; it++) {  	// TODO  fix loop thingy; some quads don't render!  	PrimitiveType loop = (it == 1 ? PrimitiveType.LineLoop : PrimitiveType.Quads);  	PrimitiveType norm = (it == 1 ? PrimitiveType.Lines : PrimitiveType.QuadStrip);  	Color4 col = (it == 1 ? Color4.Black : Color);  	GL.Color4 (col);  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i]);  	GL.End ();  	GL.Begin (norm);  	for (int i = 0; i < 4; i++) {  		GL.Vertex3 (Verts [i]);  		GL.Vertex3 (Verts [i + 4]);  	}  	GL.End ();  	GL.Begin (loop);  	for (int i = 0; i < 4; i++)  		GL.Vertex3 (Verts [i + 4]);  	GL.End ();  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	GL.Vertex3 (Verts [i]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	GL.Vertex3 (Verts [i]);  	GL.Vertex3 (Verts [i + 4]);  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	GL.Vertex3 (Verts [i]);  	GL.Vertex3 (Verts [i + 4]);  }  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (Verts [i + 4]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	GL.Vertex3 (Verts [i + 4]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	GL.Vertex3 (Verts [i + 4]);  
Magic Number,SceneNavi.OpenGLHelpers,MiscDrawingHelpers,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\MiscDrawingHelpers.cs,DrawBox,The following statement contains a magic number: GL.Vertex3 (Verts [i + 4]);  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,WorldToScreen,The following statement contains a magic number: point.Y = (float)viewport [3] - point.Y;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,ScreenToWorld,The following statement contains a magic number: win.Y = (viewport [3] - pos.Y);  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,ScreenToWorld,The following statement contains a magic number: GL.ReadPixels ((int)pos.X' viewport [3] - (int)pos.Y' 1' 1' PixelFormat.DepthComponent' PixelType.Float' boxedZ);  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,UnProject,The following statement contains a magic number: pos.X = ((screen.X - (double)viewport [0]) / (double)viewport [2]) * 2.0 - 1.0;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,UnProject,The following statement contains a magic number: pos.X = ((screen.X - (double)viewport [0]) / (double)viewport [2]) * 2.0 - 1.0;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,UnProject,The following statement contains a magic number: pos.Y = ((screen.Y - (double)viewport [1]) / (double)viewport [3]) * 2.0 - 1.0;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,UnProject,The following statement contains a magic number: pos.Y = ((screen.Y - (double)viewport [1]) / (double)viewport [3]) * 2.0 - 1.0;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,UnProject,The following statement contains a magic number: pos.Z = (2.0 * screen.Z) - 1.0;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,Project,The following statement contains a magic number: _in.X = _in.X * 0.5 + 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,Project,The following statement contains a magic number: _in.X = _in.X * 0.5 + 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,Project,The following statement contains a magic number: _in.Y = _in.Y * 0.5 + 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,Project,The following statement contains a magic number: _in.Y = _in.Y * 0.5 + 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,Project,The following statement contains a magic number: _in.Z = _in.Z * 0.5 + 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,Project,The following statement contains a magic number: _in.Z = _in.Z * 0.5 + 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,Project,The following statement contains a magic number: _in.X = _in.X * viewport [2] + viewport [0];  
Magic Number,SceneNavi.OpenGLHelpers,ScreenWorldConversion,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\ScreenWorldConversion.cs,Project,The following statement contains a magic number: _in.Y = _in.Y * viewport [3] + viewport [1];  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.DepthRange (0.0' 0.99999);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Rotate (90.0' 1.0' 0.0' 0.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderNotchCircle (radius / 2.0' 48);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderNotchCircle (radius / 2.0' 48);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.DepthRange (0.0' 0.99999);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderSphere (Vector3d.Zero' 3.0' 12);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderSphere (Vector3d.Zero' 3.0' 12);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (1.0' 2.0' -1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (-1.0' 2.0' -1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (-1.0' 2.0' 1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (1.0' 2.0' 1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (-1.0' 2.0' 1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (-1.0' 2.0' -1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (1.0' 2.0' -1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (1.0' 2.0' 1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (1.0' 2.0' 1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (-1.0' 2.0' 1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (-1.0' 2.0' -1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: GL.Vertex3 (1.0' 2.0' -1.0);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (3.0' 2.0' 2.0)' false);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (3.0' 2.0' 2.0)' false);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (3.0' 2.0' 2.0)' false);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (3.0' 2.0' 2.0)' true);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (3.0' 2.0' 2.0)' true);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (3.0' 2.0' 2.0)' true);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (2.5' 4.5' 0.5)' new Vector3d (0.0' 4.0' 0.0)' false);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (2.5' 4.5' 0.5)' new Vector3d (0.0' 4.0' 0.0)' false);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (2.5' 4.5' 0.5)' new Vector3d (0.0' 4.0' 0.0)' false);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (2.5' 4.5' 0.5)' new Vector3d (0.0' 4.0' 0.0)' false);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (2.5' 4.5' 0.5)' new Vector3d (0.0' 4.0' 0.0)' true);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (2.5' 4.5' 0.5)' new Vector3d (0.0' 4.0' 0.0)' true);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (2.5' 4.5' 0.5)' new Vector3d (0.0' 4.0' 0.0)' true);  
Magic Number,SceneNavi.OpenGLHelpers,StockObjects,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\StockObjects.cs,StockObjects,The following statement contains a magic number: MiscDrawingHelpers.RenderCube (new Vector3d (2.5' 4.5' 0.5)' new Vector3d (0.0' 4.0' 0.0)' true);  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,Reset,The following statement contains a magic number: Pos = new Vector3d (0.0' 0.0' -15.0);  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Changed) {  	if (MouseCoord.X < NewMouseCoord.X) {  		Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  		if (Rot.Y > 360.0)  			Rot.Y = 0.0;  	} else {  		Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  		if (Rot.Y < -360.0)  			Rot.Y = 0.0;  	}  	if (MouseCoord.Y < NewMouseCoord.Y) {  		if (Rot.X >= 90.0)  			Rot.X = 90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	} else {  		if (Rot.X <= -90.0)  			Rot.X = -90.0;  		else  			Rot.X += (Dy / Sensitivity) * 0.225;  	}  	MouseCoordOld = MouseCoord;  	MouseCoord = NewMouseCoord;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.X < NewMouseCoord.X) {  	Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  	if (Rot.Y > 360.0)  		Rot.Y = 0.0;  } else {  	Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  	if (Rot.Y < -360.0)  		Rot.Y = 0.0;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.X < NewMouseCoord.X) {  	Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  	if (Rot.Y > 360.0)  		Rot.Y = 0.0;  } else {  	Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  	if (Rot.Y < -360.0)  		Rot.Y = 0.0;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.X < NewMouseCoord.X) {  	Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  	if (Rot.Y > 360.0)  		Rot.Y = 0.0;  } else {  	Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  	if (Rot.Y < -360.0)  		Rot.Y = 0.0;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.X < NewMouseCoord.X) {  	Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  	if (Rot.Y > 360.0)  		Rot.Y = 0.0;  } else {  	Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  	if (Rot.Y < -360.0)  		Rot.Y = 0.0;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: Rot.Y += (NewMouseCoord.X - MouseCoord.X) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Rot.Y > 360.0)  	Rot.Y = 0.0;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: Rot.Y -= (MouseCoord.X - NewMouseCoord.X) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Rot.Y < -360.0)  	Rot.Y = 0.0;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.Y < NewMouseCoord.Y) {  	if (Rot.X >= 90.0)  		Rot.X = 90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  } else {  	if (Rot.X <= -90.0)  		Rot.X = -90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.Y < NewMouseCoord.Y) {  	if (Rot.X >= 90.0)  		Rot.X = 90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  } else {  	if (Rot.X <= -90.0)  		Rot.X = -90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.Y < NewMouseCoord.Y) {  	if (Rot.X >= 90.0)  		Rot.X = 90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  } else {  	if (Rot.X <= -90.0)  		Rot.X = -90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.Y < NewMouseCoord.Y) {  	if (Rot.X >= 90.0)  		Rot.X = 90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  } else {  	if (Rot.X <= -90.0)  		Rot.X = -90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.Y < NewMouseCoord.Y) {  	if (Rot.X >= 90.0)  		Rot.X = 90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  } else {  	if (Rot.X <= -90.0)  		Rot.X = -90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (MouseCoord.Y < NewMouseCoord.Y) {  	if (Rot.X >= 90.0)  		Rot.X = 90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  } else {  	if (Rot.X <= -90.0)  		Rot.X = -90.0;  	else  		Rot.X += (Dy / Sensitivity) * 0.225;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Rot.X >= 90.0)  	Rot.X = 90.0;  else  	Rot.X += (Dy / Sensitivity) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Rot.X >= 90.0)  	Rot.X = 90.0;  else  	Rot.X += (Dy / Sensitivity) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Rot.X >= 90.0)  	Rot.X = 90.0;  else  	Rot.X += (Dy / Sensitivity) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: Rot.X = 90.0;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: Rot.X += (Dy / Sensitivity) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Rot.X <= -90.0)  	Rot.X = -90.0;  else  	Rot.X += (Dy / Sensitivity) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Rot.X <= -90.0)  	Rot.X = -90.0;  else  	Rot.X += (Dy / Sensitivity) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: if (Rot.X <= -90.0)  	Rot.X = -90.0;  else  	Rot.X += (Dy / Sensitivity) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: Rot.X = -90.0;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,MouseMove,The following statement contains a magic number: Rot.X += (Dy / Sensitivity) * 0.225;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.Space])  	Modifier = 10.0;  else if (KeysDown [(char)Keys.ShiftKey])  	Modifier = 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.Space])  	Modifier = 10.0;  else if (KeysDown [(char)Keys.ShiftKey])  	Modifier = 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Modifier = 10.0;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.ShiftKey])  	Modifier = 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Modifier = 0.5;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.W]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.W]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.W]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.W]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.W]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.W]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.X -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.Z += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.Y += Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.S]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.S]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.S]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.S]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.S]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.S]) {  	if (Rot.X >= 90.0 || Rot.X <= -90.0) {  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	} else {  		Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  		Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  	}  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (Rot.X >= 90.0 || Rot.X <= -90.0) {  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  } else {  	Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.X += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.Z -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.Y -= Math.Sin (RotXRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.A]) {  	Pos.X += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.A]) {  	Pos.X += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.X += Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.Z += Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.D]) {  	Pos.X -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: if (KeysDown [(char)Keys.D]) {  	Pos.X -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  	Pos.Z -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  }  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.X -= Math.Cos (RotYRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Camera,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Camera.cs,KeyUpdate,The following statement contains a magic number: Pos.Z -= Math.Sin (RotYRad) * CameraCoeff * 2.0 * Modifier;  
Magic Number,SceneNavi.OpenGLHelpers,Initialization,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Initialization.cs,SetDefaults,The following statement contains a magic number: GL.ClearDepth (5.0);  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SceneTableEntryMajora,The following statement contains a magic number: sceneEndAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 4));  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SceneTableEntryMajora,The following statement contains a magic number: Unknown1 = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 8];  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SceneTableEntryMajora,The following statement contains a magic number: Unknown2 = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 9];  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SceneTableEntryMajora,The following statement contains a magic number: Unknown3 = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 10];  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SceneTableEntryMajora,The following statement contains a magic number: Unknown4 = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 11];  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SceneTableEntryMajora,The following statement contains a magic number: PresumedPadding = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 12));  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SaveTableEntry,The following statement contains a magic number: Buffer.BlockCopy (tmpbuf' 0' (IsOffsetRelative ? ROM.CodeData : ROM.Data)' Offset + 4' tmpbuf.Length);  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 8] = Unknown1;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 9] = Unknown2;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 10] = Unknown3;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 11] = Unknown4;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,SaveTableEntry,The following statement contains a magic number: Buffer.BlockCopy (tmpbuf' 0' (IsOffsetRelative ? ROM.CodeData : ROM.Data)' Offset + 12' tmpbuf.Length);  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: if (data [0] == (byte)HeaderLoader.CommandTypeIDs.SettingsSoundScene || data [0] == (byte)HeaderLoader.CommandTypeIDs.Rooms || BitConverter.ToUInt32 (data' 0) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) {  	/* Get rooms & collision command from first header */newheader = new HeaderLoader (ROM' this' (byte)0x02' 0' 0);  	/* If external rooms should be forced' overwrite command in header */if (forcerooms != null) {  		int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		if (roomidx != -1)  			newheader.Commands [roomidx] = forcerooms;  	}  	rooms = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms;  	coll = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision;  	sceneHeaders.Add (newheader);  	if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  		int hnum = 1;  		uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  		while (true) {  			uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  			if (rofs != 0) {  				if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  					break;  				newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  				/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  				/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  					newheader.Commands [roomidx] = forcerooms;  				/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  					newheader.Commands [roomidx] = rooms;  				/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  				if (collidx != -1 && coll != null)  					newheader.Commands [collidx] = coll;  				sceneHeaders.Add (newheader);  			}  			aofs += 4;  		}  	}  	currentSceneHeader = sceneHeaders [0];  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: if (data [0] == (byte)HeaderLoader.CommandTypeIDs.SettingsSoundScene || data [0] == (byte)HeaderLoader.CommandTypeIDs.Rooms || BitConverter.ToUInt32 (data' 0) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) {  	/* Get rooms & collision command from first header */newheader = new HeaderLoader (ROM' this' (byte)0x02' 0' 0);  	/* If external rooms should be forced' overwrite command in header */if (forcerooms != null) {  		int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		if (roomidx != -1)  			newheader.Commands [roomidx] = forcerooms;  	}  	rooms = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms;  	coll = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision;  	sceneHeaders.Add (newheader);  	if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  		int hnum = 1;  		uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  		while (true) {  			uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  			if (rofs != 0) {  				if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  					break;  				newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  				/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  				/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  					newheader.Commands [roomidx] = forcerooms;  				/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  					newheader.Commands [roomidx] = rooms;  				/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  				if (collidx != -1 && coll != null)  					newheader.Commands [collidx] = coll;  				sceneHeaders.Add (newheader);  			}  			aofs += 4;  		}  	}  	currentSceneHeader = sceneHeaders [0];  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: if (data [0] == (byte)HeaderLoader.CommandTypeIDs.SettingsSoundScene || data [0] == (byte)HeaderLoader.CommandTypeIDs.Rooms || BitConverter.ToUInt32 (data' 0) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) {  	/* Get rooms & collision command from first header */newheader = new HeaderLoader (ROM' this' (byte)0x02' 0' 0);  	/* If external rooms should be forced' overwrite command in header */if (forcerooms != null) {  		int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		if (roomidx != -1)  			newheader.Commands [roomidx] = forcerooms;  	}  	rooms = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms;  	coll = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision;  	sceneHeaders.Add (newheader);  	if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  		int hnum = 1;  		uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  		while (true) {  			uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  			if (rofs != 0) {  				if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  					break;  				newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  				/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  				/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  					newheader.Commands [roomidx] = forcerooms;  				/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  					newheader.Commands [roomidx] = rooms;  				/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  				if (collidx != -1 && coll != null)  					newheader.Commands [collidx] = coll;  				sceneHeaders.Add (newheader);  			}  			aofs += 4;  		}  	}  	currentSceneHeader = sceneHeaders [0];  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  	int hnum = 1;  	uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  	while (true) {  		uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  		if (rofs != 0) {  			if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  				break;  			newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  			/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  			/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  				newheader.Commands [roomidx] = forcerooms;  			/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  				newheader.Commands [roomidx] = rooms;  			/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  			if (collidx != -1 && coll != null)  				newheader.Commands [collidx] = coll;  			sceneHeaders.Add (newheader);  		}  		aofs += 4;  	}  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  	int hnum = 1;  	uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  	while (true) {  		uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  		if (rofs != 0) {  			if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  				break;  			newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  			/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  			/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  				newheader.Commands [roomidx] = forcerooms;  			/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  				newheader.Commands [roomidx] = rooms;  			/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  			if (collidx != -1 && coll != null)  				newheader.Commands [collidx] = coll;  			sceneHeaders.Add (newheader);  		}  		aofs += 4;  	}  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  	int hnum = 1;  	uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  	while (true) {  		uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  		if (rofs != 0) {  			if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  				break;  			newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  			/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  			/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  				newheader.Commands [roomidx] = forcerooms;  			/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  				newheader.Commands [roomidx] = rooms;  			/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  			if (collidx != -1 && coll != null)  				newheader.Commands [collidx] = coll;  			sceneHeaders.Add (newheader);  		}  		aofs += 4;  	}  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: while (true) {  	uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  	if (rofs != 0) {  		if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  			break;  		newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  		/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  			newheader.Commands [roomidx] = forcerooms;  		/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  			newheader.Commands [roomidx] = rooms;  		/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  		if (collidx != -1 && coll != null)  			newheader.Commands [collidx] = coll;  		sceneHeaders.Add (newheader);  	}  	aofs += 4;  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: while (true) {  	uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  	if (rofs != 0) {  		if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  			break;  		newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  		/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  			newheader.Commands [roomidx] = forcerooms;  		/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  			newheader.Commands [roomidx] = rooms;  		/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  		if (collidx != -1 && coll != null)  			newheader.Commands [collidx] = coll;  		sceneHeaders.Add (newheader);  	}  	aofs += 4;  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: if (rofs != 0) {  	if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  		break;  	newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  	/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  	/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  		newheader.Commands [roomidx] = forcerooms;  	/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  		newheader.Commands [roomidx] = rooms;  	/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  	if (collidx != -1 && coll != null)  		newheader.Commands [collidx] = coll;  	sceneHeaders.Add (newheader);  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  	break;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryMajora,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryMajora.cs,ReadScene,The following statement contains a magic number: aofs += 4;  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: EndAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 4));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: RAMStartAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 8));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: RAMEndAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 12));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: Unknown1 = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 16));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: ActorInfoRAMAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 20));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: ActorNameRAMAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 24));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: Unknown2 = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 28));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: IsValid = (ActorInfoRAMAddress >> 24 == 0x80) && (((ActorNameRAMAddress >> 24 == 0x80) && (ActorNameRAMAddress - ROMHandler.CodeRAMAddress) < rom.CodeData.Length) || (ActorNameRAMAddress == 0));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: IsValid = (ActorInfoRAMAddress >> 24 == 0x80) && (((ActorNameRAMAddress >> 24 == 0x80) && (ActorNameRAMAddress - ROMHandler.CodeRAMAddress) < rom.CodeData.Length) || (ActorNameRAMAddress == 0));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: IsComplete = (StartAddress > rom.Code.VStart && StartAddress < rom.Size) && (EndAddress > StartAddress && EndAddress > rom.Code.VStart && EndAddress < rom.Size) && (RAMStartAddress >> 24 == 0x80) && (RAMEndAddress > RAMStartAddress && RAMEndAddress >> 24 == 0x80) && (ActorInfoRAMAddress >> 24 == 0x80) && (((ActorNameRAMAddress >> 24 == 0x80) && (ActorNameRAMAddress - ROMHandler.CodeRAMAddress) < rom.CodeData.Length) || (ActorNameRAMAddress == 0));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: IsComplete = (StartAddress > rom.Code.VStart && StartAddress < rom.Size) && (EndAddress > StartAddress && EndAddress > rom.Code.VStart && EndAddress < rom.Size) && (RAMStartAddress >> 24 == 0x80) && (RAMEndAddress > RAMStartAddress && RAMEndAddress >> 24 == 0x80) && (ActorInfoRAMAddress >> 24 == 0x80) && (((ActorNameRAMAddress >> 24 == 0x80) && (ActorNameRAMAddress - ROMHandler.CodeRAMAddress) < rom.CodeData.Length) || (ActorNameRAMAddress == 0));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: IsComplete = (StartAddress > rom.Code.VStart && StartAddress < rom.Size) && (EndAddress > StartAddress && EndAddress > rom.Code.VStart && EndAddress < rom.Size) && (RAMStartAddress >> 24 == 0x80) && (RAMEndAddress > RAMStartAddress && RAMEndAddress >> 24 == 0x80) && (ActorInfoRAMAddress >> 24 == 0x80) && (((ActorNameRAMAddress >> 24 == 0x80) && (ActorNameRAMAddress - ROMHandler.CodeRAMAddress) < rom.CodeData.Length) || (ActorNameRAMAddress == 0));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: IsComplete = (StartAddress > rom.Code.VStart && StartAddress < rom.Size) && (EndAddress > StartAddress && EndAddress > rom.Code.VStart && EndAddress < rom.Size) && (RAMStartAddress >> 24 == 0x80) && (RAMEndAddress > RAMStartAddress && RAMEndAddress >> 24 == 0x80) && (ActorInfoRAMAddress >> 24 == 0x80) && (((ActorNameRAMAddress >> 24 == 0x80) && (ActorNameRAMAddress - ROMHandler.CodeRAMAddress) < rom.CodeData.Length) || (ActorNameRAMAddress == 0));  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: if (IsValid == true && IsEmpty == false) {  	if (ActorNameRAMAddress != 0) {  		string tmp = string.Empty;  		ROMHandler.GetTerminatedString (rom.CodeData' (int)(ActorNameRAMAddress - ROMHandler.CodeRAMAddress)' out tmp);  		Name = tmp;  	} else  		Name = string.Format ("RAM Start 0x{0:X}"' RAMStartAddress);  	if (RAMStartAddress != 0 && RAMEndAddress != 0) {  		DMATableEntry dma = rom.Files.Find (x => x.PStart == StartAddress);  		if (dma != null) {  			Filename = dma.Name;  			byte[] tmp = new byte[dma.VEnd - dma.VStart];  			Array.Copy (rom.Data' dma.PStart' tmp' 0' dma.VEnd - dma.VStart);  			uint infoadr = (ActorInfoRAMAddress - RAMStartAddress);  			if (infoadr >= tmp.Length)  				return;  			ActorNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr));  			ActorType = tmp [infoadr + 2];  			ObjectNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr + 8));  		} else  			Filename = Name;  	}  }  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: if (IsValid == true && IsEmpty == false) {  	if (ActorNameRAMAddress != 0) {  		string tmp = string.Empty;  		ROMHandler.GetTerminatedString (rom.CodeData' (int)(ActorNameRAMAddress - ROMHandler.CodeRAMAddress)' out tmp);  		Name = tmp;  	} else  		Name = string.Format ("RAM Start 0x{0:X}"' RAMStartAddress);  	if (RAMStartAddress != 0 && RAMEndAddress != 0) {  		DMATableEntry dma = rom.Files.Find (x => x.PStart == StartAddress);  		if (dma != null) {  			Filename = dma.Name;  			byte[] tmp = new byte[dma.VEnd - dma.VStart];  			Array.Copy (rom.Data' dma.PStart' tmp' 0' dma.VEnd - dma.VStart);  			uint infoadr = (ActorInfoRAMAddress - RAMStartAddress);  			if (infoadr >= tmp.Length)  				return;  			ActorNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr));  			ActorType = tmp [infoadr + 2];  			ObjectNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr + 8));  		} else  			Filename = Name;  	}  }  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: if (RAMStartAddress != 0 && RAMEndAddress != 0) {  	DMATableEntry dma = rom.Files.Find (x => x.PStart == StartAddress);  	if (dma != null) {  		Filename = dma.Name;  		byte[] tmp = new byte[dma.VEnd - dma.VStart];  		Array.Copy (rom.Data' dma.PStart' tmp' 0' dma.VEnd - dma.VStart);  		uint infoadr = (ActorInfoRAMAddress - RAMStartAddress);  		if (infoadr >= tmp.Length)  			return;  		ActorNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr));  		ActorType = tmp [infoadr + 2];  		ObjectNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr + 8));  	} else  		Filename = Name;  }  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: if (RAMStartAddress != 0 && RAMEndAddress != 0) {  	DMATableEntry dma = rom.Files.Find (x => x.PStart == StartAddress);  	if (dma != null) {  		Filename = dma.Name;  		byte[] tmp = new byte[dma.VEnd - dma.VStart];  		Array.Copy (rom.Data' dma.PStart' tmp' 0' dma.VEnd - dma.VStart);  		uint infoadr = (ActorInfoRAMAddress - RAMStartAddress);  		if (infoadr >= tmp.Length)  			return;  		ActorNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr));  		ActorType = tmp [infoadr + 2];  		ObjectNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr + 8));  	} else  		Filename = Name;  }  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: if (dma != null) {  	Filename = dma.Name;  	byte[] tmp = new byte[dma.VEnd - dma.VStart];  	Array.Copy (rom.Data' dma.PStart' tmp' 0' dma.VEnd - dma.VStart);  	uint infoadr = (ActorInfoRAMAddress - RAMStartAddress);  	if (infoadr >= tmp.Length)  		return;  	ActorNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr));  	ActorType = tmp [infoadr + 2];  	ObjectNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr + 8));  } else  	Filename = Name;  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: if (dma != null) {  	Filename = dma.Name;  	byte[] tmp = new byte[dma.VEnd - dma.VStart];  	Array.Copy (rom.Data' dma.PStart' tmp' 0' dma.VEnd - dma.VStart);  	uint infoadr = (ActorInfoRAMAddress - RAMStartAddress);  	if (infoadr >= tmp.Length)  		return;  	ActorNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr));  	ActorType = tmp [infoadr + 2];  	ObjectNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr + 8));  } else  	Filename = Name;  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: ActorType = tmp [infoadr + 2];  
Magic Number,SceneNavi.ROMHandler,ActorTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ActorTableEntry.cs,ActorTableEntry,The following statement contains a magic number: ObjectNumber = Endian.SwapUInt16 (BitConverter.ToUInt16 (tmp' (int)infoadr + 8));  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,DMATableEntry,The following statement contains a magic number: VEnd = Endian.SwapUInt32 (BitConverter.ToUInt32 (rom.Data' readofs + 4));  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,DMATableEntry,The following statement contains a magic number: PStart = Endian.SwapUInt32 (BitConverter.ToUInt32 (rom.Data' readofs + 8));  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,DMATableEntry,The following statement contains a magic number: PEnd = Endian.SwapUInt32 (BitConverter.ToUInt32 (rom.Data' readofs + 12));  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,DMATableEntry,The following statement contains a magic number: if (PStart == 0xFFFFFFFF || PEnd == 0xFFFFFFFF)  	IsValid = false;  else {  	IsValid = true;  	if (PEnd != 0 && Encoding.ASCII.GetString (rom.Data' (int)PStart' 4) == "Yaz0")  		IsCompressed = true;  	else  		IsCompressed = false;  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,DMATableEntry,The following statement contains a magic number: if (PEnd != 0 && Encoding.ASCII.GetString (rom.Data' (int)PStart' 4) == "Yaz0")  	IsCompressed = true;  else  	IsCompressed = false;  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (!IsCompressed) {  	byte[] data = new byte[VEnd - VStart];  	Buffer.BlockCopy (rom.Data' (int)PStart' data' 0' data.Length);  	/* Room file? */if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  				AssumedSegment = 0x03;  				FileType = FileTypes.Room;  				return;  			}  	}  	/* Scene file? */if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  		for (int i = 8; i < HeaderScanThreshold; i += 8)  			if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  				AssumedSegment = 0x02;  				FileType = FileTypes.Scene;  				return;  			}  	}  	/* Overlay file? */uint ovlheader = ((uint)data.Length - Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (data.Length - 4))));  	if ((ovlheader + 16) < data.Length) {  		uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  		uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  		uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  		uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  		if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  			FileType = FileTypes.Overlay;  			return;  		}  	}  	/* Object file? */bool indl' hassync' hasvtx' hasdlend;  	int[] segcount = new int[16];  	indl = hassync = hasvtx = hasdlend = false;  	for (int i = 0; i < data.Length; i += 8) {  		if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hassync = true;  			indl = true;  		} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  			hasvtx = true;  			segcount [data [i + 4]]++;  		} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  			hasdlend = true;  			indl = false;  		}  	}  	if (hassync && hasvtx && hasdlend && (fnassumed == FileTypes.General || fnassumed == FileTypes.Object)) {  		AssumedSegment = (byte)segcount.ToList ().IndexOf (segcount.Max ());  		FileType = FileTypes.Object;  		return;  	}  	/* Empty file? */if (data.Length < 0x100) {  		int isempty = data.Count (x => x != 0);  		if (isempty == 0) {  			FileType = FileTypes.Empty;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  	for (int i = 8; i < HeaderScanThreshold; i += 8)  		if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  			AssumedSegment = 0x03;  			FileType = FileTypes.Room;  			return;  		}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  	for (int i = 8; i < HeaderScanThreshold; i += 8)  		if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  			AssumedSegment = 0x03;  			FileType = FileTypes.Room;  			return;  		}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  	for (int i = 8; i < HeaderScanThreshold; i += 8)  		if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  			AssumedSegment = 0x03;  			FileType = FileTypes.Room;  			return;  		}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (BitConverter.ToUInt32 (data' (int)0) == 0x16 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x03 && BitConverter.ToUInt32 (data' (int)8) == 0x16)) {  	for (int i = 8; i < HeaderScanThreshold; i += 8)  		if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  			AssumedSegment = 0x03;  			FileType = FileTypes.Room;  			return;  		}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: for (int i = 8; i < HeaderScanThreshold; i += 8)  	if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  		AssumedSegment = 0x03;  		FileType = FileTypes.Room;  		return;  	}  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: for (int i = 8; i < HeaderScanThreshold; i += 8)  	if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Room)) {  		AssumedSegment = 0x03;  		FileType = FileTypes.Room;  		return;  	}  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: i += 8
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  	for (int i = 8; i < HeaderScanThreshold; i += 8)  		if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  			AssumedSegment = 0x02;  			FileType = FileTypes.Scene;  			return;  		}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  	for (int i = 8; i < HeaderScanThreshold; i += 8)  		if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  			AssumedSegment = 0x02;  			FileType = FileTypes.Scene;  			return;  		}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  	for (int i = 8; i < HeaderScanThreshold; i += 8)  		if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  			AssumedSegment = 0x02;  			FileType = FileTypes.Scene;  			return;  		}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if ((BitConverter.ToUInt32 (data' (int)0) & 0xFFFF00FF) == 0x15 || ((BitConverter.ToUInt32 (data' (int)0) == 0x18) && data [4] == 0x02 && (BitConverter.ToUInt32 (data' (int)8) & 0xFFFF00FF) == 0x15)) {  	for (int i = 8; i < HeaderScanThreshold; i += 8)  		if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  			AssumedSegment = 0x02;  			FileType = FileTypes.Scene;  			return;  		}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: for (int i = 8; i < HeaderScanThreshold; i += 8)  	if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  		AssumedSegment = 0x02;  		FileType = FileTypes.Scene;  		return;  	}  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: for (int i = 8; i < HeaderScanThreshold; i += 8)  	if (BitConverter.ToUInt32 (data' i) == 0x14 && (fnassumed == FileTypes.General || fnassumed == FileTypes.Scene)) {  		AssumedSegment = 0x02;  		FileType = FileTypes.Scene;  		return;  	}  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: i += 8
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if ((ovlheader + 16) < data.Length) {  	uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  	uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  	uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  	uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  	if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  		FileType = FileTypes.Overlay;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if ((ovlheader + 16) < data.Length) {  	uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  	uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  	uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  	uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  	if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  		FileType = FileTypes.Overlay;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if ((ovlheader + 16) < data.Length) {  	uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  	uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  	uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  	uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  	if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  		FileType = FileTypes.Overlay;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if ((ovlheader + 16) < data.Length) {  	uint btext = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader));  	uint bdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 4));  	uint brodata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 8));  	uint bssdata = Endian.SwapUInt32 (BitConverter.ToUInt32 (data' (int)ovlheader + 12));  	if ((btext + bdata + brodata == data.Length || btext + bdata + brodata == ovlheader) && (fnassumed == FileTypes.General || fnassumed == FileTypes.Overlay)) {  		FileType = FileTypes.Overlay;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 8) {  	if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hassync = true;  		indl = true;  	} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  		hasvtx = true;  		segcount [data [i + 4]]++;  	} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hasdlend = true;  		indl = false;  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 8) {  	if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hassync = true;  		indl = true;  	} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  		hasvtx = true;  		segcount [data [i + 4]]++;  	} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hasdlend = true;  		indl = false;  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 8) {  	if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hassync = true;  		indl = true;  	} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  		hasvtx = true;  		segcount [data [i + 4]]++;  	} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hasdlend = true;  		indl = false;  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 8) {  	if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hassync = true;  		indl = true;  	} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  		hasvtx = true;  		segcount [data [i + 4]]++;  	} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hasdlend = true;  		indl = false;  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 8) {  	if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hassync = true;  		indl = true;  	} else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  		hasvtx = true;  		segcount [data [i + 4]]++;  	} else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  		hasdlend = true;  		indl = false;  	}  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: i += 8
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hassync = true;  	indl = true;  } else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  	hasvtx = true;  	segcount [data [i + 4]]++;  } else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hasdlend = true;  	indl = false;  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hassync = true;  	indl = true;  } else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  	hasvtx = true;  	segcount [data [i + 4]]++;  } else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hasdlend = true;  	indl = false;  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hassync = true;  	indl = true;  } else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  	hasvtx = true;  	segcount [data [i + 4]]++;  } else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hasdlend = true;  	indl = false;  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (BitConverter.ToUInt32 (data' i) == 0xE7 && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hassync = true;  	indl = true;  } else if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  	hasvtx = true;  	segcount [data [i + 4]]++;  } else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hasdlend = true;  	indl = false;  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  	hasvtx = true;  	segcount [data [i + 4]]++;  } else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hasdlend = true;  	indl = false;  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  	hasvtx = true;  	segcount [data [i + 4]]++;  } else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hasdlend = true;  	indl = false;  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (indl && data [i] == 0x01 && data [i + 4] <= 0x0F) {  	hasvtx = true;  	segcount [data [i + 4]]++;  } else if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hasdlend = true;  	indl = false;  }  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: segcount [data [i + 4]]++;  
Magic Number,SceneNavi.ROMHandler,DMATableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\DMATableEntry.cs,Identify,The following statement contains a magic number: if (BitConverter.ToUInt32 (data' i) == 0xDF && BitConverter.ToUInt32 (data' i + 4) == 0x0) {  	hasdlend = true;  	indl = false;  }  
Magic Number,SceneNavi.ROMHandler,EntranceTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\EntranceTableEntry.cs,EntranceTableEntry,The following statement contains a magic number: Variable = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 2];  
Magic Number,SceneNavi.ROMHandler,EntranceTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\EntranceTableEntry.cs,EntranceTableEntry,The following statement contains a magic number: Fade = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 3];  
Magic Number,SceneNavi.ROMHandler,EntranceTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\EntranceTableEntry.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 2] = Variable;  
Magic Number,SceneNavi.ROMHandler,EntranceTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\EntranceTableEntry.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 3] = Fade;  
Magic Number,SceneNavi.ROMHandler,ObjectTableEntry,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ObjectTableEntry.cs,ObjectTableEntry,The following statement contains a magic number: EndAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 4));  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SceneTableEntryOcarina,The following statement contains a magic number: sceneEndAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 4));  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SceneTableEntryOcarina,The following statement contains a magic number: LabelStartAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 8));  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SceneTableEntryOcarina,The following statement contains a magic number: LabelEndAddress = Endian.SwapUInt32 (BitConverter.ToUInt32 (IsOffsetRelative ? rom.CodeData : rom.Data' ofs + 12));  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SceneTableEntryOcarina,The following statement contains a magic number: Unknown1 = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 16];  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SceneTableEntryOcarina,The following statement contains a magic number: ConfigurationNo = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 17];  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SceneTableEntryOcarina,The following statement contains a magic number: Unknown3 = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 18];  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SceneTableEntryOcarina,The following statement contains a magic number: Unknown4 = (IsOffsetRelative ? rom.CodeData : rom.Data) [ofs + 19];  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SaveTableEntry,The following statement contains a magic number: Buffer.BlockCopy (tmpbuf' 0' (IsOffsetRelative ? ROM.CodeData : ROM.Data)' Offset + 4' tmpbuf.Length);  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SaveTableEntry,The following statement contains a magic number: Buffer.BlockCopy (tmpbuf' 0' (IsOffsetRelative ? ROM.CodeData : ROM.Data)' Offset + 8' tmpbuf.Length);  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SaveTableEntry,The following statement contains a magic number: Buffer.BlockCopy (tmpbuf' 0' (IsOffsetRelative ? ROM.CodeData : ROM.Data)' Offset + 12' tmpbuf.Length);  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 16] = Unknown1;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 17] = ConfigurationNo;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 18] = Unknown3;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,SaveTableEntry,The following statement contains a magic number: (IsOffsetRelative ? ROM.CodeData : ROM.Data) [Offset + 19] = Unknown4;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: if (data [0] == (byte)HeaderLoader.CommandTypeIDs.SettingsSoundScene || data [0] == (byte)HeaderLoader.CommandTypeIDs.Rooms || BitConverter.ToUInt32 (data' 0) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) {  	/* Get rooms & collision command from first header */newheader = new HeaderLoader (ROM' this' (byte)0x02' 0' 0);  	/* If external rooms should be forced' overwrite command in header */if (forcerooms != null) {  		int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		if (roomidx != -1)  			newheader.Commands [roomidx] = forcerooms;  	}  	rooms = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms;  	coll = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision;  	sceneHeaders.Add (newheader);  	if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  		int hnum = 1;  		uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  		while (true) {  			uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  			if (rofs != 0) {  				if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  					break;  				newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  				/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  				/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  					newheader.Commands [roomidx] = forcerooms;  				/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  					newheader.Commands [roomidx] = rooms;  				/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  				if (collidx != -1 && coll != null)  					newheader.Commands [collidx] = coll;  				sceneHeaders.Add (newheader);  			}  			aofs += 4;  		}  	}  	currentSceneHeader = sceneHeaders [0];  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: if (data [0] == (byte)HeaderLoader.CommandTypeIDs.SettingsSoundScene || data [0] == (byte)HeaderLoader.CommandTypeIDs.Rooms || BitConverter.ToUInt32 (data' 0) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) {  	/* Get rooms & collision command from first header */newheader = new HeaderLoader (ROM' this' (byte)0x02' 0' 0);  	/* If external rooms should be forced' overwrite command in header */if (forcerooms != null) {  		int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		if (roomidx != -1)  			newheader.Commands [roomidx] = forcerooms;  	}  	rooms = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms;  	coll = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision;  	sceneHeaders.Add (newheader);  	if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  		int hnum = 1;  		uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  		while (true) {  			uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  			if (rofs != 0) {  				if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  					break;  				newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  				/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  				/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  					newheader.Commands [roomidx] = forcerooms;  				/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  					newheader.Commands [roomidx] = rooms;  				/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  				if (collidx != -1 && coll != null)  					newheader.Commands [collidx] = coll;  				sceneHeaders.Add (newheader);  			}  			aofs += 4;  		}  	}  	currentSceneHeader = sceneHeaders [0];  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: if (data [0] == (byte)HeaderLoader.CommandTypeIDs.SettingsSoundScene || data [0] == (byte)HeaderLoader.CommandTypeIDs.Rooms || BitConverter.ToUInt32 (data' 0) == (byte)HeaderLoader.CommandTypeIDs.SubHeaders) {  	/* Get rooms & collision command from first header */newheader = new HeaderLoader (ROM' this' (byte)0x02' 0' 0);  	/* If external rooms should be forced' overwrite command in header */if (forcerooms != null) {  		int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		if (roomidx != -1)  			newheader.Commands [roomidx] = forcerooms;  	}  	rooms = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms) as HeaderCommands.Rooms;  	coll = newheader.Commands.FirstOrDefault (x => x.Command == HeaderLoader.CommandTypeIDs.Collision) as HeaderCommands.Collision;  	sceneHeaders.Add (newheader);  	if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  		int hnum = 1;  		uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  		while (true) {  			uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  			if (rofs != 0) {  				if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  					break;  				newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  				/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  				/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  					newheader.Commands [roomidx] = forcerooms;  				/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  					newheader.Commands [roomidx] = rooms;  				/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  				if (collidx != -1 && coll != null)  					newheader.Commands [collidx] = coll;  				sceneHeaders.Add (newheader);  			}  			aofs += 4;  		}  	}  	currentSceneHeader = sceneHeaders [0];  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  	int hnum = 1;  	uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  	while (true) {  		uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  		if (rofs != 0) {  			if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  				break;  			newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  			/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  			/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  				newheader.Commands [roomidx] = forcerooms;  			/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  				newheader.Commands [roomidx] = rooms;  			/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  			if (collidx != -1 && coll != null)  				newheader.Commands [collidx] = coll;  			sceneHeaders.Add (newheader);  		}  		aofs += 4;  	}  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  	int hnum = 1;  	uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  	while (true) {  		uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  		if (rofs != 0) {  			if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  				break;  			newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  			/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  			/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  				newheader.Commands [roomidx] = forcerooms;  			/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  				newheader.Commands [roomidx] = rooms;  			/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  			if (collidx != -1 && coll != null)  				newheader.Commands [collidx] = coll;  			sceneHeaders.Add (newheader);  		}  		aofs += 4;  	}  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: if (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 0) == 0x18) {  	int hnum = 1;  	uint aofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' 4));  	while (true) {  		uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  		if (rofs != 0) {  			if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  				break;  			newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  			/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  			/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  				newheader.Commands [roomidx] = forcerooms;  			/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  				newheader.Commands [roomidx] = rooms;  			/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  			if (collidx != -1 && coll != null)  				newheader.Commands [collidx] = coll;  			sceneHeaders.Add (newheader);  		}  		aofs += 4;  	}  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: while (true) {  	uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  	if (rofs != 0) {  		if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  			break;  		newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  		/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  			newheader.Commands [roomidx] = forcerooms;  		/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  			newheader.Commands [roomidx] = rooms;  		/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  		if (collidx != -1 && coll != null)  			newheader.Commands [collidx] = coll;  		sceneHeaders.Add (newheader);  	}  	aofs += 4;  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: while (true) {  	uint rofs = Endian.SwapUInt32 (BitConverter.ToUInt32 (((byte[])ROM.SegmentMapping [(byte)0x02])' (int)(aofs & 0x00FFFFFF)));  	if (rofs != 0) {  		if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  			break;  		newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  		/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  		/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  			newheader.Commands [roomidx] = forcerooms;  		/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  			newheader.Commands [roomidx] = rooms;  		/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  		if (collidx != -1 && coll != null)  			newheader.Commands [collidx] = coll;  		sceneHeaders.Add (newheader);  	}  	aofs += 4;  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: if (rofs != 0) {  	if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  		break;  	newheader = new HeaderLoader (ROM' this' (byte)0x02' (int)(rofs & 0x00FFFFFF)' hnum++);  	/* Get room command index... */int roomidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Rooms);  	/* If external rooms should be forced' overwrite command in header */if (roomidx != -1 && forcerooms != null)  		newheader.Commands [roomidx] = forcerooms;  	/* If rooms were found in first header' force using these! */if (roomidx != -1 && rooms != null)  		newheader.Commands [roomidx] = rooms;  	/* If collision was found in header' force */int collidx = newheader.Commands.FindIndex (x => x.Command == HeaderLoader.CommandTypeIDs.Collision);  	if (collidx != -1 && coll != null)  		newheader.Commands [collidx] = coll;  	sceneHeaders.Add (newheader);  }  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: if ((rofs & 0x00FFFFFF) > ((byte[])ROM.SegmentMapping [(byte)0x02]).Length || (rofs >> 24) != 0x02)  	break;  
Magic Number,SceneNavi.ROMHandler,SceneTableEntryOcarina,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\SceneTableEntryOcarina.cs,ReadScene,The following statement contains a magic number: aofs += 4;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder != ByteOrder.BigEndian) {  	if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  		/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  		if (fnnew != string.Empty) {  			fn = fnnew;  			/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  			byte[] conv = null;  			for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  				if (DetectedByteOrder == ByteOrder.MiddleEndian)  					conv = new byte[4] {  						Data [i + 1]'  						Data [i]'  						Data [i + 3]'  						Data [i + 2]  					};  				else if (DetectedByteOrder == ByteOrder.LittleEndian)  					conv = new byte[4] {  						Data [i + 3]'  						Data [i + 2]'  						Data [i + 1]'  						Data [i]  					};  				Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  			}  			/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  			bw.Write (datanew);  			bw.Close ();  			goto reload;  		}  	} else {  		/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  	}  } else {  	/* Read header */ReadROMHeader ();  	/* Create XML actor definition reader */XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  	if (XMLActorDefReader.Definitions.Count > 0) {  		/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  		XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  		XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  		XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  		XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  		XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  		/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  		/* Find and read build information' DMA table' etc. */FindBuildInfo ();  		FindFileNameTable ();  		ReadDMATable ();  		ReadFileNameTable ();  		/* Try to identify files */foreach (DMATableEntry dte in Files)  			dte.Identify (this);  		/* Find the code file */FindCodeFile ();  		/* Find other Zelda-specific stuff */FindActorTable ();  		FindObjectTable ();  		FindSceneTable ();  		ReadEntranceTable ();  		/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  			throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  		/* Done */Loaded = true;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  	/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  	if (fnnew != string.Empty) {  		fn = fnnew;  		/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  		byte[] conv = null;  		for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  			if (DetectedByteOrder == ByteOrder.MiddleEndian)  				conv = new byte[4] {  					Data [i + 1]'  					Data [i]'  					Data [i + 3]'  					Data [i + 2]  				};  			else if (DetectedByteOrder == ByteOrder.LittleEndian)  				conv = new byte[4] {  					Data [i + 3]'  					Data [i + 2]'  					Data [i + 1]'  					Data [i]  				};  			Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  		}  		/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  		bw.Write (datanew);  		bw.Close ();  		goto reload;  	}  } else {  	/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  	/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  	if (fnnew != string.Empty) {  		fn = fnnew;  		/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  		byte[] conv = null;  		for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  			if (DetectedByteOrder == ByteOrder.MiddleEndian)  				conv = new byte[4] {  					Data [i + 1]'  					Data [i]'  					Data [i + 3]'  					Data [i + 2]  				};  			else if (DetectedByteOrder == ByteOrder.LittleEndian)  				conv = new byte[4] {  					Data [i + 3]'  					Data [i + 2]'  					Data [i + 1]'  					Data [i]  				};  			Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  		}  		/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  		bw.Write (datanew);  		bw.Close ();  		goto reload;  	}  } else {  	/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  	/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  	if (fnnew != string.Empty) {  		fn = fnnew;  		/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  		byte[] conv = null;  		for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  			if (DetectedByteOrder == ByteOrder.MiddleEndian)  				conv = new byte[4] {  					Data [i + 1]'  					Data [i]'  					Data [i + 3]'  					Data [i + 2]  				};  			else if (DetectedByteOrder == ByteOrder.LittleEndian)  				conv = new byte[4] {  					Data [i + 3]'  					Data [i + 2]'  					Data [i + 1]'  					Data [i]  				};  			Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  		}  		/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  		bw.Write (datanew);  		bw.Close ();  		goto reload;  	}  } else {  	/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  	/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  	if (fnnew != string.Empty) {  		fn = fnnew;  		/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  		byte[] conv = null;  		for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  			if (DetectedByteOrder == ByteOrder.MiddleEndian)  				conv = new byte[4] {  					Data [i + 1]'  					Data [i]'  					Data [i + 3]'  					Data [i + 2]  				};  			else if (DetectedByteOrder == ByteOrder.LittleEndian)  				conv = new byte[4] {  					Data [i + 3]'  					Data [i + 2]'  					Data [i + 1]'  					Data [i]  				};  			Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  		}  		/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  		bw.Write (datanew);  		bw.Close ();  		goto reload;  	}  } else {  	/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  	/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  	if (fnnew != string.Empty) {  		fn = fnnew;  		/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  		byte[] conv = null;  		for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  			if (DetectedByteOrder == ByteOrder.MiddleEndian)  				conv = new byte[4] {  					Data [i + 1]'  					Data [i]'  					Data [i + 3]'  					Data [i + 2]  				};  			else if (DetectedByteOrder == ByteOrder.LittleEndian)  				conv = new byte[4] {  					Data [i + 3]'  					Data [i + 2]'  					Data [i + 1]'  					Data [i]  				};  			Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  		}  		/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  		bw.Write (datanew);  		bw.Close ();  		goto reload;  	}  } else {  	/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  	/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  	if (fnnew != string.Empty) {  		fn = fnnew;  		/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  		byte[] conv = null;  		for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  			if (DetectedByteOrder == ByteOrder.MiddleEndian)  				conv = new byte[4] {  					Data [i + 1]'  					Data [i]'  					Data [i + 3]'  					Data [i + 2]  				};  			else if (DetectedByteOrder == ByteOrder.LittleEndian)  				conv = new byte[4] {  					Data [i + 3]'  					Data [i + 2]'  					Data [i + 1]'  					Data [i]  				};  			Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  		}  		/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  		bw.Write (datanew);  		bw.Close ();  		goto reload;  	}  } else {  	/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  	/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  	if (fnnew != string.Empty) {  		fn = fnnew;  		/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  		byte[] conv = null;  		for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  			if (DetectedByteOrder == ByteOrder.MiddleEndian)  				conv = new byte[4] {  					Data [i + 1]'  					Data [i]'  					Data [i + 3]'  					Data [i + 2]  				};  			else if (DetectedByteOrder == ByteOrder.LittleEndian)  				conv = new byte[4] {  					Data [i + 3]'  					Data [i + 2]'  					Data [i + 1]'  					Data [i]  				};  			Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  		}  		/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  		bw.Write (datanew);  		bw.Close ();  		goto reload;  	}  } else {  	/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (MessageBox.Show ("The ROM file you have selected uses an incompatible byte order' and needs to be converted to Big Endian format to be used." + Environment.NewLine + Environment.NewLine + "Convert the ROM now? (You will be asked for the target filename; the converted ROM will also be reloaded.)"' "Byte Order Warning"' MessageBoxButtons.YesNo' MessageBoxIcon.Question) == DialogResult.Yes) {  	/* Ask for new filename */string fnnew = GUIHelpers.ShowSaveFileDialog ("Nintendo 64 ROMs (*.z64;*.bin)|*.z64;*.bin|All Files (*.*)|*.*");  	if (fnnew != string.Empty) {  		fn = fnnew;  		/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  		byte[] conv = null;  		for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  			if (DetectedByteOrder == ByteOrder.MiddleEndian)  				conv = new byte[4] {  					Data [i + 1]'  					Data [i]'  					Data [i + 3]'  					Data [i + 2]  				};  			else if (DetectedByteOrder == ByteOrder.LittleEndian)  				conv = new byte[4] {  					Data [i + 3]'  					Data [i + 2]'  					Data [i + 1]'  					Data [i]  				};  			Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  		}  		/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  		bw.Write (datanew);  		bw.Close ();  		goto reload;  	}  } else {  	/* Wrong byte order' no conversion performed */throw new ByteOrderException (string.Format ("Incompatible byte order {0} detected; ROM cannot be used."' DetectedByteOrder));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (fnnew != string.Empty) {  	fn = fnnew;  	/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  	byte[] conv = null;  	for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  		if (DetectedByteOrder == ByteOrder.MiddleEndian)  			conv = new byte[4] {  				Data [i + 1]'  				Data [i]'  				Data [i + 3]'  				Data [i + 2]  			};  		else if (DetectedByteOrder == ByteOrder.LittleEndian)  			conv = new byte[4] {  				Data [i + 3]'  				Data [i + 2]'  				Data [i + 1]'  				Data [i]  			};  		Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  	}  	/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  	bw.Write (datanew);  	bw.Close ();  	goto reload;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (fnnew != string.Empty) {  	fn = fnnew;  	/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  	byte[] conv = null;  	for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  		if (DetectedByteOrder == ByteOrder.MiddleEndian)  			conv = new byte[4] {  				Data [i + 1]'  				Data [i]'  				Data [i + 3]'  				Data [i + 2]  			};  		else if (DetectedByteOrder == ByteOrder.LittleEndian)  			conv = new byte[4] {  				Data [i + 3]'  				Data [i + 2]'  				Data [i + 1]'  				Data [i]  			};  		Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  	}  	/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  	bw.Write (datanew);  	bw.Close ();  	goto reload;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (fnnew != string.Empty) {  	fn = fnnew;  	/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  	byte[] conv = null;  	for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  		if (DetectedByteOrder == ByteOrder.MiddleEndian)  			conv = new byte[4] {  				Data [i + 1]'  				Data [i]'  				Data [i + 3]'  				Data [i + 2]  			};  		else if (DetectedByteOrder == ByteOrder.LittleEndian)  			conv = new byte[4] {  				Data [i + 3]'  				Data [i + 2]'  				Data [i + 1]'  				Data [i]  			};  		Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  	}  	/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  	bw.Write (datanew);  	bw.Close ();  	goto reload;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (fnnew != string.Empty) {  	fn = fnnew;  	/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  	byte[] conv = null;  	for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  		if (DetectedByteOrder == ByteOrder.MiddleEndian)  			conv = new byte[4] {  				Data [i + 1]'  				Data [i]'  				Data [i + 3]'  				Data [i + 2]  			};  		else if (DetectedByteOrder == ByteOrder.LittleEndian)  			conv = new byte[4] {  				Data [i + 3]'  				Data [i + 2]'  				Data [i + 1]'  				Data [i]  			};  		Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  	}  	/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  	bw.Write (datanew);  	bw.Close ();  	goto reload;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (fnnew != string.Empty) {  	fn = fnnew;  	/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  	byte[] conv = null;  	for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  		if (DetectedByteOrder == ByteOrder.MiddleEndian)  			conv = new byte[4] {  				Data [i + 1]'  				Data [i]'  				Data [i + 3]'  				Data [i + 2]  			};  		else if (DetectedByteOrder == ByteOrder.LittleEndian)  			conv = new byte[4] {  				Data [i + 3]'  				Data [i + 2]'  				Data [i + 1]'  				Data [i]  			};  		Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  	}  	/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  	bw.Write (datanew);  	bw.Close ();  	goto reload;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (fnnew != string.Empty) {  	fn = fnnew;  	/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  	byte[] conv = null;  	for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  		if (DetectedByteOrder == ByteOrder.MiddleEndian)  			conv = new byte[4] {  				Data [i + 1]'  				Data [i]'  				Data [i + 3]'  				Data [i + 2]  			};  		else if (DetectedByteOrder == ByteOrder.LittleEndian)  			conv = new byte[4] {  				Data [i + 3]'  				Data [i + 2]'  				Data [i + 1]'  				Data [i]  			};  		Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  	}  	/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  	bw.Write (datanew);  	bw.Close ();  	goto reload;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (fnnew != string.Empty) {  	fn = fnnew;  	/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  	byte[] conv = null;  	for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  		if (DetectedByteOrder == ByteOrder.MiddleEndian)  			conv = new byte[4] {  				Data [i + 1]'  				Data [i]'  				Data [i + 3]'  				Data [i + 2]  			};  		else if (DetectedByteOrder == ByteOrder.LittleEndian)  			conv = new byte[4] {  				Data [i + 3]'  				Data [i + 2]'  				Data [i + 1]'  				Data [i]  			};  		Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  	}  	/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  	bw.Write (datanew);  	bw.Close ();  	goto reload;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (fnnew != string.Empty) {  	fn = fnnew;  	/* Perform byte order conversion */byte[] datanew = new byte[Data.Length];  	byte[] conv = null;  	for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  		if (DetectedByteOrder == ByteOrder.MiddleEndian)  			conv = new byte[4] {  				Data [i + 1]'  				Data [i]'  				Data [i + 3]'  				Data [i + 2]  			};  		else if (DetectedByteOrder == ByteOrder.LittleEndian)  			conv = new byte[4] {  				Data [i + 3]'  				Data [i + 2]'  				Data [i + 1]'  				Data [i]  			};  		Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  	}  	/* Save converted ROM' then reload it */System.IO.BinaryWriter bw = new System.IO.BinaryWriter (System.IO.File.Create (fn));  	bw.Write (datanew);  	bw.Close ();  	goto reload;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  	if (DetectedByteOrder == ByteOrder.MiddleEndian)  		conv = new byte[4] {  			Data [i + 1]'  			Data [i]'  			Data [i + 3]'  			Data [i + 2]  		};  	else if (DetectedByteOrder == ByteOrder.LittleEndian)  		conv = new byte[4] {  			Data [i + 3]'  			Data [i + 2]'  			Data [i + 1]'  			Data [i]  		};  	Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  	if (DetectedByteOrder == ByteOrder.MiddleEndian)  		conv = new byte[4] {  			Data [i + 1]'  			Data [i]'  			Data [i + 3]'  			Data [i + 2]  		};  	else if (DetectedByteOrder == ByteOrder.LittleEndian)  		conv = new byte[4] {  			Data [i + 3]'  			Data [i + 2]'  			Data [i + 1]'  			Data [i]  		};  	Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  	if (DetectedByteOrder == ByteOrder.MiddleEndian)  		conv = new byte[4] {  			Data [i + 1]'  			Data [i]'  			Data [i + 3]'  			Data [i + 2]  		};  	else if (DetectedByteOrder == ByteOrder.LittleEndian)  		conv = new byte[4] {  			Data [i + 3]'  			Data [i + 2]'  			Data [i + 1]'  			Data [i]  		};  	Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  	if (DetectedByteOrder == ByteOrder.MiddleEndian)  		conv = new byte[4] {  			Data [i + 1]'  			Data [i]'  			Data [i + 3]'  			Data [i + 2]  		};  	else if (DetectedByteOrder == ByteOrder.LittleEndian)  		conv = new byte[4] {  			Data [i + 3]'  			Data [i + 2]'  			Data [i + 1]'  			Data [i]  		};  	Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  	if (DetectedByteOrder == ByteOrder.MiddleEndian)  		conv = new byte[4] {  			Data [i + 1]'  			Data [i]'  			Data [i + 3]'  			Data [i + 2]  		};  	else if (DetectedByteOrder == ByteOrder.LittleEndian)  		conv = new byte[4] {  			Data [i + 3]'  			Data [i + 2]'  			Data [i + 1]'  			Data [i]  		};  	Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  	if (DetectedByteOrder == ByteOrder.MiddleEndian)  		conv = new byte[4] {  			Data [i + 1]'  			Data [i]'  			Data [i + 3]'  			Data [i + 2]  		};  	else if (DetectedByteOrder == ByteOrder.LittleEndian)  		conv = new byte[4] {  			Data [i + 3]'  			Data [i + 2]'  			Data [i + 1]'  			Data [i]  		};  	Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  	if (DetectedByteOrder == ByteOrder.MiddleEndian)  		conv = new byte[4] {  			Data [i + 1]'  			Data [i]'  			Data [i + 3]'  			Data [i + 2]  		};  	else if (DetectedByteOrder == ByteOrder.LittleEndian)  		conv = new byte[4] {  			Data [i + 3]'  			Data [i + 2]'  			Data [i + 1]'  			Data [i]  		};  	Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: for (int i = 0' j = 0; i < Data.Length; i += 4' j += 4) {  	if (DetectedByteOrder == ByteOrder.MiddleEndian)  		conv = new byte[4] {  			Data [i + 1]'  			Data [i]'  			Data [i + 3]'  			Data [i + 2]  		};  	else if (DetectedByteOrder == ByteOrder.LittleEndian)  		conv = new byte[4] {  			Data [i + 3]'  			Data [i + 2]'  			Data [i + 1]'  			Data [i]  		};  	Buffer.BlockCopy (conv' 0' datanew' j' conv.Length);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: i += 4
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: j += 4
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder == ByteOrder.MiddleEndian)  	conv = new byte[4] {  		Data [i + 1]'  		Data [i]'  		Data [i + 3]'  		Data [i + 2]  	};  else if (DetectedByteOrder == ByteOrder.LittleEndian)  	conv = new byte[4] {  		Data [i + 3]'  		Data [i + 2]'  		Data [i + 1]'  		Data [i]  	};  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder == ByteOrder.MiddleEndian)  	conv = new byte[4] {  		Data [i + 1]'  		Data [i]'  		Data [i + 3]'  		Data [i + 2]  	};  else if (DetectedByteOrder == ByteOrder.LittleEndian)  	conv = new byte[4] {  		Data [i + 3]'  		Data [i + 2]'  		Data [i + 1]'  		Data [i]  	};  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder == ByteOrder.MiddleEndian)  	conv = new byte[4] {  		Data [i + 1]'  		Data [i]'  		Data [i + 3]'  		Data [i + 2]  	};  else if (DetectedByteOrder == ByteOrder.LittleEndian)  	conv = new byte[4] {  		Data [i + 3]'  		Data [i + 2]'  		Data [i + 1]'  		Data [i]  	};  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder == ByteOrder.MiddleEndian)  	conv = new byte[4] {  		Data [i + 1]'  		Data [i]'  		Data [i + 3]'  		Data [i + 2]  	};  else if (DetectedByteOrder == ByteOrder.LittleEndian)  	conv = new byte[4] {  		Data [i + 3]'  		Data [i + 2]'  		Data [i + 1]'  		Data [i]  	};  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder == ByteOrder.MiddleEndian)  	conv = new byte[4] {  		Data [i + 1]'  		Data [i]'  		Data [i + 3]'  		Data [i + 2]  	};  else if (DetectedByteOrder == ByteOrder.LittleEndian)  	conv = new byte[4] {  		Data [i + 3]'  		Data [i + 2]'  		Data [i + 1]'  		Data [i]  	};  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder == ByteOrder.MiddleEndian)  	conv = new byte[4] {  		Data [i + 1]'  		Data [i]'  		Data [i + 3]'  		Data [i + 2]  	};  else if (DetectedByteOrder == ByteOrder.LittleEndian)  	conv = new byte[4] {  		Data [i + 3]'  		Data [i + 2]'  		Data [i + 1]'  		Data [i]  	};  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: conv = new byte[4] {  	Data [i + 1]'  	Data [i]'  	Data [i + 3]'  	Data [i + 2]  };  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: conv = new byte[4] {  	Data [i + 1]'  	Data [i]'  	Data [i + 3]'  	Data [i + 2]  };  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: conv = new byte[4] {  	Data [i + 1]'  	Data [i]'  	Data [i + 3]'  	Data [i + 2]  };  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder == ByteOrder.LittleEndian)  	conv = new byte[4] {  		Data [i + 3]'  		Data [i + 2]'  		Data [i + 1]'  		Data [i]  	};  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder == ByteOrder.LittleEndian)  	conv = new byte[4] {  		Data [i + 3]'  		Data [i + 2]'  		Data [i + 1]'  		Data [i]  	};  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (DetectedByteOrder == ByteOrder.LittleEndian)  	conv = new byte[4] {  		Data [i + 3]'  		Data [i + 2]'  		Data [i + 1]'  		Data [i]  	};  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: conv = new byte[4] {  	Data [i + 3]'  	Data [i + 2]'  	Data [i + 1]'  	Data [i]  };  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: conv = new byte[4] {  	Data [i + 3]'  	Data [i + 2]'  	Data [i + 1]'  	Data [i]  };  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: conv = new byte[4] {  	Data [i + 3]'  	Data [i + 2]'  	Data [i + 1]'  	Data [i]  };  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: XMLActorDefReader = new XMLActorDefinitionReader (System.IO.Path.Combine ("XML"' "ActorDefinitions"' GameID.Substring (1' 2)));  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (XMLActorDefReader.Definitions.Count > 0) {  	/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  	XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  	XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  	XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  	XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  	XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  	/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  	/* Find and read build information' DMA table' etc. */FindBuildInfo ();  	FindFileNameTable ();  	ReadDMATable ();  	ReadFileNameTable ();  	/* Try to identify files */foreach (DMATableEntry dte in Files)  		dte.Identify (this);  	/* Find the code file */FindCodeFile ();  	/* Find other Zelda-specific stuff */FindActorTable ();  	FindObjectTable ();  	FindSceneTable ();  	ReadEntranceTable ();  	/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  		throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  	/* Done */Loaded = true;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (XMLActorDefReader.Definitions.Count > 0) {  	/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  	XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  	XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  	XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  	XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  	XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  	/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  	/* Find and read build information' DMA table' etc. */FindBuildInfo ();  	FindFileNameTable ();  	ReadDMATable ();  	ReadFileNameTable ();  	/* Try to identify files */foreach (DMATableEntry dte in Files)  		dte.Identify (this);  	/* Find the code file */FindCodeFile ();  	/* Find other Zelda-specific stuff */FindActorTable ();  	FindObjectTable ();  	FindSceneTable ();  	ReadEntranceTable ();  	/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  		throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  	/* Done */Loaded = true;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (XMLActorDefReader.Definitions.Count > 0) {  	/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  	XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  	XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  	XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  	XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  	XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  	/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  	/* Find and read build information' DMA table' etc. */FindBuildInfo ();  	FindFileNameTable ();  	ReadDMATable ();  	ReadFileNameTable ();  	/* Try to identify files */foreach (DMATableEntry dte in Files)  		dte.Identify (this);  	/* Find the code file */FindCodeFile ();  	/* Find other Zelda-specific stuff */FindActorTable ();  	FindObjectTable ();  	FindSceneTable ();  	ReadEntranceTable ();  	/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  		throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  	/* Done */Loaded = true;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: if (XMLActorDefReader.Definitions.Count > 0) {  	/* Create remaining XML-related objects */XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  	XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  	XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  	XMLSceneNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "SceneNames.xml");  	XMLRoomNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "RoomNames.xml");  	XMLStageDescriptions = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataSpecific"' string.Format ("{0}{1:X1}"' GameID' Version))' "StageDescriptions.xml");  	/* Determine if ROM uses z64tables hack */HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  	/* Find and read build information' DMA table' etc. */FindBuildInfo ();  	FindFileNameTable ();  	ReadDMATable ();  	ReadFileNameTable ();  	/* Try to identify files */foreach (DMATableEntry dte in Files)  		dte.Identify (this);  	/* Find the code file */FindCodeFile ();  	/* Find other Zelda-specific stuff */FindActorTable ();  	FindObjectTable ();  	FindSceneTable ();  	ReadEntranceTable ();  	/* Some sanity checking & exception handling*/if (Scenes == null || Scenes.Count == 0)  		throw new ROMHandlerException ("No valid scenes could be recognized in the ROM.");  	/* Done */Loaded = true;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: XMLActorNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ActorNames.xml");  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: XMLObjectNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "ObjectNames.xml");  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: XMLSongNames = new XMLHashTableReader (System.IO.Path.Combine ("XML"' "GameDataGeneric"' GameID.Substring (1' 2))' "SongNames.xml");  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ROMHandler,The following statement contains a magic number: HasZ64TablesHack = (Version == 15 && Endian.SwapUInt32 (BitConverter.ToUInt32 (Data' 0x1238)) != 0x0C00084C);  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The following statement contains a magic number: if (address >> 24 != 0x80) {  	if ((address >> 24) > 0x0F || SegmentMapping [(byte)(address >> 24)] == null)  		return false;  	if ((address & 0xFFFFFF) > ((byte[])SegmentMapping [(byte)(address >> 24)]).Length && ((byte[])SegmentMapping [(byte)(address >> 24)]).Length != 0)  		return false;  } else  	return false;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The following statement contains a magic number: if (address >> 24 != 0x80) {  	if ((address >> 24) > 0x0F || SegmentMapping [(byte)(address >> 24)] == null)  		return false;  	if ((address & 0xFFFFFF) > ((byte[])SegmentMapping [(byte)(address >> 24)]).Length && ((byte[])SegmentMapping [(byte)(address >> 24)]).Length != 0)  		return false;  } else  	return false;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The following statement contains a magic number: if (address >> 24 != 0x80) {  	if ((address >> 24) > 0x0F || SegmentMapping [(byte)(address >> 24)] == null)  		return false;  	if ((address & 0xFFFFFF) > ((byte[])SegmentMapping [(byte)(address >> 24)]).Length && ((byte[])SegmentMapping [(byte)(address >> 24)]).Length != 0)  		return false;  } else  	return false;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The following statement contains a magic number: if (address >> 24 != 0x80) {  	if ((address >> 24) > 0x0F || SegmentMapping [(byte)(address >> 24)] == null)  		return false;  	if ((address & 0xFFFFFF) > ((byte[])SegmentMapping [(byte)(address >> 24)]).Length && ((byte[])SegmentMapping [(byte)(address >> 24)]).Length != 0)  		return false;  } else  	return false;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The following statement contains a magic number: if (address >> 24 != 0x80) {  	if ((address >> 24) > 0x0F || SegmentMapping [(byte)(address >> 24)] == null)  		return false;  	if ((address & 0xFFFFFF) > ((byte[])SegmentMapping [(byte)(address >> 24)]).Length && ((byte[])SegmentMapping [(byte)(address >> 24)]).Length != 0)  		return false;  } else  	return false;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The following statement contains a magic number: if ((address >> 24) > 0x0F || SegmentMapping [(byte)(address >> 24)] == null)  	return false;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The following statement contains a magic number: if ((address >> 24) > 0x0F || SegmentMapping [(byte)(address >> 24)] == null)  	return false;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The following statement contains a magic number: if ((address & 0xFFFFFF) > ((byte[])SegmentMapping [(byte)(address >> 24)]).Length && ((byte[])SegmentMapping [(byte)(address >> 24)]).Length != 0)  	return false;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,IsAddressSupported,The following statement contains a magic number: if ((address & 0xFFFFFF) > ((byte[])SegmentMapping [(byte)(address >> 24)]).Length && ((byte[])SegmentMapping [(byte)(address >> 24)]).Length != 0)  	return false;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindBuildInfo,The following statement contains a magic number: for (int i = 0; i < MinROMSize; i++) {  	if (Encoding.ASCII.GetString (Data' i' 4) == "@srd") {  		i -= (i % 8);  		string tmp = string.Empty;  		int next = GetTerminatedString (Data' i' out tmp);  		Creator = tmp;  		int next2 = GetTerminatedString (Data' next' out tmp);  		BuildDateString = tmp;  		next2 -= (next2 % 8);  		DMATableAddress = next2;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindBuildInfo,The following statement contains a magic number: for (int i = 0; i < MinROMSize; i++) {  	if (Encoding.ASCII.GetString (Data' i' 4) == "@srd") {  		i -= (i % 8);  		string tmp = string.Empty;  		int next = GetTerminatedString (Data' i' out tmp);  		Creator = tmp;  		int next2 = GetTerminatedString (Data' next' out tmp);  		BuildDateString = tmp;  		next2 -= (next2 % 8);  		DMATableAddress = next2;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindBuildInfo,The following statement contains a magic number: for (int i = 0; i < MinROMSize; i++) {  	if (Encoding.ASCII.GetString (Data' i' 4) == "@srd") {  		i -= (i % 8);  		string tmp = string.Empty;  		int next = GetTerminatedString (Data' i' out tmp);  		Creator = tmp;  		int next2 = GetTerminatedString (Data' next' out tmp);  		BuildDateString = tmp;  		next2 -= (next2 % 8);  		DMATableAddress = next2;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindBuildInfo,The following statement contains a magic number: if (Encoding.ASCII.GetString (Data' i' 4) == "@srd") {  	i -= (i % 8);  	string tmp = string.Empty;  	int next = GetTerminatedString (Data' i' out tmp);  	Creator = tmp;  	int next2 = GetTerminatedString (Data' next' out tmp);  	BuildDateString = tmp;  	next2 -= (next2 % 8);  	DMATableAddress = next2;  	return;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindBuildInfo,The following statement contains a magic number: if (Encoding.ASCII.GetString (Data' i' 4) == "@srd") {  	i -= (i % 8);  	string tmp = string.Empty;  	int next = GetTerminatedString (Data' i' out tmp);  	Creator = tmp;  	int next2 = GetTerminatedString (Data' next' out tmp);  	BuildDateString = tmp;  	next2 -= (next2 % 8);  	DMATableAddress = next2;  	return;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindBuildInfo,The following statement contains a magic number: if (Encoding.ASCII.GetString (Data' i' 4) == "@srd") {  	i -= (i % 8);  	string tmp = string.Empty;  	int next = GetTerminatedString (Data' i' out tmp);  	Creator = tmp;  	int next2 = GetTerminatedString (Data' next' out tmp);  	BuildDateString = tmp;  	next2 -= (next2 % 8);  	DMATableAddress = next2;  	return;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindBuildInfo,The following statement contains a magic number: i -= (i % 8);  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindBuildInfo,The following statement contains a magic number: next2 -= (next2 % 8);  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindFileNameTable,The following statement contains a magic number: for (int i = 0; i < MinROMSize; i += 4) {  	if (Encoding.ASCII.GetString (Data' i' 7) == "makerom") {  		FileNameTableAddress = i;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindFileNameTable,The following statement contains a magic number: for (int i = 0; i < MinROMSize; i += 4) {  	if (Encoding.ASCII.GetString (Data' i' 7) == "makerom") {  		FileNameTableAddress = i;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindFileNameTable,The following statement contains a magic number: i += 4
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindFileNameTable,The following statement contains a magic number: if (Encoding.ASCII.GetString (Data' i' 7) == "makerom") {  	FileNameTableAddress = i;  	return;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadFileNameTable,The following statement contains a magic number: for (int i = 0; i < Files.Count; i++) {  	Files [i].Name = Encoding.ASCII.GetString (Data' nofs' 50).TrimEnd ('\0');  	int index = Files [i].Name.IndexOf ('\0');  	if (index >= 0)  		Files [i].Name = Files [i].Name.Remove (index);  	nofs += Files [i].Name.Length;  	while (Data [nofs] == 0)  		nofs++;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadFileNameTable,The following statement contains a magic number: Files [i].Name = Encoding.ASCII.GetString (Data' nofs' 50).TrimEnd ('\0');  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindCodeFile,The following statement contains a magic number: foreach (DMATableEntry dma in Files) {  	if (dma.IsValid == false)  		continue;  	byte[] fdata = new byte[dma.VEnd - dma.VStart];  	if (dma.IsCompressed == true)  		throw new ROMHandlerException ("Compressed ROMs are not supported.");  	Array.Copy (Data' dma.PStart' fdata' 0' dma.VEnd - dma.VStart);  	for (int i = (fdata.Length - 8); i > Math.Min ((uint)(fdata.Length - CodeUcodeThreshold)' fdata.Length); i -= 8) {  		if (Encoding.ASCII.GetString (fdata' i' 8) == "RSP Gfx ") {  			Code = dma;  			CodeData = fdata;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindCodeFile,The following statement contains a magic number: foreach (DMATableEntry dma in Files) {  	if (dma.IsValid == false)  		continue;  	byte[] fdata = new byte[dma.VEnd - dma.VStart];  	if (dma.IsCompressed == true)  		throw new ROMHandlerException ("Compressed ROMs are not supported.");  	Array.Copy (Data' dma.PStart' fdata' 0' dma.VEnd - dma.VStart);  	for (int i = (fdata.Length - 8); i > Math.Min ((uint)(fdata.Length - CodeUcodeThreshold)' fdata.Length); i -= 8) {  		if (Encoding.ASCII.GetString (fdata' i' 8) == "RSP Gfx ") {  			Code = dma;  			CodeData = fdata;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindCodeFile,The following statement contains a magic number: foreach (DMATableEntry dma in Files) {  	if (dma.IsValid == false)  		continue;  	byte[] fdata = new byte[dma.VEnd - dma.VStart];  	if (dma.IsCompressed == true)  		throw new ROMHandlerException ("Compressed ROMs are not supported.");  	Array.Copy (Data' dma.PStart' fdata' 0' dma.VEnd - dma.VStart);  	for (int i = (fdata.Length - 8); i > Math.Min ((uint)(fdata.Length - CodeUcodeThreshold)' fdata.Length); i -= 8) {  		if (Encoding.ASCII.GetString (fdata' i' 8) == "RSP Gfx ") {  			Code = dma;  			CodeData = fdata;  			return;  		}  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindCodeFile,The following statement contains a magic number: for (int i = (fdata.Length - 8); i > Math.Min ((uint)(fdata.Length - CodeUcodeThreshold)' fdata.Length); i -= 8) {  	if (Encoding.ASCII.GetString (fdata' i' 8) == "RSP Gfx ") {  		Code = dma;  		CodeData = fdata;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindCodeFile,The following statement contains a magic number: for (int i = (fdata.Length - 8); i > Math.Min ((uint)(fdata.Length - CodeUcodeThreshold)' fdata.Length); i -= 8) {  	if (Encoding.ASCII.GetString (fdata' i' 8) == "RSP Gfx ") {  		Code = dma;  		CodeData = fdata;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindCodeFile,The following statement contains a magic number: for (int i = (fdata.Length - 8); i > Math.Min ((uint)(fdata.Length - CodeUcodeThreshold)' fdata.Length); i -= 8) {  	if (Encoding.ASCII.GetString (fdata' i' 8) == "RSP Gfx ") {  		Code = dma;  		CodeData = fdata;  		return;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindCodeFile,The following statement contains a magic number: i -= 8
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindCodeFile,The following statement contains a magic number: if (Encoding.ASCII.GetString (fdata' i' 8) == "RSP Gfx ") {  	Code = dma;  	CodeData = fdata;  	return;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (IsMajora || !HasZ64TablesHack) {  	int increment = (IsMajora ? 16 : 20);  	DMATableEntry dma = Files.OrderBy (x => x.VStart).FirstOrDefault (x => x.FileType == DMATableEntry.FileTypes.Scene);  	for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  		ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  			SceneTableAddress = i;  			break;  		}  	}  	if (SceneTableAddress != -1) {  		for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  			ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  			if (!scn1.IsValid () && !scn1.IsAllZero ())  				break;  			scn1.SetNumber ((ushort)j);  			if (!scn1.IsAllZero ())  				Scenes.Add (scn1);  			j++;  		}  	}  } else {  	SceneTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 4));  	for (int i = 0; i < cnt; i++) {  		Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (IsMajora || !HasZ64TablesHack) {  	int increment = (IsMajora ? 16 : 20);  	DMATableEntry dma = Files.OrderBy (x => x.VStart).FirstOrDefault (x => x.FileType == DMATableEntry.FileTypes.Scene);  	for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  		ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  			SceneTableAddress = i;  			break;  		}  	}  	if (SceneTableAddress != -1) {  		for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  			ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  			if (!scn1.IsValid () && !scn1.IsAllZero ())  				break;  			scn1.SetNumber ((ushort)j);  			if (!scn1.IsAllZero ())  				Scenes.Add (scn1);  			j++;  		}  	}  } else {  	SceneTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 4));  	for (int i = 0; i < cnt; i++) {  		Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (IsMajora || !HasZ64TablesHack) {  	int increment = (IsMajora ? 16 : 20);  	DMATableEntry dma = Files.OrderBy (x => x.VStart).FirstOrDefault (x => x.FileType == DMATableEntry.FileTypes.Scene);  	for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  		ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  			SceneTableAddress = i;  			break;  		}  	}  	if (SceneTableAddress != -1) {  		for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  			ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  			if (!scn1.IsValid () && !scn1.IsAllZero ())  				break;  			scn1.SetNumber ((ushort)j);  			if (!scn1.IsAllZero ())  				Scenes.Add (scn1);  			j++;  		}  	}  } else {  	SceneTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 4));  	for (int i = 0; i < cnt; i++) {  		Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (IsMajora || !HasZ64TablesHack) {  	int increment = (IsMajora ? 16 : 20);  	DMATableEntry dma = Files.OrderBy (x => x.VStart).FirstOrDefault (x => x.FileType == DMATableEntry.FileTypes.Scene);  	for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  		ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  			SceneTableAddress = i;  			break;  		}  	}  	if (SceneTableAddress != -1) {  		for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  			ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  			if (!scn1.IsValid () && !scn1.IsAllZero ())  				break;  			scn1.SetNumber ((ushort)j);  			if (!scn1.IsAllZero ())  				Scenes.Add (scn1);  			j++;  		}  	}  } else {  	SceneTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 4));  	for (int i = 0; i < cnt; i++) {  		Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (IsMajora || !HasZ64TablesHack) {  	int increment = (IsMajora ? 16 : 20);  	DMATableEntry dma = Files.OrderBy (x => x.VStart).FirstOrDefault (x => x.FileType == DMATableEntry.FileTypes.Scene);  	for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  		ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  			SceneTableAddress = i;  			break;  		}  	}  	if (SceneTableAddress != -1) {  		for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  			ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  			if (!scn1.IsValid () && !scn1.IsAllZero ())  				break;  			scn1.SetNumber ((ushort)j);  			if (!scn1.IsAllZero ())  				Scenes.Add (scn1);  			j++;  		}  	}  } else {  	SceneTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 4));  	for (int i = 0; i < cnt; i++) {  		Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (IsMajora || !HasZ64TablesHack) {  	int increment = (IsMajora ? 16 : 20);  	DMATableEntry dma = Files.OrderBy (x => x.VStart).FirstOrDefault (x => x.FileType == DMATableEntry.FileTypes.Scene);  	for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  		ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  			SceneTableAddress = i;  			break;  		}  	}  	if (SceneTableAddress != -1) {  		for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  			ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  			if (!scn1.IsValid () && !scn1.IsAllZero ())  				break;  			scn1.SetNumber ((ushort)j);  			if (!scn1.IsAllZero ())  				Scenes.Add (scn1);  			j++;  		}  	}  } else {  	SceneTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 4));  	for (int i = 0; i < cnt; i++) {  		Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (IsMajora || !HasZ64TablesHack) {  	int increment = (IsMajora ? 16 : 20);  	DMATableEntry dma = Files.OrderBy (x => x.VStart).FirstOrDefault (x => x.FileType == DMATableEntry.FileTypes.Scene);  	for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  		ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  			SceneTableAddress = i;  			break;  		}  	}  	if (SceneTableAddress != -1) {  		for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  			ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  			if (!scn1.IsValid () && !scn1.IsAllZero ())  				break;  			scn1.SetNumber ((ushort)j);  			if (!scn1.IsAllZero ())  				Scenes.Add (scn1);  			j++;  		}  	}  } else {  	SceneTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 4));  	for (int i = 0; i < cnt; i++) {  		Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (IsMajora || !HasZ64TablesHack) {  	int increment = (IsMajora ? 16 : 20);  	DMATableEntry dma = Files.OrderBy (x => x.VStart).FirstOrDefault (x => x.FileType == DMATableEntry.FileTypes.Scene);  	for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  		ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  			SceneTableAddress = i;  			break;  		}  	}  	if (SceneTableAddress != -1) {  		for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  			ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  			if (!scn1.IsValid () && !scn1.IsAllZero ())  				break;  			scn1.SetNumber ((ushort)j);  			if (!scn1.IsAllZero ())  				Scenes.Add (scn1);  			j++;  		}  	}  } else {  	SceneTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 4));  	for (int i = 0; i < cnt; i++) {  		Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  	ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  	if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  		SceneTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: for (int i = CodeData.Length - (increment * 2); i > 0; i -= 4) {  	ISceneTableEntry entry = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  	if (entry.GetSceneStartAddress () == dma.VStart && entry.GetSceneEndAddress () == dma.VEnd) {  		SceneTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: i -= 4
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (SceneTableAddress != -1) {  	for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  		ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (!scn1.IsValid () && !scn1.IsAllZero ())  			break;  		scn1.SetNumber ((ushort)j);  		if (!scn1.IsAllZero ())  			Scenes.Add (scn1);  		j++;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: if (SceneTableAddress != -1) {  	for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  		ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  		if (!scn1.IsValid () && !scn1.IsAllZero ())  			break;  		scn1.SetNumber ((ushort)j);  		if (!scn1.IsAllZero ())  			Scenes.Add (scn1);  		j++;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  	ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  	if (!scn1.IsValid () && !scn1.IsAllZero ())  		break;  	scn1.SetNumber ((ushort)j);  	if (!scn1.IsAllZero ())  		Scenes.Add (scn1);  	j++;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: for (int i = SceneTableAddress' j = 0; i < CodeData.Length - (16 * 16); i += increment) {  	ISceneTableEntry scn1 = (!IsMajora ? (ISceneTableEntry)new SceneTableEntryOcarina (this' i' true) : (ISceneTableEntry)new SceneTableEntryMajora (this' i' true));  	if (!scn1.IsValid () && !scn1.IsAllZero ())  		break;  	scn1.SetNumber ((ushort)j);  	if (!scn1.IsAllZero ())  		Scenes.Add (scn1);  	j++;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: for (int i = 0; i < cnt; i++) {  	Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindSceneTable,The following statement contains a magic number: Scenes.Add (new SceneTableEntryOcarina (this' SceneTableAddress + (i * 20)' false));  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 16;  	for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  		ActorTableEntry act1 = new ActorTableEntry (this' i' true);  		ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  		ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  		if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  			break;  		if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  			ActorTableAddress = i;  			break;  		}  	}  	for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  		ActorTableEntry nact = new ActorTableEntry (this' i' true);  		if (nact.IsEmpty || nact.IsValid)  			Actors.Add (nact);  		else  			break;  	}  } else {  	ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 28));  	for (int i = 0; i < cnt; i++) {  		Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  	ActorTableEntry act1 = new ActorTableEntry (this' i' true);  	ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  	ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  	if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  		break;  	if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  		ActorTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  	ActorTableEntry act1 = new ActorTableEntry (this' i' true);  	ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  	ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  	if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  		break;  	if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  		ActorTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  	ActorTableEntry act1 = new ActorTableEntry (this' i' true);  	ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  	ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  	if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  		break;  	if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  		ActorTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: for (int i = 0; i < CodeData.Length - (16 * 16); i += inc) {  	ActorTableEntry act1 = new ActorTableEntry (this' i' true);  	ActorTableEntry act2 = new ActorTableEntry (this' i + 32' true);  	ActorTableEntry act3 = new ActorTableEntry (this' i + 64' true);  	if (act1.IsComplete == false && act1.IsEmpty == false && act2.IsComplete == false && act2.IsEmpty == false && Actors.Count > 0)  		break;  	if ((act1.IsValid == true && act1.IsIncomplete == true) && (act2.IsComplete == true || act2.IsEmpty == true) && Actors.Count == 0) {  		ActorTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  	ActorTableEntry nact = new ActorTableEntry (this' i' true);  	if (nact.IsEmpty || nact.IsValid)  		Actors.Add (nact);  	else  		break;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: for (int i = (int)ActorTableAddress; i < CodeData.Length - 32; i += 32) {  	ActorTableEntry nact = new ActorTableEntry (this' i' true);  	if (nact.IsEmpty || nact.IsValid)  		Actors.Add (nact);  	else  		break;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: i += 32
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: ActorTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 24));  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: for (int i = 0; i < cnt; i++) {  	Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindActorTable,The following statement contains a magic number: Actors.Add (new ActorTableEntry (this' ActorTableAddress + i * 32' false));  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	int inc = 8;  	for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  		ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  		if (ObjectCount < 0x100 || ObjectCount > 0x300)  			continue;  		ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  		ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  		ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  		if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  			ObjectTableAddress = i;  			break;  		}  	}  	if (ObjectTableAddress != 0 && ObjectCount != 0) {  		int i' j = 0;  		for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  			Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  			j++;  		}  		if (!IsMajora)  			EntranceTableAddress = i + (i % 16);  	}  } else {  	ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  	ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  	for (int i = 0; i < ObjectCount; i++) {  		Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  	ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  	if (ObjectCount < 0x100 || ObjectCount > 0x300)  		continue;  	ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  	ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  	ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  	if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  		ObjectTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  	ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  	if (ObjectCount < 0x100 || ObjectCount > 0x300)  		continue;  	ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  	ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  	ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  	if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  		ObjectTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  	ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  	if (ObjectCount < 0x100 || ObjectCount > 0x300)  		continue;  	ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  	ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  	ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  	if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  		ObjectTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  	ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  	if (ObjectCount < 0x100 || ObjectCount > 0x300)  		continue;  	ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  	ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  	ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  	if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  		ObjectTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: for (int i = (int)ActorTableAddress; i < CodeData.Length - (8 * 8); i += inc) {  	ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  	if (ObjectCount < 0x100 || ObjectCount > 0x300)  		continue;  	ObjectTableEntry obj1 = new ObjectTableEntry (this' i' true);  	ObjectTableEntry obj2 = new ObjectTableEntry (this' i + 8' true);  	ObjectTableEntry obj3 = new ObjectTableEntry (this' i + 16' true);  	if (obj1.IsEmpty == true && obj2.IsValid == true && obj3.IsValid == true && Objects.Count == 0) {  		ObjectTableAddress = i;  		break;  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: ObjectCount = Endian.SwapUInt16 (BitConverter.ToUInt16 (CodeData' i - 2));  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (ObjectTableAddress != 0 && ObjectCount != 0) {  	int i' j = 0;  	for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  		Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  		j++;  	}  	if (!IsMajora)  		EntranceTableAddress = i + (i % 16);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (ObjectTableAddress != 0 && ObjectCount != 0) {  	int i' j = 0;  	for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  		Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  		j++;  	}  	if (!IsMajora)  		EntranceTableAddress = i + (i % 16);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (ObjectTableAddress != 0 && ObjectCount != 0) {  	int i' j = 0;  	for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  		Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  		j++;  	}  	if (!IsMajora)  		EntranceTableAddress = i + (i % 16);  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  	Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  	j++;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: for (i = ObjectTableAddress; i < (ObjectTableAddress + (ObjectCount * 8)); i += 8) {  	Objects.Add (new ObjectTableEntry (this' i' true' (ushort)j));  	j++;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: i += 8
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: if (!IsMajora)  	EntranceTableAddress = i + (i % 16);  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: EntranceTableAddress = i + (i % 16);  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: ObjectTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 8));  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: ObjectCount = (ushort)Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 12));  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: for (int i = 0; i < ObjectCount; i++) {  	Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,FindObjectTable,The following statement contains a magic number: Objects.Add (new ObjectTableEntry (this' ObjectTableAddress + i * 8' false' (ushort)i));  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadEntranceTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	if (EntranceTableAddress == 0)  		return;  	int i = EntranceTableAddress' cnt = 0;  	while (i < SceneTableAddress) {  		Entrances.Add (new EntranceTableEntry (this' i' true) {  			Number = (ushort)cnt++  		});  		i += 4;  	}  } else {  	EntranceTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 16));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 20));  	for (int i = 0; i < cnt; i++) {  		Entrances.Add (new EntranceTableEntry (this' EntranceTableAddress + i * 4' false) {  			Number = (ushort)i  		});  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadEntranceTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	if (EntranceTableAddress == 0)  		return;  	int i = EntranceTableAddress' cnt = 0;  	while (i < SceneTableAddress) {  		Entrances.Add (new EntranceTableEntry (this' i' true) {  			Number = (ushort)cnt++  		});  		i += 4;  	}  } else {  	EntranceTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 16));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 20));  	for (int i = 0; i < cnt; i++) {  		Entrances.Add (new EntranceTableEntry (this' EntranceTableAddress + i * 4' false) {  			Number = (ushort)i  		});  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadEntranceTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	if (EntranceTableAddress == 0)  		return;  	int i = EntranceTableAddress' cnt = 0;  	while (i < SceneTableAddress) {  		Entrances.Add (new EntranceTableEntry (this' i' true) {  			Number = (ushort)cnt++  		});  		i += 4;  	}  } else {  	EntranceTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 16));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 20));  	for (int i = 0; i < cnt; i++) {  		Entrances.Add (new EntranceTableEntry (this' EntranceTableAddress + i * 4' false) {  			Number = (ushort)i  		});  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadEntranceTable,The following statement contains a magic number: if (!HasZ64TablesHack) {  	if (EntranceTableAddress == 0)  		return;  	int i = EntranceTableAddress' cnt = 0;  	while (i < SceneTableAddress) {  		Entrances.Add (new EntranceTableEntry (this' i' true) {  			Number = (ushort)cnt++  		});  		i += 4;  	}  } else {  	EntranceTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 16));  	int cnt = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 20));  	for (int i = 0; i < cnt; i++) {  		Entrances.Add (new EntranceTableEntry (this' EntranceTableAddress + i * 4' false) {  			Number = (ushort)i  		});  	}  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadEntranceTable,The following statement contains a magic number: while (i < SceneTableAddress) {  	Entrances.Add (new EntranceTableEntry (this' i' true) {  		Number = (ushort)cnt++  	});  	i += 4;  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadEntranceTable,The following statement contains a magic number: i += 4;  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadEntranceTable,The following statement contains a magic number: EntranceTableAddress = Endian.SwapInt32 (BitConverter.ToInt32 (Data' Z64TablesAdrOffset + 16));  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadEntranceTable,The following statement contains a magic number: for (int i = 0; i < cnt; i++) {  	Entrances.Add (new EntranceTableEntry (this' EntranceTableAddress + i * 4' false) {  		Number = (ushort)i  	});  }  
Magic Number,SceneNavi.ROMHandler,ROMHandler,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ROMHandler\ROMHandler.cs,ReadEntranceTable,The following statement contains a magic number: Entrances.Add (new EntranceTableEntry (this' EntranceTableAddress + i * 4' false) {  	Number = (ushort)i  });  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  		Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  		Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  		Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	UInt16 Raw = (UInt16)((Source [SourceOffset] << 8) | Source [SourceOffset + 1]);  	Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  	Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  	Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: Target [TargetOffset] = (byte)((Raw & 0xF800) >> 8);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: Target [TargetOffset + 1] = (byte)(((Raw & 0x07C0) << 5) >> 8);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)(((Raw & 0x003E) << 18) >> 16);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: Target [TargetOffset + 3] = 0;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: if ((Raw & 0x0001) == 1)  	Target [TargetOffset + 3] = 0xFF;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: Target [TargetOffset + 3] = 0xFF;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: SourceOffset += 2;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: TargetOffset += 4;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,RGBA16,The following statement contains a magic number: SourceOffset += LineSize * 4 - Width;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex = (byte)((Source [SourceOffset]) + (Palette << 4));  		Target [TargetOffset] = (byte)PalColors [CIIndex].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex = (byte)((Source [SourceOffset]) + (Palette << 4));  		Target [TargetOffset] = (byte)PalColors [CIIndex].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex = (byte)((Source [SourceOffset]) + (Palette << 4));  		Target [TargetOffset] = (byte)PalColors [CIIndex].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex = (byte)((Source [SourceOffset]) + (Palette << 4));  		Target [TargetOffset] = (byte)PalColors [CIIndex].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex = (byte)((Source [SourceOffset]) + (Palette << 4));  		Target [TargetOffset] = (byte)PalColors [CIIndex].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex = (byte)((Source [SourceOffset]) + (Palette << 4));  	Target [TargetOffset] = (byte)PalColors [CIIndex].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex = (byte)((Source [SourceOffset]) + (Palette << 4));  	Target [TargetOffset] = (byte)PalColors [CIIndex].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex = (byte)((Source [SourceOffset]) + (Palette << 4));  	Target [TargetOffset] = (byte)PalColors [CIIndex].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex = (byte)((Source [SourceOffset]) + (Palette << 4));  	Target [TargetOffset] = (byte)PalColors [CIIndex].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)PalColors [CIIndex].B;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: Target [TargetOffset + 3] = (byte)PalColors [CIIndex].A;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: TargetOffset += 4;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI4,The following statement contains a magic number: SourceOffset += LineSize * 8 - Width;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  		Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  		Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  		Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  		Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  		Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  		Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  		Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  	Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  	Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  	Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  	Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  	Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  	Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  	Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  	Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  	Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  	Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  	Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  	Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  	Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  	Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  	Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  	Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  	Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  	Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  	Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  	Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  	Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  	Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  	Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  	Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  	Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  	Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  	Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  	Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  	Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  	Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  	Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  	Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte CIIndex1 = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	byte CIIndex2 = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset] = (byte)PalColors [CIIndex1].R;  	Target [TargetOffset + 1] = (byte)PalColors [CIIndex1].G;  	Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  	Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  	Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  	Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  	Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  	Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)PalColors [CIIndex1].B;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: Target [TargetOffset + 3] = (byte)PalColors [CIIndex1].A;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: Target [TargetOffset + 4] = (byte)PalColors [CIIndex2].R;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: Target [TargetOffset + 5] = (byte)PalColors [CIIndex2].G;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: Target [TargetOffset + 6] = (byte)PalColors [CIIndex2].B;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: Target [TargetOffset + 7] = (byte)PalColors [CIIndex2].A;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: TargetOffset += 8;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: SourceOffset += LineSize * 8 - (Width / 2);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,CI8,The following statement contains a magic number: SourceOffset += LineSize * 8 - (Width / 2);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 3] = 0xFF;  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = 0;  		if ((Raw & 0x0001) == 1)  			Target [TargetOffset + 7] = 0xFF;  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 3] = 0xFF;  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = 0;  	if ((Raw & 0x0001) == 1)  		Target [TargetOffset + 7] = 0xFF;  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 3] = 0;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: if ((Raw & 0x0001) == 1)  	Target [TargetOffset + 3] = 0xFF;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 3] = 0xFF;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 7] = 0;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: if ((Raw & 0x0001) == 1)  	Target [TargetOffset + 7] = 0xFF;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: Target [TargetOffset + 7] = 0xFF;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: TargetOffset += 8;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: SourceOffset += LineSize * 8 - (Width / 2);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA4,The following statement contains a magic number: SourceOffset += LineSize * 8 - (Width / 2);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)(Source [SourceOffset]);  		Target [TargetOffset] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 1] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)(Source [SourceOffset]);  		Target [TargetOffset] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 1] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)(Source [SourceOffset]);  		Target [TargetOffset] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 1] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)(Source [SourceOffset]);  		Target [TargetOffset] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 1] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)(Source [SourceOffset]);  		Target [TargetOffset] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 1] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)(Source [SourceOffset]);  	Target [TargetOffset] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 1] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)(Source [SourceOffset]);  	Target [TargetOffset] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 1] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)(Source [SourceOffset]);  	Target [TargetOffset] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 1] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)(Source [SourceOffset]);  	Target [TargetOffset] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 1] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)((Raw & 0xF0) + 0x0F);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: Target [TargetOffset + 3] = (byte)((Raw & 0x0F) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: TargetOffset += 4;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA8,The following statement contains a magic number: SourceOffset += LineSize * 8 - Width;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		Target [TargetOffset] = Source [SourceOffset];  		Target [TargetOffset + 1] = Source [SourceOffset];  		Target [TargetOffset + 2] = Source [SourceOffset];  		Target [TargetOffset + 3] = Source [SourceOffset + 1];  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		Target [TargetOffset] = Source [SourceOffset];  		Target [TargetOffset + 1] = Source [SourceOffset];  		Target [TargetOffset + 2] = Source [SourceOffset];  		Target [TargetOffset + 3] = Source [SourceOffset + 1];  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		Target [TargetOffset] = Source [SourceOffset];  		Target [TargetOffset + 1] = Source [SourceOffset];  		Target [TargetOffset + 2] = Source [SourceOffset];  		Target [TargetOffset + 3] = Source [SourceOffset + 1];  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		Target [TargetOffset] = Source [SourceOffset];  		Target [TargetOffset + 1] = Source [SourceOffset];  		Target [TargetOffset + 2] = Source [SourceOffset];  		Target [TargetOffset + 3] = Source [SourceOffset + 1];  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		Target [TargetOffset] = Source [SourceOffset];  		Target [TargetOffset + 1] = Source [SourceOffset];  		Target [TargetOffset + 2] = Source [SourceOffset];  		Target [TargetOffset + 3] = Source [SourceOffset + 1];  		SourceOffset += 2;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 4 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	Target [TargetOffset] = Source [SourceOffset];  	Target [TargetOffset + 1] = Source [SourceOffset];  	Target [TargetOffset + 2] = Source [SourceOffset];  	Target [TargetOffset + 3] = Source [SourceOffset + 1];  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	Target [TargetOffset] = Source [SourceOffset];  	Target [TargetOffset + 1] = Source [SourceOffset];  	Target [TargetOffset + 2] = Source [SourceOffset];  	Target [TargetOffset + 3] = Source [SourceOffset + 1];  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	Target [TargetOffset] = Source [SourceOffset];  	Target [TargetOffset + 1] = Source [SourceOffset];  	Target [TargetOffset + 2] = Source [SourceOffset];  	Target [TargetOffset + 3] = Source [SourceOffset + 1];  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	Target [TargetOffset] = Source [SourceOffset];  	Target [TargetOffset + 1] = Source [SourceOffset];  	Target [TargetOffset + 2] = Source [SourceOffset];  	Target [TargetOffset + 3] = Source [SourceOffset + 1];  	SourceOffset += 2;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: Target [TargetOffset + 2] = Source [SourceOffset];  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: Target [TargetOffset + 3] = Source [SourceOffset + 1];  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: SourceOffset += 2;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: TargetOffset += 4;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,IA16,The following statement contains a magic number: SourceOffset += LineSize * 4 - Width;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width / 2; i++) {  		if (SourceOffset >= Source.Length)  			return;  		byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  		Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  		Raw = (byte)(Source [SourceOffset] & 0x0F);  		Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  		Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  		SourceOffset++;  		TargetOffset += 8;  	}  	SourceOffset += LineSize * 8 - (Width / 2);  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: for (int i = 0; i < Width / 2; i++) {  	if (SourceOffset >= Source.Length)  		return;  	byte Raw = (byte)((Source [SourceOffset] & 0xF0) >> 4);  	Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  	Raw = (byte)(Source [SourceOffset] & 0x0F);  	Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  	Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  	SourceOffset++;  	TargetOffset += 8;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 1] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 2] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 3] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 4] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 5] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 6] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: Target [TargetOffset + 7] = (byte)((Raw & 0x0E) << 4);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: TargetOffset += 8;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: SourceOffset += LineSize * 8 - (Width / 2);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I4,The following statement contains a magic number: SourceOffset += LineSize * 8 - (Width / 2);  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		Target [TargetOffset] = Source [SourceOffset];  		Target [TargetOffset + 1] = Source [SourceOffset];  		Target [TargetOffset + 2] = Source [SourceOffset];  		Target [TargetOffset + 3] = Source [SourceOffset];  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		Target [TargetOffset] = Source [SourceOffset];  		Target [TargetOffset + 1] = Source [SourceOffset];  		Target [TargetOffset + 2] = Source [SourceOffset];  		Target [TargetOffset + 3] = Source [SourceOffset];  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		Target [TargetOffset] = Source [SourceOffset];  		Target [TargetOffset + 1] = Source [SourceOffset];  		Target [TargetOffset + 2] = Source [SourceOffset];  		Target [TargetOffset + 3] = Source [SourceOffset];  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: for (int j = 0; j < Height; j++) {  	for (int i = 0; i < Width; i++) {  		if (SourceOffset >= Source.Length)  			return;  		Target [TargetOffset] = Source [SourceOffset];  		Target [TargetOffset + 1] = Source [SourceOffset];  		Target [TargetOffset + 2] = Source [SourceOffset];  		Target [TargetOffset + 3] = Source [SourceOffset];  		SourceOffset++;  		TargetOffset += 4;  	}  	SourceOffset += LineSize * 8 - Width;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	Target [TargetOffset] = Source [SourceOffset];  	Target [TargetOffset + 1] = Source [SourceOffset];  	Target [TargetOffset + 2] = Source [SourceOffset];  	Target [TargetOffset + 3] = Source [SourceOffset];  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	Target [TargetOffset] = Source [SourceOffset];  	Target [TargetOffset + 1] = Source [SourceOffset];  	Target [TargetOffset + 2] = Source [SourceOffset];  	Target [TargetOffset + 3] = Source [SourceOffset];  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: for (int i = 0; i < Width; i++) {  	if (SourceOffset >= Source.Length)  		return;  	Target [TargetOffset] = Source [SourceOffset];  	Target [TargetOffset + 1] = Source [SourceOffset];  	Target [TargetOffset + 2] = Source [SourceOffset];  	Target [TargetOffset + 3] = Source [SourceOffset];  	SourceOffset++;  	TargetOffset += 4;  }  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: Target [TargetOffset + 2] = Source [SourceOffset];  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: Target [TargetOffset + 3] = Source [SourceOffset];  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: TargetOffset += 4;  
Magic Number,SceneNavi.SimpleF3DEX2,ImageHelper,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\ImageHelper.cs,I8,The following statement contains a magic number: SourceOffset += LineSize * 8 - Width;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,F3DEX2Interpreter,The following statement contains a magic number: VertexBuffer = new Vertex[32];  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,F3DEX2Interpreter,The following statement contains a magic number: Textures = new Texture[2];  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,F3DEX2Interpreter,The following statement contains a magic number: palette = new Color4[256];  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,F3DEX2Interpreter,The following statement contains a magic number: ScaleS = new float[2];  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,F3DEX2Interpreter,The following statement contains a magic number: ScaleT = new float[2];  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,InitializeParser,The following statement contains a magic number: ucodecmds = new UcodeCommandDelegate[256];  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: try {  	ActiveGLDL.Push (gldl);  	/* Set some defaults */if (!call) {  		GL.DepthMask (true);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  			GL.Disable ((EnableCap)All.FragmentProgram);  		if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  			GL.UseProgram (0);  		PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  		/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  			GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  			GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  		}  		/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  			GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  		}  	}  	/* Ucode interpreter starts here */byte seg = (byte)(adr >> 24);  	adr &= 0xFFFFFF;  	byte[] segdata = (byte[])ROM.SegmentMapping [seg];  	while (adr < segdata.Length) {  		byte cmd = segdata [adr];  		/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  			break;  		/* Try to detect macros if any are defined */inmacro = false;  		if (macros != null) {  			foreach (Macro m in macros) {  				if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  					break;  				General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  				uint[] nextw0 = new uint[nextcmd.Length + 2];  				uint[] nextw1 = new uint[nextcmd.Length + 2];  				for (int i = 0; i < nextw0.Length; i++) {  					nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  					nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  					if (i < m.Commands.Length)  						nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  				}  				if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  					m.Function (nextw0' nextw1);  					adr += (uint)(m.Commands.Length * 8);  					break;  				}  			}  		}  		/* No macro detected */if (!inmacro) {  			/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  			adr += 8;  			/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  				LoadTextures ();  		}  	}  } catch (EntryPointNotFoundException) {  	//TODO handle this?  } finally {  	ActiveGLDL.Pop ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (!call) {  	GL.DepthMask (true);  	if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  		GL.Disable ((EnableCap)All.FragmentProgram);  	if (OpenGLHelpers.Initialization.SupportsFunction ("glCreateShader"))  		GL.UseProgram (0);  	PrimColor = EnvColor = new Color4 (0.5f' 0.5f' 0.5f' 0.5f);  	/* If emulating combiner' set more defaults / load values */if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  		GL.Arb.BindProgram (AssemblyProgramTargetArb.FragmentProgram' 0);  		GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  		GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 1' EnvColor.R' EnvColor.G' EnvColor.B' EnvColor.A);  	}  	/* Clear out texture units */for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  		OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  		GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: for (int i = 0; i < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? 2 : 1); i++) {  	OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0 + i);  	GL.BindTexture (TextureTarget.Texture2D' OpenGLHelpers.MiscDrawingHelpers.DummyTextureID);  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: while (adr < segdata.Length) {  	byte cmd = segdata [adr];  	/* EndDL */if (cmd == (byte)General.UcodeCmds.ENDDL)  		break;  	/* Try to detect macros if any are defined */inmacro = false;  	if (macros != null) {  		foreach (Macro m in macros) {  			if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  				break;  			General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  			uint[] nextw0 = new uint[nextcmd.Length + 2];  			uint[] nextw1 = new uint[nextcmd.Length + 2];  			for (int i = 0; i < nextw0.Length; i++) {  				nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  				nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  				if (i < m.Commands.Length)  					nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  			}  			if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  				m.Function (nextw0' nextw1);  				adr += (uint)(m.Commands.Length * 8);  				break;  			}  		}  	}  	/* No macro detected */if (!inmacro) {  		/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  		adr += 8;  		/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  			LoadTextures ();  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (macros != null) {  	foreach (Macro m in macros) {  		if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  			break;  		General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  		uint[] nextw0 = new uint[nextcmd.Length + 2];  		uint[] nextw1 = new uint[nextcmd.Length + 2];  		for (int i = 0; i < nextw0.Length; i++) {  			nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  			nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  			if (i < m.Commands.Length)  				nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  		}  		if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  			m.Function (nextw0' nextw1);  			adr += (uint)(m.Commands.Length * 8);  			break;  		}  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (macros != null) {  	foreach (Macro m in macros) {  		if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  			break;  		General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  		uint[] nextw0 = new uint[nextcmd.Length + 2];  		uint[] nextw1 = new uint[nextcmd.Length + 2];  		for (int i = 0; i < nextw0.Length; i++) {  			nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  			nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  			if (i < m.Commands.Length)  				nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  		}  		if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  			m.Function (nextw0' nextw1);  			adr += (uint)(m.Commands.Length * 8);  			break;  		}  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (macros != null) {  	foreach (Macro m in macros) {  		if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  			break;  		General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  		uint[] nextw0 = new uint[nextcmd.Length + 2];  		uint[] nextw1 = new uint[nextcmd.Length + 2];  		for (int i = 0; i < nextw0.Length; i++) {  			nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  			nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  			if (i < m.Commands.Length)  				nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  		}  		if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  			m.Function (nextw0' nextw1);  			adr += (uint)(m.Commands.Length * 8);  			break;  		}  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (macros != null) {  	foreach (Macro m in macros) {  		if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  			break;  		General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  		uint[] nextw0 = new uint[nextcmd.Length + 2];  		uint[] nextw1 = new uint[nextcmd.Length + 2];  		for (int i = 0; i < nextw0.Length; i++) {  			nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  			nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  			if (i < m.Commands.Length)  				nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  		}  		if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  			m.Function (nextw0' nextw1);  			adr += (uint)(m.Commands.Length * 8);  			break;  		}  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (macros != null) {  	foreach (Macro m in macros) {  		if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  			break;  		General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  		uint[] nextw0 = new uint[nextcmd.Length + 2];  		uint[] nextw1 = new uint[nextcmd.Length + 2];  		for (int i = 0; i < nextw0.Length; i++) {  			nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  			nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  			if (i < m.Commands.Length)  				nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  		}  		if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  			m.Function (nextw0' nextw1);  			adr += (uint)(m.Commands.Length * 8);  			break;  		}  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (macros != null) {  	foreach (Macro m in macros) {  		if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  			break;  		General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  		uint[] nextw0 = new uint[nextcmd.Length + 2];  		uint[] nextw1 = new uint[nextcmd.Length + 2];  		for (int i = 0; i < nextw0.Length; i++) {  			nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  			nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  			if (i < m.Commands.Length)  				nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  		}  		if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  			m.Function (nextw0' nextw1);  			adr += (uint)(m.Commands.Length * 8);  			break;  		}  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (macros != null) {  	foreach (Macro m in macros) {  		if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  			break;  		General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  		uint[] nextw0 = new uint[nextcmd.Length + 2];  		uint[] nextw1 = new uint[nextcmd.Length + 2];  		for (int i = 0; i < nextw0.Length; i++) {  			nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  			nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  			if (i < m.Commands.Length)  				nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  		}  		if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  			m.Function (nextw0' nextw1);  			adr += (uint)(m.Commands.Length * 8);  			break;  		}  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (macros != null) {  	foreach (Macro m in macros) {  		if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  			break;  		General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  		uint[] nextw0 = new uint[nextcmd.Length + 2];  		uint[] nextw1 = new uint[nextcmd.Length + 2];  		for (int i = 0; i < nextw0.Length; i++) {  			nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  			nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  			if (i < m.Commands.Length)  				nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  		}  		if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  			m.Function (nextw0' nextw1);  			adr += (uint)(m.Commands.Length * 8);  			break;  		}  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (macros != null) {  	foreach (Macro m in macros) {  		if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  			break;  		General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  		uint[] nextw0 = new uint[nextcmd.Length + 2];  		uint[] nextw1 = new uint[nextcmd.Length + 2];  		for (int i = 0; i < nextw0.Length; i++) {  			nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  			nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  			if (i < m.Commands.Length)  				nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  		}  		if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  			m.Function (nextw0' nextw1);  			adr += (uint)(m.Commands.Length * 8);  			break;  		}  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: foreach (Macro m in macros) {  	if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  		break;  	General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  	uint[] nextw0 = new uint[nextcmd.Length + 2];  	uint[] nextw1 = new uint[nextcmd.Length + 2];  	for (int i = 0; i < nextw0.Length; i++) {  		nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  		nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  		if (i < m.Commands.Length)  			nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  	}  	if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  		m.Function (nextw0' nextw1);  		adr += (uint)(m.Commands.Length * 8);  		break;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: foreach (Macro m in macros) {  	if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  		break;  	General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  	uint[] nextw0 = new uint[nextcmd.Length + 2];  	uint[] nextw1 = new uint[nextcmd.Length + 2];  	for (int i = 0; i < nextw0.Length; i++) {  		nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  		nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  		if (i < m.Commands.Length)  			nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  	}  	if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  		m.Function (nextw0' nextw1);  		adr += (uint)(m.Commands.Length * 8);  		break;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: foreach (Macro m in macros) {  	if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  		break;  	General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  	uint[] nextw0 = new uint[nextcmd.Length + 2];  	uint[] nextw1 = new uint[nextcmd.Length + 2];  	for (int i = 0; i < nextw0.Length; i++) {  		nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  		nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  		if (i < m.Commands.Length)  			nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  	}  	if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  		m.Function (nextw0' nextw1);  		adr += (uint)(m.Commands.Length * 8);  		break;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: foreach (Macro m in macros) {  	if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  		break;  	General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  	uint[] nextw0 = new uint[nextcmd.Length + 2];  	uint[] nextw1 = new uint[nextcmd.Length + 2];  	for (int i = 0; i < nextw0.Length; i++) {  		nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  		nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  		if (i < m.Commands.Length)  			nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  	}  	if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  		m.Function (nextw0' nextw1);  		adr += (uint)(m.Commands.Length * 8);  		break;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: foreach (Macro m in macros) {  	if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  		break;  	General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  	uint[] nextw0 = new uint[nextcmd.Length + 2];  	uint[] nextw1 = new uint[nextcmd.Length + 2];  	for (int i = 0; i < nextw0.Length; i++) {  		nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  		nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  		if (i < m.Commands.Length)  			nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  	}  	if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  		m.Function (nextw0' nextw1);  		adr += (uint)(m.Commands.Length * 8);  		break;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: foreach (Macro m in macros) {  	if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  		break;  	General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  	uint[] nextw0 = new uint[nextcmd.Length + 2];  	uint[] nextw1 = new uint[nextcmd.Length + 2];  	for (int i = 0; i < nextw0.Length; i++) {  		nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  		nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  		if (i < m.Commands.Length)  			nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  	}  	if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  		m.Function (nextw0' nextw1);  		adr += (uint)(m.Commands.Length * 8);  		break;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: foreach (Macro m in macros) {  	if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  		break;  	General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  	uint[] nextw0 = new uint[nextcmd.Length + 2];  	uint[] nextw1 = new uint[nextcmd.Length + 2];  	for (int i = 0; i < nextw0.Length; i++) {  		nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  		nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  		if (i < m.Commands.Length)  			nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  	}  	if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  		m.Function (nextw0' nextw1);  		adr += (uint)(m.Commands.Length * 8);  		break;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: foreach (Macro m in macros) {  	if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  		break;  	General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  	uint[] nextw0 = new uint[nextcmd.Length + 2];  	uint[] nextw1 = new uint[nextcmd.Length + 2];  	for (int i = 0; i < nextw0.Length; i++) {  		nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  		nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  		if (i < m.Commands.Length)  			nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  	}  	if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  		m.Function (nextw0' nextw1);  		adr += (uint)(m.Commands.Length * 8);  		break;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: foreach (Macro m in macros) {  	if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  		break;  	General.UcodeCmds[] nextcmd = new General.UcodeCmds[m.Commands.Length];  	uint[] nextw0 = new uint[nextcmd.Length + 2];  	uint[] nextw1 = new uint[nextcmd.Length + 2];  	for (int i = 0; i < nextw0.Length; i++) {  		nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  		nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  		if (i < m.Commands.Length)  			nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  	}  	if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  		m.Function (nextw0' nextw1);  		adr += (uint)(m.Commands.Length * 8);  		break;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  	break;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (adr + ((m.Commands.Length + 3) * 8) > segdata.Length)  	break;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: for (int i = 0; i < nextw0.Length; i++) {  	nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  	nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  	if (i < m.Commands.Length)  		nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: for (int i = 0; i < nextw0.Length; i++) {  	nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  	nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  	if (i < m.Commands.Length)  		nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: for (int i = 0; i < nextw0.Length; i++) {  	nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  	nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  	if (i < m.Commands.Length)  		nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: for (int i = 0; i < nextw0.Length; i++) {  	nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  	nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  	if (i < m.Commands.Length)  		nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: nextw0 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8)));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: nextw1 [i] = Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + (i * 8) + 4));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (i < m.Commands.Length)  	nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: nextcmd [i] = (General.UcodeCmds)(nextw0 [i] >> 24);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (inmacro = (Enumerable.SequenceEqual (m.Commands' nextcmd))) {  	m.Function (nextw0' nextw1);  	adr += (uint)(m.Commands.Length * 8);  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: adr += (uint)(m.Commands.Length * 8);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (!inmacro) {  	/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  	adr += 8;  	/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  		LoadTextures ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: if (!inmacro) {  	/* Execute command */ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  	adr += 8;  	/* Texture loading hack; if SetCombine OR LoadBlock command detected' try loading textures again (fixes Water Temple 1st room' borked walls; SM64toZ64 conversions?) */if (Configuration.RenderTextures && (cmd == (byte)General.UcodeCmds.SETCOMBINE || cmd == (byte)General.UcodeCmds.LOADBLOCK) && Textures [0] != null)  		LoadTextures ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: ucodecmds [cmd] (Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr))' Endian.SwapUInt32 (BitConverter.ToUInt32 (segdata' (int)adr + 4)));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,Render,The following statement contains a magic number: adr += 8;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: activetex = (int)((w1 [6] >> 24) & 0x01);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: activetex = (int)((w1 [6] >> 24) & 0x01);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: CommandSetTile (w0 [5]' w1 [5]);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: CommandSetTile (w0 [5]' w1 [5]);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: CommandSetTileSize (w0 [6]' w1 [6]);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: CommandSetTileSize (w0 [6]' w1 [6]);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: if ((Textures [activetex].Format == 0x40 || Textures [activetex].Format == 0x48 || Textures [activetex].Format == 0x50) && ((w0 [7] >> 24) == (byte)General.UcodeCmds.SETTIMG) || ((w0 [8] >> 24) == (byte)General.UcodeCmds.SETTIMG))  	return;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: if ((Textures [activetex].Format == 0x40 || Textures [activetex].Format == 0x48 || Textures [activetex].Format == 0x50) && ((w0 [7] >> 24) == (byte)General.UcodeCmds.SETTIMG) || ((w0 [8] >> 24) == (byte)General.UcodeCmds.SETTIMG))  	return;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: if ((Textures [activetex].Format == 0x40 || Textures [activetex].Format == 0x48 || Textures [activetex].Format == 0x50) && ((w0 [7] >> 24) == (byte)General.UcodeCmds.SETTIMG) || ((w0 [8] >> 24) == (byte)General.UcodeCmds.SETTIMG))  	return;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTextureBlock,The following statement contains a magic number: if ((Textures [activetex].Format == 0x40 || Textures [activetex].Format == 0x48 || Textures [activetex].Format == 0x50) && ((w0 [7] >> 24) == (byte)General.UcodeCmds.SETTIMG) || ((w0 [8] >> 24) == (byte)General.UcodeCmds.SETTIMG))  	return;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: for (int i = 0; i < psize; i++) {  	ushort r = (ushort)((segdata [adr] << 8) | segdata [adr + 1]);  	palette [i].R = (byte)((r & 0xF800) >> 8);  	palette [i].G = (byte)(((r & 0x07C0) << 5) >> 8);  	palette [i].B = (byte)(((r & 0x003E) << 18) >> 16);  	palette [i].A = 0;  	if ((r & 0x0001) == 1)  		palette [i].A = 0xFF;  	adr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: for (int i = 0; i < psize; i++) {  	ushort r = (ushort)((segdata [adr] << 8) | segdata [adr + 1]);  	palette [i].R = (byte)((r & 0xF800) >> 8);  	palette [i].G = (byte)(((r & 0x07C0) << 5) >> 8);  	palette [i].B = (byte)(((r & 0x003E) << 18) >> 16);  	palette [i].A = 0;  	if ((r & 0x0001) == 1)  		palette [i].A = 0xFF;  	adr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: for (int i = 0; i < psize; i++) {  	ushort r = (ushort)((segdata [adr] << 8) | segdata [adr + 1]);  	palette [i].R = (byte)((r & 0xF800) >> 8);  	palette [i].G = (byte)(((r & 0x07C0) << 5) >> 8);  	palette [i].B = (byte)(((r & 0x003E) << 18) >> 16);  	palette [i].A = 0;  	if ((r & 0x0001) == 1)  		palette [i].A = 0xFF;  	adr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: for (int i = 0; i < psize; i++) {  	ushort r = (ushort)((segdata [adr] << 8) | segdata [adr + 1]);  	palette [i].R = (byte)((r & 0xF800) >> 8);  	palette [i].G = (byte)(((r & 0x07C0) << 5) >> 8);  	palette [i].B = (byte)(((r & 0x003E) << 18) >> 16);  	palette [i].A = 0;  	if ((r & 0x0001) == 1)  		palette [i].A = 0xFF;  	adr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: for (int i = 0; i < psize; i++) {  	ushort r = (ushort)((segdata [adr] << 8) | segdata [adr + 1]);  	palette [i].R = (byte)((r & 0xF800) >> 8);  	palette [i].G = (byte)(((r & 0x07C0) << 5) >> 8);  	palette [i].B = (byte)(((r & 0x003E) << 18) >> 16);  	palette [i].A = 0;  	if ((r & 0x0001) == 1)  		palette [i].A = 0xFF;  	adr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: for (int i = 0; i < psize; i++) {  	ushort r = (ushort)((segdata [adr] << 8) | segdata [adr + 1]);  	palette [i].R = (byte)((r & 0xF800) >> 8);  	palette [i].G = (byte)(((r & 0x07C0) << 5) >> 8);  	palette [i].B = (byte)(((r & 0x003E) << 18) >> 16);  	palette [i].A = 0;  	if ((r & 0x0001) == 1)  		palette [i].A = 0xFF;  	adr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: for (int i = 0; i < psize; i++) {  	ushort r = (ushort)((segdata [adr] << 8) | segdata [adr + 1]);  	palette [i].R = (byte)((r & 0xF800) >> 8);  	palette [i].G = (byte)(((r & 0x07C0) << 5) >> 8);  	palette [i].B = (byte)(((r & 0x003E) << 18) >> 16);  	palette [i].A = 0;  	if ((r & 0x0001) == 1)  		palette [i].A = 0xFF;  	adr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: palette [i].R = (byte)((r & 0xF800) >> 8);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: palette [i].G = (byte)(((r & 0x07C0) << 5) >> 8);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: palette [i].G = (byte)(((r & 0x07C0) << 5) >> 8);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: palette [i].B = (byte)(((r & 0x003E) << 18) >> 16);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: palette [i].B = (byte)(((r & 0x003E) << 18) >> 16);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,MacroLoadTLUT,The following statement contains a magic number: adr += 2;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandVtx,The following statement contains a magic number: for (int i = 0; i < N; i++)  	VertexBuffer [V0 + i] = new Vertex (ROM' (byte[])ROM.SegmentMapping [(byte)(w1 >> 24)]' (uint)(w1 + i * 16)' mtxstack.Peek ());  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandVtx,The following statement contains a magic number: for (int i = 0; i < N; i++)  	VertexBuffer [V0 + i] = new Vertex (ROM' (byte[])ROM.SegmentMapping [(byte)(w1 >> 24)]' (uint)(w1 + i * 16)' mtxstack.Peek ());  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandVtx,The following statement contains a magic number: VertexBuffer [V0 + i] = new Vertex (ROM' (byte[])ROM.SegmentMapping [(byte)(w1 >> 24)]' (uint)(w1 + i * 16)' mtxstack.Peek ());  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandVtx,The following statement contains a magic number: VertexBuffer [V0 + i] = new Vertex (ROM' (byte[])ROM.SegmentMapping [(byte)(w1 >> 24)]' (uint)(w1 + i * 16)' mtxstack.Peek ());  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri1,The following statement contains a magic number: if (ActiveGLDL.Peek () != null)  	ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri1,The following statement contains a magic number: ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri1,The following statement contains a magic number: LastTriList.Add (new SimpleTriangle (VertexBuffer [idxs [0]].Position' VertexBuffer [idxs [1]].Position' VertexBuffer [idxs [2]].Position));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: if (ActiveGLDL != null) {  	if (ActiveGLDL.Peek () != null)  		ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]]));  	if (ActiveGLDL.Peek () != null)  		ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: if (ActiveGLDL != null) {  	if (ActiveGLDL.Peek () != null)  		ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]]));  	if (ActiveGLDL.Peek () != null)  		ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: if (ActiveGLDL != null) {  	if (ActiveGLDL.Peek () != null)  		ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]]));  	if (ActiveGLDL.Peek () != null)  		ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: if (ActiveGLDL != null) {  	if (ActiveGLDL.Peek () != null)  		ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]]));  	if (ActiveGLDL.Peek () != null)  		ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: if (ActiveGLDL.Peek () != null)  	ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [0]]' VertexBuffer [idxs [1]]' VertexBuffer [idxs [2]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: if (ActiveGLDL.Peek () != null)  	ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: if (ActiveGLDL.Peek () != null)  	ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: if (ActiveGLDL.Peek () != null)  	ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: ActiveGLDL.Peek ().Triangles.Add (new OpenGLHelpers.DisplayListEx.Triangle (VertexBuffer [idxs [3]]' VertexBuffer [idxs [4]]' VertexBuffer [idxs [5]]));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: LastTriList.Add (new SimpleTriangle (VertexBuffer [idxs [0]].Position' VertexBuffer [idxs [1]].Position' VertexBuffer [idxs [2]].Position));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: LastTriList.Add (new SimpleTriangle (VertexBuffer [idxs [3]].Position' VertexBuffer [idxs [4]].Position' VertexBuffer [idxs [5]].Position));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: LastTriList.Add (new SimpleTriangle (VertexBuffer [idxs [3]].Position' VertexBuffer [idxs [4]].Position' VertexBuffer [idxs [5]].Position));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandTri2,The following statement contains a magic number: LastTriList.Add (new SimpleTriangle (VertexBuffer [idxs [3]].Position' VertexBuffer [idxs [4]].Position' VertexBuffer [idxs [5]].Position));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandDL,The following statement contains a magic number: if ((byte[])ROM.SegmentMapping [(byte)(w1 >> 24)] != null)  	Render (w1' true' ActiveGLDL.Peek ());  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandBranchZ,The following statement contains a magic number: if ((byte[])ROM.SegmentMapping [(byte)(rdphalf1 >> 24)] != null)  	Render (rdphalf1' true' ActiveGLDL.Peek ());  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int x = 0; x < 4; x++) {  	for (int y = 0; y < 4; y++) {  		mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  		mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  		matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  		madr += 2;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int x = 0; x < 4; x++) {  	for (int y = 0; y < 4; y++) {  		mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  		mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  		matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  		madr += 2;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int x = 0; x < 4; x++) {  	for (int y = 0; y < 4; y++) {  		mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  		mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  		matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  		madr += 2;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int x = 0; x < 4; x++) {  	for (int y = 0; y < 4; y++) {  		mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  		mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  		matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  		madr += 2;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int x = 0; x < 4; x++) {  	for (int y = 0; y < 4; y++) {  		mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  		mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  		matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  		madr += 2;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int x = 0; x < 4; x++) {  	for (int y = 0; y < 4; y++) {  		mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  		mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  		matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  		madr += 2;  	}  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int y = 0; y < 4; y++) {  	mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  	mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  	matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  	madr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int y = 0; y < 4; y++) {  	mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  	mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  	matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  	madr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int y = 0; y < 4; y++) {  	mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  	mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  	matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  	madr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int y = 0; y < 4; y++) {  	mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  	mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  	matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  	madr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: for (int y = 0; y < 4; y++) {  	mt1 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr));  	mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  	matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  	madr += 2;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: mt2 = Endian.SwapUInt16 (BitConverter.ToUInt16 (msegdata' (int)madr + 32));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: matrix [(x * 4) + y] = ((mt1 << 16) | mt2) * (1.0f / 65536.0f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandMtx,The following statement contains a magic number: madr += 2;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,The following statement contains a magic number: switch ((General.OtherModeHShifts)(32 - General.ShiftR (w0' 8' 8) - (General.ShiftR (w0' 0' 8) + 1))) {  case General.OtherModeHShifts.TEXTLUT:  	uint tlutmode = (w1 >> (int)General.OtherModeHShifts.TEXTLUT);  	break;  default:  	uint length = (uint)(General.ShiftR (w0' 0' 8) + 1);  	uint shift = (uint)(32 - General.ShiftR (w0' 8' 8) - length);  	uint mask = (uint)(((1 << (int)length) - 1) << (int)shift);  	OtherModeH &= ~mask;  	OtherModeH |= w1 & mask;  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,The following statement contains a magic number: switch ((General.OtherModeHShifts)(32 - General.ShiftR (w0' 8' 8) - (General.ShiftR (w0' 0' 8) + 1))) {  case General.OtherModeHShifts.TEXTLUT:  	uint tlutmode = (w1 >> (int)General.OtherModeHShifts.TEXTLUT);  	break;  default:  	uint length = (uint)(General.ShiftR (w0' 0' 8) + 1);  	uint shift = (uint)(32 - General.ShiftR (w0' 8' 8) - length);  	uint mask = (uint)(((1 << (int)length) - 1) << (int)shift);  	OtherModeH &= ~mask;  	OtherModeH |= w1 & mask;  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,The following statement contains a magic number: switch ((General.OtherModeHShifts)(32 - General.ShiftR (w0' 8' 8) - (General.ShiftR (w0' 0' 8) + 1))) {  case General.OtherModeHShifts.TEXTLUT:  	uint tlutmode = (w1 >> (int)General.OtherModeHShifts.TEXTLUT);  	break;  default:  	uint length = (uint)(General.ShiftR (w0' 0' 8) + 1);  	uint shift = (uint)(32 - General.ShiftR (w0' 8' 8) - length);  	uint mask = (uint)(((1 << (int)length) - 1) << (int)shift);  	OtherModeH &= ~mask;  	OtherModeH |= w1 & mask;  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,The following statement contains a magic number: switch ((General.OtherModeHShifts)(32 - General.ShiftR (w0' 8' 8) - (General.ShiftR (w0' 0' 8) + 1))) {  case General.OtherModeHShifts.TEXTLUT:  	uint tlutmode = (w1 >> (int)General.OtherModeHShifts.TEXTLUT);  	break;  default:  	uint length = (uint)(General.ShiftR (w0' 0' 8) + 1);  	uint shift = (uint)(32 - General.ShiftR (w0' 8' 8) - length);  	uint mask = (uint)(((1 << (int)length) - 1) << (int)shift);  	OtherModeH &= ~mask;  	OtherModeH |= w1 & mask;  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,The following statement contains a magic number: switch ((General.OtherModeHShifts)(32 - General.ShiftR (w0' 8' 8) - (General.ShiftR (w0' 0' 8) + 1))) {  case General.OtherModeHShifts.TEXTLUT:  	uint tlutmode = (w1 >> (int)General.OtherModeHShifts.TEXTLUT);  	break;  default:  	uint length = (uint)(General.ShiftR (w0' 0' 8) + 1);  	uint shift = (uint)(32 - General.ShiftR (w0' 8' 8) - length);  	uint mask = (uint)(((1 << (int)length) - 1) << (int)shift);  	OtherModeH &= ~mask;  	OtherModeH |= w1 & mask;  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,The following statement contains a magic number: switch ((General.OtherModeHShifts)(32 - General.ShiftR (w0' 8' 8) - (General.ShiftR (w0' 0' 8) + 1))) {  case General.OtherModeHShifts.TEXTLUT:  	uint tlutmode = (w1 >> (int)General.OtherModeHShifts.TEXTLUT);  	break;  default:  	uint length = (uint)(General.ShiftR (w0' 0' 8) + 1);  	uint shift = (uint)(32 - General.ShiftR (w0' 8' 8) - length);  	uint mask = (uint)(((1 << (int)length) - 1) << (int)shift);  	OtherModeH &= ~mask;  	OtherModeH |= w1 & mask;  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,The following statement contains a magic number: switch ((General.OtherModeHShifts)(32 - General.ShiftR (w0' 8' 8) - (General.ShiftR (w0' 0' 8) + 1))) {  case General.OtherModeHShifts.TEXTLUT:  	uint tlutmode = (w1 >> (int)General.OtherModeHShifts.TEXTLUT);  	break;  default:  	uint length = (uint)(General.ShiftR (w0' 0' 8) + 1);  	uint shift = (uint)(32 - General.ShiftR (w0' 8' 8) - length);  	uint mask = (uint)(((1 << (int)length) - 1) << (int)shift);  	OtherModeH &= ~mask;  	OtherModeH |= w1 & mask;  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeH,The following statement contains a magic number: switch ((General.OtherModeHShifts)(32 - General.ShiftR (w0' 8' 8) - (General.ShiftR (w0' 0' 8) + 1))) {  case General.OtherModeHShifts.TEXTLUT:  	uint tlutmode = (w1 >> (int)General.OtherModeHShifts.TEXTLUT);  	break;  default:  	uint length = (uint)(General.ShiftR (w0' 0' 8) + 1);  	uint shift = (uint)(32 - General.ShiftR (w0' 8' 8) - length);  	uint mask = (uint)(((1 << (int)length) - 1) << (int)shift);  	OtherModeH &= ~mask;  	OtherModeH |= w1 & mask;  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeL,The following statement contains a magic number: if ((32 - ((w0 & 0x00FFFFFF) << 4 >> 4) - 1) == 3) {  	uint data = OtherModeL.Data;  	data &= 0x00000007;  	data |= (w1 & 0xCCCCFFFF | w1 & 0x3333FFFF);  	OtherModeL = new SimpleF3DEX2.OtherModeL (data);  	General.PerformModeChanges (this);  	if (Configuration.CombinerType == CombinerTypes.GLSLCombiner && glslCombiner != null)  		glslCombiner.BindCombiner (LastComb0' LastComb1' Configuration.RenderTextures);  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeL,The following statement contains a magic number: if ((32 - ((w0 & 0x00FFFFFF) << 4 >> 4) - 1) == 3) {  	uint data = OtherModeL.Data;  	data &= 0x00000007;  	data |= (w1 & 0xCCCCFFFF | w1 & 0x3333FFFF);  	OtherModeL = new SimpleF3DEX2.OtherModeL (data);  	General.PerformModeChanges (this);  	if (Configuration.CombinerType == CombinerTypes.GLSLCombiner && glslCombiner != null)  		glslCombiner.BindCombiner (LastComb0' LastComb1' Configuration.RenderTextures);  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeL,The following statement contains a magic number: if ((32 - ((w0 & 0x00FFFFFF) << 4 >> 4) - 1) == 3) {  	uint data = OtherModeL.Data;  	data &= 0x00000007;  	data |= (w1 & 0xCCCCFFFF | w1 & 0x3333FFFF);  	OtherModeL = new SimpleF3DEX2.OtherModeL (data);  	General.PerformModeChanges (this);  	if (Configuration.CombinerType == CombinerTypes.GLSLCombiner && glslCombiner != null)  		glslCombiner.BindCombiner (LastComb0' LastComb1' Configuration.RenderTextures);  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetOtherModeL,The following statement contains a magic number: if ((32 - ((w0 & 0x00FFFFFF) << 4 >> 4) - 1) == 3) {  	uint data = OtherModeL.Data;  	data &= 0x00000007;  	data |= (w1 & 0xCCCCFFFF | w1 & 0x3333FFFF);  	OtherModeL = new SimpleF3DEX2.OtherModeL (data);  	General.PerformModeChanges (this);  	if (Configuration.CombinerType == CombinerTypes.GLSLCombiner && glslCombiner != null)  		glslCombiner.BindCombiner (LastComb0' LastComb1' Configuration.RenderTextures);  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].Format = (byte)((w0 & 0xFF0000) >> 16);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].CMS = (uint)General.ShiftR (w1' 8' 2);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].CMS = (uint)General.ShiftR (w1' 8' 2);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].CMT = (uint)General.ShiftR (w1' 18' 2);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].CMT = (uint)General.ShiftR (w1' 18' 2);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].LineSize = General.ShiftR (w0' 9' 9);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].LineSize = General.ShiftR (w0' 9' 9);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].Palette = General.ShiftR (w1' 20' 4);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].Palette = General.ShiftR (w1' 20' 4);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].ShiftS = General.ShiftR (w1' 0' 4);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].ShiftT = General.ShiftR (w1' 10' 4);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].ShiftT = General.ShiftR (w1' 10' 4);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].MaskS = General.ShiftR (w1' 4' 4);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].MaskS = General.ShiftR (w1' 4' 4);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].MaskT = General.ShiftR (w1' 14' 4);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTile,The following statement contains a magic number: Textures [activetex].MaskT = General.ShiftR (w1' 14' 4);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].Tile = General.ShiftR (w1' 24' 3);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].Tile = General.ShiftR (w1' 24' 3);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].ULS = General.ShiftR (ULS' 2' 10);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].ULS = General.ShiftR (ULS' 2' 10);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].ULT = General.ShiftR (ULT' 2' 10);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].ULT = General.ShiftR (ULT' 2' 10);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].LRS = General.ShiftR (LRS' 2' 10);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].LRS = General.ShiftR (LRS' 2' 10);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].LRT = General.ShiftR (LRT' 2' 10);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetTileSize,The following statement contains a magic number: Textures [activetex].LRT = General.ShiftR (LRT' 2' 10);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: PrimColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: PrimColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: PrimColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: PrimColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: PrimColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: PrimColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: PrimColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  	float m = (float)General.ShiftL (w0' 8' 8);  	float l = (float)General.ShiftL (w0' 0' 8) * 0.0039215689f;  	GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  	GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 2' l' l' l' l);  } else if (Configuration.CombinerType == CombinerTypes.GLSLCombiner && glslCombiner != null) {  	glslCombiner.BindCombiner (LastComb0' LastComb1' Configuration.RenderTextures);  } else {  	/* Super-simple colorization faking */GL.Material (MaterialFace.FrontAndBack' MaterialParameter.Diffuse' new Color4 (PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A));  	//GL.Light(LightName.Light0' LightParameter.Diffuse' new Color4(PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A));  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  	float m = (float)General.ShiftL (w0' 8' 8);  	float l = (float)General.ShiftL (w0' 0' 8) * 0.0039215689f;  	GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  	GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 2' l' l' l' l);  } else if (Configuration.CombinerType == CombinerTypes.GLSLCombiner && glslCombiner != null) {  	glslCombiner.BindCombiner (LastComb0' LastComb1' Configuration.RenderTextures);  } else {  	/* Super-simple colorization faking */GL.Material (MaterialFace.FrontAndBack' MaterialParameter.Diffuse' new Color4 (PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A));  	//GL.Light(LightName.Light0' LightParameter.Diffuse' new Color4(PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A));  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  	float m = (float)General.ShiftL (w0' 8' 8);  	float l = (float)General.ShiftL (w0' 0' 8) * 0.0039215689f;  	GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  	GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 2' l' l' l' l);  } else if (Configuration.CombinerType == CombinerTypes.GLSLCombiner && glslCombiner != null) {  	glslCombiner.BindCombiner (LastComb0' LastComb1' Configuration.RenderTextures);  } else {  	/* Super-simple colorization faking */GL.Material (MaterialFace.FrontAndBack' MaterialParameter.Diffuse' new Color4 (PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A));  	//GL.Light(LightName.Light0' LightParameter.Diffuse' new Color4(PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A));  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: if (Configuration.CombinerType == CombinerTypes.ArbCombiner) {  	float m = (float)General.ShiftL (w0' 8' 8);  	float l = (float)General.ShiftL (w0' 0' 8) * 0.0039215689f;  	GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 0' PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A);  	GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 2' l' l' l' l);  } else if (Configuration.CombinerType == CombinerTypes.GLSLCombiner && glslCombiner != null) {  	glslCombiner.BindCombiner (LastComb0' LastComb1' Configuration.RenderTextures);  } else {  	/* Super-simple colorization faking */GL.Material (MaterialFace.FrontAndBack' MaterialParameter.Diffuse' new Color4 (PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A));  	//GL.Light(LightName.Light0' LightParameter.Diffuse' new Color4(PrimColor.R' PrimColor.G' PrimColor.B' PrimColor.A));  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetPrimColor,The following statement contains a magic number: GL.Arb.ProgramEnvParameter4 (AssemblyProgramTargetArb.FragmentProgram' 2' l' l' l' l);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetEnvColor,The following statement contains a magic number: EnvColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetEnvColor,The following statement contains a magic number: EnvColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetEnvColor,The following statement contains a magic number: EnvColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetEnvColor,The following statement contains a magic number: EnvColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetEnvColor,The following statement contains a magic number: EnvColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetEnvColor,The following statement contains a magic number: EnvColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CommandSetEnvColor,The following statement contains a magic number: EnvColor = new Color4 (General.ShiftR (w1' 24' 8) * 0.0039215689f' General.ShiftR (w1' 16' 8) * 0.0039215689f' General.ShiftR (w1' 8' 8) * 0.0039215689f' General.ShiftR (w1' 0' 8) * 0.0039215689f);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,LoadTexture,The following statement contains a magic number: if (Textures [tx].CMS == 2 || Textures [tx].CMS == 3)  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)All.ClampToEdge);  else if (Textures [tx].CMS == 1)  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)All.MirroredRepeatArb);  else  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)All.Repeat);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,LoadTexture,The following statement contains a magic number: if (Textures [tx].CMS == 2 || Textures [tx].CMS == 3)  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)All.ClampToEdge);  else if (Textures [tx].CMS == 1)  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)All.MirroredRepeatArb);  else  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapS' (int)All.Repeat);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,LoadTexture,The following statement contains a magic number: if (Textures [tx].CMT == 2 || Textures [tx].CMT == 3)  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)All.ClampToEdge);  else if (Textures [tx].CMT == 1)  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)All.MirroredRepeatArb);  else  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)All.Repeat);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,LoadTexture,The following statement contains a magic number: if (Textures [tx].CMT == 2 || Textures [tx].CMT == 3)  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)All.ClampToEdge);  else if (Textures [tx].CMT == 1)  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)All.MirroredRepeatArb);  else  	GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureWrapT' (int)All.Repeat);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: switch (Textures [tx].Format) {  /* 4-bit */case 0x00:  	// RGBA  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x40:  	// CI  	MaxTexel = 4096;  	LineShift = 4;  	break;  case 0x60:  	// IA  	MaxTexel = 8192;  	LineShift = 4;  	break;  case 0x80:  	// I  	MaxTexel = 8192;  	LineShift = 4;  	break;  /* 8-bit */case 0x08:  	// RGBA  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x48:  	// CI  	MaxTexel = 2048;  	LineShift = 3;  	break;  case 0x68:  	// IA  	MaxTexel = 4096;  	LineShift = 3;  	break;  case 0x88:  	// I  	MaxTexel = 4096;  	LineShift = 3;  	break;  /* 16-bit */case 0x10:  	// RGBA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x50:  	// CI  	MaxTexel = 2048;  	LineShift = 0;  	break;  case 0x70:  	// IA  	MaxTexel = 2048;  	LineShift = 2;  	break;  case 0x90:  	// I  	MaxTexel = 2048;  	LineShift = 0;  	break;  /* 32-bit */case 0x18:  	// RGBA  	MaxTexel = 1024;  	LineShift = 2;  	break;  default:  	return;  }  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 4096;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 4;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 4096;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 4;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 8192;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 4;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 8192;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 4;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 2048;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 3;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 2048;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 3;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 4096;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 3;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 4096;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 3;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 2048;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 2;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 2048;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 2048;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 2;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 2048;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: MaxTexel = 1024;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: LineShift = 2;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Clamp_Width > 256)  	Textures [tx].CMS &= ~(uint)0x01;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Clamp_Height > 256)  	Textures [tx].CMT &= ~(uint)0x01;  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Textures [tx].CMS == 2 || Textures [tx].CMS == 3)  	Textures [tx].RealWidth = General.Pow2 (Clamp_Width);  else if (Textures [tx].CMS == 1)  	Textures [tx].RealWidth = General.Pow2 (Mask_Width);  else  	Textures [tx].RealWidth = General.Pow2 ((int)Textures [tx].Width);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Textures [tx].CMS == 2 || Textures [tx].CMS == 3)  	Textures [tx].RealWidth = General.Pow2 (Clamp_Width);  else if (Textures [tx].CMS == 1)  	Textures [tx].RealWidth = General.Pow2 (Mask_Width);  else  	Textures [tx].RealWidth = General.Pow2 ((int)Textures [tx].Width);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Textures [tx].CMT == 2 || Textures [tx].CMT == 3)  	Textures [tx].RealHeight = General.Pow2 (Clamp_Height);  else if (Textures [tx].CMT == 1)  	Textures [tx].RealHeight = General.Pow2 (Mask_Height);  else  	Textures [tx].RealHeight = General.Pow2 ((int)Textures [tx].Height);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Textures [tx].CMT == 2 || Textures [tx].CMT == 3)  	Textures [tx].RealHeight = General.Pow2 (Clamp_Height);  else if (Textures [tx].CMT == 1)  	Textures [tx].RealHeight = General.Pow2 (Mask_Height);  else  	Textures [tx].RealHeight = General.Pow2 ((int)Textures [tx].Height);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Textures [tx].ShiftS > 10)  	Textures [tx].ShiftScaleS = (float)(1 << (int)(16 - Textures [tx].ShiftS));  else if (Textures [tx].ShiftS > 0)  	Textures [tx].ShiftScaleS /= (float)(1 << (int)Textures [tx].ShiftS);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Textures [tx].ShiftS > 10)  	Textures [tx].ShiftScaleS = (float)(1 << (int)(16 - Textures [tx].ShiftS));  else if (Textures [tx].ShiftS > 0)  	Textures [tx].ShiftScaleS /= (float)(1 << (int)Textures [tx].ShiftS);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: Textures [tx].ShiftScaleS = (float)(1 << (int)(16 - Textures [tx].ShiftS));  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Textures [tx].ShiftT > 10)  	Textures [tx].ShiftScaleT = (float)(1 << (16 - (int)Textures [tx].ShiftT));  else if (Textures [tx].ShiftT > 0)  	Textures [tx].ShiftScaleT /= (float)(1 << (int)Textures [tx].ShiftT);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: if (Textures [tx].ShiftT > 10)  	Textures [tx].ShiftScaleT = (float)(1 << (16 - (int)Textures [tx].ShiftT));  else if (Textures [tx].ShiftT > 0)  	Textures [tx].ShiftScaleT /= (float)(1 << (int)Textures [tx].ShiftT);  
Magic Number,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,CalculateTextureSize,The following statement contains a magic number: Textures [tx].ShiftScaleT = (float)(1 << (16 - (int)Textures [tx].ShiftT));  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,PerformModeChanges,The following statement contains a magic number: switch (f3dex2.OtherModeL.Data >> 16) {  case 0x0448:  case 0x055A:  	GL.BlendFunc (BlendingFactorSrc.One' BlendingFactorDest.One);  	break;  case 0x0382:  case 0x0091:  case 0x0C08:  case 0x0F0A:  case 0x0302:  	GL.BlendFunc (BlendingFactorSrc.One' BlendingFactorDest.Zero);  	break;  case 0xAF50:  case 0x0F5A:  case 0x0FA5:  case 0x5055:  	GL.BlendFunc (BlendingFactorSrc.Zero' BlendingFactorDest.One);  	break;  case 0x5F50:  	GL.BlendFunc (BlendingFactorSrc.Zero' BlendingFactorDest.OneMinusSrcAlpha);  	break;  default:  	GL.BlendFunc (BlendingFactorSrc.SrcAlpha' BlendingFactorDest.OneMinusSrcAlpha);  	break;  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: foreach (int i in idx) {  	if (i >= f3dex2.VertexBuffer.Length)  		continue;  	double[] S = new double[2]' T = new double[2];  	for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  		if (f3dex2.Textures [j].MaskS != 0)  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  		else  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  		if (f3dex2.Textures [j].MaskT != 0)  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  		else  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  		OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  	}  	if (!Convert.ToBoolean (f3dex2.GeometryMode & (uint)General.GeometryMode.LIGHTING))  		GL.Color4 (f3dex2.VertexBuffer [i].Colors);  	GL.Normal3 (f3dex2.VertexBuffer [i].Normals);  	GL.Vertex3 (f3dex2.VertexBuffer [i].Position);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: foreach (int i in idx) {  	if (i >= f3dex2.VertexBuffer.Length)  		continue;  	double[] S = new double[2]' T = new double[2];  	for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  		if (f3dex2.Textures [j].MaskS != 0)  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  		else  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  		if (f3dex2.Textures [j].MaskT != 0)  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  		else  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  		OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  	}  	if (!Convert.ToBoolean (f3dex2.GeometryMode & (uint)General.GeometryMode.LIGHTING))  		GL.Color4 (f3dex2.VertexBuffer [i].Colors);  	GL.Normal3 (f3dex2.VertexBuffer [i].Normals);  	GL.Vertex3 (f3dex2.VertexBuffer [i].Position);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: foreach (int i in idx) {  	if (i >= f3dex2.VertexBuffer.Length)  		continue;  	double[] S = new double[2]' T = new double[2];  	for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  		if (f3dex2.Textures [j].MaskS != 0)  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  		else  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  		if (f3dex2.Textures [j].MaskT != 0)  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  		else  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  		OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  	}  	if (!Convert.ToBoolean (f3dex2.GeometryMode & (uint)General.GeometryMode.LIGHTING))  		GL.Color4 (f3dex2.VertexBuffer [i].Colors);  	GL.Normal3 (f3dex2.VertexBuffer [i].Normals);  	GL.Vertex3 (f3dex2.VertexBuffer [i].Position);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: foreach (int i in idx) {  	if (i >= f3dex2.VertexBuffer.Length)  		continue;  	double[] S = new double[2]' T = new double[2];  	for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  		if (f3dex2.Textures [j].MaskS != 0)  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  		else  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  		if (f3dex2.Textures [j].MaskT != 0)  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  		else  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  		OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  	}  	if (!Convert.ToBoolean (f3dex2.GeometryMode & (uint)General.GeometryMode.LIGHTING))  		GL.Color4 (f3dex2.VertexBuffer [i].Colors);  	GL.Normal3 (f3dex2.VertexBuffer [i].Normals);  	GL.Vertex3 (f3dex2.VertexBuffer [i].Position);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: foreach (int i in idx) {  	if (i >= f3dex2.VertexBuffer.Length)  		continue;  	double[] S = new double[2]' T = new double[2];  	for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  		if (f3dex2.Textures [j].MaskS != 0)  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  		else  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  		if (f3dex2.Textures [j].MaskT != 0)  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  		else  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  		OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  	}  	if (!Convert.ToBoolean (f3dex2.GeometryMode & (uint)General.GeometryMode.LIGHTING))  		GL.Color4 (f3dex2.VertexBuffer [i].Colors);  	GL.Normal3 (f3dex2.VertexBuffer [i].Normals);  	GL.Vertex3 (f3dex2.VertexBuffer [i].Position);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: foreach (int i in idx) {  	if (i >= f3dex2.VertexBuffer.Length)  		continue;  	double[] S = new double[2]' T = new double[2];  	for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  		if (f3dex2.Textures [j].MaskS != 0)  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  		else  			S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  		if (f3dex2.Textures [j].MaskT != 0)  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  		else  			T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  		OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  	}  	if (!Convert.ToBoolean (f3dex2.GeometryMode & (uint)General.GeometryMode.LIGHTING))  		GL.Color4 (f3dex2.VertexBuffer [i].Colors);  	GL.Normal3 (f3dex2.VertexBuffer [i].Normals);  	GL.Vertex3 (f3dex2.VertexBuffer [i].Position);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  	if (f3dex2.Textures [j].MaskS != 0)  		S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  	else  		S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  	if (f3dex2.Textures [j].MaskT != 0)  		T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  	else  		T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  	OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  	if (f3dex2.Textures [j].MaskS != 0)  		S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  	else  		S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  	if (f3dex2.Textures [j].MaskT != 0)  		T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  	else  		T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  	OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  	if (f3dex2.Textures [j].MaskS != 0)  		S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  	else  		S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  	if (f3dex2.Textures [j].MaskT != 0)  		T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  	else  		T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  	OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: for (int j = 0; j < (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB") ? f3dex2.Textures.Length : 1); j++) {  	if (f3dex2.Textures [j].MaskS != 0)  		S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  	else  		S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  	if (f3dex2.Textures [j].MaskT != 0)  		T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  	else  		T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  	OpenGLHelpers.Initialization.MultiTexCoord2Checked (TextureUnit.Texture0 + j' S [j]' T [j]);  }  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: if (f3dex2.Textures [j].MaskS != 0)  	S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  else  	S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: if (f3dex2.Textures [j].MaskS != 0)  	S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  else  	S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - ((f3dex2.Textures [j].ULS * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskS))) * f3dex2.Textures [j].ScaleS;  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: S [j] = (f3dex2.VertexBuffer [i].TexCoord.X * f3dex2.Textures [j].ShiftScaleS * f3dex2.ScaleS [j] - (f3dex2.Textures [j].ULS * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleS;  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: if (f3dex2.Textures [j].MaskT != 0)  	T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  else  	T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: if (f3dex2.Textures [j].MaskT != 0)  	T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  else  	T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - ((f3dex2.Textures [j].ULT * General.Fixed2Float [2]) % (float)(1 << f3dex2.Textures [j].MaskT))) * f3dex2.Textures [j].ScaleT;  
Magic Number,SceneNavi.SimpleF3DEX2,General,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\General.cs,RenderTriangles,The following statement contains a magic number: T [j] = (f3dex2.VertexBuffer [i].TexCoord.Y * f3dex2.Textures [j].ShiftScaleT * f3dex2.ScaleT [j] - (f3dex2.Textures [j].ULT * General.Fixed2Float [2])) * f3dex2.Textures [j].ScaleT;  
Magic Number,SceneNavi.SimpleF3DEX2,SimpleTriangle,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\SimpleTriangle.cs,SimpleTriangle,The following statement contains a magic number: Vertices = new Vector3d[3];  
Magic Number,SceneNavi.SimpleF3DEX2,SimpleTriangle,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\SimpleTriangle.cs,SimpleTriangle,The following statement contains a magic number: Vertices [2] = v3;  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cA = new ComponentsC16[2];  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cB = new ComponentsC16[2];  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cC = new ComponentsC32[2];  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cD = new ComponentsC8[2];  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aA = new ComponentsA8[2];  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aB = new ComponentsA8[2];  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aC = new ComponentsA8[2];  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aD = new ComponentsA8[2];  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cA [0] = (ComponentsC16)(byte)((m0 >> 20) & 0x0F);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cB [0] = (ComponentsC16)(byte)((m1 >> 28) & 0x0F);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cC [0] = (ComponentsC32)(byte)((m0 >> 15) & 0x1F);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cD [0] = (ComponentsC8)(byte)((m1 >> 15) & 0x07);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aA [0] = (ComponentsA8)(byte)((m0 >> 12) & 0x07);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aB [0] = (ComponentsA8)(byte)((m1 >> 12) & 0x07);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aC [0] = (ComponentsA8)(byte)((m0 >> 9) & 0x07);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aD [0] = (ComponentsA8)(byte)((m1 >> 9) & 0x07);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cA [1] = (ComponentsC16)(byte)((m0 >> 5) & 0x0F);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cB [1] = (ComponentsC16)(byte)((m1 >> 24) & 0x0F);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: cD [1] = (ComponentsC8)(byte)((m1 >> 6) & 0x07);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aA [1] = (ComponentsA8)(byte)((m1 >> 21) & 0x07);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aB [1] = (ComponentsA8)(byte)((m1 >> 3) & 0x07);  
Magic Number,SceneNavi.SimpleF3DEX2,UnpackedCombinerMux,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\UnpackedCombinerMux.cs,UnpackedCombinerMux,The following statement contains a magic number: aC [1] = (ComponentsA8)(byte)((m1 >> 18) & 0x07);  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: Position = new Vector3d ((double)Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)adr))' (double)Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 2)))' (double)Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 4))));  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: Position = new Vector3d ((double)Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)adr))' (double)Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 2)))' (double)Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 4))));  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: TexCoord = new Vector2d ((float)(Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 8)))) * General.Fixed2Float [5]' (float)(Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 10)))) * General.Fixed2Float [5]);  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: TexCoord = new Vector2d ((float)(Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 8)))) * General.Fixed2Float [5]' (float)(Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 10)))) * General.Fixed2Float [5]);  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: TexCoord = new Vector2d ((float)(Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 8)))) * General.Fixed2Float [5]' (float)(Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 10)))) * General.Fixed2Float [5]);  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: TexCoord = new Vector2d ((float)(Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 8)))) * General.Fixed2Float [5]' (float)(Endian.SwapInt16 (BitConverter.ToInt16 (raw' (int)(adr + 10)))) * General.Fixed2Float [5]);  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: Colors = new byte[] {  	raw [adr + 12]'  	raw [adr + 13]'  	raw [adr + 14]'  	raw [adr + 15]  };  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: Colors = new byte[] {  	raw [adr + 12]'  	raw [adr + 13]'  	raw [adr + 14]'  	raw [adr + 15]  };  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: Colors = new byte[] {  	raw [adr + 12]'  	raw [adr + 13]'  	raw [adr + 14]'  	raw [adr + 15]  };  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: Colors = new byte[] {  	raw [adr + 12]'  	raw [adr + 13]'  	raw [adr + 14]'  	raw [adr + 15]  };  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: Normals = new sbyte[] {  	(sbyte)raw [adr + 12]'  	(sbyte)raw [adr + 13]'  	(sbyte)raw [adr + 14]  };  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: Normals = new sbyte[] {  	(sbyte)raw [adr + 12]'  	(sbyte)raw [adr + 13]'  	(sbyte)raw [adr + 14]  };  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Vertex,The following statement contains a magic number: Normals = new sbyte[] {  	(sbyte)raw [adr + 12]'  	(sbyte)raw [adr + 13]'  	(sbyte)raw [adr + 14]  };  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Store,The following statement contains a magic number: databuf [(int)(baseadr + (Address & 0xFFFFFF)) + 12] = Colors [0];  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Store,The following statement contains a magic number: databuf [(int)(baseadr + (Address & 0xFFFFFF)) + 13] = Colors [1];  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Store,The following statement contains a magic number: databuf [(int)(baseadr + (Address & 0xFFFFFF)) + 14] = Colors [2];  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Store,The following statement contains a magic number: databuf [(int)(baseadr + (Address & 0xFFFFFF)) + 14] = Colors [2];  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Store,The following statement contains a magic number: databuf [(int)(baseadr + (Address & 0xFFFFFF)) + 15] = Colors [3];  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Store,The following statement contains a magic number: databuf [(int)(baseadr + (Address & 0xFFFFFF)) + 15] = Colors [3];  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Render,The following statement contains a magic number: if (rendertype == HeaderCommands.PickableObjectRenderType.Picking) {  	GL.PushAttrib (AttribMask.AllAttribBits);  	GL.Disable (EnableCap.Texture2D);  	GL.Disable (EnableCap.Lighting);  	if (OpenGLHelpers.Initialization.SupportsFunction ("glGenProgramsARB"))  		GL.Disable ((EnableCap)All.FragmentProgram);  	GL.Disable (EnableCap.CullFace);  	GL.DepthRange (0.0' 0.999);  	GL.PointSize (50.0f);  	GL.Color3 (PickColor);  	GL.Begin (PrimitiveType.Points);  	GL.Vertex3 (Position);  	GL.End ();  	GL.PopAttrib ();  }  
Magic Number,SceneNavi.SimpleF3DEX2,Vertex,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\Vertex.cs,Render,The following statement contains a magic number: GL.DepthRange (0.0' 0.999);  
Magic Number,SceneNavi.SimpleF3DEX2.CombinerEmulation,ArbCombineProgram,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\ArbCombineProgram.cs,ArbCombineProgram,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	switch (Unpacked.cA [i]) {  	case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED:  		pstring += "MOV R0.rgb' Comb;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0:  		if (Textured)  			pstring += "MOV R0.rgb' Tex0;\n";  		else  			pstring += "MOV R0.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1:  		if (Textured)  			pstring += "MOV R0.rgb' Tex1;\n";  		else  			pstring += "MOV R0.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE:  		pstring += "MOV R0.rgb' PrimColor;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE:  		pstring += "MOV R0.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_ENVIRONMENT:  		pstring += "MOV R0.rgb' EnvColor;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_1:  		pstring += "MOV R0.rgb' {1.0' 1.0' 1.0' 1.0};\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED_ALPHA:  		pstring += "MOV R0.rgb' Comb.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0_ALPHA:  		if (Textured)  			pstring += "MOV R0.rgb' Tex0.a;\n";  		else  			pstring += "MOV R0.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1_ALPHA:  		if (Textured)  			pstring += "MOV R0.rgb' Tex1.a;\n";  		else  			pstring += "MOV R0.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE_ALPHA:  		pstring += "MOV R0.rgb' PrimColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE_ALPHA:  		pstring += "MOV R0.rgb' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_ENV_ALPHA:  		pstring += "MOV R0.rgb' EnvColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_LOD_FRACTION:  		pstring += "MOV R0.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		// unemulated  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIM_LOD_FRAC:  		pstring += "MOV R0.rgb' PrimColorLOD;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_0:  		pstring += "MOV R0.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	default:  		pstring += "MOV R0.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	}  	switch (Unpacked.cB [i]) {  	case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED:  		pstring += "MOV R1.rgb' Comb;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0:  		if (Textured)  			pstring += "MOV R1.rgb' Tex0;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1:  		if (Textured)  			pstring += "MOV R1.rgb' Tex1;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE:  		pstring += "MOV R1.rgb' PrimColor;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE:  		pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_ENVIRONMENT:  		pstring += "MOV R1.rgb' EnvColor;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_1:  		pstring += "MOV R1.rgb' {1.0' 1.0' 1.0' 1.0};\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED_ALPHA:  		pstring += "MOV R1.rgb' Comb.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0_ALPHA:  		if (Textured)  			pstring += "MOV R1.rgb' Tex0.a;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1_ALPHA:  		if (Textured)  			pstring += "MOV R1.rgb' Tex1.a;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE_ALPHA:  		pstring += "MOV R1.rgb' PrimColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE_ALPHA:  		pstring += "MOV R1.rgb' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_ENV_ALPHA:  		pstring += "MOV R1.rgb' EnvColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_LOD_FRACTION:  		pstring += "MOV R1.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		// unemulated  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIM_LOD_FRAC:  		pstring += "MOV R1.rgb' PrimColorLOD;\n";  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_0:  		pstring += "MOV R1.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	default:  		pstring += "MOV R1.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	}  	pstring += "SUB R0' R0' R1;\n\n";  	switch (Unpacked.cC [i]) {  	case UnpackedCombinerMux.ComponentsC32.CCMUX_COMBINED:  		pstring += "MOV R1.rgb' Comb;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL0:  		if (Textured)  			pstring += "MOV R1.rgb' Tex0;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL1:  		if (Textured)  			pstring += "MOV R1.rgb' Tex1;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_PRIMITIVE:  		pstring += "MOV R1.rgb' PrimColor;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_SHADE:  		pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_ENVIRONMENT:  		pstring += "MOV R1.rgb' EnvColor;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_1:  		pstring += "MOV R1.rgb' {1.0' 1.0' 1.0' 1.0};\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_COMBINED_ALPHA:  		pstring += "MOV R1.rgb' Comb.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL0_ALPHA:  		if (Textured)  			pstring += "MOV R1.rgb' Tex0.a;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL1_ALPHA:  		if (Textured)  			pstring += "MOV R1.rgb' Tex1.a;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_PRIMITIVE_ALPHA:  		pstring += "MOV R1.rgb' PrimColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_SHADE_ALPHA:  		pstring += "MOV R1.rgb' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_ENV_ALPHA:  		pstring += "MOV R1.rgb' EnvColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_LOD_FRACTION:  		pstring += "MOV R1.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		// unemulated  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_PRIM_LOD_FRAC:  		pstring += "MOV R1.rgb' PrimColorLOD;\n";  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_K5:  		pstring += "MOV R1.rgb' {1.0' 1.0' 1.0' 1.0};\n";  		// unemulated  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_0:  		pstring += "MOV R1.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	default:  		pstring += "MOV R1.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	}  	pstring += "MUL R0' R0' R1;\n\n";  	switch (Unpacked.cD [i]) {  	case UnpackedCombinerMux.ComponentsC8.CCMUX_COMBINED:  		pstring += "MOV R1.rgb' Comb;\n";  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_TEXEL0:  		if (Textured)  			pstring += "MOV R1.rgb' Tex0;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_TEXEL1:  		if (Textured)  			pstring += "MOV R1.rgb' Tex1;\n";  		else  			pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_PRIMITIVE:  		pstring += "MOV R1.rgb' PrimColor;\n";  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_SHADE:  		pstring += "MOV R1.rgb' Shade;\n";  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_ENVIRONMENT:  		pstring += "MOV R1.rgb' EnvColor;\n";  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_1:  		pstring += "MOV R1.rgb' {1.0' 1.0' 1.0' 1.0};\n";  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_0:  		pstring += "MOV R1.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	default:  		pstring += "MOV R1.rgb' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	}  	pstring += "ADD R0' R0' R1;\n\n";  	switch (Unpacked.aA [i]) {  	case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  		pstring += "MOV aR0.a' aComb;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  		if (Textured)  			pstring += "MOV aR0.a' Tex0.a;\n";  		else  			pstring += "MOV aR0.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  		if (Textured)  			pstring += "MOV aR0.a' Tex1.a;\n";  		else  			pstring += "MOV aR0.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  		pstring += "MOV aR0.a' PrimColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  		pstring += "MOV aR0.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  		pstring += "MOV aR0.a' EnvColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  		pstring += "MOV aR0.a' {1.0' 1.0' 1.0' 1.0};\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  		pstring += "MOV aR0.a' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	default:  		pstring += "MOV aR0.a' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	}  	switch (Unpacked.aB [i]) {  	case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  		pstring += "MOV aR1.a' aComb;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  		if (Textured)  			pstring += "MOV aR1.a' Tex0.a;\n";  		else  			pstring += "MOV aR1.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  		if (Textured)  			pstring += "MOV aR1.a' Tex1.a;\n";  		else  			pstring += "MOV aR1.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  		pstring += "MOV aR1.a' PrimColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  		pstring += "MOV aR1.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  		pstring += "MOV aR1.a' EnvColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  		pstring += "MOV aR1.a' {1.0' 1.0' 1.0' 1.0};\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  		pstring += "MOV aR1.a' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	default:  		pstring += "MOV aR1.a' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	}  	pstring += "SUB aR0.a' aR0.a' aR1.a;\n\n";  	switch (Unpacked.aC [i]) {  	case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  		pstring += "MOV aR1.a' aComb;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  		if (Textured)  			pstring += "MOV aR1.a' Tex0.a;\n";  		else  			pstring += "MOV aR1.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  		if (Textured)  			pstring += "MOV aR1.a' Tex1.a;\n";  		else  			pstring += "MOV aR1.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  		pstring += "MOV aR1.a' PrimColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  		pstring += "MOV aR1.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  		pstring += "MOV aR1.a' EnvColor.a;\n";  		break;  	//TODO  check this!  	//case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIM_LOD_FRAC:  	//pstring += "MOV aR1.a' PrimColorLOD.a;\n";  	//break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  		pstring += "MOV aR1.a' {1.0' 1.0' 1.0' 1.0};\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  		pstring += "MOV aR1.a' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	default:  		pstring += "MOV aR1.a' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	}  	pstring += "MUL aR0.a' aR0.a' aR1.a;\n\n";  	switch (Unpacked.aD [i]) {  	case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  		pstring += "MOV aR1.a' aComb.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  		if (Textured)  			pstring += "MOV aR1.a' Tex0.a;\n";  		else  			pstring += "MOV aR1.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  		if (Textured)  			pstring += "MOV aR1.a' Tex1.a;\n";  		else  			pstring += "MOV aR1.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  		pstring += "MOV aR1.a' PrimColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  		pstring += "MOV aR1.a' Shade.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  		pstring += "MOV aR1.a' EnvColor.a;\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  		pstring += "MOV aR1.a' {1.0' 1.0' 1.0' 1.0};\n";  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  		pstring += "MOV aR1.a' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	default:  		pstring += "MOV aR1.a' {0.0' 0.0' 0.0' 0.0};\n";  		break;  	}  	pstring += "ADD aR0.a' aR0.a' aR1.a;\n\n";  	pstring += "MOV Comb.rgb' R0;\n";  	pstring += "MOV aComb.a' aR0;\n\n";  }  
Magic Number,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	StringBuilder calc = new StringBuilder ();  	calc.AppendFormat ("{0} = vec4(("' (i == 0 ? "combColor" : "outColor"));  	switch (Unpacked.cA [i]) {  	case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED:  		calc.Append ("combColor");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0:  		calc.Append ("tex0color");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1:  		calc.Append ("tex1color");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE:  		calc.Append ("primColor");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE:  		calc.Append ("lightColor");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_ENVIRONMENT:  		calc.Append ("envColor");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_1:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED_ALPHA:  		calc.Append ("comb.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0_ALPHA:  		calc.Append ("tex0color.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1_ALPHA:  		calc.Append ("tex1color.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE_ALPHA:  		calc.Append ("primColor.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE_ALPHA:  		calc.Append ("lightColor.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_ENV_ALPHA:  		calc.Append ("envColor.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_LOD_FRACTION:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIM_LOD_FRAC:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		//unemulated for now  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_0:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	}  	calc.Append (" - ");  	switch (Unpacked.cB [i]) {  	case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED:  		calc.Append ("combColor");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0:  		calc.Append ("tex0color");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1:  		calc.Append ("tex1color");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE:  		calc.Append ("primColor");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE:  		calc.Append ("lightColor");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_ENVIRONMENT:  		calc.Append ("envColor");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_1:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED_ALPHA:  		calc.Append ("comb.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0_ALPHA:  		calc.Append ("tex0color.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1_ALPHA:  		calc.Append ("tex1color.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE_ALPHA:  		calc.Append ("primColor.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE_ALPHA:  		calc.Append ("lightColor.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_ENV_ALPHA:  		calc.Append ("envColor.a");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_LOD_FRACTION:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIM_LOD_FRAC:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		//unemulated for now  		break;  	case UnpackedCombinerMux.ComponentsC16.CCMUX_0:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	}  	calc.Append (") * ");  	switch (Unpacked.cC [i]) {  	case UnpackedCombinerMux.ComponentsC32.CCMUX_COMBINED:  		calc.Append ("combColor");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL0:  		calc.Append ("tex0color");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL1:  		calc.Append ("tex1color");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_PRIMITIVE:  		calc.Append ("primColor");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_SHADE:  		calc.Append ("lightColor");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_ENVIRONMENT:  		calc.Append ("envColor");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_1:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_COMBINED_ALPHA:  		calc.Append ("comb.a");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL0_ALPHA:  		calc.Append ("tex0color.a");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL1_ALPHA:  		calc.Append ("tex1color.a");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_PRIMITIVE_ALPHA:  		calc.Append ("primColor.a");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_SHADE_ALPHA:  		calc.Append ("lightColor.a");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_ENV_ALPHA:  		calc.Append ("envColor.a");  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_LOD_FRACTION:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		//unemulated for now  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_PRIM_LOD_FRAC:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		//unemulated for now  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_K5:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		//unemulated for now  		break;  	case UnpackedCombinerMux.ComponentsC32.CCMUX_0:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	}  	calc.Append (" + ");  	switch (Unpacked.cD [i]) {  	case UnpackedCombinerMux.ComponentsC8.CCMUX_COMBINED:  		calc.Append ("combColor");  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_TEXEL0:  		calc.Append ("tex0color");  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_TEXEL1:  		calc.Append ("tex1color");  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_PRIMITIVE:  		calc.Append ("primColor");  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_SHADE:  		calc.Append ("lightColor");  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_ENVIRONMENT:  		calc.Append ("envColor");  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_1:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		break;  	case UnpackedCombinerMux.ComponentsC8.CCMUX_0:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	}  	calc.AppendLine (");");  	calc.AppendFormat ("{0} = vec4(("' (i == 0 ? "combAlpha" : "outAlpha"));  	switch (Unpacked.aA [i]) {  	case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  		calc.Append ("combAlpha.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  		calc.Append ("tex0color.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  		calc.Append ("tex1color.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  		calc.Append ("primColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  		calc.Append ("lightColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  		calc.Append ("envColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	}  	calc.Append (" - ");  	switch (Unpacked.aB [i]) {  	case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  		calc.Append ("combAlpha.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  		calc.Append ("tex0color.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  		calc.Append ("tex1color.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  		calc.Append ("primColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  		calc.Append ("lightColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  		calc.Append ("envColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	}  	calc.Append (") * ");  	switch (Unpacked.aC [i]) {  	case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  		calc.Append ("combAlpha.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  		calc.Append ("tex0color.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  		calc.Append ("tex1color.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  		calc.Append ("primColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  		calc.Append ("lightColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  		calc.Append ("envColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	}  	calc.Append (" + ");  	switch (Unpacked.aD [i]) {  	case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  		calc.Append ("combAlpha.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  		calc.Append ("tex0color.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  		calc.Append ("tex1color.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  		calc.Append ("primColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  		calc.Append ("lightColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  		calc.Append ("envColor.a");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  		calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  		break;  	case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  		calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  		break;  	}  	calc.AppendLine (");");  	calc.AppendLine ("gl_FragColor.rgb = outColor.rgb;");  	calc.AppendLine ("gl_FragColor.a = outAlpha.a;");  	fs.AppendLine (calc.ToString ());  	//fs.AppendLine("gl_FragColor = lightColor;");  }  
Duplicate Code,SceneNavi.SimpleF3DEX2.CombinerEmulation,ArbCombineProgram,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\ArbCombineProgram.cs,ArbCombineProgram,The method contains a code clone-set at the following line numbers (starting from the method definition): ((285' 308)' (321' 344))
Duplicate Code,SceneNavi.SimpleF3DEX2.CombinerEmulation,ArbCombineProgram,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\ArbCombineProgram.cs,ArbCombineProgram,The method contains a code clone-set at the following line numbers (starting from the method definition): ((287' 318)' (363' 394))
Duplicate Code,SceneNavi.SimpleF3DEX2.CombinerEmulation,ArbCombineProgram,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\ArbCombineProgram.cs,ArbCombineProgram,The method contains a code clone-set at the following line numbers (starting from the method definition): ((323' 344)' (363' 384))
Duplicate Code,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The method contains a code clone-set at the following line numbers (starting from the method definition): ((34' 83)' (86' 135))
Duplicate Code,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The method contains a code clone-set at the following line numbers (starting from the method definition): ((223' 247)' (250' 274)' (277' 301)' (304' 328))
Missing Default,SceneNavi,ColorPickerDialog,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\ColorPickerDialog.cs,ColorSlide,The following switch statement is missing a default case: switch (colorComponent) {  case ColorComponents.Red:  	Color = Color.FromArgb (color.A' newValue' color.G' color.B);  	break;  case ColorComponents.Green:  	Color = Color.FromArgb (color.A' color.R' newValue' color.B);  	break;  case ColorComponents.Blue:  	Color = Color.FromArgb (color.A' color.R' color.G' newValue);  	break;  case ColorComponents.Alpha:  	Color = Color.FromArgb (newValue' color.R' color.G' color.B);  	break;  }  
Missing Default,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseDown,The following switch statement is missing a default case: switch (currentToolMode) {  case ToolModes.Camera: {  	/* Camera only */if (Convert.ToBoolean (camera.ButtonsDown & MouseButtons.Left))  		camera.MouseCenter (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs:  case ToolModes.StaticObjs: {  	/* Object picking */if (Convert.ToBoolean (camera.ButtonsDown & MouseButtons.Left) || Convert.ToBoolean (camera.ButtonsDown & MouseButtons.Middle)) {  		pickedObject = TryPickObject (e.X' e.Y' (currentToolMode == ToolModes.MoveableObjs));  		if (pickedObject == null) {  			/* No pick? Camera */camera.MouseCenter (new Vector2d (e.X' e.Y));  		} else {  			/* Object found */pickObjLastPosition = pickObjPosition = new Vector2d (e.X' e.Y);  			pickObjDisplacement = Vector2d.Zero;  			((Control)sender).Focus ();  			/* Mark GLDLs as dirty? */collisionDirty = (pickedObject is HeaderCommands.Collision.Polygon);  			waterboxesDirty = (pickedObject is HeaderCommands.Collision.Waterbox);  			/* Static object? Camera */if (currentToolMode == ToolModes.StaticObjs) {  				camera.MouseCenter (new Vector2d (e.X' e.Y));  				/*if (e.Clicks == 2 && currentRoomVertex != null)                                     {                                         EditVertexColor(currentRoomVertex);                                     }*/}  		}  	} else if (Convert.ToBoolean (camera.ButtonsDown & MouseButtons.Right)) {  		pickedObject = TryPickObject (e.X' e.Y' (currentToolMode == ToolModes.MoveableObjs));  		if (pickedObject != null) {  			if (currentToolMode == ToolModes.MoveableObjs) {  				if (pickedObject is HeaderCommands.Actors.Entry) {  					HeaderCommands.Actors.Entry ac = (pickedObject as HeaderCommands.Actors.Entry);  					/* Determine what menu entries should be enabled */xAxisToolStripMenuItem.Enabled = !(ac.Definition.Items.FirstOrDefault (x => x.Usage == XMLActorDefinitionReader.Definition.Item.Usages.RotationX) == null);  					yAxisToolStripMenuItem.Enabled = !(ac.Definition.Items.FirstOrDefault (x => x.Usage == XMLActorDefinitionReader.Definition.Item.Usages.RotationY) == null);  					zAxisToolStripMenuItem.Enabled = !(ac.Definition.Items.FirstOrDefault (x => x.Usage == XMLActorDefinitionReader.Definition.Item.Usages.RotationZ) == null);  					rotateToolStripMenuItem.Enabled = (xAxisToolStripMenuItem.Enabled || yAxisToolStripMenuItem.Enabled || zAxisToolStripMenuItem.Enabled);  				} else  					rotateToolStripMenuItem.Enabled = false;  				cmsMoveableObjectEdit.Show (((Control)sender).PointToScreen (e.Location));  			} else if (currentToolMode == ToolModes.StaticObjs) {  				if (pickedObject is SimpleF3DEX2.Vertex) {  					cmsVertexEdit.Show (((Control)sender).PointToScreen (e.Location));  				}  			}  		}  	}  	break;  }  }  
Missing Default,SceneNavi,MainForm,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\MainForm.cs,customGLControl_MouseMove,The following switch statement is missing a default case: switch (currentToolMode) {  case ToolModes.Camera: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left))  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  case ToolModes.MoveableObjs: {  	if (!Convert.ToBoolean (e.Button & MouseButtons.Left) && !Convert.ToBoolean (e.Button & MouseButtons.Middle))  		break;  	if (pickedObject == null)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	else {  		// TODO  make this not shitty; try to get the "new method" to work with anything that's not at (0'0'0)  		/* Speed modifiers */double movemod = 3.0;  		if (keysDown [(ushort)Keys.Space])  			movemod = 8.0;  		else if (keysDown [(ushort)Keys.ShiftKey])  			movemod = 1.0;  		/* Determine mouse position and displacement */pickObjPosition = new Vector2d (e.X' e.Y);  		pickObjDisplacement = ((pickObjPosition - pickObjLastPosition) * movemod);  		/* No displacement? Exit */if (pickObjDisplacement == Vector2d.Zero)  			return;  		/* Calculate camera rotation */double CamXRotd = camera.Rot.X * (double)(Math.PI / 180);  		double CamYRotd = camera.Rot.Y * (double)(Math.PI / 180);  		/* WARNING: Cam position stuff below is "I dunno why it works' but it does!" */Vector3d objpos = pickedObject.Position;  		if (Convert.ToBoolean (e.Button & MouseButtons.Middle) || (Convert.ToBoolean (e.Button & MouseButtons.Left) && keysDown [(ushort)Keys.ControlKey])) {  			/* Middle mouse button OR left button + Ctrl -> move forward/backward */objpos.X += ((Math.Sin (CamYRotd) * -pickObjDisplacement.Y));  			objpos.Z -= ((Math.Cos (CamYRotd) * -pickObjDisplacement.Y));  			camera.Pos.X -= ((Math.Sin (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  			camera.Pos.Z += ((Math.Cos (CamYRotd) * (-pickObjDisplacement.Y * camera.CameraCoeff * camera.Sensitivity) / 1.25));  		} else if (Convert.ToBoolean (e.Button & MouseButtons.Left)) {  			/* Left mouse button -> move up/down/left/right */objpos.X += ((Math.Cos (CamYRotd) * pickObjDisplacement.X));  			objpos.Y -= (pickObjDisplacement.Y);  			objpos.Z += ((Math.Sin (CamYRotd) * pickObjDisplacement.X));  			camera.Pos.X -= ((Math.Cos (CamYRotd) * pickObjDisplacement.X)) * 0.02;  			camera.Pos.Y += (pickObjDisplacement.Y) * 0.02;  			camera.Pos.Z -= ((Math.Sin (CamYRotd) * pickObjDisplacement.X)) * 0.02;  		}  		/* Round away decimal places (mainly for waypoints) */objpos.X = Math.Round (objpos.X' 0);  		objpos.Y = Math.Round (objpos.Y' 0);  		objpos.Z = Math.Round (objpos.Z' 0);  		pickedObject.Position = objpos;  		/* Refresh GUI according to type of picked object */if (pickedObject is HeaderCommands.Waypoints.Waypoint) {  			foreach (DataGridViewCell cell in dgvPathWaypoints.SelectedCells) {  				for (int i = 0; i < dgvPathWaypoints.ColumnCount; i++)  					dgvPathWaypoints.UpdateCellValue (i' cell.RowIndex);  			}  		} else if (pickedObject is HeaderCommands.Actors.Entry) {  			HeaderCommands.Actors.Entry actor = (pickedObject as HeaderCommands.Actors.Entry);  			if (actor.IsSpawnPoint)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExSpawnPoints);  			else if (actor.IsTransitionActor)  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExTransitions);  			else  				XMLActorDefinitionReader.RefreshActorPositionRotation (actor' tlpExRoomActors);  		} else if (pickedObject is HeaderCommands.Collision.Waterbox) {  			waterboxesDirty = true;  			RefreshWaterboxControls ();  		}  		pickObjLastPosition = pickObjPosition;  		((Control)sender).Focus ();  	}  	break;  }  case ToolModes.StaticObjs: {  	if (Convert.ToBoolean (e.Button & MouseButtons.Left)/* && PickedObject == null*/)  		camera.MouseMove (new Vector2d (e.X' e.Y));  	break;  }  }  
Missing Default,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following switch statement is missing a default case: switch (xml.Name) {  case "Number":  	if (xml.Value.StartsWith ("0x") == true)  		ndef.Number = ushort.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  	else  		ndef.Number = ushort.Parse (xml.Value);  	break;  case "IsDefault":  	ndef.IsDefault = (Definition.DefaultTypes)Enum.Parse (typeof(Definition.DefaultTypes)' xml.Value);  	break;  case "DisplayModel":  	displaydl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  	if (displaydl != null)  		ndef.DisplayModel = displaydl;  	break;  case "PickModel":  	pickdl = OpenGLHelpers.StockObjects.GetDisplayList (xml.Value);  	if (pickdl != null)  		ndef.PickModel = pickdl;  	break;  case "FrontOffset":  	ndef.FrontOffset = double.Parse (xml.Value' System.Globalization.CultureInfo.InvariantCulture);  	break;  }  
Missing Default,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following switch statement is missing a default case: switch (xml.Name) {  case "Index":  	nitem.Index = int.Parse (xml.Value);  	break;  case "ValueType":  	nitem.ValueType = FindTypeInCurrentAssemblies (xml.Value);  	break;  case "DisplayStyle":  	nitem.DisplayStyle = (Definition.Item.DisplayStyles)Enum.Parse (typeof(Definition.Item.DisplayStyles)' xml.Value);  	break;  case "Usage":  	nitem.Usage = (Definition.Item.Usages)Enum.Parse (typeof(Definition.Item.Usages)' xml.Value);  	break;  case "Description":  	nitem.Description = xml.Value;  	break;  case "Mask":  	if (xml.Value.StartsWith ("0x") == true)  		nitem.Mask = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  	else  		nitem.Mask = UInt64.Parse (xml.Value);  	break;  case "ControlType":  	nitem.ControlType = FindTypeInCurrentAssemblies (xml.Value);  	break;  }  
Missing Default,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,XMLActorDefinitionReader,The following switch statement is missing a default case: switch (xml.Name) {  case "Value":  	if (xml.Value.StartsWith ("0x") == true)  		nopt.Value = UInt64.Parse (xml.Value.Substring (2)' System.Globalization.NumberStyles.HexNumber);  	else  		nopt.Value = UInt64.Parse (xml.Value);  	break;  case "Description":  	nopt.Description = xml.Value;  	break;  }  
Missing Default,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,RefreshActorPositionRotation,The following switch statement is missing a default case: switch (item.DisplayStyle) {  case Definition.Item.DisplayStyles.Hexadecimal:  	fstr = "0x{0:X}";  	break;  case Definition.Item.DisplayStyles.Decimal:  	fstr = "{0:D}";  	break;  }  
Missing Default,SceneNavi,XMLActorDefinitionReader,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\XMLActorDefinitionReader.cs,CreateActorEditingControls,The following switch statement is missing a default case: switch (item.DisplayStyle) {  case Definition.Item.DisplayStyles.Hexadecimal:  	fstr = "0x{0:X}";  	break;  case Definition.Item.DisplayStyles.Decimal:  	fstr = "{0:D}";  	break;  }  
Missing Default,SceneNavi.OpenGLHelpers,Initialization,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\OpenGLHelpers\Initialization.cs,CreateViewportAndProjection,The following switch statement is missing a default case: switch (projectionType) {  case ProjectionTypes.Perspective:  	double aspect = clientRectangle.Width / (double)clientRectangle.Height;  	projectionMatrix = Matrix4.CreatePerspectiveFieldOfView (MathHelper.PiOver3' (float)aspect' near' far);  	break;  case ProjectionTypes.Orthographic:  	projectionMatrix = Matrix4.CreateOrthographicOffCenter (clientRectangle.Left' clientRectangle.Right' clientRectangle.Bottom' clientRectangle.Top' near' far);  	break;  }  
Missing Default,SceneNavi.SimpleF3DEX2,F3DEX2Interpreter,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\F3DEX2Interpreter.cs,LoadTextures,The following switch statement is missing a default case: switch (Configuration.CombinerType) {  case CombinerTypes.None:  	{  		CalculateTextureSize (0);  		OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0);  		GL.Enable (EnableCap.Texture2D);  		GL.BindTexture (TextureTarget.Texture2D' CheckTextureCache (0));  	}  	break;  case CombinerTypes.GLSLCombiner:  	{  		CalculateTextureSize (0);  		OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0);  		GL.Enable (EnableCap.Texture2D);  		GL.BindTexture (TextureTarget.Texture2D' CheckTextureCache (0));  		if (OpenGLHelpers.Initialization.SupportsFunction ("glActiveTextureARB")) {  			CalculateTextureSize (1);  			GL.ActiveTexture (TextureUnit.Texture1);  			GL.Enable (EnableCap.Texture2D);  			GL.BindTexture (TextureTarget.Texture2D' 0);  			if (multitex)  				GL.BindTexture (TextureTarget.Texture2D' CheckTextureCache (1));  		}  	}  	break;  case CombinerTypes.ArbCombiner:  	{  		OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0);  		GL.Disable (EnableCap.Texture2D);  		GL.BindTexture (TextureTarget.Texture2D' 0);  		OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture1);  		GL.Disable (EnableCap.Texture2D);  		GL.BindTexture (TextureTarget.Texture2D' 0);  		CalculateTextureSize (0);  		OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0);  		GL.Enable (EnableCap.Texture2D);  		GL.BindTexture (TextureTarget.Texture2D' CheckTextureCache (0));  		if (multitex) {  			CalculateTextureSize (1);  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture1);  			GL.Enable (EnableCap.Texture2D);  			GL.BindTexture (TextureTarget.Texture2D' CheckTextureCache (1));  			GL.Disable (EnableCap.Texture2D);  		} else {  			OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture1);  			GL.Disable (EnableCap.Texture2D);  		}  		OpenGLHelpers.Initialization.ActiveTextureChecked (TextureUnit.Texture0);  		GL.Disable (EnableCap.Texture2D);  	}  	break;  }  
Missing Default,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The following switch statement is missing a default case: switch (Unpacked.cA [i]) {  case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED:  	calc.Append ("combColor");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0:  	calc.Append ("tex0color");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1:  	calc.Append ("tex1color");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE:  	calc.Append ("primColor");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE:  	calc.Append ("lightColor");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_ENVIRONMENT:  	calc.Append ("envColor");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_1:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED_ALPHA:  	calc.Append ("comb.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0_ALPHA:  	calc.Append ("tex0color.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1_ALPHA:  	calc.Append ("tex1color.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE_ALPHA:  	calc.Append ("primColor.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE_ALPHA:  	calc.Append ("lightColor.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_ENV_ALPHA:  	calc.Append ("envColor.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_LOD_FRACTION:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIM_LOD_FRAC:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	//unemulated for now  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_0:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  }  
Missing Default,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The following switch statement is missing a default case: switch (Unpacked.cB [i]) {  case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED:  	calc.Append ("combColor");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0:  	calc.Append ("tex0color");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1:  	calc.Append ("tex1color");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE:  	calc.Append ("primColor");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE:  	calc.Append ("lightColor");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_ENVIRONMENT:  	calc.Append ("envColor");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_1:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_COMBINED_ALPHA:  	calc.Append ("comb.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL0_ALPHA:  	calc.Append ("tex0color.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_TEXEL1_ALPHA:  	calc.Append ("tex1color.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIMITIVE_ALPHA:  	calc.Append ("primColor.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_SHADE_ALPHA:  	calc.Append ("lightColor.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_ENV_ALPHA:  	calc.Append ("envColor.a");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_LOD_FRACTION:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_PRIM_LOD_FRAC:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	//unemulated for now  	break;  case UnpackedCombinerMux.ComponentsC16.CCMUX_0:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  }  
Missing Default,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The following switch statement is missing a default case: switch (Unpacked.cC [i]) {  case UnpackedCombinerMux.ComponentsC32.CCMUX_COMBINED:  	calc.Append ("combColor");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL0:  	calc.Append ("tex0color");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL1:  	calc.Append ("tex1color");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_PRIMITIVE:  	calc.Append ("primColor");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_SHADE:  	calc.Append ("lightColor");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_ENVIRONMENT:  	calc.Append ("envColor");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_1:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_COMBINED_ALPHA:  	calc.Append ("comb.a");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL0_ALPHA:  	calc.Append ("tex0color.a");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_TEXEL1_ALPHA:  	calc.Append ("tex1color.a");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_PRIMITIVE_ALPHA:  	calc.Append ("primColor.a");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_SHADE_ALPHA:  	calc.Append ("lightColor.a");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_ENV_ALPHA:  	calc.Append ("envColor.a");  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_LOD_FRACTION:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	//unemulated for now  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_PRIM_LOD_FRAC:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	//unemulated for now  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_K5:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	//unemulated for now  	break;  case UnpackedCombinerMux.ComponentsC32.CCMUX_0:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  }  
Missing Default,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The following switch statement is missing a default case: switch (Unpacked.cD [i]) {  case UnpackedCombinerMux.ComponentsC8.CCMUX_COMBINED:  	calc.Append ("combColor");  	break;  case UnpackedCombinerMux.ComponentsC8.CCMUX_TEXEL0:  	calc.Append ("tex0color");  	break;  case UnpackedCombinerMux.ComponentsC8.CCMUX_TEXEL1:  	calc.Append ("tex1color");  	break;  case UnpackedCombinerMux.ComponentsC8.CCMUX_PRIMITIVE:  	calc.Append ("primColor");  	break;  case UnpackedCombinerMux.ComponentsC8.CCMUX_SHADE:  	calc.Append ("lightColor");  	break;  case UnpackedCombinerMux.ComponentsC8.CCMUX_ENVIRONMENT:  	calc.Append ("envColor");  	break;  case UnpackedCombinerMux.ComponentsC8.CCMUX_1:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	break;  case UnpackedCombinerMux.ComponentsC8.CCMUX_0:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  }  
Missing Default,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The following switch statement is missing a default case: switch (Unpacked.aA [i]) {  case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  	calc.Append ("combAlpha.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  	calc.Append ("tex0color.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  	calc.Append ("tex1color.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  	calc.Append ("primColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  	calc.Append ("lightColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  	calc.Append ("envColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  }  
Missing Default,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The following switch statement is missing a default case: switch (Unpacked.aB [i]) {  case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  	calc.Append ("combAlpha.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  	calc.Append ("tex0color.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  	calc.Append ("tex1color.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  	calc.Append ("primColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  	calc.Append ("lightColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  	calc.Append ("envColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  }  
Missing Default,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The following switch statement is missing a default case: switch (Unpacked.aC [i]) {  case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  	calc.Append ("combAlpha.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  	calc.Append ("tex0color.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  	calc.Append ("tex1color.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  	calc.Append ("primColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  	calc.Append ("lightColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  	calc.Append ("envColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  }  
Missing Default,SceneNavi.SimpleF3DEX2.CombinerEmulation,GLSLShaders,D:\newReposJune17\xdanieldzd_SceneNavi\SceneNavi\SimpleF3DEX2\CombinerEmulation\GLSLShaders.cs,GLSLShaders,The following switch statement is missing a default case: switch (Unpacked.aD [i]) {  case UnpackedCombinerMux.ComponentsA8.ACMUX_COMBINED:  	calc.Append ("combAlpha.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL0:  	calc.Append ("tex0color.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_TEXEL1:  	calc.Append ("tex1color.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_PRIMITIVE:  	calc.Append ("primColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_SHADE:  	calc.Append ("lightColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_ENVIRONMENT:  	calc.Append ("envColor.a");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_1:  	calc.Append ("vec4(1.0' 1.0' 1.0' 1.0)");  	break;  case UnpackedCombinerMux.ComponentsA8.ACMUX_0:  	calc.Append ("vec4(0.0' 0.0' 0.0' 0.0)");  	break;  }  
