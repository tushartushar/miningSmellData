Implementation smell,Namespace,Class,File,Method,Description
Long Method,NHibernate.Search.Mapping.AttributeBased,AttributeSearchMappingBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Mapping\AttributeBased\AttributeSearchMappingBuilder.cs,BuildProperty,The method has 111 lines of code.
Long Method,NHibernate.Search.Query,FullTextQueryImpl,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Query\FullTextQueryImpl.cs,BuildFilters,The method has 106 lines of code.
Long Method,NHibernate.Search.Store,DirectoryProviderFactory,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\DirectoryProviderFactory.cs,GetDirectoryProperties,The method has 107 lines of code.
Complex Method,NHibernate.Search.Backend,Workspace,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Backend\Workspace.cs,CleanUp,Cyclomatic complexity of the method is 8
Complex Method,NHibernate.Search.Mapping.AttributeBased,AttributeSearchMappingBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Mapping\AttributeBased\AttributeSearchMappingBuilder.cs,BuildFilterDef,Cyclomatic complexity of the method is 8
Complex Method,NHibernate.Search.Mapping.AttributeBased,AttributeSearchMappingBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Mapping\AttributeBased\AttributeSearchMappingBuilder.cs,BuildProperty,Cyclomatic complexity of the method is 12
Complex Method,NHibernate.Search.Engine,QueryLoader,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Engine\QueryLoader.cs,Load,Cyclomatic complexity of the method is 9
Complex Method,NHibernate.Search.Store,DirectoryProviderFactory,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\DirectoryProviderFactory.cs,GetDirectoryProperties,Cyclomatic complexity of the method is 17
Complex Method,NHibernate.Search.Store,FileHelper,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FileHelper.cs,Synchronize,Cyclomatic complexity of the method is 8
Long Parameter List,NHibernate.Search.Mapping.AttributeBased,AttributeSearchMappingBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Mapping\AttributeBased\AttributeSearchMappingBuilder.cs,BuildProperty,The method has 6 parameters. Parameters: documentMapping' member' parentAnalyzer' isRoot' path' context
Long Parameter List,NHibernate.Search.Engine,DocumentBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Engine\DocumentBuilder.cs,AddToWorkQueue,The method has 6 parameters. Parameters: entityClass' entity' id' workType' queue' searchFactoryImplementor
Long Parameter List,NHibernate.Search.Engine,DocumentBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Engine\DocumentBuilder.cs,CollectAnalyzers,The method has 5 parameters. Parameters: class' parentAnalyzer' isRoot' prefix' processedClasses
Long Parameter List,NHibernate.Search.Engine,DocumentBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Engine\DocumentBuilder.cs,PopulateResult,The method has 6 parameters. Parameters: fieldName' fieldBridge' fieldStore' fields' result' document
Long Parameter List,NHibernate.Search.Engine,DocumentBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Engine\DocumentBuilder.cs,ProcessContainedInValue,The method has 5 parameters. Parameters: value' queue' valueClass' builder' searchFactory
Long Parameter List,NHibernate.Search.Bridge,IFieldBridge,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Bridge\IFieldBridge.cs,Set,The method has 6 parameters. Parameters: name' value' document' store' index' boost
Long Parameter List,NHibernate.Search.Bridge,String2FieldBridgeAdaptor,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Bridge\String2FieldBridgeAdaptor.cs,Set,The method has 6 parameters. Parameters: name' value' document' store' index' boost
Long Identifier,NHibernate.Search.Reader,SharedReaderProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Reader\SharedReaderProvider.cs,,The length of the parameter perDirectoryProviderManipulationLocks is 37.
Long Statement,NHibernate.Search.Mapping.AttributeBased,AttributeUtil,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Mapping\AttributeBased\AttributeUtil.cs,GetClassBridgeParameters,The length of the statement  "                // 3. If there's > 1 class bridge and no field bridge' that's an error - we don't know which class bridge should get them " is 121.
Long Statement,NHibernate.Search.Engine,QueryLoader,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Engine\QueryLoader.cs,Load,The length of the statement  "                    log.Warn("Lucene index contains info about entity " + entityInfo.Clazz.Name + "#" + entityInfo.Id + " which wasn't found in the database. Rebuild the index."); " is 159.
Long Statement,NHibernate.Search.Engine,DocumentBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Engine\DocumentBuilder.cs,GetDocument,The length of the statement  "                Field classField = new Field(CLASS_FIELDNAME' TypeHelper.LuceneTypeName(entityType)' Field.Store.YES' Field.Index.UN_TOKENIZED); " is 128.
Long Statement,NHibernate.Search.Engine,DocumentBuilder,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Engine\DocumentBuilder.cs,PostInitialize,The length of the statement  "            // together with the caller this creates a o(2)' but I think it's still faster than create the up hierarchy for each class " is 122.
Long Statement,NHibernate.Search.Event,FullTextIndexCollectionEventListener,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Event\FullTextIndexCollectionEventListener.cs,ProcessCollectionEvent,The length of the statement  "                    log.Warn("Unable to reindex entity on collection change' id cannot be extracted: " + @event.GetAffectedOwnerEntityName()); " is 122.
Long Statement,NHibernate.Search.Impl,SearchFactoryImpl,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Impl\SearchFactoryImpl.cs,InitDocumentBuilders,The length of the statement  "                DocumentBuilder documentBuilder = new DocumentBuilder(classMapping' analyzer' providers.Providers' providers.SelectionStrategy); " is 128.
Long Statement,NHibernate.Search.Query,FullTextSearchHelper,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Query\FullTextSearchHelper.cs,BuildSearcher,The length of the statement  "                    foreach (IDirectoryProvider provider in builder.DirectoryProvidersSelectionStrategy.GetDirectoryProvidersForAllShards()) " is 120.
Long Statement,NHibernate.Search.Query,FullTextSearchHelper,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Query\FullTextSearchHelper.cs,BuildSearcher,The length of the statement  "                    foreach (IDirectoryProvider provider in builder.DirectoryProvidersSelectionStrategy.GetDirectoryProvidersForAllShards()) " is 120.
Long Statement,NHibernate.Search.Query,FullTextQueryImpl,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Query\FullTextQueryImpl.cs,LogQuery,The length of the statement  "            log.DebugFormat("Execute lucene query [{0}]: {1}. Max rows: {2}' First result: {3}"' sb' luceneQuery' maxRows' firstRow);" is 121.
Long Statement,NHibernate.Search.Backend.Impl.Lucene,LuceneBackendQueueProcessor,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Backend\Impl\Lucene\LuceneBackendQueueProcessor.cs,Run,The length of the statement  "                        IDirectoryProvider[] providers = shardingStrategy.GetDirectoryProvidersForDeletion(work.EntityClass' work.Id' work.IdInString); " is 127.
Long Statement,NHibernate.Search.Backend.Impl.Lucene,LuceneBackendQueueProcessor,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Backend\Impl\Lucene\LuceneBackendQueueProcessor.cs,Run,The length of the statement  "                        IDirectoryProvider provider = shardingStrategy.GetDirectoryProviderForAddition(work.EntityClass' work.Id' work.IdInString' work.Document); " is 138.
Long Statement,NHibernate.Search.Backend.Impl.Lucene,LuceneBackendQueueProcessor,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Backend\Impl\Lucene\LuceneBackendQueueProcessor.cs,Run,The length of the statement  "                        IDirectoryProvider[] providers = shardingStrategy.GetDirectoryProvidersForDeletion(work.EntityClass' work.Id' work.IdInString); " is 127.
Long Statement,NHibernate.Search.Store,FSMasterDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSMasterDirectoryProvider.cs,Initialize,The length of the statement  "            source = DirectoryProviderHelper.GetSourceDirectory(Environment.SourceBase' Environment.Source' directoryProviderName' (IDictionary) properties); " is 145.
Long Statement,NHibernate.Search.Store,FSSlaveDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSSlaveDirectoryProvider.cs,Initialize,The length of the statement  "            source = DirectoryProviderHelper.GetSourceDirectory(Environment.SourceBase' Environment.Source' directoryProviderName' (IDictionary) properties); " is 145.
Long Statement,NHibernate.Search.Store.Optimization,IncrementalOptimizerStrategy,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\Optimization\IncrementalOptimizerStrategy.cs,Optimize,The length of the statement  "                log.Debug("Optimize " + directoryProvider.Directory + " after " + operations + " operations and " + transactions + " transactions"); " is 132.
Virtual Method Call from Constructor,NHibernate.Search.Cfg,NHSConfiguration,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Cfg\NHSConfiguration.cs,NHSConfiguration,The constructor "NHSConfiguration" calls a virtual method "Parse".
Empty Catch Block,NHibernate.Search.Backend,ParameterSet,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Backend\ParameterSet.cs,ApplyToWriter,The method has an empty catch block.
Empty Catch Block,NHibernate.Search,DirectoryProviderHelper,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Util\DirectoryProviderHelper.cs,HasWriteAccess,The method has an empty catch block.
Empty Catch Block,NHibernate.Search.Reader,ReaderProviderHelper,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Reader\ReaderProviderHelper.cs,Clean,The method has an empty catch block.
Magic Number,NHibernate.Search.Backend.Impl,TransactionalWorker,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Backend\Impl\TransactionalWorker.cs,PerformWork,The following statement contains a magic number: if (session.TransactionInProgress)              {                  ITransaction transaction = ((ISession)session).Transaction;                  PostTransactionWorkQueueSynchronization txSync = (PostTransactionWorkQueueSynchronization)                                                                   synchronizationPerTransaction[transaction];                  if (txSync == null || txSync.IsConsumed)                  {                      txSync =                          new PostTransactionWorkQueueSynchronization(queueingProcessor' synchronizationPerTransaction);                      transaction.RegisterSynchronization(txSync);                      lock (synchronizationPerTransaction.SyncRoot)                          synchronizationPerTransaction[transaction] = txSync;                  }                  txSync.Add(work);              }              else              {                  WorkQueue queue = new WorkQueue(2); //one work can be split                  queueingProcessor.Add(work' queue);                  queueingProcessor.PrepareWorks(queue);                  queueingProcessor.PerformWorks(queue);              }
Magic Number,NHibernate.Search.Filter,MruFilterCachingStrategy,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Filter\MruFilterCachingStrategy.cs,Initialize,The following statement contains a magic number: int size = 128;
Magic Number,NHibernate.Search.Filter,MruFilterCachingStrategy,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Filter\MruFilterCachingStrategy.cs,Initialize,The following statement contains a magic number: if (properties.ContainsKey(SIZE))              {                  if (!int.TryParse(properties[SIZE]' out size))                  {                      // TODO: Log a warning                      size = 128;                  }              }
Magic Number,NHibernate.Search.Filter,StandardFilterKey,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Filter\StandardFilterKey.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,NHibernate.Search.Filter,StandardFilterKey,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Filter\StandardFilterKey.cs,GetHashCode,The following statement contains a magic number: foreach (object param in parameters)              {                  hash = 31 * hash + (param != null ? param.GetHashCode() : 0);              }
Magic Number,NHibernate.Search,DirectoryProviderHelper,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Util\DirectoryProviderHelper.cs,DetermineIndexDir,The following statement contains a magic number: if (indexBase == null)              {                  indexBase = ".";              }              else if (indexBase.StartsWith("~"))              {                  // We need this to allow using the search from the web' where the "." directory is somewhere in the system root.                  indexBase = indexBase.Replace("~"' AppDomain.CurrentDomain.BaseDirectory);              }              else if (indexBase.StartsWith(".."))              {                  // determine the indexBase path when using parent directory (eg. "../indexes")                    DirectoryInfo targetParentDir = new DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory);                    string path = indexBase;                    while (path.StartsWith(".."))                  {                      if (targetParentDir.Parent == null)                          throw new HibernateException("IndexBase path not valid");                        targetParentDir = targetParentDir.Parent;                      path = path.Remove(0' 3);                  }                    indexBase = Path.Combine(targetParentDir.FullName' path);              }
Magic Number,NHibernate.Search.Backend.Impl.Lucene,LuceneBackendQueueProcessor,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Backend\Impl\Lucene\LuceneBackendQueueProcessor.cs,Run,The following statement contains a magic number: try              {                  List<LuceneWorker.WorkWithPayload> queueWithFlatDPs = new List<LuceneWorker.WorkWithPayload>(queue.Count*2);                  foreach (LuceneWork work in queue)                  {                      DocumentBuilder documentBuilder = searchFactoryImplementor.DocumentBuilders[work.EntityClass];                      IIndexShardingStrategy shardingStrategy = documentBuilder.DirectoryProvidersSelectionStrategy;                      if (work is PurgeAllLuceneWork)                      {                          IDirectoryProvider[] providers = shardingStrategy.GetDirectoryProvidersForDeletion(work.EntityClass' work.Id' work.IdInString);                          foreach (IDirectoryProvider provider in providers)                          {                              queueWithFlatDPs.Add(new LuceneWorker.WorkWithPayload(work' provider));                          }                      }                      else if (work is AddLuceneWork)                      {                          IDirectoryProvider provider = shardingStrategy.GetDirectoryProviderForAddition(work.EntityClass' work.Id' work.IdInString' work.Document);                          queueWithFlatDPs.Add(new LuceneWorker.WorkWithPayload(work' provider));                      }                      else if (work is DeleteLuceneWork)                      {                          IDirectoryProvider[] providers = shardingStrategy.GetDirectoryProvidersForDeletion(work.EntityClass' work.Id' work.IdInString);                          foreach (IDirectoryProvider provider in providers)                          {                              queueWithFlatDPs.Add(new LuceneWorker.WorkWithPayload(work' provider));                          }                      }                      else if (work is OptimizeLuceneWork)                      {                          IDirectoryProvider[] providers = shardingStrategy.GetDirectoryProvidersForAllShards();                          foreach (IDirectoryProvider provider in providers)                          {                              queueWithFlatDPs.Add(new LuceneWorker.WorkWithPayload(work' provider));                          }                      }                      else                      {                          throw new AssertionFailure("Unknown work type: " + work.GetType());                      }                  }                    DeadLockFreeQueue(queueWithFlatDPs);                  CheckForBatchIndexing(workspace);                  foreach (LuceneWorker.WorkWithPayload luceneWork in queueWithFlatDPs)                  {                      worker.PerformWork(luceneWork);                  }              }              finally              {                  workspace.Dispose();                  queue.Clear();              }
Magic Number,NHibernate.Search.Backend.Impl.Lucene,LuceneBackendQueueProcessor,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Backend\Impl\Lucene\LuceneBackendQueueProcessor.cs,GetWorkHashCode,The following statement contains a magic number: h = (31 * h) + provider.GetHashCode();
Magic Number,NHibernate.Search.Backend.Impl.Lucene,LuceneBackendQueueProcessor,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Backend\Impl\Lucene\LuceneBackendQueueProcessor.cs,GetWorkHashCode,The following statement contains a magic number: if (luceneWork.Work is OptimizeLuceneWork)              {                  extendedHash += 2; // optimize after everything              }
Magic Number,NHibernate.Search.Reader,CacheableMultiReader,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Reader\CacheableMultiReader.cs,GetHashCode,The following statement contains a magic number: foreach (object reader in subReaders)              {                  result = 31*result + reader.GetHashCode();              }
Magic Number,NHibernate.Search.Store,FSDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSDirectoryProvider.cs,GetHashCode,The following statement contains a magic number: const int hash = 11;
Magic Number,NHibernate.Search.Store,FSDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSDirectoryProvider.cs,GetHashCode,The following statement contains a magic number: return 37*hash + indexName.GetHashCode();
Magic Number,NHibernate.Search.Store,FSMasterDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSMasterDirectoryProvider.cs,Start,The following statement contains a magic number: if (!long.TryParse(refreshPeriod' out period))              {                                  period = 3600;                  log.Warn("Error parsing refresh period' defaulting to 1 hour");              }
Magic Number,NHibernate.Search.Store,FSMasterDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSMasterDirectoryProvider.cs,Start,The following statement contains a magic number: period *= 1000;
Magic Number,NHibernate.Search.Store,FSMasterDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSMasterDirectoryProvider.cs,Start,The following statement contains a magic number: try              {                  // Copy to source                  if (File.Exists(Path.Combine(source' "current1")))                  {                      current = 2;                  }                  else if (File.Exists(Path.Combine(source' "current2")))                  {                      current = 1;                  }                  else                  {                      log.DebugFormat("Source directory for '{0}' will be initialized"' indexName);                      current = 1;                  }                    string currentString = current.ToString();                  DirectoryInfo subDir = new DirectoryInfo(Path.Combine(source' currentString));                  FileHelper.Synchronize(indexDir' subDir' true);                  File.Delete(Path.Combine(source' "current1"));                  File.Delete(Path.Combine(source' "current2"));                  log.Debug("Current directory: " + current);                                }              catch (IOException e)              {                  throw new HibernateException("Unable to initialize index: " + directoryProviderName' e);              }
Magic Number,NHibernate.Search.Store,FSMasterDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSMasterDirectoryProvider.cs,GetHashCode,The following statement contains a magic number: int hash = 11;
Magic Number,NHibernate.Search.Store,FSMasterDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSMasterDirectoryProvider.cs,GetHashCode,The following statement contains a magic number: return 37*hash + indexName.GetHashCode();
Magic Number,NHibernate.Search.Store,CopyDirectory,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSMasterDirectoryProvider.cs,Run,The following statement contains a magic number: try                  {                      lock (directoryProviderLock)                      {                          int oldIndex = parent.current;                          int index = parent.current == 1 ? 2 : 1;                          DirectoryInfo sourceFile = new DirectoryInfo(source);                          DirectoryInfo destinationFile = new DirectoryInfo(Path.Combine(destination' index.ToString()));                            // TODO make smart a parameter                          try                          {                              log.Info("Copying " + sourceFile + " into " + destinationFile);                              FileHelper.Synchronize(sourceFile' destinationFile' true);                              parent.current = index;                          }                          catch (IOException e)                          {                              // Don't change current                              log.Error("Unable to synchronize source of " + parent.indexName' e);                              return;                          }                            try                          {                              File.Delete(Path.Combine(destination' "current" + oldIndex));                          }                          catch (IOException e)                          {                              log.Warn("Unable to remove previous marker file from source of " + parent.indexName' e);                          }                            try                          {                              File.Create(Path.Combine(destination' "current" + index)).Dispose();                          }                          catch (IOException e)                          {                              log.Warn("Unable to create current marker in source of " + parent.indexName' e);                          }                      }                  }                  finally                  {                      inProgress = false;                  }
Magic Number,NHibernate.Search.Store,CopyDirectory,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSMasterDirectoryProvider.cs,Run,The following statement contains a magic number: try                  {                      inProgress = true;                      int oldIndex = parent.current;                      int index = parent.current == 1 ? 2 : 1;                      DirectoryInfo sourceFile;                      string current1Slave = Path.Combine(source' "current1");                      string current2Slave = Path.Combine(source' "current2");                      if (File.Exists(current1Slave))                      {                          sourceFile = new DirectoryInfo(Path.Combine(source' "1"));                      }                      else if (File.Exists(current2Slave))                      {                          sourceFile = new DirectoryInfo(Path.Combine(source' "2"));                      }                      else                      {                          log.Warn("Unable to determine current in source directory");                          inProgress = false;                          return;                      }                        DirectoryInfo destinationFile = new DirectoryInfo(Path.Combine(destination' index.ToString()));                        // TODO make smart a parameter                      try                      {                          log.Info("Copying " + sourceFile + " into " + destinationFile);                          FileHelper.Synchronize(sourceFile' destinationFile' true);                          parent.current = index;                      }                      catch (IOException e)                      {                          //don't change current                          log.Error("Unable to synchronize " + parent.indexName' e);                          inProgress = false;                          return;                      }                        try                      {                          File.Delete(Path.Combine(parent.indexName' "current" + oldIndex));                      }                      catch (Exception e)                      {                          log.Warn("Unable to remove previous marker file in " + parent.indexName' e);                      }                        try                      {                          File.Create(Path.Combine(parent.indexName' "current" + index)).Dispose();                      }                      catch (IOException e)                      {                          log.Warn("Unable to create current marker file in " + parent.indexName' e);                      }                  }                  finally                  {                      inProgress = false;                  }
Magic Number,NHibernate.Search.Store,FSSlaveDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSSlaveDirectoryProvider.cs,Start,The following statement contains a magic number: if (!long.TryParse(refreshPeriod' out period))              {                  period = 3600;                  log.Warn("Error parsing refresh period' defaulting to 1 hour");              }
Magic Number,NHibernate.Search.Store,FSSlaveDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSSlaveDirectoryProvider.cs,Start,The following statement contains a magic number: period *= 1000;
Magic Number,NHibernate.Search.Store,FSSlaveDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSSlaveDirectoryProvider.cs,Start,The following statement contains a magic number: try              {                  bool create;                    DirectoryInfo subDir = new DirectoryInfo(Path.Combine(indexName' "1"));                  create = !IndexReader.IndexExists(subDir.FullName);                   directory1 = FSDirectory.GetDirectory(subDir.FullName' create);                  if (create)                  {                      log.DebugFormat("Initialize index: '{0}'"' subDir.FullName);                      IndexWriter iw1 = new IndexWriter(directory1' new StandardAnalyzer()' create);                      iw1.Close();                  }                    subDir = new DirectoryInfo(Path.Combine(indexName' "2"));                  create = !IndexReader.IndexExists(subDir.FullName);                   directory2 = FSDirectory.GetDirectory(subDir.FullName' create);                  if (create)                  {                      log.DebugFormat("Initialize index: '{0}'"' subDir.FullName);                      IndexWriter iw2 = new IndexWriter(directory2' new StandardAnalyzer()' create);                      iw2.Close();                  }                    string current1Marker = Path.Combine(indexName' "current1");                  string current2Marker = Path.Combine(indexName' "current2");                  if (File.Exists(current1Marker))                  {                      current = 1;                  }                  else if (File.Exists(current2Marker))                  {                      current = 2;                  }                  else                  {                      // no default                      log.Debug("Setting directory 1 as current");                      current = 1;                      DirectoryInfo srcDir = new DirectoryInfo(source);                      DirectoryInfo destDir = new DirectoryInfo(Path.Combine(indexName' current.ToString()));                      int sourceCurrent = -1;                      if (File.Exists(Path.Combine(srcDir.Name' "current1")))                      {                          sourceCurrent = 1;                      }                      else if (File.Exists(Path.Combine(srcDir.Name' "current2")))                      {                          sourceCurrent = 2;                      }                        if (sourceCurrent != -1)                      {                          try                          {                              FileHelper.Synchronize(                                      new DirectoryInfo(Path.Combine(source' sourceCurrent.ToString()))' destDir' true);                          }                          catch (IOException e)                          {                              throw new HibernateException("Umable to synchonize directory: " + indexName' e);                          }                      }                        try                      {                          File.Create(current1Marker).Dispose();                      }                      catch (IOException e)                      {                          throw new HibernateException("Unable to create the directory marker file: " + indexName' e);                      }                  }                  log.Debug("Current directory: " + current);              }              catch (IOException e)              {                  throw new HibernateException("Unable to initialize index: " + directoryProviderName' e);              }
Magic Number,NHibernate.Search.Store,FSSlaveDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSSlaveDirectoryProvider.cs,Start,The following statement contains a magic number: try              {                  bool create;                    DirectoryInfo subDir = new DirectoryInfo(Path.Combine(indexName' "1"));                  create = !IndexReader.IndexExists(subDir.FullName);                   directory1 = FSDirectory.GetDirectory(subDir.FullName' create);                  if (create)                  {                      log.DebugFormat("Initialize index: '{0}'"' subDir.FullName);                      IndexWriter iw1 = new IndexWriter(directory1' new StandardAnalyzer()' create);                      iw1.Close();                  }                    subDir = new DirectoryInfo(Path.Combine(indexName' "2"));                  create = !IndexReader.IndexExists(subDir.FullName);                   directory2 = FSDirectory.GetDirectory(subDir.FullName' create);                  if (create)                  {                      log.DebugFormat("Initialize index: '{0}'"' subDir.FullName);                      IndexWriter iw2 = new IndexWriter(directory2' new StandardAnalyzer()' create);                      iw2.Close();                  }                    string current1Marker = Path.Combine(indexName' "current1");                  string current2Marker = Path.Combine(indexName' "current2");                  if (File.Exists(current1Marker))                  {                      current = 1;                  }                  else if (File.Exists(current2Marker))                  {                      current = 2;                  }                  else                  {                      // no default                      log.Debug("Setting directory 1 as current");                      current = 1;                      DirectoryInfo srcDir = new DirectoryInfo(source);                      DirectoryInfo destDir = new DirectoryInfo(Path.Combine(indexName' current.ToString()));                      int sourceCurrent = -1;                      if (File.Exists(Path.Combine(srcDir.Name' "current1")))                      {                          sourceCurrent = 1;                      }                      else if (File.Exists(Path.Combine(srcDir.Name' "current2")))                      {                          sourceCurrent = 2;                      }                        if (sourceCurrent != -1)                      {                          try                          {                              FileHelper.Synchronize(                                      new DirectoryInfo(Path.Combine(source' sourceCurrent.ToString()))' destDir' true);                          }                          catch (IOException e)                          {                              throw new HibernateException("Umable to synchonize directory: " + indexName' e);                          }                      }                        try                      {                          File.Create(current1Marker).Dispose();                      }                      catch (IOException e)                      {                          throw new HibernateException("Unable to create the directory marker file: " + indexName' e);                      }                  }                  log.Debug("Current directory: " + current);              }              catch (IOException e)              {                  throw new HibernateException("Unable to initialize index: " + directoryProviderName' e);              }
Magic Number,NHibernate.Search.Store,FSSlaveDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSSlaveDirectoryProvider.cs,GetHashCode,The following statement contains a magic number: const int hash = 11;
Magic Number,NHibernate.Search.Store,FSSlaveDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\FSSlaveDirectoryProvider.cs,GetHashCode,The following statement contains a magic number: return 37*hash + indexName.GetHashCode();
Magic Number,NHibernate.Search.Store,IdHashShardingStrategy,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\IdHashShardingStrategy.cs,HashKey,The following statement contains a magic number: foreach (char c in key)              {                  hash = (31 * hash) + c;              }
Magic Number,NHibernate.Search.Store,RAMDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\RAMDirectoryProvider.cs,GetHashCode,The following statement contains a magic number: int hash = 7;
Magic Number,NHibernate.Search.Store,RAMDirectoryProvider,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Store\RAMDirectoryProvider.cs,GetHashCode,The following statement contains a magic number: return 29*hash + indexName.GetHashCode();
Missing Default,NHibernate.Search.Engine,DocumentExtractor,C:\repos\nhibernate_NHibernate-Search\src\NHibernate.Search\Engine\DocumentExtractor.cs,Extract,The following switch statement is missing a default case: switch (projection[x])                      {                          case ProjectionConstants.SCORE:                              eip[x] = hits.Score(index);                              break;                            case ProjectionConstants.ID:                              eip[x] = entityInfo.Id;                              break;                            case ProjectionConstants.DOCUMENT:                              eip[x] = doc;                              break;                            case ProjectionConstants.DOCUMENT_ID:                              eip[x] = hits.Id(index);                              break;                            case ProjectionConstants.BOOST:                              eip[x] = doc.GetBoost();                              break;                            case ProjectionConstants.THIS:                              //THIS could be projected more than once                              //THIS loading delayed to the Loader phase                              if (entityInfo.IndexesOfThis == null)                              {                                  entityInfo.IndexesOfThis = new List<int>(1);                              }                              entityInfo.IndexesOfThis.Add(x);                              break;                      }
