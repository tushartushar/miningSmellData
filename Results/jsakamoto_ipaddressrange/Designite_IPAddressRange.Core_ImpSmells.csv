Implementation smell,Namespace,Class,File,Method,Description
Long Statement,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMask,The length of the statement  "            if (bitsLen > 0) maskBytes[bytesLen] = (byte)~Enumerable.Range(1' 8 - bitsLen).Select(n => 1 << n - 1).Aggregate((a' b) => a | b); " is 130.
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMask,The following statement contains a magic number: var bytesLen = bitLen / 8;
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMask,The following statement contains a magic number: var bitsLen = bitLen % 8;
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMask,The following statement contains a magic number: if (bitsLen > 0) maskBytes[bytesLen] = (byte)~Enumerable.Range(1' 8 - bitsLen).Select(n => 1 << n - 1).Aggregate((a' b) => a | b);
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: bitLength = 8 * idx;
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: if (idx < bytes.Length)              {                  switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }                  // remainder must be 0x00                  if (bytes.Skip(idx + 1).Any(x => x != 0x00)) return null;              }
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: if (idx < bytes.Length)              {                  switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }                  // remainder must be 0x00                  if (bytes.Skip(idx + 1).Any(x => x != 0x00)) return null;              }
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: if (idx < bytes.Length)              {                  switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }                  // remainder must be 0x00                  if (bytes.Skip(idx + 1).Any(x => x != 0x00)) return null;              }
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: if (idx < bytes.Length)              {                  switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }                  // remainder must be 0x00                  if (bytes.Skip(idx + 1).Any(x => x != 0x00)) return null;              }
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: if (idx < bytes.Length)              {                  switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }                  // remainder must be 0x00                  if (bytes.Skip(idx + 1).Any(x => x != 0x00)) return null;              }
Magic Number,NetTools,Bits,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: if (idx < bytes.Length)              {                  switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }                  // remainder must be 0x00                  if (bytes.Skip(idx + 1).Any(x => x != 0x00)) return null;              }
Magic Number,NetTools,IPAddressRange,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,IPAddressRange,The following statement contains a magic number: if (baseAdrBytes.Length * 8 < maskLength) throw new FormatException();
Magic Number,NetTools,IPAddressRange,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,Parse,The following statement contains a magic number: if (m1.Success)              {                  var baseAdrBytes = IPAddress.Parse(stripScopeId(m1.Groups["adr"].Value)).GetAddressBytes();                  var maskLen = int.Parse(m1.Groups["maskLen"].Value);                  if (baseAdrBytes.Length * 8 < maskLen) throw new FormatException();                  var maskBytes = Bits.GetBitMask(baseAdrBytes.Length' maskLen);                  baseAdrBytes = Bits.And(baseAdrBytes' maskBytes);                  return new IPAddressRange(new IPAddress(baseAdrBytes)' new IPAddress(Bits.Or(baseAdrBytes' Bits.Not(maskBytes))));              }
Magic Number,NetTools,IPAddressRange,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,GetPrefixLength,The following statement contains a magic number: if (Begin.Equals(End))              {                  return byteBegin.Length * 8;              }
Magic Number,NetTools,IPAddressRange,C:\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,GetPrefixLength,The following statement contains a magic number: int length = byteBegin.Length * 8;
