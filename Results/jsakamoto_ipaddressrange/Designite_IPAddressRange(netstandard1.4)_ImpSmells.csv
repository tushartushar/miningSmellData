Implementation smell,Namespace,Class,File,Method,Description
Complex Method,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,Cyclomatic complexity of the method is 13
Complex Method,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,Parse,Cyclomatic complexity of the method is 9
Long Statement,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,LtE,The length of the statement  "            if (A.Length <= offset || B.Length <= offset) throw new ArgumentException("offset must be less than length of A and B."' nameof(offset)); " is 137.
Long Statement,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GtE,The length of the statement  "            if (A.Length <= offset || B.Length <= offset) throw new ArgumentException("offset must be less than length of A and B."' nameof(offset)); " is 137.
Long Statement,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMask,The length of the statement  "            if (bitsLen > 0) maskBytes[bytesLen] = (byte)~Enumerable.Range(1' 8 - bitsLen).Select(n => 1 << n - 1).Aggregate((a' b) => a | b); " is 130.
Long Statement,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,Contains,The length of the statement  "            return Bits.LtECore(this.Begin.GetAddressBytes()' adrBytes' offset) && Bits.GtECore(this.End.GetAddressBytes()' adrBytes' offset); " is 130.
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMask,The following statement contains a magic number: var bytesLen = bitLen / 8;
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMask,The following statement contains a magic number: var bitsLen = bitLen % 8;
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMask,The following statement contains a magic number: maskBytes[bytesLen] = (byte)~Enumerable.Range(1' 8 - bitsLen).Select(n => 1 << n - 1).Aggregate((a' b) => a | b);
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: bitLength = 8 * idx;
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }
Magic Number,NetTools,Bits,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\Bits.cs,GetBitMaskLength,The following statement contains a magic number: switch (bytes[idx])                  {                      case 0xFE: bitLength += 7; break;                      case 0xFC: bitLength += 6; break;                      case 0xF8: bitLength += 5; break;                      case 0xF0: bitLength += 4; break;                      case 0xE0: bitLength += 3; break;                      case 0xC0: bitLength += 2; break;                      case 0x80: bitLength += 1; break;                      case 0x00: break;                      default: // invalid bitmask                          return null;                  }
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,IPAddressRange,The following statement contains a magic number: baseAdrBytes.Length * 8 < maskLength
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,Contains,The following statement contains a magic number: offset = 12;
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,Contains,The following statement contains a magic number: offset = 12;
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,Parse,The following statement contains a magic number: baseAdrBytes.Length * 8 < maskLen
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,ValidateSubnetMaskIsLinear,The following statement contains a magic number: b < 8
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,GetHashCode,The following statement contains a magic number: var hashCode = 1903003160;
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,GetHashCode,The following statement contains a magic number: hashCode = hashCode * -1521134295 + EqualityComparer<IPAddress>.Default.GetHashCode(Begin);
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,GetHashCode,The following statement contains a magic number: hashCode = hashCode * -1521134295 + EqualityComparer<IPAddress>.Default.GetHashCode(End);
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,GetPrefixLength,The following statement contains a magic number: return byteBegin.Length * 8;
Magic Number,NetTools,IPAddressRange,D:\research\architectureSmells\repos\jsakamoto_ipaddressrange\IPAddressRange\IPAddressRange.cs,GetPrefixLength,The following statement contains a magic number: int length = byteBegin.Length * 8;
