Implementation smell,Namespace,Class,File,Method,Description
Long Method,Poderosa.Terminal,ISO2022CharDecoder,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CharDecoder.cs,ProcessByte,The method has 126 lines of code.
Long Method,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The method has 109 lines of code.
Long Method,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The method has 100 lines of code.
Long Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The method has 182 lines of code.
Long Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The method has 150 lines of code.
Long Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The method has 116 lines of code.
Long Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessDECSET,The method has 107 lines of code.
Complex Method,Poderosa.Terminal,ISO2022CharDecoder,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CharDecoder.cs,ProcessByte,Cyclomatic complexity of the method is 27
Complex Method,Poderosa.Terminal,EncodingProfile,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,Poderosa.Terminal,UTF8ProfileBase,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,Cyclomatic complexity of the method is 8
Complex Method,Poderosa.Terminal,IntelliSenseContext,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,BuildCandidates,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,IntelliSenseWindow,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,DoChar,Cyclomatic complexity of the method is 8
Complex Method,Poderosa.Terminal,IntelliSenseWindow,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,CheckCharQueue,Cyclomatic complexity of the method is 8
Complex Method,Poderosa.Terminal,IntelliSenseBox,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,ProcessCmdKey,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,LogUtil,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,CheckLogFileName,Cyclomatic complexity of the method is 8
Complex Method,Poderosa.Terminal,GenericShellScheme,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\ShellScheme.cs,FormatCommandList,Cyclomatic complexity of the method is 8
Complex Method,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,OnReception,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,EscapeSequenceTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessChar,Cyclomatic complexity of the method is 13
Complex Method,Poderosa.Terminal,EscapeSequenceTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessControlChar,Cyclomatic complexity of the method is 16
Complex Method,Poderosa.Terminal,TerminalDocument,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalDocument.cs,Remove,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,CustomKeySettings,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,Reset,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessDialogKey,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessScrollKey,Cyclomatic complexity of the method is 8
Complex Method,Poderosa.Terminal,MouseTrackingHandler,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnMouseMove,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,TerminalSettingsSerializer,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalSettingsSerialize.cs,Serialize,Cyclomatic complexity of the method is 8
Complex Method,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessEscapeSequence,Cyclomatic complexity of the method is 12
Complex Method,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessAfterCSI,Cyclomatic complexity of the method is 15
Complex Method,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,Cyclomatic complexity of the method is 23
Complex Method,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,Cyclomatic complexity of the method is 16
Complex Method,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,Cyclomatic complexity of the method is 31
Complex Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,Cyclomatic complexity of the method is 36
Complex Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessEscapeSequence,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterCSI,Cyclomatic complexity of the method is 16
Complex Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,Cyclomatic complexity of the method is 23
Complex Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,Cyclomatic complexity of the method is 23
Complex Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessDECSET,Cyclomatic complexity of the method is 29
Complex Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,SequenceKeyData,Cyclomatic complexity of the method is 10
Complex Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,XtermFunctionKey,Cyclomatic complexity of the method is 16
Complex Method,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,Cyclomatic complexity of the method is 10
Long Parameter List,Poderosa.Terminal,CJKByteProcessor,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CharDecoder.cs,CJKByteProcessor,The method has 5 parameters. Parameters: processor' buffer' encoding' leadingBytes' trailingBytes
Long Parameter List,Poderosa.Terminal,IntelliSenseContext,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,Init,The method has 5 parameters. Parameters: terminal' scheme' current_input' mode' append_char
Long Parameter List,Poderosa.Terminal,PromptRecognizer,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\PromptRecognizer.cs,DeterminePromptLine,The method has 5 parameters. Parameters: line' limitLineID' limitColumn' prompt' command
Long Parameter List,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessMouse,The method has 5 parameters. Parameters: action' button' modifierKeys' row' col
Long Parameter List,Poderosa.Terminal,TerminalCommand,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,TerminalCommand,The method has 5 parameters. Parameters: id' description' category' body' enabled
Long Parameter List,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The method has 5 parameters. Parameters: action' button' modKeys' row' col
Long Identifier,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,,The length of the parameter _enableComplementForNewConnections is 34.
Long Identifier,Poderosa.Terminal,PromptRecognizerPreferences,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\PromptRecognizer.cs,,The length of the parameter DEFAULT_PROMPT_SEARCH_MAX_LINES is 31.
Long Identifier,Poderosa.Terminal,TerminalCommand,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,,The length of the parameter _doesExistCharacterDocumentViewer is 33.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter TERMINAL_CONTEXT_MENU_EXTENSIONPOINT is 36.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter DOCUMENT_CONTEXT_MENU_EXTENSIONPOINT is 36.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter TERMINALSPECIAL_EXTENSIONPOINT is 30.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter INTELLISENSE_CANDIDATE_EXTENSIONPOINT is 37.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter LOG_FILENAME_FORMATTER_EXTENSIONPOINT is 37.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter DYNAMIC_CAPTION_FORMATTER_EXTENSIONPOINT is 40.
Long Identifier,Poderosa.Terminal,TerminalSettings,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalSettings.cs,,The length of the parameter _enabledCharTriggerIntelliSense is 31.
Long Identifier,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,,The length of the parameter _bracketedPasteModeLeadingBytes is 31.
Long Identifier,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,,The length of the parameter _bracketedPasteModeTrailingBytes is 32.
Long Statement,Poderosa.Terminal,CommandResultRecognizer,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,ProcessCommandResult,The length of the statement  "                Debug.WriteLineIf(DebugOpt.CommandPopup' String.Format("Ignored for 0-length' start={0} end={1}"' _commandStartLineID' end_line_id)); " is 133.
Long Statement,Poderosa.Terminal,PopupStyleCommandResultRecognizer,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,CreateExtensionPointAndDefaultCommands,The length of the statement  "            IExtensionPoint pt = pm.CreateExtensionPoint(POPUP_MENU_EXTENSION_POINT' typeof(ICommandResultProcessorMenuItem)' TerminalEmulatorPlugin.Instance); " is 147.
Long Statement,Poderosa.Terminal,PopupStyleCommandResultRecognizer,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,ProcessKey,The length of the statement  "            if (_state == State.Prompt && _lastCommand.Length > 0 && TerminalEmulatorPlugin.Instance.TerminalEmulatorOptions.CommandPopupKey == (modifiers | keybody)) { " is 156.
Long Statement,Poderosa.Terminal,PopupStyleCommandResultRecognizer,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,ShowMenu,The length of the statement  "            Point popup = new Point((int)(doc.CaretColumn * pitch.Width)' (int)((doc.CurrentLineNumber - doc.TopLineNumber + 1) * pitch.Height)); " is 133.
Long Statement,Poderosa.Terminal,PopupStyleCommandResultRecognizer,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,CreatePopupMenuItems,The length of the statement  "            foreach (ICommandResultProcessorMenuItem item in TerminalEmulatorPlugin.Instance.PoderosaWorld.PluginManager.FindExtensionPoint(POPUP_MENU_EXTENSION_POINT).GetExtensions()) { " is 174.
Long Statement,Poderosa.Terminal,CommandResultSession,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopupSession.cs,SessionEntryPoint,The length of the statement  "                cp.InitialSize = new Size(tc.ClientSize.Width' (int)(RuntimeUtil.AdjustIntRange(document.Size' 0' 20) * rp.Pitch.Height) + 2); " is 126.
Long Statement,Poderosa.Terminal,IntelliSense,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,TryParseMultiLineCommand,The length of the statement  "                if (_terminal.PromptRecognizer.DeterminePromptLine(command_start_candidate' current.ID' current.DisplayLength' out prompt' out command)) { " is 138.
Long Statement,Poderosa.Terminal,IntelliSense,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,PopupMain,The length of the statement  "            IntelliSenseMode mode = line.Length == 0 || ss.IsDelimiter(line[line.Length - 1]) ? IntelliSenseMode.ArgComplement : IntelliSenseMode.CharComplement; " is 149.
Long Statement,Poderosa.Terminal,IntelliSenseContext,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,Init,The length of the statement  "            _commandStartPoint = new Point(doc.CaretColumn + (append_char == '\0' ? 0 : 1)' doc.CurrentLineNumber - doc.TopLineNumber); " is 123.
Long Statement,Poderosa.Terminal,IntelliSenseContext,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,Init,The length of the statement  "            Debug.WriteLineIf(DebugOpt.IntelliSense' String.Format("IS CtxInit M={0} CaretC={1}"' mode.ToString()' doc.CaretColumn)); " is 121.
Long Statement,Poderosa.Terminal,IntelliSenseContext,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,BuildCandidates,The length of the statement  "            IntelliSenseItemCollection col = (IntelliSenseItemCollection)_scheme.CommandHistory.GetAdapter(typeof(IntelliSenseItemCollection)); " is 131.
Long Statement,Poderosa.Terminal,IntelliSenseContext,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,BuildCandidates,The length of the statement  "                else if (_intelliSenseMode == IntelliSenseMode.CharComplement && r == IntelliSenseItem.MatchForwardResult.PartialChar) { " is 120.
Long Statement,Poderosa.Terminal,IntelliSenseWindow,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,DoSpecialKey,The length of the statement  "                _context.SortStyle = _context.SortStyle == IntelliSenseSort.Alphabet ? IntelliSenseSort.Historical : IntelliSenseSort.Alphabet; " is 127.
Long Statement,Poderosa.Terminal,IntelliSenseWindow,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,DoSpecialKey,The length of the statement  "                IntelliSenseItemCollection col = (IntelliSenseItemCollection)_context.CurrentScheme.CommandHistory.GetAdapter(typeof(IntelliSenseItemCollection)); " is 146.
Long Statement,Poderosa.Terminal,LogService,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,ApplySimpleLogSetting,The length of the statement  "            FileStream fs = new FileStream(sl.LogPath' sl.LogAppend ? FileMode.Append : FileMode.Create' FileAccess.Write' FileShare.Read); " is 127.
Long Statement,Poderosa.Terminal,LogService,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,CreateAutoLogFileName,The length of the statement  "                filebody = String.Format("{0}\\{1}_{2}{3'2:D2}{4'2:D2}"' opt.DefaultLogDirectory' ReplaceCharForLogFile(settings.Caption)' now.Year' now.Month' now.Day); " is 153.
Long Statement,Poderosa.Terminal,LogService,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,ReplaceCharForLogFile,The length of the statement  "                if (ch == '\\' || ch == '/' || ch == ':' || ch == ';' || ch == ''' || ch == '*' || ch == '?' || ch == '"' || ch == '<' || ch == '>' || ch == '|') " is 145.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _fontSize = builder.DefineIntValue(_folder' "fontSize"' 10' PreferenceValidatorUtil.PositiveIntegerValidator); //floatにすべきかなあ " is 125.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _textColor = new ColorPreferenceItem(builder.DefineStringValue(_folder' "textColor"' "WindowText"' null)' KnownColor.WindowText); " is 129.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _imageStyle = new EnumPreferenceItem<ImageStyle>(builder.DefineStringValue(_folder' "imageStyle"' "Center"' null)' ImageStyle.Center); " is 134.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _caretType = new EnumPreferenceItem<CaretType>(builder.DefineStringValue(_folder' "caretType"' "Box"' null)' CaretType.Box); " is 124.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _charDecodeErrorBehavior = new EnumPreferenceItem<WarningOption>(builder.DefineStringValue(_folder' "charDecodeErrorBehavior"' "MessageBox"' null)' WarningOption.MessageBox); " is 174.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _disconnectNotification = new EnumPreferenceItem<WarningOption>(builder.DefineStringValue(_folder' "disconnectNotification"' "StatusBar"' null)' WarningOption.StatusBar); " is 170.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _enableComplementForNewConnections = builder.DefineBoolValue(_folder' "enableComplementForNewConnections"' false' null); " is 120.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _terminalBufferSize = builder.DefineIntValue(_folder' "terminalBufferSize"' 1000' PreferenceValidatorUtil.PositiveIntegerValidator); " is 132.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _zone0x1F = new EnumPreferenceItem<KeyboardStyle>(builder.DefineStringValue(_folder' "zone0x1F"' "None"' null)' KeyboardStyle.None); " is 132.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _keepAliveInterval = builder.DefineIntValue(_folder' "keepAliveInterval"' 60000' PreferenceValidatorUtil.IntRangeValidator(0' 100 * 60000)); " is 140.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _leftAltKey = new EnumPreferenceItem<AltKeyAction>(builder.DefineStringValue(_folder' "leftAltKey"' "Menu"' null)' AltKeyAction.Menu); " is 134.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _rightAltKey = new EnumPreferenceItem<AltKeyAction>(builder.DefineStringValue(_folder' "rightAltKey"' "Menu"' null)' AltKeyAction.Menu); " is 136.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _rightButtonAction = new EnumPreferenceItem<MouseButtonAction>(builder.DefineStringValue(_folder' "rightButtonAction"' "ContextMenu"' null)' MouseButtonAction.ContextMenu); " is 172.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _middleButtonAction = new EnumPreferenceItem<MouseButtonAction>(builder.DefineStringValue(_folder' "middleButtonAction"' "None"' null)' MouseButtonAction.None); " is 160.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _defaultLogType = new EnumPreferenceItem<LogType>(builder.DefineStringValue(_folder' "defaultLogType"' "None"' null)' LogType.None); " is 132.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _intelliSenseKey = builder.DefineStringValue(_folder' "intelliSenseKey"' "Ctrl+OemPeriod"' PreferenceValidatorUtil.KeyWithModifierValidator); " is 141.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _commandPopupKey = builder.DefineStringValue(_folder' "commandPopupKey"' "Ctrl+Oemcomma"' PreferenceValidatorUtil.KeyWithModifierValidator); " is 140.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _shellHistoryLimitCount = builder.DefineIntValue(_folder' "shellHistoryLimitCount"' 100' PreferenceValidatorUtil.PositiveIntegerValidator); " is 139.
Long Statement,Poderosa.Terminal,PromptRecognizer,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\PromptRecognizer.cs,Recognize,The length of the statement  "            if (!DeterminePromptLine(promptCandidate' doc.CurrentLine.ID' doc.CaretColumn' out prompt' out command)) { //プロンプトではないとき " is 120.
Long Statement,Poderosa.Terminal,PromptRecognizerPreferences,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\PromptRecognizer.cs,InitializePreference,The length of the statement  "            _promptSearchMaxLines = builder.DefineIntValue(folder' "promptSearchMaxLines"' DEFAULT_PROMPT_SEARCH_MAX_LINES' PreferenceValidatorUtil.PositiveIntegerValidator); " is 162.
Long Statement,Poderosa.Terminal,ShellSchemeCollection,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\ShellScheme.cs,InitializePreference,The length of the statement  "            _promptPreference = builder.DefineStringValue(_schemeTemplate' "prompt"' GenericShellScheme.DEFAULT_PROMPT_REGEX' null); " is 120.
Long Statement,Poderosa.Terminal,ShellSchemeCollection,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\ShellScheme.cs,PreClose,The length of the statement  "                    _preferenceFolderArray.ConvertItem(content' _backspacePreference).AsString().Value = ((int)ss.BackSpaceChar).ToString("X2"); " is 124.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,InvalidCharDetected,The length of the statement  "            CharDecodeError(String.Format(GEnv.Strings.GetString("Message.AbstractTerminal.UnexpectedChar")' _encodingProfile.Encoding.WebName)); " is 133.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,OnReception,The length of the statement  "                        //Debug.WriteLine(String.Format("E={0} C={1} T={2} H={3} LC={4} MAX={5} n={6}"' _transientScrollBarEnabled' _tag.Document.CurrentLineNumber' _tag.Document.TopLineNumber' _tag.Connection.TerminalHeight' _transientScrollBarLargeChange' _transientScrollBarMaximum' n)); " is 266.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,OnAbnormalTermination,The length of the statement  "            //TODO メッセージを GEnv.Strings.GetString("Message.TerminalDataReceiver.GenericError")'_tag.Connection.Param.ShortDescription' msg " is 125.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,Cleanup,The length of the statement  "            //NOTE _session.CloseByReceptionThread()は、そのままアプリ終了と直結する場合がある。すると、_logService.Close()の処理が終わらないうちに強制終了になってログが書ききれない可能性がある " is 120.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,CleanupCommon,The length of the statement  "                TerminalEmulatorPlugin.Instance.ShellSchemeCollection.RemoveDynamicChangeListener((IShellSchemeDynamicChangeListener)GetTerminalSettings().GetAdapter(typeof(IShellSchemeDynamicChangeListener))); " is 194.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,AdjustTransientScrollBar,The length of the statement  "            int docheight = Math.Max(document.LastLineNumber' document.TopLineNumber + paneheight - 1) - document.FirstLineNumber + 1; " is 122.
Long Statement,Poderosa.Terminal,EscapeSequenceTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessChar,The length of the statement  "                    RuntimeUtil.SilentReportException(new UnknownEscapeSequenceException("Incomplete escape sequence: ESC " + _escapeSequence.ToString())); " is 135.
Long Statement,Poderosa.Terminal,EscapeSequenceTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessChar,The length of the statement  "                    end_flag = ('0' <= ch && ch <= '9') || ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z' && ch != 'P') || ch == '>' || ch == '=' || ch == '|' || ch == '}' || ch == '~'; " is 170.
Long Statement,Poderosa.Terminal,EscapeSequenceTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,DoLineFeed,The length of the statement  "            _manipulator.EOLType = (_manipulator.EOLType == EOLType.CR || _manipulator.EOLType == EOLType.CRLF) ? EOLType.CRLF : EOLType.LF; " is 128.
Long Statement,Poderosa.Terminal,TerminalCommand,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,Register,The length of the statement  "                "Command.SelectAll"' _terminalEdit' new ExecuteDelegate(CmdSelectAll)' TerminalCommand.DoesExistCharacterDocumentViewer)); " is 122.
Long Statement,Poderosa.Terminal,TerminalCommand,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,Register,The length of the statement  "            //cm.Register(new TerminalCommand("org.poderosa.terminalemulator.reproduce"' new ExecuteDelegate(CmdReproduce)' new EnabledDelegate(DoesOpenTargetSession))); " is 157.
Long Statement,Poderosa.Terminal,TerminalSettingMenuGroup,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,GetTerminalSpecialMenuGroups,The length of the statement  "            return (IPoderosaMenuGroup[])TerminalEmulatorPlugin.Instance.PoderosaWorld.PluginManager.FindExtensionPoint(TerminalEmulatorConstants.TERMINALSPECIAL_EXTENSIONPOINT).GetExtensions(); " is 182.
Long Statement,Poderosa.Terminal,TerminalSettingMenuGroup,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,Initialize,The length of the statement  "            IExtensionPoint p = TerminalEmulatorPlugin.Instance.PoderosaWorld.PluginManager.CreateExtensionPoint(TerminalEmulatorConstants.TERMINALSPECIAL_EXTENSIONPOINT' typeof(IPoderosaMenuGroup)' TerminalEmulatorPlugin.Instance); " is 220.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _contextMenu = pm.CreateExtensionPoint(TerminalEmulatorConstants.TERMINAL_CONTEXT_MENU_EXTENSIONPOINT' typeof(IPoderosaMenuGroup)' this); " is 137.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _documentContextMenu = pm.CreateExtensionPoint(TerminalEmulatorConstants.DOCUMENT_CONTEXT_MENU_EXTENSIONPOINT' typeof(IPoderosaMenuGroup)' this); " is 145.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _intelliSenseExtension = pm.CreateExtensionPoint(TerminalEmulatorConstants.INTELLISENSE_CANDIDATE_EXTENSIONPOINT' typeof(IIntelliSenseCandidateExtension)' this); " is 161.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _autoLogFileFormatter = pm.CreateExtensionPoint(TerminalEmulatorConstants.LOG_FILENAME_FORMATTER_EXTENSIONPOINT' typeof(IAutoLogFileFormatter)' this); " is 150.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _dynamicCaptionFormatter = pm.CreateExtensionPoint(TerminalEmulatorConstants.DYNAMIC_CAPTION_FORMATTER_EXTENSIONPOINT' typeof(IDynamicCaptionFormatter)' this); " is 159.
Long Statement,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,MakeCurrentLineVisible,The length of the statement  "            else if (_VScrollBar.Value + document.TerminalHeight <= document.CurrentLineNumber - document.FirstLineNumber) { //下に隠れた " is 120.
Long Statement,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnResize,The length of the statement  "            //Debug.WriteLine(String.Format("TC RESIZE {0} {1} {2}'{3}"' _resizeCount++' DateTime.Now.ToString()' this.Size.Width' this.Size.Height)); " is 138.
Long Statement,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnResize,The length of the statement  "            if (this.DesignMode || this.FindForm() == null || this.FindForm().WindowState == FormWindowState.Minimized || _session == null) " is 127.
Long Statement,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,CalcTerminalSize,The length of the statement  "            int width = (int)Math.Floor((float)(this.ClientSize.Width - sm.ScrollBarWidth - CharacterDocumentViewer.BORDER * 2) / charPitch.Width); " is 135.
Long Statement,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,CalcTerminalSize,The length of the statement  "            int height = (int)Math.Floor((float)(this.ClientSize.Height - CharacterDocumentViewer.BORDER * 2 + prof.LineSpacing) / (charPitch.Height + prof.LineSpacing)); " is 158.
Long Statement,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,AdjustIMEComposition,The length of the statement  "            //Debug.WriteLine(String.Format("{0} {1} {2}"' document.CaretColumn' charwidth' document.CurrentLine.CharPosToDisplayPos(document.CaretColumn))); " is 145.
Long Statement,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,AdjustIMEComposition,The length of the statement  "            form.ptCurrentPos.y = sm.ControlBorderHeight + (int)((prof.Pitch.Height + prof.LineSpacing) * (document.CurrentLineNumber - document.TopLineNumber)); " is 149.
Long Statement,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnGotFocus,The length of the statement  "                TerminalEmulatorPlugin.Instance.GetSessionManager().ActivateDocument(this.CharacterDocument' ActivateReason.ViewGotFocus); " is 122.
Long Statement,Poderosa.Terminal,TerminalEmulatorMouseHandler,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnMouseUp,The length of the statement  "                        TerminalEmulatorPlugin.Instance.GetCommandManager().Execute(vc.Paste' (ICommandTarget)vc.GetAdapter(typeof(ICommandTarget))); " is 125.
Long Statement,Poderosa.Terminal,TerminalEmulatorMouseHandler,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ShowContextMenu,The length of the statement  "            view.ParentForm.ShowContextMenu(TerminalEmulatorPlugin.Instance.ContextMenu' view' _control.PointToScreen(pt)' ContextMenuFlags.None); " is 134.
Long Statement,Poderosa.Terminal,DrawingPerformance,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,Output,The length of the statement  "            Debug.WriteLine(String.Format("FullInvalidate:{0} PartialInvalidate:{1} 1-Line:{2} AvgLine:{3:F2}"' _fullInvalidateCount' _partialInvalidateCount' _invalidate1LineCount' (double)_totalInvalidatedLineCount / _partialInvalidateCount)); " is 233.
Long Statement,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessDeviceStatusReport,The length of the statement  "                response = String.Format(" [{0};{1}R"' GetDocument().CurrentLineNumber - GetDocument().TopLineNumber + 1' _manipulator.CaretColumn + 1); " is 136.
Long Statement,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,Index,The length of the statement  "            if (current == GetDocument().TopLineNumber + GetDocument().TerminalHeight - 1 || current == GetDocument().ScrollingBottom) " is 122.
Long Statement,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ChangeMode,The length of the statement  "                GetConnection().TerminalOutput.Resize(GetDocument().TerminalWidth' GetDocument().TerminalHeight); //たとえばemacs起動中にリサイズし、シェルへ戻るとシェルは新しいサイズを認識していない " is 144.
Long Statement,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The length of the statement  "            MouseTrackingState currentState = _mouseTrackingState;  // copy value because _mouseTrackingState may be changed in another thread. " is 131.
Long Statement,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The length of the statement  "            MouseTrackingProtocol protocol = _mouseTrackingProtocol; // copy value because _mouseTrackingProtocol may be changed in another thread. " is 135.
Long Statement,Poderosa.Terminal,XTermPreferences,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,InitializePreference,The length of the statement  "            _modifyCursorKeys = builder.DefineIntValue(folder' "modifyCursorKeys"' DEFAULT_MODIFY_CURSOR_KEYS' PreferenceValidatorUtil.PositiveIntegerValidator); " is 149.
Long Statement,Poderosa,GUtil,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Util.cs,Warning,The length of the statement  "            MessageBox.Show(owner' msg' GEnv.Strings.GetString("Common.MessageBoxTitle")' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 128.
Long Statement,Poderosa,GUtil,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Util.cs,AskUserYesNo,The length of the statement  "            return MessageBox.Show(owner' msg' GEnv.Strings.GetString("Common.MessageBoxTitle")' MessageBoxButtons.YesNo' MessageBoxIcon.Question); " is 135.
Complex Conditional,Poderosa.Terminal,LogService,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,ReplaceCharForLogFile,The conditional expression  "ch == '\\' || ch == '/' || ch == ':' || ch == ';' || ch == ''' || ch == '*' || ch == '?' || ch == '"' || ch == '<' || ch == '>' || ch == '|'"  is complex.
Complex Conditional,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnResize,The conditional expression  "this.DesignMode || this.FindForm() == null || this.FindForm().WindowState == FormWindowState.Minimized || _session == null"  is complex.
Complex Conditional,Poderosa.Terminal,TerminalSettings,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalSettings.cs,TerminalSettings,The conditional expression  "culture.IsJapaneseOS || culture.IsSimplifiedChineseOS || culture.IsTraditionalChineseOS || culture.IsKoreanOS"  is complex.
Complex Conditional,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The conditional expression  "vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)"  is complex.
Magic Number,Poderosa.Terminal,CommandResultProcessorBase,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,AsyncResultQuickHack,The following statement contains a magic number: ar.AsyncWaitHandle.WaitOne(100' false)
Magic Number,Poderosa.Terminal,CommandResultSession,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopupSession.cs,SessionEntryPoint,The following statement contains a magic number: cp.InitialSize = new Size(tc.ClientSize.Width' (int)(RuntimeUtil.AdjustIntRange(document.Size' 0' 20) * rp.Pitch.Height) + 2);
Magic Number,Poderosa.Terminal,CommandResultSession,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopupSession.cs,SessionEntryPoint,The following statement contains a magic number: cp.InitialSize = new Size(tc.ClientSize.Width' (int)(RuntimeUtil.AdjustIntRange(document.Size' 0' 20) * rp.Pitch.Height) + 2);
Magic Number,Poderosa.Terminal,Decoder,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,Decoder,The following statement contains a magic number: _buffer = new byte[6];
Magic Number,Poderosa.Terminal,Encoder,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,Encoder,The following statement contains a magic number: _buff = new char[2];
Magic Number,Poderosa.Terminal,Encoder,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetBytes,The following statement contains a magic number: bytes = _profile.Encoding.GetBytes(_buff' 0' 2);
Magic Number,Poderosa.Terminal,ShiftJISProfile,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return (b >= 0xA1 && b <= 0xDF) ? 1 : 2;
Magic Number,Poderosa.Terminal,EUCJPProfile,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return b == 0x8F ? 3 : b >= 0x8E ? 2 : 1;
Magic Number,Poderosa.Terminal,EUCJPProfile,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return b == 0x8F ? 3 : b >= 0x8E ? 2 : 1;
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 2;
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 3;
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 4;
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 5;
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 6;
Magic Number,Poderosa.Terminal,GB2312Profile,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 2;
Magic Number,Poderosa.Terminal,Big5Profile,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 2;
Magic Number,Poderosa.Terminal,EUCCNProfile,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 2;
Magic Number,Poderosa.Terminal,EUCKRProfile,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 2;
Magic Number,Poderosa.Terminal,CharQueue,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,CharQueue,The following statement contains a magic number: _buffer = new char[80];
Magic Number,Poderosa.Terminal,IntelliSense,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,OnNotPromptLine,The following statement contains a magic number: ar.AsyncWaitHandle.WaitOne(100' false)
Magic Number,Poderosa.Terminal,IntelliSenseWindow,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,AdjustListBox,The following statement contains a magic number: _listBox.MaximumSize = new Size((int)(pitch.Width * 80)' (int)(pitch.Height * 10));
Magic Number,Poderosa.Terminal,IntelliSenseWindow,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,AdjustListBox,The following statement contains a magic number: _listBox.MaximumSize = new Size((int)(pitch.Width * 80)' (int)(pitch.Height * 10));
Magic Number,Poderosa.Terminal,IntelliSenseWindow,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,ToControlPoint,The following statement contains a magic number: int x = (int)(textPoint.X * pitch.Width) - 2;
Magic Number,Poderosa.Terminal,Entry,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\KeyFunction.cs,ParseData,The following statement contains a magic number: Int32.TryParse(s.Substring(c + 2' 2)' NumberStyles.HexNumber' null' out t)
Magic Number,Poderosa.Terminal,Entry,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\KeyFunction.cs,ParseData,The following statement contains a magic number: Int32.TryParse(s.Substring(c + 2' 2)' NumberStyles.HexNumber' null' out t)
Magic Number,Poderosa.Terminal,Entry,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\KeyFunction.cs,ParseData,The following statement contains a magic number: c += 4;
Magic Number,Poderosa.Terminal,Entry,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\KeyFunction.cs,ParseData,The following statement contains a magic number: ch == '0' && c + 3 <= s.Length && s[c + 1] == 'x'
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,DefaultLogger,The following statement contains a magic number: _timestampBuffer = new char[26];
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 4' dt.Year);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Month);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Day);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Hour);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Minute);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Second);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 3' dt.Millisecond);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteInt,The following statement contains a magic number: buff[--index] = (char)('0' + value % 10);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteInt,The following statement contains a magic number: value /= 10;
Magic Number,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _fontSize = builder.DefineIntValue(_folder' "fontSize"' 10' PreferenceValidatorUtil.PositiveIntegerValidator);
Magic Number,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _lineSpacing = builder.DefineIntValue(_folder' "lineSpacing"' 0' PreferenceValidatorUtil.IntRangeValidator(0' 10));
Magic Number,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _terminalBufferSize = builder.DefineIntValue(_folder' "terminalBufferSize"' 1000' PreferenceValidatorUtil.PositiveIntegerValidator);
Magic Number,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _keepAliveInterval = builder.DefineIntValue(_folder' "keepAliveInterval"' 60000' PreferenceValidatorUtil.IntRangeValidator(0' 100 * 60000));
Magic Number,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _keepAliveInterval = builder.DefineIntValue(_folder' "keepAliveInterval"' 60000' PreferenceValidatorUtil.IntRangeValidator(0' 100 * 60000));
Magic Number,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _keepAliveInterval = builder.DefineIntValue(_folder' "keepAliveInterval"' 60000' PreferenceValidatorUtil.IntRangeValidator(0' 100 * 60000));
Magic Number,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _wheelAmount = builder.DefineIntValue(_folder' "wheelAmount"' 3' PreferenceValidatorUtil.PositiveIntegerValidator);
Magic Number,Poderosa.Terminal,TerminalOptions,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _shellHistoryLimitCount = builder.DefineIntValue(_folder' "shellHistoryLimitCount"' 100' PreferenceValidatorUtil.PositiveIntegerValidator);
Magic Number,Poderosa.Terminal,GenericShellScheme,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\ShellScheme.cs,ParseCommandList,The following statement contains a magic number: cursor += 2;
Magic Number,Poderosa.Terminal,EscapeSequenceTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,GetNextTabStop,The following statement contains a magic number: t += (8 - t % 8);
Magic Number,Poderosa.Terminal,EscapeSequenceTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,GetNextTabStop,The following statement contains a magic number: t += (8 - t % 8);
Magic Number,Poderosa.Terminal,EscapeSequenceTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessNormalUnicodeChar,The following statement contains a magic number: _manipulator.CaretColumn + (unicodeChar.IsWideWidth ? 2 : 1) > tw
Magic Number,Poderosa.Terminal,EscapeSequenceTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ParseIntPair,The following statement contains a magic number: s.Length >= 2 && s[1].Length > 0
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,TerminalControl,The following statement contains a magic number: _sizeTipTimer.Interval = 2000;
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,InitializeComponent,The following statement contains a magic number: this._sizeTip.Size = new Size(64' 16);
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,InitializeComponent,The following statement contains a magic number: this._sizeTip.Size = new Size(64' 16);
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SmartInvalidate,The following statement contains a magic number: switch (_drawOptimizingState) {                  case 0:                      _drawOptimizingState = 1;                      InvalidateEx();                      break;                  case 1:                      if (_session.TerminalConnection.Socket.Available)                          Interlocked.Exchange(ref _drawOptimizingState' 2); //間引きモードへ                      else                          InvalidateEx();                      break;                  case 2:                      break; //do nothing              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SmartInvalidate,The following statement contains a magic number: switch (_drawOptimizingState) {                  case 0:                      _drawOptimizingState = 1;                      InvalidateEx();                      break;                  case 1:                      if (_session.TerminalConnection.Socket.Available)                          Interlocked.Exchange(ref _drawOptimizingState' 2); //間引きモードへ                      else                          InvalidateEx();                      break;                  case 2:                      break; //do nothing              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnWindowManagerTimer,The following statement contains a magic number: switch (_drawOptimizingState) {                  case 0:                      break; //do nothing                  case 1:                      Interlocked.CompareExchange(ref _drawOptimizingState' 0' 1);                      break;                  case 2: //忙しくても偶には描画                      _drawOptimizingState = 1;                      InvalidateEx();                      break;              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessSpecialAltKey,The following statement contains a magic number: ch = (char)((int)ch % 32);
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessSpecialAltKey,The following statement contains a magic number: byte[] t = new byte[2];
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,CalcTerminalSize,The following statement contains a magic number: int width = (int)Math.Floor((float)(this.ClientSize.Width - sm.ScrollBarWidth - CharacterDocumentViewer.BORDER * 2) / charPitch.Width);
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,CalcTerminalSize,The following statement contains a magic number: int height = (int)Math.Floor((float)(this.ClientSize.Height - CharacterDocumentViewer.BORDER * 2 + prof.LineSpacing) / (charPitch.Height + prof.LineSpacing));
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ShowSizeTip,The following statement contains a magic number: const int MARGIN = 8;
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SplitterDragging,The following statement contains a magic number: width = (int)Math.Floor(((float)width - sm.ScrollBarWidth - sm.ControlBorderWidth * 2) / charSize.Width);
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SplitterDragging,The following statement contains a magic number: height = (int)Math.Floor((float)(height - sm.ControlBorderHeight * 2) / charSize.Height);
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessVScrollMessage,The following statement contains a magic number: switch (cmd) {                  case 0: //SB_LINEUP                      newval--;                      break;                  case 1: //SB_LINEDOWN                      newval++;                      break;                  case 2: //SB_PAGEUP                      newval -= GetDocument().TerminalHeight;                      break;                  case 3: //SB_PAGEDOWN                      newval += GetDocument().TerminalHeight;                      break;              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessVScrollMessage,The following statement contains a magic number: switch (cmd) {                  case 0: //SB_LINEUP                      newval--;                      break;                  case 1: //SB_LINEDOWN                      newval++;                      break;                  case 2: //SB_PAGEUP                      newval -= GetDocument().TerminalHeight;                      break;                  case 3: //SB_PAGEDOWN                      newval += GetDocument().TerminalHeight;                      break;              }
Magic Number,Poderosa.Terminal,MouseWheelHandler,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnMouseWheel,The following statement contains a magic number: int d = args.Delta / 120;
Magic Number,Poderosa.Terminal,DrawingPerformance,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,MarkReceiveData,The following statement contains a magic number: now - _lastReceivedTime < 10 * 1000 * 100
Magic Number,Poderosa.Terminal,DrawingPerformance,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,MarkReceiveData,The following statement contains a magic number: now - _lastReceivedTime < 10 * 1000 * 100
Magic Number,Poderosa.Terminal,DrawingPerformance,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,MarkReceiveData,The following statement contains a magic number: now - _lastReceivedTime < 10 * 1000 * 100
Magic Number,Poderosa.Terminal,TerminalUtil,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,NewLineChars,The following statement contains a magic number: switch (nl) {                  case NewLine.CR:                      return new char[1] { '\r' };                  case NewLine.LF:                      return new char[1] { '\n' };                  case NewLine.CRLF:                      return new char[2] { '\r'' '\n' };                  default:                      throw new ArgumentException("Unknown NewLine " + nl);              }
Magic Number,Poderosa.Terminal,TerminalUtil,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,NewLineBytes,The following statement contains a magic number: switch (nl) {                  case NewLine.CR:                      return new byte[1] { (byte)'\r' };                  case NewLine.LF:                      return new byte[1] { (byte)'\n' };                  case NewLine.CRLF:                      return new byte[2] { (byte)'\r'' (byte)'\n' };                  default:                      throw new ArgumentException("Unknown NewLine " + nl);              }
Magic Number,Poderosa.Terminal,KeyboardInfo,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,Init,The following statement contains a magic number: _defaultGroup = new char[256];
Magic Number,Poderosa.Terminal,KeyboardInfo,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,Init,The following statement contains a magic number: _shiftGroup = new char[256];
Magic Number,Poderosa.Terminal,KeyboardInfo,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,Init,The following statement contains a magic number: i < 128
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessEraseInDisplay,The following statement contains a magic number: switch (d) {                  case 0: //erase below                      {                          if (col == 0 && cur == top)                              goto ERASE_ALL;                            EraseRight();                          doc.UpdateCurrentLine(_manipulator);                          doc.EnsureLine(bottom - 1);                          doc.RemoveAfter(bottom);                          doc.ClearRange(cur + 1' bottom' _currentdecoration);                          _manipulator.Load(doc.CurrentLine' col);                      }                      break;                  case 1: //erase above                      {                          if (col == doc.TerminalWidth - 1 && cur == bottom - 1)                              goto ERASE_ALL;                            EraseLeft();                          doc.UpdateCurrentLine(_manipulator);                          doc.ClearRange(top' cur' _currentdecoration);                          _manipulator.Load(doc.CurrentLine' col);                      }                      break;                  case 2: //erase all                  ERASE_ALL: {                          GetDocument().ApplicationModeBackColor =                              (_currentdecoration != null) ? _currentdecoration.GetBackColorSpec() : ColorSpec.Default;                            doc.UpdateCurrentLine(_manipulator);                          //if(_homePositionOnCSIJ2) { //SFUではこうなる                          //	ProcessCursorPosition(1'1);                           //	col = 0;                          //}                          doc.EnsureLine(bottom - 1);                          doc.RemoveAfter(bottom);                          doc.ClearRange(top' bottom' _currentdecoration);                          _manipulator.Load(doc.CurrentLine' col);                      }                      break;                  default:                      throw new UnknownEscapeSequenceException(String.Format("unknown ED option {0}"' param));              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessEraseInLine,The following statement contains a magic number: switch (d) {                  case 0: //erase right                      EraseRight();                      break;                  case 1: //erase left                      EraseLeft();                      break;                  case 2: //erase all                      EraseLine();                      break;                  default:                      throw new UnknownEscapeSequenceException(String.Format("unknown EL option {0}"' param));              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: byte[] r = new byte[5];
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: n += 10;
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: n >= 20
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: r[2] = (byte)f[0];
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: r[3] = (byte)f[1];
Magic Number,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: r[4] = (byte)tail;
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XmlLogger,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessNormalUnicodeChar,The following statement contains a magic number: _manipulator.InsertBlanks(_manipulator.CaretColumn' ch.IsWideWidth ? 2 : 1' _currentdecoration);
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,InitTabStops,The following statement contains a magic number: _tabStops[i] = (i % 8) == 0;
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,EnsureTabStops,The following statement contains a magic number: bool[] newarray = new bool[Math.Max(length' _tabStops.Length * 2)];
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,EnsureTabStops,The following statement contains a magic number: newarray[i] = (i % 8) == 0;
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,XtermFunctionKey,The following statement contains a magic number: m += 2;
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,XtermFunctionKey,The following statement contains a magic number: m += 4;
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: m += 2;
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: m += 4;
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: m == 1 || m == 8
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: switch (XTermPreferences.Instance.modifyCursorKeys) {                  // only modifyCursorKeys=2 and modifyCursorKeys=3 are supported                  case 2: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }                  case 3: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'>'' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }              }
Magic Number,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: switch (XTermPreferences.Instance.modifyCursorKeys) {                  // only modifyCursorKeys=2 and modifyCursorKeys=3 are supported                  case 2: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }                  case 3: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'>'' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }              }
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Location = new System.Drawing.Point(120' 72);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Location = new System.Drawing.Point(120' 72);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Size = new System.Drawing.Size(75' 23);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Size = new System.Drawing.Size(75' 23);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._messageLabel.Location = new System.Drawing.Point(56' 8);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._messageLabel.Location = new System.Drawing.Point(56' 8);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._messageLabel.Size = new System.Drawing.Size(248' 40);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._messageLabel.Size = new System.Drawing.Size(248' 40);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.Location = new System.Drawing.Point(56' 48);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.Location = new System.Drawing.Point(56' 48);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.Size = new System.Drawing.Size(248' 24);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.Size = new System.Drawing.Size(248' 24);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.TabIndex = 2;
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 12);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 12);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(314' 103);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(314' 103);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,OnPaint,The following statement contains a magic number: a.Graphics.DrawIcon(_warningIcon' 12' 24);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,OnPaint,The following statement contains a magic number: a.Graphics.DrawIcon(_warningIcon' 12' 24);
Missing Default,Poderosa.Terminal,UTF8ProfileBase,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,IsIgnoreableChar,The following switch statement is missing a default case: switch (charBuff[0]) {                          case '\uFFF9':  // INTERLINEAR ANNOTATION ANCHOR                          case '\uFFFA':  // INTERLINEAR ANNOTATION SEPARATOR                          case '\uFFFB':  // INTERLINEAR ANNOTATION TERMINATOR                          case '\uFFFF':  // not a character                          case '\uFFFE':  // BOM                          case '\uFEFF':  // BOM                          case '\uFE00':  // Variation Selector                          case '\uFE01':  // Variation Selector                          case '\uFE02':  // Variation Selector                          case '\uFE03':  // Variation Selector                          case '\uFE04':  // Variation Selector                          case '\uFE05':  // Variation Selector                          case '\uFE06':  // Variation Selector                          case '\uFE07':  // Variation Selector                          case '\uFE08':  // Variation Selector                          case '\uFE09':  // Variation Selector                          case '\uFE0A':  // Variation Selector                          case '\uFE0B':  // Variation Selector                          case '\uFE0C':  // Variation Selector                          case '\uFE0D':  // Variation Selector                          case '\uFE0E':  // Variation Selector                          case '\uFE0F':  // Variation Selector                              return true;                      }
Missing Default,Poderosa.Terminal,LogService,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,ApplySimpleLogSetting,The following switch statement is missing a default case: switch (sl.LogType) {                  case LogType.Binary:                      AddBinaryLogger(new BinaryLogger(loginfo' fs));                      break;                  case LogType.Default:                  case LogType.PlainTextWithTimestamp:                      bool withTimestamp = (sl.LogType == LogType.PlainTextWithTimestamp);                      AddTextLogger(new DefaultLogger(loginfo' new StreamWriter(fs' Encoding.Default)' withTimestamp));                      break;                  case LogType.Xml:                      AddXmlLogger(new XmlLogger(loginfo' new StreamWriter(fs' Encoding.Default)));                      break;              }
Missing Default,Poderosa.Terminal,GenericShellScheme,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\ShellScheme.cs,DetermineDelimiter,The following switch statement is missing a default case: switch (value[cursor + 1]) {                      case '[':                          return ']';                      case '<':                          return '>';                      case '{':                          return '}';                  }
Missing Default,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,CharDecodeError,The following switch statement is missing a default case: switch (GEnv.Options.CharDecodeErrorBehavior) {                  case WarningOption.StatusBar:                      window.StatusBar.SetMainText(msg);                      break;                  case WarningOption.MessageBox:                      window.AsForm().Invoke(new CharDecodeErrorDialogDelegate(CharDecodeErrorDialog)' window' msg);                      break;              }
Missing Default,Poderosa.Terminal,AbstractTerminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ShowAbnormalTerminationMessage,The following switch statement is missing a default case: switch (GEnv.Options.DisconnectNotification) {                          case WarningOption.StatusBar:                              window.StatusBar.SetMainText(msg);                              break;                          case WarningOption.MessageBox:                              window.Warning(msg); //TODO Disableオプションつきのサポート                              break;                      }
Missing Default,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SmartInvalidate,The following switch statement is missing a default case: switch (_drawOptimizingState) {                  case 0:                      _drawOptimizingState = 1;                      InvalidateEx();                      break;                  case 1:                      if (_session.TerminalConnection.Socket.Available)                          Interlocked.Exchange(ref _drawOptimizingState' 2); //間引きモードへ                      else                          InvalidateEx();                      break;                  case 2:                      break; //do nothing              }
Missing Default,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnWindowManagerTimer,The following switch statement is missing a default case: switch (_drawOptimizingState) {                  case 0:                      break; //do nothing                  case 1:                      Interlocked.CompareExchange(ref _drawOptimizingState' 0' 1);                      break;                  case 2: //忙しくても偶には描画                      _drawOptimizingState = 1;                      InvalidateEx();                      break;              }
Missing Default,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessScrollKey,The following switch statement is missing a default case: switch (key) {                  case Keys.Up:                      newvalue = current - 1;                      break;                  case Keys.Down:                      newvalue = current + 1;                      break;                  case Keys.PageUp:                      newvalue = current - doc.TerminalHeight;                      break;                  case Keys.PageDown:                      newvalue = current + doc.TerminalHeight;                      break;                  case Keys.Home:                      newvalue = 0;                      break;                  case Keys.End:                      newvalue = doc.LastLineNumber - doc.FirstLineNumber + 1 - doc.TerminalHeight;                      break;              }
Missing Default,Poderosa.Terminal,TerminalControl,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessVScrollMessage,The following switch statement is missing a default case: switch (cmd) {                  case 0: //SB_LINEUP                      newval--;                      break;                  case 1: //SB_LINEDOWN                      newval++;                      break;                  case 2: //SB_PAGEUP                      newval -= GetDocument().TerminalHeight;                      break;                  case 3: //SB_PAGEDOWN                      newval += GetDocument().TerminalHeight;                      break;              }
Missing Default,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessEscapeSequence,The following switch statement is missing a default case: switch (code) {                  case '[':                      if (seq.Length - offset - 1 >= 0) {                          param = new string(seq' offset' seq.Length - offset - 1);                          return ProcessAfterCSI(param' seq[seq.Length - 1]);                      }                      break;                  //throw new UnknownEscapeSequenceException(String.Format("unknown command after CSI {0}"' code));                  case ']':                      if (seq.Length - offset - 1 >= 0) {                          param = new string(seq' offset' seq.Length - offset - 1);                          return ProcessAfterOSC(param' seq[seq.Length - 1]);                      }                      break;                  case '=':                      ChangeMode(TerminalMode.Application);                      return ProcessCharResult.Processed;                  case '>':                      ChangeMode(TerminalMode.Normal);                      return ProcessCharResult.Processed;                  case 'E':                      ProcessNextLine();                      return ProcessCharResult.Processed;                  case 'M':                      ReverseIndex();                      return ProcessCharResult.Processed;                  case 'D':                      Index();                      return ProcessCharResult.Processed;                  case '7':                      SaveCursor();                      return ProcessCharResult.Processed;                  case '8':                      RestoreCursor();                      return ProcessCharResult.Processed;                  case 'c':                      FullReset();                      return ProcessCharResult.Processed;              }
Missing Default,Poderosa.Terminal,VT100Terminal,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessCursorMove,The following switch statement is missing a default case: switch (method) {                  case 'A':                      GetDocument().UpdateCurrentLine(_manipulator);                      GetDocument().CurrentLineNumber = (GetDocument().CurrentLineNumber - count);                      _manipulator.Load(GetDocument().CurrentLine' column);                      break;                  case 'B':                      GetDocument().UpdateCurrentLine(_manipulator);                      GetDocument().CurrentLineNumber = (GetDocument().CurrentLineNumber + count);                      _manipulator.Load(GetDocument().CurrentLine' column);                      break;                  case 'C': {                          int newvalue = column + count;                          if (newvalue >= GetDocument().TerminalWidth)                              newvalue = GetDocument().TerminalWidth - 1;                          _manipulator.CaretColumn = newvalue;                      }                      break;                  case 'D': {                          int newvalue = column - count;                          if (newvalue < 0)                              newvalue = 0;                          _manipulator.CaretColumn = newvalue;                      }                      break;              }
Missing Default,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following switch statement is missing a default case: switch (action) {                      case TerminalMouseAction.ButtonUp:                      case TerminalMouseAction.ButtonDown:                          _mouseButton = MouseButtons.None;                          break;                  }
Missing Default,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessEscapeSequence,The following switch statement is missing a default case: switch (code) {                  case 'F':                      if (seq.Length == offset) { //パラメータなしの場合                          ProcessCursorPosition(1' 1);                          return ProcessCharResult.Processed;                      }                      else if (seq.Length > offset && seq[offset] == ' ')                          return ProcessCharResult.Processed; //7/8ビットコントロールは常に両方をサポート                      break;                  case 'G':                      if (seq.Length > offset && seq[offset] == ' ')                          return ProcessCharResult.Processed; //7/8ビットコントロールは常に両方をサポート                      break;                  case 'L':                      if (seq.Length > offset && seq[offset] == ' ')                          return ProcessCharResult.Processed; //VT100は最初からOK                      break;                  case 'H':                      SetTabStop(_manipulator.CaretColumn' true);                      return ProcessCharResult.Processed;              }
Missing Default,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following switch statement is missing a default case: switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }
Missing Default,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following switch statement is missing a default case: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Missing Default,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSaveDECSET,The following switch statement is missing a default case: switch (param) {                  case "1047":                  case "47":                      _savedMode_isAlternateBuffer = _isAlternateBuffer;                      break;              }
Missing Default,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessRestoreDECSET,The following switch statement is missing a default case: switch (param) {                  case "1047":                  case "47":                      SwitchBuffer(_savedMode_isAlternateBuffer);                      break;              }
Missing Default,Poderosa.Terminal,XTerm,C:\research\architectureSmells\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following switch statement is missing a default case: switch (XTermPreferences.Instance.modifyCursorKeys) {                  // only modifyCursorKeys=2 and modifyCursorKeys=3 are supported                  case 2: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }                  case 3: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'>'' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }              }
