Implementation smell,Namespace,Class,File,Method,Description
Long Method,Poderosa.Terminal,ISO2022CharDecoder,C:\repos\poderosaproject_poderosa\TerminalEmulator\CharDecoder.cs,ProcessByte,The method has 126 lines of code.
Long Method,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The method has 109 lines of code.
Long Method,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The method has 100 lines of code.
Long Method,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The method has 182 lines of code.
Long Method,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The method has 150 lines of code.
Long Method,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The method has 116 lines of code.
Long Method,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessDECSET,The method has 104 lines of code.
Complex Method,Poderosa.Terminal,UTF8ProfileBase,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,Cyclomatic complexity of the method is 8
Complex Method,Poderosa.Terminal,TerminalDocument,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalDocument.cs,Remove,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,CustomKeySettings,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,Reset,Cyclomatic complexity of the method is 9
Complex Method,Poderosa.Terminal,TerminalSettingsSerializer,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalSettingsSerialize.cs,Serialize,Cyclomatic complexity of the method is 8
Complex Method,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,Cyclomatic complexity of the method is 11
Long Parameter List,Poderosa.Terminal,CJKByteProcessor,C:\repos\poderosaproject_poderosa\TerminalEmulator\CharDecoder.cs,CJKByteProcessor,The method has 5 parameters. Parameters: processor' buffer' encoding' leadingBytes' trailingBytes
Long Parameter List,Poderosa.Terminal,IntelliSenseContext,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,Init,The method has 5 parameters. Parameters: terminal' scheme' current_input' mode' append_char
Long Parameter List,Poderosa.Terminal,PromptRecognizer,C:\repos\poderosaproject_poderosa\TerminalEmulator\PromptRecognizer.cs,DeterminePromptLine,The method has 5 parameters. Parameters: line' limitLineID' limitColumn' prompt' command
Long Parameter List,Poderosa.Terminal,AbstractTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessMouse,The method has 5 parameters. Parameters: action' button' modifierKeys' row' col
Long Parameter List,Poderosa.Terminal,TerminalCommand,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,TerminalCommand,The method has 5 parameters. Parameters: id' description' category' body' enabled
Long Parameter List,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The method has 5 parameters. Parameters: action' button' modKeys' row' col
Long Identifier,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,,The length of the parameter _enableComplementForNewConnections is 34.
Long Identifier,Poderosa.Terminal,PromptRecognizerPreferences,C:\repos\poderosaproject_poderosa\TerminalEmulator\PromptRecognizer.cs,,The length of the parameter DEFAULT_PROMPT_SEARCH_MAX_LINES is 31.
Long Identifier,Poderosa.Terminal,TerminalCommand,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,,The length of the parameter _doesExistCharacterDocumentViewer is 33.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter TERMINAL_CONTEXT_MENU_EXTENSIONPOINT is 36.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter DOCUMENT_CONTEXT_MENU_EXTENSIONPOINT is 36.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter TERMINALSPECIAL_EXTENSIONPOINT is 30.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter INTELLISENSE_CANDIDATE_EXTENSIONPOINT is 37.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter LOG_FILENAME_FORMATTER_EXTENSIONPOINT is 37.
Long Identifier,Poderosa.Terminal,TerminalEmulatorConstants,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,,The length of the parameter DYNAMIC_CAPTION_FORMATTER_EXTENSIONPOINT is 40.
Long Identifier,Poderosa.Terminal,TerminalSettings,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalSettings.cs,,The length of the parameter _enabledCharTriggerIntelliSense is 31.
Long Statement,Poderosa.Terminal,CommandResultRecognizer,C:\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,ProcessCommandResult,The length of the statement  "                Debug.WriteLineIf(DebugOpt.CommandPopup' String.Format("Ignored for 0-length' start={0} end={1}"' _commandStartLineID' end_line_id)); " is 133.
Long Statement,Poderosa.Terminal,PopupStyleCommandResultRecognizer,C:\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,CreateExtensionPointAndDefaultCommands,The length of the statement  "            IExtensionPoint pt = pm.CreateExtensionPoint(POPUP_MENU_EXTENSION_POINT' typeof(ICommandResultProcessorMenuItem)' TerminalEmulatorPlugin.Instance); " is 147.
Long Statement,Poderosa.Terminal,PopupStyleCommandResultRecognizer,C:\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,ProcessKey,The length of the statement  "            if (_state == State.Prompt && _lastCommand.Length > 0 && TerminalEmulatorPlugin.Instance.TerminalEmulatorOptions.CommandPopupKey == (modifiers | keybody)) { " is 156.
Long Statement,Poderosa.Terminal,PopupStyleCommandResultRecognizer,C:\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,ShowMenu,The length of the statement  "            Point popup = new Point((int)(doc.CaretColumn * pitch.Width)' (int)((doc.CurrentLineNumber - doc.TopLineNumber + 1) * pitch.Height)); " is 133.
Long Statement,Poderosa.Terminal,PopupStyleCommandResultRecognizer,C:\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,CreatePopupMenuItems,The length of the statement  "            foreach (ICommandResultProcessorMenuItem item in TerminalEmulatorPlugin.Instance.PoderosaWorld.PluginManager.FindExtensionPoint(POPUP_MENU_EXTENSION_POINT).GetExtensions()) { " is 174.
Long Statement,Poderosa.Terminal,CommandResultSession,C:\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopupSession.cs,SessionEntryPoint,The length of the statement  "                cp.InitialSize = new Size(tc.ClientSize.Width' (int)(RuntimeUtil.AdjustIntRange(document.Size' 0' 20) * rp.Pitch.Height) + 2); " is 126.
Long Statement,Poderosa.Terminal,IntelliSense,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,TryParseMultiLineCommand,The length of the statement  "                if (_terminal.PromptRecognizer.DeterminePromptLine(command_start_candidate' current.ID' current.DisplayLength' out prompt' out command)) { " is 138.
Long Statement,Poderosa.Terminal,IntelliSense,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,PopupMain,The length of the statement  "            IntelliSenseMode mode = line.Length == 0 || ss.IsDelimiter(line[line.Length - 1]) ? IntelliSenseMode.ArgComplement : IntelliSenseMode.CharComplement; " is 149.
Long Statement,Poderosa.Terminal,IntelliSenseContext,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,Init,The length of the statement  "            _commandStartPoint = new Point(doc.CaretColumn + (append_char == '\0' ? 0 : 1)' doc.CurrentLineNumber - doc.TopLineNumber); " is 123.
Long Statement,Poderosa.Terminal,IntelliSenseContext,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,Init,The length of the statement  "            Debug.WriteLineIf(DebugOpt.IntelliSense' String.Format("IS CtxInit M={0} CaretC={1}"' mode.ToString()' doc.CaretColumn)); " is 121.
Long Statement,Poderosa.Terminal,IntelliSenseContext,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,BuildCandidates,The length of the statement  "            IntelliSenseItemCollection col = (IntelliSenseItemCollection)_scheme.CommandHistory.GetAdapter(typeof(IntelliSenseItemCollection)); " is 131.
Long Statement,Poderosa.Terminal,IntelliSenseContext,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,BuildCandidates,The length of the statement  "                else if (_intelliSenseMode == IntelliSenseMode.CharComplement && r == IntelliSenseItem.MatchForwardResult.PartialChar) { " is 120.
Long Statement,Poderosa.Terminal,IntelliSenseWindow,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,DoSpecialKey,The length of the statement  "                _context.SortStyle = _context.SortStyle == IntelliSenseSort.Alphabet ? IntelliSenseSort.Historical : IntelliSenseSort.Alphabet; " is 127.
Long Statement,Poderosa.Terminal,IntelliSenseWindow,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,DoSpecialKey,The length of the statement  "                IntelliSenseItemCollection col = (IntelliSenseItemCollection)_context.CurrentScheme.CommandHistory.GetAdapter(typeof(IntelliSenseItemCollection)); " is 146.
Long Statement,Poderosa.Terminal,LogService,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,ApplySimpleLogSetting,The length of the statement  "            FileStream fs = new FileStream(sl.LogPath' sl.LogAppend ? FileMode.Append : FileMode.Create' FileAccess.Write' FileShare.Read); " is 127.
Long Statement,Poderosa.Terminal,LogService,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,CreateAutoLogFileName,The length of the statement  "                filebody = String.Format("{0}\\{1}_{2}{3'2:D2}{4'2:D2}"' opt.DefaultLogDirectory' ReplaceCharForLogFile(settings.Caption)' now.Year' now.Month' now.Day); " is 153.
Long Statement,Poderosa.Terminal,LogService,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,ReplaceCharForLogFile,The length of the statement  "                if (ch == '\\' || ch == '/' || ch == ':' || ch == ';' || ch == ''' || ch == '*' || ch == '?' || ch == '"' || ch == '<' || ch == '>' || ch == '|') " is 145.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _fontSize = builder.DefineIntValue(_folder' "fontSize"' 10' PreferenceValidatorUtil.PositiveIntegerValidator); //floatにすべきかなあ " is 125.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _textColor = new ColorPreferenceItem(builder.DefineStringValue(_folder' "textColor"' "WindowText"' null)' KnownColor.WindowText); " is 129.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _imageStyle = new EnumPreferenceItem<ImageStyle>(builder.DefineStringValue(_folder' "imageStyle"' "Center"' null)' ImageStyle.Center); " is 134.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _caretType = new EnumPreferenceItem<CaretType>(builder.DefineStringValue(_folder' "caretType"' "Box"' null)' CaretType.Box); " is 124.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _charDecodeErrorBehavior = new EnumPreferenceItem<WarningOption>(builder.DefineStringValue(_folder' "charDecodeErrorBehavior"' "MessageBox"' null)' WarningOption.MessageBox); " is 174.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _disconnectNotification = new EnumPreferenceItem<WarningOption>(builder.DefineStringValue(_folder' "disconnectNotification"' "StatusBar"' null)' WarningOption.StatusBar); " is 170.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _enableComplementForNewConnections = builder.DefineBoolValue(_folder' "enableComplementForNewConnections"' false' null); " is 120.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _terminalBufferSize = builder.DefineIntValue(_folder' "terminalBufferSize"' 1000' PreferenceValidatorUtil.PositiveIntegerValidator); " is 132.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _zone0x1F = new EnumPreferenceItem<KeyboardStyle>(builder.DefineStringValue(_folder' "zone0x1F"' "None"' null)' KeyboardStyle.None); " is 132.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _keepAliveInterval = builder.DefineIntValue(_folder' "keepAliveInterval"' 60000' PreferenceValidatorUtil.IntRangeValidator(0' 100 * 60000)); " is 140.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _leftAltKey = new EnumPreferenceItem<AltKeyAction>(builder.DefineStringValue(_folder' "leftAltKey"' "Menu"' null)' AltKeyAction.Menu); " is 134.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _rightAltKey = new EnumPreferenceItem<AltKeyAction>(builder.DefineStringValue(_folder' "rightAltKey"' "Menu"' null)' AltKeyAction.Menu); " is 136.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _rightButtonAction = new EnumPreferenceItem<MouseButtonAction>(builder.DefineStringValue(_folder' "rightButtonAction"' "ContextMenu"' null)' MouseButtonAction.ContextMenu); " is 172.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _middleButtonAction = new EnumPreferenceItem<MouseButtonAction>(builder.DefineStringValue(_folder' "middleButtonAction"' "None"' null)' MouseButtonAction.None); " is 160.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _defaultLogType = new EnumPreferenceItem<LogType>(builder.DefineStringValue(_folder' "defaultLogType"' "None"' null)' LogType.None); " is 132.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _intelliSenseKey = builder.DefineStringValue(_folder' "intelliSenseKey"' "Ctrl+OemPeriod"' PreferenceValidatorUtil.KeyWithModifierValidator); " is 141.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _commandPopupKey = builder.DefineStringValue(_folder' "commandPopupKey"' "Ctrl+Oemcomma"' PreferenceValidatorUtil.KeyWithModifierValidator); " is 140.
Long Statement,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The length of the statement  "            _shellHistoryLimitCount = builder.DefineIntValue(_folder' "shellHistoryLimitCount"' 100' PreferenceValidatorUtil.PositiveIntegerValidator); " is 139.
Long Statement,Poderosa.Terminal,PromptRecognizer,C:\repos\poderosaproject_poderosa\TerminalEmulator\PromptRecognizer.cs,Recognize,The length of the statement  "            if (!DeterminePromptLine(promptCandidate' doc.CurrentLine.ID' doc.CaretColumn' out prompt' out command)) { //プロンプトではないとき " is 120.
Long Statement,Poderosa.Terminal,PromptRecognizerPreferences,C:\repos\poderosaproject_poderosa\TerminalEmulator\PromptRecognizer.cs,InitializePreference,The length of the statement  "            _promptSearchMaxLines = builder.DefineIntValue(folder' "promptSearchMaxLines"' DEFAULT_PROMPT_SEARCH_MAX_LINES' PreferenceValidatorUtil.PositiveIntegerValidator); " is 162.
Long Statement,Poderosa.Terminal,ShellSchemeCollection,C:\repos\poderosaproject_poderosa\TerminalEmulator\ShellScheme.cs,InitializePreference,The length of the statement  "            _promptPreference = builder.DefineStringValue(_schemeTemplate' "prompt"' GenericShellScheme.DEFAULT_PROMPT_REGEX' null); " is 120.
Long Statement,Poderosa.Terminal,ShellSchemeCollection,C:\repos\poderosaproject_poderosa\TerminalEmulator\ShellScheme.cs,PreClose,The length of the statement  "                    _preferenceFolderArray.ConvertItem(content' _backspacePreference).AsString().Value = ((int)ss.BackSpaceChar).ToString("X2"); " is 124.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,InvalidCharDetected,The length of the statement  "            CharDecodeError(String.Format(GEnv.Strings.GetString("Message.AbstractTerminal.UnexpectedChar")' _encodingProfile.Encoding.WebName)); " is 133.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,OnReception,The length of the statement  "                        //Debug.WriteLine(String.Format("E={0} C={1} T={2} H={3} LC={4} MAX={5} n={6}"' _transientScrollBarEnabled' _tag.Document.CurrentLineNumber' _tag.Document.TopLineNumber' _tag.Connection.TerminalHeight' _transientScrollBarLargeChange' _transientScrollBarMaximum' n)); " is 266.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,OnAbnormalTermination,The length of the statement  "            //TODO メッセージを GEnv.Strings.GetString("Message.TerminalDataReceiver.GenericError")'_tag.Connection.Param.ShortDescription' msg " is 125.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,Cleanup,The length of the statement  "            //NOTE _session.CloseByReceptionThread()は、そのままアプリ終了と直結する場合がある。すると、_logService.Close()の処理が終わらないうちに強制終了になってログが書ききれない可能性がある " is 120.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,CleanupCommon,The length of the statement  "                TerminalEmulatorPlugin.Instance.ShellSchemeCollection.RemoveDynamicChangeListener((IShellSchemeDynamicChangeListener)GetTerminalSettings().GetAdapter(typeof(IShellSchemeDynamicChangeListener))); " is 194.
Long Statement,Poderosa.Terminal,AbstractTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,AdjustTransientScrollBar,The length of the statement  "            int docheight = Math.Max(document.LastLineNumber' document.TopLineNumber + paneheight - 1) - document.FirstLineNumber + 1; " is 122.
Long Statement,Poderosa.Terminal,EscapeSequenceTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessChar,The length of the statement  "                    RuntimeUtil.SilentReportException(new UnknownEscapeSequenceException("Incomplete escape sequence: ESC " + _escapeSequence.ToString())); " is 135.
Long Statement,Poderosa.Terminal,EscapeSequenceTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessChar,The length of the statement  "                    end_flag = ('0' <= ch && ch <= '9') || ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z' && ch != 'P') || ch == '>' || ch == '=' || ch == '|' || ch == '}' || ch == '~'; " is 170.
Long Statement,Poderosa.Terminal,EscapeSequenceTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,DoLineFeed,The length of the statement  "            _manipulator.EOLType = (_manipulator.EOLType == EOLType.CR || _manipulator.EOLType == EOLType.CRLF) ? EOLType.CRLF : EOLType.LF; " is 128.
Long Statement,Poderosa.Terminal,TerminalCommand,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,Register,The length of the statement  "                "Command.SelectAll"' _terminalEdit' new ExecuteDelegate(CmdSelectAll)' TerminalCommand.DoesExistCharacterDocumentViewer)); " is 122.
Long Statement,Poderosa.Terminal,TerminalCommand,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,Register,The length of the statement  "            //cm.Register(new TerminalCommand("org.poderosa.terminalemulator.reproduce"' new ExecuteDelegate(CmdReproduce)' new EnabledDelegate(DoesOpenTargetSession))); " is 157.
Long Statement,Poderosa.Terminal,TerminalSettingMenuGroup,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,GetTerminalSpecialMenuGroups,The length of the statement  "            return (IPoderosaMenuGroup[])TerminalEmulatorPlugin.Instance.PoderosaWorld.PluginManager.FindExtensionPoint(TerminalEmulatorConstants.TERMINALSPECIAL_EXTENSIONPOINT).GetExtensions(); " is 182.
Long Statement,Poderosa.Terminal,TerminalSettingMenuGroup,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalCommands.cs,Initialize,The length of the statement  "            IExtensionPoint p = TerminalEmulatorPlugin.Instance.PoderosaWorld.PluginManager.CreateExtensionPoint(TerminalEmulatorConstants.TERMINALSPECIAL_EXTENSIONPOINT' typeof(IPoderosaMenuGroup)' TerminalEmulatorPlugin.Instance); " is 220.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _contextMenu = pm.CreateExtensionPoint(TerminalEmulatorConstants.TERMINAL_CONTEXT_MENU_EXTENSIONPOINT' typeof(IPoderosaMenuGroup)' this); " is 137.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _documentContextMenu = pm.CreateExtensionPoint(TerminalEmulatorConstants.DOCUMENT_CONTEXT_MENU_EXTENSIONPOINT' typeof(IPoderosaMenuGroup)' this); " is 145.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _intelliSenseExtension = pm.CreateExtensionPoint(TerminalEmulatorConstants.INTELLISENSE_CANDIDATE_EXTENSIONPOINT' typeof(IIntelliSenseCandidateExtension)' this); " is 161.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _autoLogFileFormatter = pm.CreateExtensionPoint(TerminalEmulatorConstants.LOG_FILENAME_FORMATTER_EXTENSIONPOINT' typeof(IAutoLogFileFormatter)' this); " is 150.
Long Statement,Poderosa.Terminal,TerminalEmulatorPlugin,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalEmulatorPlugin.cs,InitializePlugin,The length of the statement  "            _dynamicCaptionFormatter = pm.CreateExtensionPoint(TerminalEmulatorConstants.DYNAMIC_CAPTION_FORMATTER_EXTENSIONPOINT' typeof(IDynamicCaptionFormatter)' this); " is 159.
Long Statement,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,MakeCurrentLineVisible,The length of the statement  "            else if (_VScrollBar.Value + document.TerminalHeight <= document.CurrentLineNumber - document.FirstLineNumber) { //下に隠れた " is 120.
Long Statement,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnResize,The length of the statement  "            //Debug.WriteLine(String.Format("TC RESIZE {0} {1} {2}'{3}"' _resizeCount++' DateTime.Now.ToString()' this.Size.Width' this.Size.Height)); " is 138.
Long Statement,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnResize,The length of the statement  "            if (this.DesignMode || this.FindForm() == null || this.FindForm().WindowState == FormWindowState.Minimized || _session == null) " is 127.
Long Statement,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,CalcTerminalSize,The length of the statement  "            int width = (int)Math.Floor((float)(this.ClientSize.Width - sm.ScrollBarWidth - CharacterDocumentViewer.BORDER * 2) / charPitch.Width); " is 135.
Long Statement,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,CalcTerminalSize,The length of the statement  "            int height = (int)Math.Floor((float)(this.ClientSize.Height - CharacterDocumentViewer.BORDER * 2 + prof.LineSpacing) / (charPitch.Height + prof.LineSpacing)); " is 158.
Long Statement,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,AdjustIMEComposition,The length of the statement  "            //Debug.WriteLine(String.Format("{0} {1} {2}"' document.CaretColumn' charwidth' document.CurrentLine.CharPosToDisplayPos(document.CaretColumn))); " is 145.
Long Statement,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,AdjustIMEComposition,The length of the statement  "            form.ptCurrentPos.y = sm.ControlBorderHeight + (int)((prof.Pitch.Height + prof.LineSpacing) * (document.CurrentLineNumber - document.TopLineNumber)); " is 149.
Long Statement,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnGotFocus,The length of the statement  "                TerminalEmulatorPlugin.Instance.GetSessionManager().ActivateDocument(this.CharacterDocument' ActivateReason.ViewGotFocus); " is 122.
Long Statement,Poderosa.Terminal,TerminalEmulatorMouseHandler,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnMouseUp,The length of the statement  "                        TerminalEmulatorPlugin.Instance.GetCommandManager().Execute(vc.Paste' (ICommandTarget)vc.GetAdapter(typeof(ICommandTarget))); " is 125.
Long Statement,Poderosa.Terminal,TerminalEmulatorMouseHandler,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ShowContextMenu,The length of the statement  "            view.ParentForm.ShowContextMenu(TerminalEmulatorPlugin.Instance.ContextMenu' view' _control.PointToScreen(pt)' ContextMenuFlags.None); " is 134.
Long Statement,Poderosa.Terminal,DrawingPerformance,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,Output,The length of the statement  "            Debug.WriteLine(String.Format("FullInvalidate:{0} PartialInvalidate:{1} 1-Line:{2} AvgLine:{3:F2}"' _fullInvalidateCount' _partialInvalidateCount' _invalidate1LineCount' (double)_totalInvalidatedLineCount / _partialInvalidateCount)); " is 233.
Long Statement,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessDeviceStatusReport,The length of the statement  "                response = String.Format(" [{0};{1}R"' GetDocument().CurrentLineNumber - GetDocument().TopLineNumber + 1' _manipulator.CaretColumn + 1); " is 136.
Long Statement,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,Index,The length of the statement  "            if (current == GetDocument().TopLineNumber + GetDocument().TerminalHeight - 1 || current == GetDocument().ScrollingBottom) " is 122.
Long Statement,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ChangeMode,The length of the statement  "                GetConnection().TerminalOutput.Resize(GetDocument().TerminalWidth' GetDocument().TerminalHeight); //たとえばemacs起動中にリサイズし、シェルへ戻るとシェルは新しいサイズを認識していない " is 144.
Long Statement,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The length of the statement  "            MouseTrackingState currentState = _mouseTrackingState;  // copy value because _mouseTrackingState may be changed in another thread. " is 131.
Long Statement,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The length of the statement  "            MouseTrackingProtocol protocol = _mouseTrackingProtocol; // copy value because _mouseTrackingProtocol may be changed in another thread. " is 135.
Long Statement,Poderosa.Terminal,XTermPreferences,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,InitializePreference,The length of the statement  "            _modifyCursorKeys = builder.DefineIntValue(folder' "modifyCursorKeys"' DEFAULT_MODIFY_CURSOR_KEYS' PreferenceValidatorUtil.PositiveIntegerValidator); " is 149.
Long Statement,Poderosa,GUtil,C:\repos\poderosaproject_poderosa\TerminalEmulator\Util.cs,Warning,The length of the statement  "            MessageBox.Show(owner' msg' GEnv.Strings.GetString("Common.MessageBoxTitle")' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 128.
Long Statement,Poderosa,GUtil,C:\repos\poderosaproject_poderosa\TerminalEmulator\Util.cs,AskUserYesNo,The length of the statement  "            return MessageBox.Show(owner' msg' GEnv.Strings.GetString("Common.MessageBoxTitle")' MessageBoxButtons.YesNo' MessageBoxIcon.Question); " is 135.
Complex Conditional,Poderosa.Terminal,LogService,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,ReplaceCharForLogFile,The conditional expression  "ch == '\\' || ch == '/' || ch == ':' || ch == ';' || ch == ''' || ch == '*' || ch == '?' || ch == '"' || ch == '<' || ch == '>' || ch == '|'"  is complex.
Complex Conditional,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnResize,The conditional expression  "this.DesignMode || this.FindForm() == null || this.FindForm().WindowState == FormWindowState.Minimized || _session == null"  is complex.
Complex Conditional,Poderosa.Terminal,TerminalSettings,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalSettings.cs,TerminalSettings,The conditional expression  "culture.IsJapaneseOS || culture.IsSimplifiedChineseOS || culture.IsTraditionalChineseOS || culture.IsKoreanOS"  is complex.
Complex Conditional,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The conditional expression  "vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)"  is complex.
Magic Number,Poderosa.Terminal,ISO2022CharDecoder,C:\repos\poderosaproject_poderosa\TerminalEmulator\CharDecoder.cs,ProcessByte,The following statement contains a magic number: if (_processor.State == ProcessCharResult.Escaping)                  _processor.ProcessChar((char)b);              else {                  if (_state == State.Normal && !IsControlChar(b) && _decoder.IsInterestingByte(b)) {                      PutMBCSByte(b);                  }                  else {                      switch (_state) {                          case State.Normal:                              if (b == 0x1B) { //ESC                                  _escseq.Reset();                                  _escseq.Append(b);                                  _state = State.ESC;                              }                              else if (b == 14) //SO                                  ChangeProcessor(_G1ByteProcessor);                              else if (b == 15) //SI                                  ChangeProcessor(_G0ByteProcessor);                              else                                  ConsumeByte(b);                              break;                          case State.ESC:                              _escseq.Append(b);                              if (b == (byte)'$')                                  _state = State.ESC_DOLLAR;                              else if (b == (byte)'(')                                  _state = State.ESC_BRACKET;                              else if (b == (byte)')')                                  _state = State.ESC_ENDBRACKET;                              else {                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_BRACKET:                              _escseq.Append(b);                              if (b == (byte)'0') {                                  _G0ByteProcessor = GetDECLineByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else if (b == (byte)'B' || b == (byte)'J' || b == (byte)'~') { //!!lessでssh2architecture.txtを見ていたら来た。詳細はまだ調べていない。                                  _G0ByteProcessor = _asciiByteProcessor;                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else {                                  _processor.UnsupportedCharSetDetected((char)b);                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_ENDBRACKET:                              _escseq.Append(b);                              if (b == (byte)'0') {                                  _G1ByteProcessor = GetDECLineByteProcessor();                                  _state = State.Normal;                              }                              else if (b == (byte)'B' || b == (byte)'J' || b == (byte)'~') { //!!lessでssh2architecture.txtを見ていたら来た。詳細はまだ調べていない。                                  _G1ByteProcessor = _asciiByteProcessor;                                  _state = State.Normal;                              }                              else {                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_DOLLAR:                              _escseq.Append(b);                              if (b == (byte)'(')                                  _state = State.ESC_DOLLAR_BRACKET;                              else if (b == (byte)')')                                  _state = State.ESC_DOLLAR_ENDBRACKET;                              else if (b == (byte)'B' || b == (byte)'@') {                                  _G0ByteProcessor = GetISO2022JPByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else {                                  _processor.UnsupportedCharSetDetected((char)b);                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_DOLLAR_BRACKET:                              _escseq.Append(b);                              if (b == (byte)'C') {                                  _G0ByteProcessor = GetISO2022KRByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else if (b == (byte)'D') {                                  _G0ByteProcessor = GetISO2022JPByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else if (b == (byte)'I') {                                  _G0ByteProcessor = GetISO2022JPKanaByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else {                                  _processor.UnsupportedCharSetDetected((char)b);                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_DOLLAR_ENDBRACKET:                              _escseq.Append(b);                              if (b == (byte)'C') {                                  _G1ByteProcessor = GetISO2022KRByteProcessor();                                  _state = State.Normal;                              }                              else {                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          default:                              Debug.Assert(false' "unexpected state transition");                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,ISO2022CharDecoder,C:\repos\poderosaproject_poderosa\TerminalEmulator\CharDecoder.cs,ProcessByte,The following statement contains a magic number: if (_processor.State == ProcessCharResult.Escaping)                  _processor.ProcessChar((char)b);              else {                  if (_state == State.Normal && !IsControlChar(b) && _decoder.IsInterestingByte(b)) {                      PutMBCSByte(b);                  }                  else {                      switch (_state) {                          case State.Normal:                              if (b == 0x1B) { //ESC                                  _escseq.Reset();                                  _escseq.Append(b);                                  _state = State.ESC;                              }                              else if (b == 14) //SO                                  ChangeProcessor(_G1ByteProcessor);                              else if (b == 15) //SI                                  ChangeProcessor(_G0ByteProcessor);                              else                                  ConsumeByte(b);                              break;                          case State.ESC:                              _escseq.Append(b);                              if (b == (byte)'$')                                  _state = State.ESC_DOLLAR;                              else if (b == (byte)'(')                                  _state = State.ESC_BRACKET;                              else if (b == (byte)')')                                  _state = State.ESC_ENDBRACKET;                              else {                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_BRACKET:                              _escseq.Append(b);                              if (b == (byte)'0') {                                  _G0ByteProcessor = GetDECLineByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else if (b == (byte)'B' || b == (byte)'J' || b == (byte)'~') { //!!lessでssh2architecture.txtを見ていたら来た。詳細はまだ調べていない。                                  _G0ByteProcessor = _asciiByteProcessor;                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else {                                  _processor.UnsupportedCharSetDetected((char)b);                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_ENDBRACKET:                              _escseq.Append(b);                              if (b == (byte)'0') {                                  _G1ByteProcessor = GetDECLineByteProcessor();                                  _state = State.Normal;                              }                              else if (b == (byte)'B' || b == (byte)'J' || b == (byte)'~') { //!!lessでssh2architecture.txtを見ていたら来た。詳細はまだ調べていない。                                  _G1ByteProcessor = _asciiByteProcessor;                                  _state = State.Normal;                              }                              else {                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_DOLLAR:                              _escseq.Append(b);                              if (b == (byte)'(')                                  _state = State.ESC_DOLLAR_BRACKET;                              else if (b == (byte)')')                                  _state = State.ESC_DOLLAR_ENDBRACKET;                              else if (b == (byte)'B' || b == (byte)'@') {                                  _G0ByteProcessor = GetISO2022JPByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else {                                  _processor.UnsupportedCharSetDetected((char)b);                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_DOLLAR_BRACKET:                              _escseq.Append(b);                              if (b == (byte)'C') {                                  _G0ByteProcessor = GetISO2022KRByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else if (b == (byte)'D') {                                  _G0ByteProcessor = GetISO2022JPByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else if (b == (byte)'I') {                                  _G0ByteProcessor = GetISO2022JPKanaByteProcessor();                                  ChangeProcessor(_G0ByteProcessor);                                  _state = State.Normal;                              }                              else {                                  _processor.UnsupportedCharSetDetected((char)b);                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          case State.ESC_DOLLAR_ENDBRACKET:                              _escseq.Append(b);                              if (b == (byte)'C') {                                  _G1ByteProcessor = GetISO2022KRByteProcessor();                                  _state = State.Normal;                              }                              else {                                  ConsumeBytes(_escseq.Buffer' _escseq.Length);                                  _state = State.Normal;                              }                              break;                          default:                              Debug.Assert(false' "unexpected state transition");                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,CommandResultProcessorBase,C:\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopup.cs,AsyncResultQuickHack,The following statement contains a magic number: if (ar.AsyncWaitHandle.WaitOne(100' false)) //IntelliSenseと同様の理由で時間制限つきのWait                  tc.EndInvoke(ar);
Magic Number,Poderosa.Terminal,CommandResultSession,C:\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopupSession.cs,SessionEntryPoint,The following statement contains a magic number: try {                  TerminalControl tc = terminal.TerminalHost.TerminalControl;                  Debug.Assert(tc != null);                  RenderProfile rp = (RenderProfile)tc.GetRenderProfile().Clone();                  CommandResultSession session = new CommandResultSession(document' rp); //現在のRenderProfileを使ってセッションを作る                  TerminalDocument terminaldoc = terminal.GetDocument();                  PopupViewCreationParam cp = new PopupViewCreationParam(_viewFactory);                  //結果のサイズに合わせる。ただし高さは20行を上限とする                  cp.InitialSize = new Size(tc.ClientSize.Width' (int)(RuntimeUtil.AdjustIntRange(document.Size' 0' 20) * rp.Pitch.Height) + 2);                  cp.OwnedByCommandTargetWindow = GEnv.Options.CommandPopupAlwaysOnTop;                  cp.ShowInTaskBar = GEnv.Options.CommandPopupInTaskBar;                    IWindowManager wm = TerminalEmulatorPlugin.Instance.GetWindowManager();                  ISessionManager sm = TerminalEmulatorPlugin.Instance.GetSessionManager();                  IPoderosaPopupWindow window = wm.CreatePopupView(cp);                  sm.StartNewSession(session' window.InternalView);                  sm.ActivateDocument(session.Document' ActivateReason.InternalAction);              }              catch (Exception ex) {                  RuntimeUtil.ReportException(ex);              }
Magic Number,Poderosa.Terminal,CommandResultSession,C:\repos\poderosaproject_poderosa\TerminalEmulator\CommandResultPopupSession.cs,SessionEntryPoint,The following statement contains a magic number: try {                  TerminalControl tc = terminal.TerminalHost.TerminalControl;                  Debug.Assert(tc != null);                  RenderProfile rp = (RenderProfile)tc.GetRenderProfile().Clone();                  CommandResultSession session = new CommandResultSession(document' rp); //現在のRenderProfileを使ってセッションを作る                  TerminalDocument terminaldoc = terminal.GetDocument();                  PopupViewCreationParam cp = new PopupViewCreationParam(_viewFactory);                  //結果のサイズに合わせる。ただし高さは20行を上限とする                  cp.InitialSize = new Size(tc.ClientSize.Width' (int)(RuntimeUtil.AdjustIntRange(document.Size' 0' 20) * rp.Pitch.Height) + 2);                  cp.OwnedByCommandTargetWindow = GEnv.Options.CommandPopupAlwaysOnTop;                  cp.ShowInTaskBar = GEnv.Options.CommandPopupInTaskBar;                    IWindowManager wm = TerminalEmulatorPlugin.Instance.GetWindowManager();                  ISessionManager sm = TerminalEmulatorPlugin.Instance.GetSessionManager();                  IPoderosaPopupWindow window = wm.CreatePopupView(cp);                  sm.StartNewSession(session' window.InternalView);                  sm.ActivateDocument(session.Document' ActivateReason.InternalAction);              }              catch (Exception ex) {                  RuntimeUtil.ReportException(ex);              }
Magic Number,Poderosa.Terminal,Decoder,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,Decoder,The following statement contains a magic number: _buffer = new byte[6];
Magic Number,Poderosa.Terminal,Encoder,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,Encoder,The following statement contains a magic number: _buff = new char[2];
Magic Number,Poderosa.Terminal,Encoder,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetBytes,The following statement contains a magic number: if (_needLowSurrogate) {                      _needLowSurrogate = false;                      if (Char.IsLowSurrogate(ch)) {                          _buff[1] = ch;                          bytes = _profile.Encoding.GetBytes(_buff' 0' 2);                          return true;                      }                        // fall through.                      // ignore high surrogate.                  }
Magic Number,Poderosa.Terminal,ShiftJISProfile,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return (b >= 0xA1 && b <= 0xDF) ? 1 : 2;
Magic Number,Poderosa.Terminal,EUCJPProfile,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return b == 0x8F ? 3 : b >= 0x8E ? 2 : 1;
Magic Number,Poderosa.Terminal,EUCJPProfile,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return b == 0x8F ? 3 : b >= 0x8E ? 2 : 1;
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: if ((b & 0x20) == 0) {                      return 2;                  }
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: if ((b & 0x10) == 0) {                      return 3;                  }
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: if ((b & 0x08) == 0) {                      return 4;                  }
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: if ((b & 0x04) == 0) {                      return 5;                  }
Magic Number,Poderosa.Terminal,UTF8ProfileBase,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: if ((b & 0x02) == 0) {                      return 6;                  }
Magic Number,Poderosa.Terminal,GB2312Profile,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 2;
Magic Number,Poderosa.Terminal,Big5Profile,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 2;
Magic Number,Poderosa.Terminal,EUCCNProfile,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 2;
Magic Number,Poderosa.Terminal,EUCKRProfile,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,GetCharLength,The following statement contains a magic number: return 2;
Magic Number,Poderosa.Terminal,CharQueue,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,CharQueue,The following statement contains a magic number: _buffer = new char[80];
Magic Number,Poderosa.Terminal,IntelliSense,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSense.cs,OnNotPromptLine,The following statement contains a magic number: if (this.OwnsIntelliSenseWindow) {                  Debug.Assert(_context.OwnerControl.InvokeRequired);                  IAsyncResult ar = _context.OwnerControl.BeginInvoke(_intelliSenseWindow.CancelDelegate);                    /* NOTE                  /*  ここはTerminalDocumentのロック中に受信スレッドにおいて実行されるが、ここを実行するときメインスレッドがOnPaint内で待機している                   *  こともある。そのときはEndInvokeでデッドロックになる。                   *  ここでの実行はBeginInvokeさえしておけばよく、実行完了を待つ必要はないのであるが、EndInvokeを呼ばないとIAsyncResult内で持っている                   *  リソースがリークするかもしれない。                   *  これはちゃんと調べる必要があるが、調べるのも面倒なので「メインスレッドがブロックしているときのみ（＝Waitに失敗したときのみ）                   *  EndInvokeをさぼる」というようにしておく。もしリソースリークの危険がないのであればEndInvokeは不要。                   *                    *  IAsyncResultをコレクションに溜めておいて、短時間のWaitOneに成功するごとにコレクションから外すという手もある                   */                    if (ar.AsyncWaitHandle.WaitOne(100' false))                      _context.OwnerControl.EndInvoke(ar);              }
Magic Number,Poderosa.Terminal,IntelliSenseWindow,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,AdjustListBox,The following statement contains a magic number: _listBox.MaximumSize = new Size((int)(pitch.Width * 80)' (int)(pitch.Height * 10));
Magic Number,Poderosa.Terminal,IntelliSenseWindow,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,AdjustListBox,The following statement contains a magic number: _listBox.MaximumSize = new Size((int)(pitch.Width * 80)' (int)(pitch.Height * 10));
Magic Number,Poderosa.Terminal,IntelliSenseWindow,C:\repos\poderosaproject_poderosa\TerminalEmulator\IntelliSenseWindow.cs,ToControlPoint,The following statement contains a magic number: int x = (int)(textPoint.X * pitch.Width) - 2;
Magic Number,Poderosa.Terminal,Entry,C:\repos\poderosaproject_poderosa\TerminalEmulator\KeyFunction.cs,ParseData,The following statement contains a magic number: while (c < s.Length) {                      char ch = s[c];                      if (ch == '0' && c + 3 <= s.Length && s[c + 1] == 'x') { //0x00形式。                          int t;                          if (Int32.TryParse(s.Substring(c + 2' 2)' NumberStyles.HexNumber' null' out t)) {                              bld.Append((char)t);                          }                          c += 4;                      }                      else {                          bld.Append(ch);                          c++;                      }                  }
Magic Number,Poderosa.Terminal,Entry,C:\repos\poderosaproject_poderosa\TerminalEmulator\KeyFunction.cs,ParseData,The following statement contains a magic number: while (c < s.Length) {                      char ch = s[c];                      if (ch == '0' && c + 3 <= s.Length && s[c + 1] == 'x') { //0x00形式。                          int t;                          if (Int32.TryParse(s.Substring(c + 2' 2)' NumberStyles.HexNumber' null' out t)) {                              bld.Append((char)t);                          }                          c += 4;                      }                      else {                          bld.Append(ch);                          c++;                      }                  }
Magic Number,Poderosa.Terminal,Entry,C:\repos\poderosaproject_poderosa\TerminalEmulator\KeyFunction.cs,ParseData,The following statement contains a magic number: while (c < s.Length) {                      char ch = s[c];                      if (ch == '0' && c + 3 <= s.Length && s[c + 1] == 'x') { //0x00形式。                          int t;                          if (Int32.TryParse(s.Substring(c + 2' 2)' NumberStyles.HexNumber' null' out t)) {                              bld.Append((char)t);                          }                          c += 4;                      }                      else {                          bld.Append(ch);                          c++;                      }                  }
Magic Number,Poderosa.Terminal,Entry,C:\repos\poderosaproject_poderosa\TerminalEmulator\KeyFunction.cs,ParseData,The following statement contains a magic number: while (c < s.Length) {                      char ch = s[c];                      if (ch == '0' && c + 3 <= s.Length && s[c + 1] == 'x') { //0x00形式。                          int t;                          if (Int32.TryParse(s.Substring(c + 2' 2)' NumberStyles.HexNumber' null' out t)) {                              bld.Append((char)t);                          }                          c += 4;                      }                      else {                          bld.Append(ch);                          c++;                      }                  }
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,DefaultLogger,The following statement contains a magic number: if (withTimestamp)                  _timestampBuffer = new char[26];  // "YYYY-MM-DD hh:mm:ss'nnn - "              else                  _timestampBuffer = null;
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 4' dt.Year);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Month);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Day);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Hour);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Minute);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 2' dt.Second);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteTimestamp,The following statement contains a magic number: offset = WriteInt(buff' offset' 3' dt.Millisecond);
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteInt,The following statement contains a magic number: for (int i = 0; i < width; i++) {                  buff[--index] = (char)('0' + value % 10);                  value /= 10;              }
Magic Number,Poderosa.Terminal,DefaultLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,WriteInt,The following statement contains a magic number: for (int i = 0; i < width; i++) {                  buff[--index] = (char)('0' + value % 10);                  value /= 10;              }
Magic Number,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _fontSize = builder.DefineIntValue(_folder' "fontSize"' 10' PreferenceValidatorUtil.PositiveIntegerValidator);
Magic Number,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _lineSpacing = builder.DefineIntValue(_folder' "lineSpacing"' 0' PreferenceValidatorUtil.IntRangeValidator(0' 10));
Magic Number,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _terminalBufferSize = builder.DefineIntValue(_folder' "terminalBufferSize"' 1000' PreferenceValidatorUtil.PositiveIntegerValidator);
Magic Number,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _keepAliveInterval = builder.DefineIntValue(_folder' "keepAliveInterval"' 60000' PreferenceValidatorUtil.IntRangeValidator(0' 100 * 60000));
Magic Number,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _keepAliveInterval = builder.DefineIntValue(_folder' "keepAliveInterval"' 60000' PreferenceValidatorUtil.IntRangeValidator(0' 100 * 60000));
Magic Number,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _keepAliveInterval = builder.DefineIntValue(_folder' "keepAliveInterval"' 60000' PreferenceValidatorUtil.IntRangeValidator(0' 100 * 60000));
Magic Number,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _wheelAmount = builder.DefineIntValue(_folder' "wheelAmount"' 3' PreferenceValidatorUtil.PositiveIntegerValidator);
Magic Number,Poderosa.Terminal,TerminalOptions,C:\repos\poderosaproject_poderosa\TerminalEmulator\Options.cs,DefineItems,The following statement contains a magic number: _shellHistoryLimitCount = builder.DefineIntValue(_folder' "shellHistoryLimitCount"' 100' PreferenceValidatorUtil.PositiveIntegerValidator);
Magic Number,Poderosa.Terminal,GenericShellScheme,C:\repos\poderosaproject_poderosa\TerminalEmulator\ShellScheme.cs,ParseCommandList,The following statement contains a magic number: while (cursor < value.Length) {                  char mark = DetermineDelimiter(value' cursor);                  int delim = value.IndexOf(mark' cursor);                  if (delim == -1)                      delim = value.Length;                  if (mark != ';')                      cursor += 2; // "\\["等の分                  string command = value.Substring(cursor' delim - cursor);                  _intelliSenseItemCollection.AddLast(new IntelliSenseItem(this.ParseCommandInput(command)));                  cursor = delim + 1;                  if (mark != ';')                      cursor++;              }
Magic Number,Poderosa.Terminal,EscapeSequenceTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,GetNextTabStop,The following statement contains a magic number: t += (8 - t % 8);
Magic Number,Poderosa.Terminal,EscapeSequenceTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,GetNextTabStop,The following statement contains a magic number: t += (8 - t % 8);
Magic Number,Poderosa.Terminal,EscapeSequenceTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ProcessNormalUnicodeChar,The following statement contains a magic number: if (_manipulator.CaretColumn + (unicodeChar.IsWideWidth ? 2 : 1) > tw) {                  _manipulator.EOLType = EOLType.Continue;                  GLine lineUpdated = GetDocument().UpdateCurrentLine(_manipulator);                  if (lineUpdated != null) {                      this.LogService.TextLogger.WriteLine(lineUpdated);                  }                  GetDocument().LineFeed();                  _manipulator.Load(GetDocument().CurrentLine' 0);              }
Magic Number,Poderosa.Terminal,EscapeSequenceTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ParseIntPair,The following statement contains a magic number: if (s.Length >= 2 && s[1].Length > 0) {                  try {                      ret.second = Int32.Parse(s[1]);                  }                  catch (Exception ex) {                      throw new UnknownEscapeSequenceException(String.Format("bad number format [{0}] : {1}"' s[1]' ex.Message));                  }              }
Magic Number,Poderosa.Terminal,TerminalDocument,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalDocument.cs,LineFeed,The following statement contains a magic number: if (_scrollingTop != -1 && _currentLine.ID >= _scrollingBottom) { //ロックされていて下まで行っている                  ScrollDown();              }              else {                  if (_height > 1) { //極端に高さがないときはこれで変な値になってしまうのでスキップ                      if (_currentLine.ID >= _topLine.ID + _height - 1)                          this.TopLineNumber = _currentLine.ID - _height + 2; //これで次のCurrentLineNumber++と合わせて行送りになる                  }                  this.CurrentLineNumber++; //これでプロパティセットがなされ、必要なら行の追加もされる。              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,TerminalControl,The following statement contains a magic number: _sizeTipTimer.Interval = 2000;
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,InitializeComponent,The following statement contains a magic number: this._sizeTip.Size = new Size(64' 16);
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,InitializeComponent,The following statement contains a magic number: this._sizeTip.Size = new Size(64' 16);
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SmartInvalidate,The following statement contains a magic number: switch (_drawOptimizingState) {                  case 0:                      _drawOptimizingState = 1;                      InvalidateEx();                      break;                  case 1:                      if (_session.TerminalConnection.Socket.Available)                          Interlocked.Exchange(ref _drawOptimizingState' 2); //間引きモードへ                      else                          InvalidateEx();                      break;                  case 2:                      break; //do nothing              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SmartInvalidate,The following statement contains a magic number: switch (_drawOptimizingState) {                  case 0:                      _drawOptimizingState = 1;                      InvalidateEx();                      break;                  case 1:                      if (_session.TerminalConnection.Socket.Available)                          Interlocked.Exchange(ref _drawOptimizingState' 2); //間引きモードへ                      else                          InvalidateEx();                      break;                  case 2:                      break; //do nothing              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnWindowManagerTimer,The following statement contains a magic number: switch (_drawOptimizingState) {                  case 0:                      break; //do nothing                  case 1:                      Interlocked.CompareExchange(ref _drawOptimizingState' 0' 1);                      break;                  case 2: //忙しくても偶には描画                      _drawOptimizingState = 1;                      InvalidateEx();                      break;              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessSpecialAltKey,The following statement contains a magic number: if ((modifiers & Keys.Control) != Keys.None)                  ch = (char)((int)ch % 32);
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessSpecialAltKey,The following statement contains a magic number: if (act == AltKeyAction.ESC) {                  byte[] t = new byte[2];                  t[0] = 0x1B;                  t[1] = (byte)ch;                  //Debug.WriteLine("ESC " + (int)ch);                  SendBytes(t);              }              else { //Meta                  ch = (char)(0x80 + ch);                  byte[] t = new byte[1];                  t[0] = (byte)ch;                  //Debug.WriteLine("META " + (int)ch);                  SendBytes(t);              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,CalcTerminalSize,The following statement contains a magic number: int width = (int)Math.Floor((float)(this.ClientSize.Width - sm.ScrollBarWidth - CharacterDocumentViewer.BORDER * 2) / charPitch.Width);
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,CalcTerminalSize,The following statement contains a magic number: int height = (int)Math.Floor((float)(this.ClientSize.Height - CharacterDocumentViewer.BORDER * 2 + prof.LineSpacing) / (charPitch.Height + prof.LineSpacing));
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ShowSizeTip,The following statement contains a magic number: const int MARGIN = 8;
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SplitterDragging,The following statement contains a magic number: width = (int)Math.Floor(((float)width - sm.ScrollBarWidth - sm.ControlBorderWidth * 2) / charSize.Width);
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SplitterDragging,The following statement contains a magic number: height = (int)Math.Floor((float)(height - sm.ControlBorderHeight * 2) / charSize.Height);
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessVScrollMessage,The following statement contains a magic number: switch (cmd) {                  case 0: //SB_LINEUP                      newval--;                      break;                  case 1: //SB_LINEDOWN                      newval++;                      break;                  case 2: //SB_PAGEUP                      newval -= GetDocument().TerminalHeight;                      break;                  case 3: //SB_PAGEDOWN                      newval += GetDocument().TerminalHeight;                      break;              }
Magic Number,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessVScrollMessage,The following statement contains a magic number: switch (cmd) {                  case 0: //SB_LINEUP                      newval--;                      break;                  case 1: //SB_LINEDOWN                      newval++;                      break;                  case 2: //SB_PAGEUP                      newval -= GetDocument().TerminalHeight;                      break;                  case 3: //SB_PAGEDOWN                      newval += GetDocument().TerminalHeight;                      break;              }
Magic Number,Poderosa.Terminal,MouseWheelHandler,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnMouseWheel,The following statement contains a magic number: if (_scrollBar.Enabled) {                  int d = args.Delta / 120; //開発環境だとDeltaに120。これで1か-1が入るはず                  d *= GEnv.Options.WheelAmount;                    int newval = _scrollBar.Value - d;                  if (newval < 0)                      newval = 0;                  if (newval > _scrollBar.Maximum - _scrollBar.LargeChange)                      newval = _scrollBar.Maximum - _scrollBar.LargeChange + 1;                  _scrollBar.Value = newval;              }
Magic Number,Poderosa.Terminal,DrawingPerformance,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,MarkReceiveData,The following statement contains a magic number: if (_lastReceivedTime != 0) {                  if (now - _lastReceivedTime < 10 * 1000 * 100)                      _shortReceiveTimeCount++;              }
Magic Number,Poderosa.Terminal,DrawingPerformance,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,MarkReceiveData,The following statement contains a magic number: if (_lastReceivedTime != 0) {                  if (now - _lastReceivedTime < 10 * 1000 * 100)                      _shortReceiveTimeCount++;              }
Magic Number,Poderosa.Terminal,DrawingPerformance,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,MarkReceiveData,The following statement contains a magic number: if (_lastReceivedTime != 0) {                  if (now - _lastReceivedTime < 10 * 1000 * 100)                      _shortReceiveTimeCount++;              }
Magic Number,Poderosa.Terminal,TerminalUtil,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,NewLineChars,The following statement contains a magic number: switch (nl) {                  case NewLine.CR:                      return new char[1] { '\r' };                  case NewLine.LF:                      return new char[1] { '\n' };                  case NewLine.CRLF:                      return new char[2] { '\r'' '\n' };                  default:                      throw new ArgumentException("Unknown NewLine " + nl);              }
Magic Number,Poderosa.Terminal,TerminalUtil,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,NewLineBytes,The following statement contains a magic number: switch (nl) {                  case NewLine.CR:                      return new byte[1] { (byte)'\r' };                  case NewLine.LF:                      return new byte[1] { (byte)'\n' };                  case NewLine.CRLF:                      return new byte[2] { (byte)'\r'' (byte)'\n' };                  default:                      throw new ArgumentException("Unknown NewLine " + nl);              }
Magic Number,Poderosa.Terminal,KeyboardInfo,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,Init,The following statement contains a magic number: _defaultGroup = new char[256];
Magic Number,Poderosa.Terminal,KeyboardInfo,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,Init,The following statement contains a magic number: _shiftGroup = new char[256];
Magic Number,Poderosa.Terminal,KeyboardInfo,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,Init,The following statement contains a magic number: for (int i = 32; i < 128; i++) {                  short v = Win32.VkKeyScan((char)i);                  bool shift = (v & 0x0100) != 0;                  short body = (short)(v & 0x00FF);                  if (shift)                      _shiftGroup[body] = (char)i;                  else                      _defaultGroup[body] = (char)i;              }
Magic Number,Poderosa.Terminal,KeyboardInfo,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalUtil.cs,Init,The following statement contains a magic number: for (int i = 32; i < 128; i++) {                  short v = Win32.VkKeyScan((char)i);                  bool shift = (v & 0x0100) != 0;                  short body = (short)(v & 0x00FF);                  if (shift)                      _shiftGroup[body] = (char)i;                  else                      _defaultGroup[body] = (char)i;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessSGRParameterANSI,The following statement contains a magic number: switch (code) {                  case 0: // default rendition (implementation-defined) (ECMA-48'VT100'VT220)                      dec = TextDecoration.Default;                      break;                  case 1: // bold or increased intensity (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithBold(true);                      break;                  case 2: // faint' decreased intensity or second colour (ECMA-48)                      break;                  case 3: // italicized (ECMA-48)                      break;                  case 4: // singly underlined (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithUnderline(true);                      break;                  case 5: // slowly blinking (ECMA-48'VT100'VT220)                  case 6: // rapidly blinking (ECMA-48)                      dec = dec.GetCopyWithBlink(true);                      break;                  case 7: // negative image (ECMA-48'VT100'VT220)                      dec = dec.GetCopyWithInverted(true);                      break;                  case 8: // concealed characters (ECMA-48'VT300)                  case 9: // crossed-out (ECMA-48)                  case 10: // primary (default) font (ECMA-48)                  case 11: // first alternative font (ECMA-48)                  case 12: // second alternative font (ECMA-48)                  case 13: // third alternative font (ECMA-48)                  case 14: // fourth alternative font (ECMA-48)                  case 15: // fifth alternative font (ECMA-48)                  case 16: // sixth alternative font (ECMA-48)                  case 17: // seventh alternative font (ECMA-48)                  case 18: // eighth alternative font (ECMA-48)                  case 19: // ninth alternative font (ECMA-48)                  case 20: // Fraktur (Gothic) (ECMA-48)                  case 21: // doubly underlined (ECMA-48)                      break;                  case 22: // normal colour or normal intensity (neither bold nor faint) (ECMA-48'VT220'VT300)                      dec = TextDecoration.Default;                      break;                  case 23: // not italicized' not fraktur (ECMA-48)                      break;                  case 24: // not underlined (neither singly nor doubly) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithUnderline(false);                      break;                  case 25: // steady (not blinking) (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithBlink(false);                      break;                  case 26: // reserved (ECMA-48)                      break;                  case 27: // positive image (ECMA-48'VT220'VT300)                      dec = dec.GetCopyWithInverted(false);                      break;                  case 28: // revealed characters (ECMA-48)                  case 29: // not crossed out (ECMA-48)                      break;                  case 30: // black display (ECMA-48)                  case 31: // red display (ECMA-48)                  case 32: // green display (ECMA-48)                  case 33: // yellow display (ECMA-48)                  case 34: // blue display (ECMA-48)                  case 35: // magenta display (ECMA-48)                  case 36: // cyan display (ECMA-48)                  case 37: // white display (ECMA-48)                      dec = SelectForeColor(dec' code - 30);                      break;                  case 38: // reserved (ECMA-48)                      break;                  case 39: // default display colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithForeColor(ColorSpec.Default);                      break;                  case 40: // black background (ECMA-48)                  case 41: // red background (ECMA-48)                  case 42: // green background (ECMA-48)                  case 43: // yellow background (ECMA-48)                  case 44: // blue background (ECMA-48)                  case 45: // magenta background (ECMA-48)                  case 46: // cyan background (ECMA-48)                  case 47: // white background (ECMA-48)                      dec = SelectBackgroundColor(dec' code - 40);                      break;                  case 48: // reserved (ECMA-48)                      break;                  case 49: // default background colour (implementation-defined) (ECMA-48)                      dec = dec.GetCopyWithBackColor(ColorSpec.Default);                      break;                  case 50: // reserved (ECMA-48)                  case 51: // framed (ECMA-48)                  case 52: // encircled (ECMA-48)                  case 53: // overlined (ECMA-48)                  case 54: // not framed' not encircled (ECMA-48)                  case 55: // not overlined (ECMA-48)                  case 56: // reserved (ECMA-48)                  case 57: // reserved (ECMA-48)                  case 58: // reserved (ECMA-48)                  case 59: // reserved (ECMA-48)                  case 60: // ideogram underline or right side line (ECMA-48)                  case 61: // ideogram double underline or double line on the right side (ECMA-48)                  case 62: // ideogram overline or left side line (ECMA-48)                  case 63: // ideogram double overline or double line on the left side (ECMA-48)                  case 64: // ideogram stress marking (ECMA-48)                  case 65: // cancels the effect of the rendition aspects established by parameter values 60 to 64 (ECMA-48)                      break;                  default:                      // other values are ignored without notification to the user                      Debug.WriteLine("unknown SGR code (ANSI) : {0}"' code);                      break;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ParseSGRCode,The following statement contains a magic number: if (param.Length == 0)                  return 0;              else if (param.Length == 1)                  return param[0] - '0';              else if (param.Length == 2)                  return (param[0] - '0') * 10 + (param[1] - '0');              else if (param.Length == 3)                  return (param[0] - '0') * 100 + (param[1] - '0') * 10 + (param[2] - '0');              else                  throw new UnknownEscapeSequenceException(String.Format("unknown SGR parameter {0}"' param));
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ParseSGRCode,The following statement contains a magic number: if (param.Length == 0)                  return 0;              else if (param.Length == 1)                  return param[0] - '0';              else if (param.Length == 2)                  return (param[0] - '0') * 10 + (param[1] - '0');              else if (param.Length == 3)                  return (param[0] - '0') * 100 + (param[1] - '0') * 10 + (param[2] - '0');              else                  throw new UnknownEscapeSequenceException(String.Format("unknown SGR parameter {0}"' param));
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ParseSGRCode,The following statement contains a magic number: if (param.Length == 0)                  return 0;              else if (param.Length == 1)                  return param[0] - '0';              else if (param.Length == 2)                  return (param[0] - '0') * 10 + (param[1] - '0');              else if (param.Length == 3)                  return (param[0] - '0') * 100 + (param[1] - '0') * 10 + (param[2] - '0');              else                  throw new UnknownEscapeSequenceException(String.Format("unknown SGR parameter {0}"' param));
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ParseSGRCode,The following statement contains a magic number: if (param.Length == 0)                  return 0;              else if (param.Length == 1)                  return param[0] - '0';              else if (param.Length == 2)                  return (param[0] - '0') * 10 + (param[1] - '0');              else if (param.Length == 3)                  return (param[0] - '0') * 100 + (param[1] - '0') * 10 + (param[2] - '0');              else                  throw new UnknownEscapeSequenceException(String.Format("unknown SGR parameter {0}"' param));
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ParseSGRCode,The following statement contains a magic number: if (param.Length == 0)                  return 0;              else if (param.Length == 1)                  return param[0] - '0';              else if (param.Length == 2)                  return (param[0] - '0') * 10 + (param[1] - '0');              else if (param.Length == 3)                  return (param[0] - '0') * 100 + (param[1] - '0') * 10 + (param[2] - '0');              else                  throw new UnknownEscapeSequenceException(String.Format("unknown SGR parameter {0}"' param));
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ParseSGRCode,The following statement contains a magic number: if (param.Length == 0)                  return 0;              else if (param.Length == 1)                  return param[0] - '0';              else if (param.Length == 2)                  return (param[0] - '0') * 10 + (param[1] - '0');              else if (param.Length == 3)                  return (param[0] - '0') * 100 + (param[1] - '0') * 10 + (param[2] - '0');              else                  throw new UnknownEscapeSequenceException(String.Format("unknown SGR parameter {0}"' param));
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessEraseInDisplay,The following statement contains a magic number: switch (d) {                  case 0: //erase below                      {                          if (col == 0 && cur == top)                              goto ERASE_ALL;                            EraseRight();                          doc.UpdateCurrentLine(_manipulator);                          doc.EnsureLine(bottom - 1);                          doc.RemoveAfter(bottom);                          doc.ClearRange(cur + 1' bottom' _currentdecoration);                          _manipulator.Load(doc.CurrentLine' col);                      }                      break;                  case 1: //erase above                      {                          if (col == doc.TerminalWidth - 1 && cur == bottom - 1)                              goto ERASE_ALL;                            EraseLeft();                          doc.UpdateCurrentLine(_manipulator);                          doc.ClearRange(top' cur' _currentdecoration);                          _manipulator.Load(doc.CurrentLine' col);                      }                      break;                  case 2: //erase all                  ERASE_ALL: {                          GetDocument().ApplicationModeBackColor =                              (_currentdecoration != null) ? _currentdecoration.GetBackColorSpec() : ColorSpec.Default;                            doc.UpdateCurrentLine(_manipulator);                          //if(_homePositionOnCSIJ2) { //SFUではこうなる                          //	ProcessCursorPosition(1'1);                           //	col = 0;                          //}                          doc.EnsureLine(bottom - 1);                          doc.RemoveAfter(bottom);                          doc.ClearRange(top' bottom' _currentdecoration);                          _manipulator.Load(doc.CurrentLine' col);                      }                      break;                  default:                      throw new UnknownEscapeSequenceException(String.Format("unknown ED option {0}"' param));              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessEraseInLine,The following statement contains a magic number: switch (d) {                  case 0: //erase right                      EraseRight();                      break;                  case 1: //erase left                      EraseLeft();                      break;                  case 2: //erase all                      EraseLine();                      break;                  default:                      throw new UnknownEscapeSequenceException(String.Format("unknown EL option {0}"' param));              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)body && (int)body <= (int)Keys.F12) {                  byte[] r = new byte[5];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  int n = (int)body - (int)Keys.F1;                  if ((modifier & Keys.Shift) != Keys.None)                      n += 10; //shiftは値を10ずらす                  char tail;                  if (n >= 20)                      tail = (modifier & Keys.Control) != Keys.None ? '@' : '$';                  else                      tail = (modifier & Keys.Control) != Keys.None ? '^' : '~';                  string f = FUNCTIONKEY_MAP[n];                  r[2] = (byte)f[0];                  r[3] = (byte)f[1];                  r[4] = (byte)tail;                  return r;              }              else if (GUtil.IsCursorKey(body)) {                  byte[] r = new byte[3];                  r[0] = 0x1B;                  if (_cursorKeyMode == TerminalMode.Normal)                      r[1] = (byte)'[';                  else                      r[1] = (byte)'O';                    switch (body) {                      case Keys.Up:                          r[2] = (byte)'A';                          break;                      case Keys.Down:                          r[2] = (byte)'B';                          break;                      case Keys.Right:                          r[2] = (byte)'C';                          break;                      case Keys.Left:                          r[2] = (byte)'D';                          break;                      default:                          throw new ArgumentException("unknown cursor key code"' "key");                  }                  return r;              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  if (body == Keys.Insert)                      r[2] = (byte)'1';                  else if (body == Keys.Home)                      r[2] = (byte)'2';                  else if (body == Keys.PageUp)                      r[2] = (byte)'3';                  else if (body == Keys.Delete)                      r[2] = (byte)'4';                  else if (body == Keys.End)                      r[2] = (byte)'5';                  else if (body == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + body.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XmlLogger,C:\repos\poderosaproject_poderosa\TerminalEmulator\XmlLogger.cs,Write,The following statement contains a magic number: lock (_sync) {                  if (_closed)                      return;                    switch (ch) {                      case (char)0:                          WriteSPChar("NUL");                          break;                      case (char)1:                          WriteSPChar("SOH");                          break;                      case (char)2:                          WriteSPChar("STX");                          break;                      case (char)3:                          WriteSPChar("ETX");                          break;                      case (char)4:                          WriteSPChar("EOT");                          break;                      case (char)5:                          WriteSPChar("ENQ");                          break;                      case (char)6:                          WriteSPChar("ACK");                          break;                      case (char)7:                          WriteSPChar("BEL");                          break;                      case (char)8:                          WriteSPChar("BS");                          break;                      case (char)11:                          WriteSPChar("VT");                          break;                      case (char)12:                          WriteSPChar("FF");                          break;                      case (char)14:                          WriteSPChar("SO");                          break;                      case (char)15:                          WriteSPChar("SI");                          break;                      case (char)16:                          WriteSPChar("DLE");                          break;                      case (char)17:                          WriteSPChar("DC1");                          break;                      case (char)18:                          WriteSPChar("DC2");                          break;                      case (char)19:                          WriteSPChar("DC3");                          break;                      case (char)20:                          WriteSPChar("DC4");                          break;                      case (char)21:                          WriteSPChar("NAK");                          break;                      case (char)22:                          WriteSPChar("SYN");                          break;                      case (char)23:                          WriteSPChar("ETB");                          break;                      case (char)24:                          WriteSPChar("CAN");                          break;                      case (char)25:                          WriteSPChar("EM");                          break;                      case (char)26:                          WriteSPChar("SUB");                          break;                      case (char)27:                          WriteSPChar("ESC");                          break;                      case (char)28:                          WriteSPChar("FS");                          break;                      case (char)29:                          WriteSPChar("GS");                          break;                      case (char)30:                          WriteSPChar("RS");                          break;                      case (char)31:                          WriteSPChar("US");                          break;                      default:                          _buffer[0] = ch;                          _writer.WriteChars(_buffer' 0' 1);                          break;                  }                    Wrote();              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following statement contains a magic number: switch (protocol) {                    case MouseTrackingProtocol.Normal:                      data = new byte[] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          (col == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(col + (1 + 0x20))'   // column 0 --> send as 1                          (row == posLimit) ?                              (byte)0 :                   // emulate xterm's bug                              (byte)(row + (1 + 0x20))'   // row 0 --> send as 1                      };                      dataLen = 6;                      break;                    case MouseTrackingProtocol.Utf8:                      data = new byte[8] {                          (byte)27' // ESCAPE                          (byte)91' // [                          (byte)77' // M                          (byte)statBits'                          0'0'0'0'                      };                        dataLen = 4;                        if (col < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(col + (1 + 0x20));     // column 0 --> send as 1                      else { // encode in UTF-8                          int val = col + 1 + 0x20;                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                        if (row < MOUSE_POS_EXT_START)                          data[dataLen++] = (byte)(row + (1 + 0x20));     // row 0 --> send as 1                      else { // encode in UTF-8                          int val = row + (1 + 0x20);                          data[dataLen++] = (byte)(0xc0 + (val >> 6));                          data[dataLen++] = (byte)(0x80 + (val & 0x3f));                      }                      break;                    case MouseTrackingProtocol.Urxvt:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append("M")                              .ToString());                      dataLen = data.Length;                      break;                    case MouseTrackingProtocol.Sgr:                      data = Encoding.ASCII.GetBytes(                          new StringBuilder()                              .Append("\x1b[<")                              .Append(statBits.ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((col + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(';')                              .Append((row + 1).ToString(NumberFormatInfo.InvariantInfo))                              .Append(action == TerminalMouseAction.ButtonUp ? 'm' : 'M')                              .ToString());                      dataLen = data.Length;                      break;                    default:                      return true;    // unknown protocol              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessNormalUnicodeChar,The following statement contains a magic number: if (_insertMode)                  _manipulator.InsertBlanks(_manipulator.CaretColumn' ch.IsWideWidth ? 2 : 1' _currentdecoration);
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following statement contains a magic number: if (ps == "0" || ps == "2") {                  IDynamicCaptionFormatter[] fmts = TerminalEmulatorPlugin.Instance.DynamicCaptionFormatter;                  TerminalDocument doc = GetDocument();                    if (fmts.Length > 0) {                      ITerminalSettings settings = GetTerminalSettings();                      string title = fmts[0].FormatCaptionUsingWindowTitle(GetConnection().Destination' settings' pt);                      _afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' title).Do));                  }                  //Quick Test                  //_afterExitLockActions.Add(new AfterExitLockDelegate(new CaptionChanger(GetTerminalSettings()' pt).Do));                    return ProcessCharResult.Processed;              }              else if (ps == "1")                  return ProcessCharResult.Processed; //Set Icon Nameというやつだが無視でよさそう              else if (ps == "4") {                  // パレット変更                  //   形式: OSC 4 ; 色番号 ; 色指定 ST                  //     色番号: 0～255                  //     色指定: 以下の形式のどれか                  //       #rgb                  //       #rrggbb                  //       #rrrgggbbb                  //       #rrrrggggbbbb                  //       rgb:r/g/b                  //       rgb:rr/gg/bb                  //       rgb:rrr/ggg/bbb                  //       rgb:rrrr/gggg/bbbb                  //       他にも幾つか形式があるけれど、通常はこれで十分と思われる。                  //       他の形式は XParseColor(1) を参照                  //                  // 参考: http://ttssh2.sourceforge.jp/manual/ja/about/ctrlseq.html#OSC                  //                  while ((semicolon = pt.IndexOf(';')) != -1) {                      string pv = pt.Substring(semicolon + 1);                      int pn;                      if (Int32.TryParse(pt.Substring(0' semicolon)' out pn) && pn >= 0 && pn <= 255) {                          if ((semicolon = pv.IndexOf(';')) != -1) {                              pt = pv.Substring(semicolon + 1);                              pv = pv.Substring(0' semicolon);                          }                          else {                              pt = pv;                          }                          int r' g' b;                          if (pv.StartsWith("#")) {                              switch (pv.Length) {                                  case 4: // #rgb                                      if (Int32.TryParse(pv.Substring(1' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(2' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(3' 1)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 7: // #rrggbb                                      if (Int32.TryParse(pv.Substring(1' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(3' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(5' 2)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 10: // #rrrgggbbb                                      if (Int32.TryParse(pv.Substring(1' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(4' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(7' 3)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  case 13: // #rrrrggggbbbb                                      if (Int32.TryParse(pv.Substring(1' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r) &&                                          Int32.TryParse(pv.Substring(5' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g) &&                                          Int32.TryParse(pv.Substring(9' 4)' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                      }                                      else {                                          return ProcessCharResult.Unsupported;                                      }                                      break;                                  default:                                      return ProcessCharResult.Unsupported;                              }                          }                          else if (pv.StartsWith("rgb:")) { // rgb:rr/gg/bb                              string[] vals = pv.Substring(4).Split(new Char[] { '/' });                              if (vals.Length == 3                                  && vals[0].Length == vals[1].Length                                  && vals[0].Length == vals[2].Length                                  && vals[0].Length > 0                                  && vals[0].Length <= 4                                  && Int32.TryParse(vals[0]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out r)                                  && Int32.TryParse(vals[1]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out g)                                  && Int32.TryParse(vals[2]' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo' out b)) {                                  switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }                              }                              else {                                  return ProcessCharResult.Unsupported;                              }                          }                          else {                              return ProcessCharResult.Unsupported;                          }                          GetRenderProfile().ESColorSet[pn] = new ESColor(Color.FromArgb(r' g' b)' true);                      }                      else {                          return ProcessCharResult.Unsupported;                      }                  }                  return ProcessCharResult.Processed;              }              else                  return ProcessCharResult.Unsupported;
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following statement contains a magic number: foreach (string cmd in ps) {                  int code = ParseSGRCode(cmd);                  if (state != 0) {                      switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }                  }                  else {                      switch (code) {                          case 8: // concealed characters (ECMA-48'VT300)                              dec = dec.GetCopyWithHidden(true);                              break;                          case 28: // revealed characters (ECMA-48)                              dec = dec.GetCopyWithHidden(false);                              break;                          case 38: // Set foreground color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 3; // set foreground color                              break;                          case 48: // Set background color (XTERM'ISO-8613-3)                              state = 1;  // start reading subsequent values                              target = 4; // set background color                              break;                          case 90: // Set foreground color to Black (XTERM)                          case 91: // Set foreground color to Red (XTERM)                          case 92: // Set foreground color to Green (XTERM)                          case 93: // Set foreground color to Yellow (XTERM)                          case 94: // Set foreground color to Blue (XTERM)                          case 95: // Set foreground color to Magenta (XTERM)                          case 96: // Set foreground color to Cyan (XTERM)                          case 97: // Set foreground color to White (XTERM)                              dec = SelectForeColor(dec' code - 90 + 8);                              break;                          case 100: // Set background color to Black (XTERM)                          case 101: // Set background color to Red (XTERM)                          case 102: // Set background color to Green (XTERM)                          case 103: // Set background color to Yellow (XTERM)                          case 104: // Set background color to Blue (XTERM)                          case 105: // Set background color to Magenta (XTERM)                          case 106: // Set background color to Cyan (XTERM)                          case 107: // Set background color to White (XTERM)                              dec = SelectBackgroundColor(dec' code - 100 + 8);                              break;                          default:                              ProcessSGRParameterANSI(code' ref dec);                              break;                      }                  }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,InitTabStops,The following statement contains a magic number: for (int i = 0; i < _tabStops.Length; i++) {                  _tabStops[i] = (i % 8) == 0;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,EnsureTabStops,The following statement contains a magic number: if (length >= _tabStops.Length) {                  bool[] newarray = new bool[Math.Max(length' _tabStops.Length * 2)];                  Array.Copy(_tabStops' 0' newarray' 0' _tabStops.Length);                  for (int i = _tabStops.Length; i < newarray.Length; i++) {                      newarray[i] = (i % 8) == 0;                  }                  _tabStops = newarray;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,EnsureTabStops,The following statement contains a magic number: if (length >= _tabStops.Length) {                  bool[] newarray = new bool[Math.Max(length' _tabStops.Length * 2)];                  Array.Copy(_tabStops' 0' newarray' 0' _tabStops.Length);                  for (int i = _tabStops.Length; i < newarray.Length; i++) {                      newarray[i] = (i % 8) == 0;                  }                  _tabStops = newarray;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)key && (int)key <= (int)Keys.F12)                  return XtermFunctionKey(modifier' key);              else if (GUtil.IsCursorKey(key)) {                  byte[] data = ModifyCursorKey(modifier' key);                  if (data != null)                      return data;                  return base.SequenceKeyData(modifier' key);              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  //このあたりはxtermでは割と違うようだ                  if (key == Keys.Insert)                      r[2] = (byte)'2';                  else if (key == Keys.Home)                      r[2] = (byte)'7';                  else if (key == Keys.PageUp)                      r[2] = (byte)'5';                  else if (key == Keys.Delete)                      r[2] = (byte)'3';                  else if (key == Keys.End)                      r[2] = (byte)'8';                  else if (key == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + key.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)key && (int)key <= (int)Keys.F12)                  return XtermFunctionKey(modifier' key);              else if (GUtil.IsCursorKey(key)) {                  byte[] data = ModifyCursorKey(modifier' key);                  if (data != null)                      return data;                  return base.SequenceKeyData(modifier' key);              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  //このあたりはxtermでは割と違うようだ                  if (key == Keys.Insert)                      r[2] = (byte)'2';                  else if (key == Keys.Home)                      r[2] = (byte)'7';                  else if (key == Keys.PageUp)                      r[2] = (byte)'5';                  else if (key == Keys.Delete)                      r[2] = (byte)'3';                  else if (key == Keys.End)                      r[2] = (byte)'8';                  else if (key == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + key.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)key && (int)key <= (int)Keys.F12)                  return XtermFunctionKey(modifier' key);              else if (GUtil.IsCursorKey(key)) {                  byte[] data = ModifyCursorKey(modifier' key);                  if (data != null)                      return data;                  return base.SequenceKeyData(modifier' key);              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  //このあたりはxtermでは割と違うようだ                  if (key == Keys.Insert)                      r[2] = (byte)'2';                  else if (key == Keys.Home)                      r[2] = (byte)'7';                  else if (key == Keys.PageUp)                      r[2] = (byte)'5';                  else if (key == Keys.Delete)                      r[2] = (byte)'3';                  else if (key == Keys.End)                      r[2] = (byte)'8';                  else if (key == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + key.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)key && (int)key <= (int)Keys.F12)                  return XtermFunctionKey(modifier' key);              else if (GUtil.IsCursorKey(key)) {                  byte[] data = ModifyCursorKey(modifier' key);                  if (data != null)                      return data;                  return base.SequenceKeyData(modifier' key);              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  //このあたりはxtermでは割と違うようだ                  if (key == Keys.Insert)                      r[2] = (byte)'2';                  else if (key == Keys.Home)                      r[2] = (byte)'7';                  else if (key == Keys.PageUp)                      r[2] = (byte)'5';                  else if (key == Keys.Delete)                      r[2] = (byte)'3';                  else if (key == Keys.End)                      r[2] = (byte)'8';                  else if (key == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + key.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)key && (int)key <= (int)Keys.F12)                  return XtermFunctionKey(modifier' key);              else if (GUtil.IsCursorKey(key)) {                  byte[] data = ModifyCursorKey(modifier' key);                  if (data != null)                      return data;                  return base.SequenceKeyData(modifier' key);              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  //このあたりはxtermでは割と違うようだ                  if (key == Keys.Insert)                      r[2] = (byte)'2';                  else if (key == Keys.Home)                      r[2] = (byte)'7';                  else if (key == Keys.PageUp)                      r[2] = (byte)'5';                  else if (key == Keys.Delete)                      r[2] = (byte)'3';                  else if (key == Keys.End)                      r[2] = (byte)'8';                  else if (key == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + key.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)key && (int)key <= (int)Keys.F12)                  return XtermFunctionKey(modifier' key);              else if (GUtil.IsCursorKey(key)) {                  byte[] data = ModifyCursorKey(modifier' key);                  if (data != null)                      return data;                  return base.SequenceKeyData(modifier' key);              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  //このあたりはxtermでは割と違うようだ                  if (key == Keys.Insert)                      r[2] = (byte)'2';                  else if (key == Keys.Home)                      r[2] = (byte)'7';                  else if (key == Keys.PageUp)                      r[2] = (byte)'5';                  else if (key == Keys.Delete)                      r[2] = (byte)'3';                  else if (key == Keys.End)                      r[2] = (byte)'8';                  else if (key == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + key.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)key && (int)key <= (int)Keys.F12)                  return XtermFunctionKey(modifier' key);              else if (GUtil.IsCursorKey(key)) {                  byte[] data = ModifyCursorKey(modifier' key);                  if (data != null)                      return data;                  return base.SequenceKeyData(modifier' key);              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  //このあたりはxtermでは割と違うようだ                  if (key == Keys.Insert)                      r[2] = (byte)'2';                  else if (key == Keys.Home)                      r[2] = (byte)'7';                  else if (key == Keys.PageUp)                      r[2] = (byte)'5';                  else if (key == Keys.Delete)                      r[2] = (byte)'3';                  else if (key == Keys.End)                      r[2] = (byte)'8';                  else if (key == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + key.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,SequenceKeyData,The following statement contains a magic number: if ((int)Keys.F1 <= (int)key && (int)key <= (int)Keys.F12)                  return XtermFunctionKey(modifier' key);              else if (GUtil.IsCursorKey(key)) {                  byte[] data = ModifyCursorKey(modifier' key);                  if (data != null)                      return data;                  return base.SequenceKeyData(modifier' key);              }              else {                  byte[] r = new byte[4];                  r[0] = 0x1B;                  r[1] = (byte)'[';                  r[3] = (byte)'~';                  //このあたりはxtermでは割と違うようだ                  if (key == Keys.Insert)                      r[2] = (byte)'2';                  else if (key == Keys.Home)                      r[2] = (byte)'7';                  else if (key == Keys.PageUp)                      r[2] = (byte)'5';                  else if (key == Keys.Delete)                      r[2] = (byte)'3';                  else if (key == Keys.End)                      r[2] = (byte)'8';                  else if (key == Keys.PageDown)                      r[2] = (byte)'6';                  else                      throw new ArgumentException("unknown key " + key.ToString());                  return r;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,XtermFunctionKey,The following statement contains a magic number: if ((modifier & Keys.Alt) != Keys.None) {                  m += 2;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,XtermFunctionKey,The following statement contains a magic number: if ((modifier & Keys.Control) != Keys.None) {                  m += 4;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: if ((modifier & Keys.Alt) != Keys.None) {                  m += 2;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: if ((modifier & Keys.Control) != Keys.None) {                  m += 4;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: if (m == 1 || m == 8) {                  return null;              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: switch (XTermPreferences.Instance.modifyCursorKeys) {                  // only modifyCursorKeys=2 and modifyCursorKeys=3 are supported                  case 2: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }                  case 3: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'>'' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }              }
Magic Number,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following statement contains a magic number: switch (XTermPreferences.Instance.modifyCursorKeys) {                  // only modifyCursorKeys=2 and modifyCursorKeys=3 are supported                  case 2: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }                  case 3: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'>'' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }              }
Magic Number,Poderosa,GUtil,C:\repos\poderosaproject_poderosa\TerminalEmulator\Util.cs,CreateLogFileName,The following statement contains a magic number: if (host == null || host.Length == 0)                  basefile = String.Format("{0}\\{1}"' GEnv.Options.DefaultLogDirectory' date);              else {                  if (host.StartsWith("rsp://"))                      host = host.Substring(6); //rsp://のあとの文字列                  basefile = String.Format("{0}\\{1}_{2}"' GEnv.Options.DefaultLogDirectory' ReplaceBadPathChar(host)' date);              }
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Location = new System.Drawing.Point(120' 72);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Location = new System.Drawing.Point(120' 72);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Size = new System.Drawing.Size(75' 23);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Size = new System.Drawing.Size(75' 23);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._messageLabel.Location = new System.Drawing.Point(56' 8);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._messageLabel.Location = new System.Drawing.Point(56' 8);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._messageLabel.Size = new System.Drawing.Size(248' 40);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._messageLabel.Size = new System.Drawing.Size(248' 40);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.Location = new System.Drawing.Point(56' 48);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.Location = new System.Drawing.Point(56' 48);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.Size = new System.Drawing.Size(248' 24);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.Size = new System.Drawing.Size(248' 24);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this._disableCheckBox.TabIndex = 2;
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 12);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 12);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(314' 103);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(314' 103);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,OnPaint,The following statement contains a magic number: a.Graphics.DrawIcon(_warningIcon' 12' 24);
Magic Number,Poderosa.Forms,WarningWithDisableOption,C:\repos\poderosaproject_poderosa\TerminalEmulator\WarningWithDisableOption.cs,OnPaint,The following statement contains a magic number: a.Graphics.DrawIcon(_warningIcon' 12' 24);
Missing Default,Poderosa.Terminal,UTF8ProfileBase,C:\repos\poderosaproject_poderosa\TerminalEmulator\Encoding.cs,IsIgnoreableChar,The following switch statement is missing a default case: switch (charBuff[0]) {                          case '\uFFF9':  // INTERLINEAR ANNOTATION ANCHOR                          case '\uFFFA':  // INTERLINEAR ANNOTATION SEPARATOR                          case '\uFFFB':  // INTERLINEAR ANNOTATION TERMINATOR                          case '\uFFFF':  // not a character                          case '\uFFFE':  // BOM                          case '\uFEFF':  // BOM                          case '\uFE00':  // Variation Selector                          case '\uFE01':  // Variation Selector                          case '\uFE02':  // Variation Selector                          case '\uFE03':  // Variation Selector                          case '\uFE04':  // Variation Selector                          case '\uFE05':  // Variation Selector                          case '\uFE06':  // Variation Selector                          case '\uFE07':  // Variation Selector                          case '\uFE08':  // Variation Selector                          case '\uFE09':  // Variation Selector                          case '\uFE0A':  // Variation Selector                          case '\uFE0B':  // Variation Selector                          case '\uFE0C':  // Variation Selector                          case '\uFE0D':  // Variation Selector                          case '\uFE0E':  // Variation Selector                          case '\uFE0F':  // Variation Selector                              return true;                      }
Missing Default,Poderosa.Terminal,LogService,C:\repos\poderosaproject_poderosa\TerminalEmulator\Logger.cs,ApplySimpleLogSetting,The following switch statement is missing a default case: switch (sl.LogType) {                  case LogType.Binary:                      AddBinaryLogger(new BinaryLogger(loginfo' fs));                      break;                  case LogType.Default:                  case LogType.PlainTextWithTimestamp:                      bool withTimestamp = (sl.LogType == LogType.PlainTextWithTimestamp);                      AddTextLogger(new DefaultLogger(loginfo' new StreamWriter(fs' Encoding.Default)' withTimestamp));                      break;                  case LogType.Xml:                      AddXmlLogger(new XmlLogger(loginfo' new StreamWriter(fs' Encoding.Default)));                      break;              }
Missing Default,Poderosa.Terminal,GenericShellScheme,C:\repos\poderosaproject_poderosa\TerminalEmulator\ShellScheme.cs,DetermineDelimiter,The following switch statement is missing a default case: switch (value[cursor + 1]) {                      case '[':                          return ']';                      case '<':                          return '>';                      case '{':                          return '}';                  }
Missing Default,Poderosa.Terminal,AbstractTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,CharDecodeError,The following switch statement is missing a default case: switch (GEnv.Options.CharDecodeErrorBehavior) {                  case WarningOption.StatusBar:                      window.StatusBar.SetMainText(msg);                      break;                  case WarningOption.MessageBox:                      window.AsForm().Invoke(new CharDecodeErrorDialogDelegate(CharDecodeErrorDialog)' window' msg);                      break;              }
Missing Default,Poderosa.Terminal,AbstractTerminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalBase.cs,ShowAbnormalTerminationMessage,The following switch statement is missing a default case: switch (GEnv.Options.DisconnectNotification) {                          case WarningOption.StatusBar:                              window.StatusBar.SetMainText(msg);                              break;                          case WarningOption.MessageBox:                              window.Warning(msg); //TODO Disableオプションつきのサポート                              break;                      }
Missing Default,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,SmartInvalidate,The following switch statement is missing a default case: switch (_drawOptimizingState) {                  case 0:                      _drawOptimizingState = 1;                      InvalidateEx();                      break;                  case 1:                      if (_session.TerminalConnection.Socket.Available)                          Interlocked.Exchange(ref _drawOptimizingState' 2); //間引きモードへ                      else                          InvalidateEx();                      break;                  case 2:                      break; //do nothing              }
Missing Default,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,OnWindowManagerTimer,The following switch statement is missing a default case: switch (_drawOptimizingState) {                  case 0:                      break; //do nothing                  case 1:                      Interlocked.CompareExchange(ref _drawOptimizingState' 0' 1);                      break;                  case 2: //忙しくても偶には描画                      _drawOptimizingState = 1;                      InvalidateEx();                      break;              }
Missing Default,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessScrollKey,The following switch statement is missing a default case: switch (key) {                  case Keys.Up:                      newvalue = current - 1;                      break;                  case Keys.Down:                      newvalue = current + 1;                      break;                  case Keys.PageUp:                      newvalue = current - doc.TerminalHeight;                      break;                  case Keys.PageDown:                      newvalue = current + doc.TerminalHeight;                      break;                  case Keys.Home:                      newvalue = 0;                      break;                  case Keys.End:                      newvalue = doc.LastLineNumber - doc.FirstLineNumber + 1 - doc.TerminalHeight;                      break;              }
Missing Default,Poderosa.Terminal,TerminalControl,C:\repos\poderosaproject_poderosa\TerminalEmulator\TerminalControl.cs,ProcessVScrollMessage,The following switch statement is missing a default case: switch (cmd) {                  case 0: //SB_LINEUP                      newval--;                      break;                  case 1: //SB_LINEDOWN                      newval++;                      break;                  case 2: //SB_PAGEUP                      newval -= GetDocument().TerminalHeight;                      break;                  case 3: //SB_PAGEDOWN                      newval += GetDocument().TerminalHeight;                      break;              }
Missing Default,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessEscapeSequence,The following switch statement is missing a default case: switch (code) {                  case '[':                      if (seq.Length - offset - 1 >= 0) {                          param = new string(seq' offset' seq.Length - offset - 1);                          return ProcessAfterCSI(param' seq[seq.Length - 1]);                      }                      break;                  //throw new UnknownEscapeSequenceException(String.Format("unknown command after CSI {0}"' code));                  case ']':                      if (seq.Length - offset - 1 >= 0) {                          param = new string(seq' offset' seq.Length - offset - 1);                          return ProcessAfterOSC(param' seq[seq.Length - 1]);                      }                      break;                  case '=':                      ChangeMode(TerminalMode.Application);                      return ProcessCharResult.Processed;                  case '>':                      ChangeMode(TerminalMode.Normal);                      return ProcessCharResult.Processed;                  case 'E':                      ProcessNextLine();                      return ProcessCharResult.Processed;                  case 'M':                      ReverseIndex();                      return ProcessCharResult.Processed;                  case 'D':                      Index();                      return ProcessCharResult.Processed;                  case '7':                      SaveCursor();                      return ProcessCharResult.Processed;                  case '8':                      RestoreCursor();                      return ProcessCharResult.Processed;                  case 'c':                      FullReset();                      return ProcessCharResult.Processed;              }
Missing Default,Poderosa.Terminal,VT100Terminal,C:\repos\poderosaproject_poderosa\TerminalEmulator\VT100.cs,ProcessCursorMove,The following switch statement is missing a default case: switch (method) {                  case 'A':                      GetDocument().UpdateCurrentLine(_manipulator);                      GetDocument().CurrentLineNumber = (GetDocument().CurrentLineNumber - count);                      _manipulator.Load(GetDocument().CurrentLine' column);                      break;                  case 'B':                      GetDocument().UpdateCurrentLine(_manipulator);                      GetDocument().CurrentLineNumber = (GetDocument().CurrentLineNumber + count);                      _manipulator.Load(GetDocument().CurrentLine' column);                      break;                  case 'C': {                          int newvalue = column + count;                          if (newvalue >= GetDocument().TerminalWidth)                              newvalue = GetDocument().TerminalWidth - 1;                          _manipulator.CaretColumn = newvalue;                      }                      break;                  case 'D': {                          int newvalue = column - count;                          if (newvalue < 0)                              newvalue = 0;                          _manipulator.CaretColumn = newvalue;                      }                      break;              }
Missing Default,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessMouse,The following switch statement is missing a default case: switch (action) {                      case TerminalMouseAction.ButtonUp:                      case TerminalMouseAction.ButtonDown:                          _mouseButton = MouseButtons.None;                          break;                  }
Missing Default,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessEscapeSequence,The following switch statement is missing a default case: switch (code) {                  case 'F':                      if (seq.Length == offset) { //パラメータなしの場合                          ProcessCursorPosition(1' 1);                          return ProcessCharResult.Processed;                      }                      else if (seq.Length > offset && seq[offset] == ' ')                          return ProcessCharResult.Processed; //7/8ビットコントロールは常に両方をサポート                      break;                  case 'G':                      if (seq.Length > offset && seq[offset] == ' ')                          return ProcessCharResult.Processed; //7/8ビットコントロールは常に両方をサポート                      break;                  case 'L':                      if (seq.Length > offset && seq[offset] == ' ')                          return ProcessCharResult.Processed; //VT100は最初からOK                      break;                  case 'H':                      SetTabStop(_manipulator.CaretColumn' true);                      return ProcessCharResult.Processed;              }
Missing Default,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessAfterOSC,The following switch statement is missing a default case: switch (vals[0].Length) {                                      case 1:                                          r <<= 4;                                          g <<= 4;                                          b <<= 4;                                          break;                                      case 3:                                          r >>= 4;                                          g >>= 4;                                          b >>= 4;                                          break;                                      case 4:                                          r >>= 8;                                          g >>= 8;                                          b >>= 8;                                          break;                                  }
Missing Default,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSGR,The following switch statement is missing a default case: switch (state) {                          case 1:                              if (code == 5) { // select indexed color                                  state = 2;                              }                              else if (code == 2) { // select RGB color                                  state = 3;  // read R value                              }                              else {                                  Debug.WriteLine("Invalid SGR code : {0}"' code);                                  goto Apply;                              }                              break;                          case 2:                              if (code < 256) {                                  if (target == 3) {                                      dec = SelectForeColor(dec' code);                                  }                                  else if (target == 4) {                                      dec = SelectBackgroundColor(dec' code);                                  }                              }                              state = 0;                              target = 0;                              break;                          case 3:                              if (code < 256) {                                  r = code;                                  state = 4;  // read G value                              }                              else {                                  Debug.WriteLine("Invalid SGR R value : {0}"' code);                                  goto Apply;                              }                              break;                          case 4:                              if (code < 256) {                                  g = code;                                  state = 5;  // read B value                              }                              else {                                  Debug.WriteLine("Invalid SGR G value : {0}"' code);                                  goto Apply;                              }                              break;                          case 5:                              if (code < 256) {                                  b = code;                                  if (target == 3) {                                      dec = SetForeColorByRGB(dec' r' g' b);                                  }                                  else if (target == 4) {                                      dec = SetBackColorByRGB(dec' r' g' b);                                  }                                  state = 0;                                  target = 0;                              }                              else {                                  Debug.WriteLine("Invalid SGR B value : {0}"' code);                                  goto Apply;                              }                              break;                      }
Missing Default,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessSaveDECSET,The following switch statement is missing a default case: switch (param) {                  case "1047":                  case "47":                      _savedMode_isAlternateBuffer = _isAlternateBuffer;                      break;              }
Missing Default,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ProcessRestoreDECSET,The following switch statement is missing a default case: switch (param) {                  case "1047":                  case "47":                      SwitchBuffer(_savedMode_isAlternateBuffer);                      break;              }
Missing Default,Poderosa.Terminal,XTerm,C:\repos\poderosaproject_poderosa\TerminalEmulator\XTerm.cs,ModifyCursorKey,The following switch statement is missing a default case: switch (XTermPreferences.Instance.modifyCursorKeys) {                  // only modifyCursorKeys=2 and modifyCursorKeys=3 are supported                  case 2: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }                  case 3: {                          byte[] data = new byte[] {                              0x1b' (byte)'['' (byte)'>'' (byte)'1'' (byte)';'' (byte)('0' + m)' (byte)c                          };                          return data;                      }              }
