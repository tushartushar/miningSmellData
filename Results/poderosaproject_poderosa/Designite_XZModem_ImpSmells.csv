Implementation smell,Namespace,Class,File,Method,Description
Long Method,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The method has 121 lines of code.
Long Method,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The method has 271 lines of code.
Complex Method,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,OnReception,Cyclomatic complexity of the method is 12
Complex Method,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,SendZDATA,Cyclomatic complexity of the method is 8
Long Parameter List,Poderosa.XZModem,Header,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,Header,The method has 5 parameters. Parameters: type' zf0' zf1' zf2' zf3
Long Statement,Poderosa.XZModem,XZModemPlugin,C:\repos\poderosaproject_poderosa\XZModem\XZModemPlugin.cs,InitializePlugin,The length of the statement  "            _terminalEmulatorService = (ITerminalEmulatorService)pm.FindPlugin("org.poderosa.terminalemulator"' typeof(ITerminalEmulatorService)); " is 134.
Complex Conditional,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,OnReception,The conditional expression  "c == LETTER_C || c == ACK || c == NAK || c == CAN"  is complex.
Complex Conditional,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The conditional expression  "c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW"  is complex.
Empty Catch Block,Poderosa.XZModem,ZModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,Dispose,The method has an empty catch block.
Magic Number,Poderosa.XZModem,Crc16,C:\repos\poderosaproject_poderosa\XZModem\Crc.cs,Update,The following statement contains a magic number: return (ushort)((crc << 8) ^ crc16tab[(byte)((crc >> 8) ^ b)]);
Magic Number,Poderosa.XZModem,Crc16,C:\repos\poderosaproject_poderosa\XZModem\Crc.cs,Update,The following statement contains a magic number: return (ushort)((crc << 8) ^ crc16tab[(byte)((crc >> 8) ^ b)]);
Magic Number,Poderosa.XZModem,Crc32,C:\repos\poderosaproject_poderosa\XZModem\Crc.cs,Update,The following statement contains a magic number: return crc32tab[(byte)(crc ^ b)] ^ (crc >> 8);
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,Monitor,The following statement contains a magic number: while (!Volatile.Read(ref _teminateMonitorTask)) {                  long last = Interlocked.Read(ref _lastBlockTimeUtcTicks);                  int elapsedMsec = (int)((DateTime.UtcNow.Ticks - last) / TimeSpan.TicksPerMillisecond);                    int mode = Volatile.Read(ref _mode);                  int sn = Volatile.Read(ref _nextSequenceNumber);                    if (mode == MODE_CRC && sn == 1 && elapsedMsec > WAIT_CRCBLOCK_TIMEOUT) {                      if (crcModeRetries < 3) {                          crcModeRetries++;                          Interlocked.Exchange(ref _lastBlockTimeUtcTicks' DateTime.UtcNow.Ticks);                          Trace("<-- Retry: C");                          Send(LETTER_C);                      }                      else {                          Interlocked.Exchange(ref _lastBlockTimeUtcTicks' DateTime.UtcNow.Ticks);                          Volatile.Write(ref _mode' MODE_CHECKSUM);                          Trace("<-- Retry: NAK");                          Send(NAK);  // fallback into checksum mode                      }                      goto Continue;                  }                    if (elapsedMsec > WAIT_BLOCK_TIMEOUT) {                      Abort(XZModemPlugin.Instance.Strings.GetString("Message.XModem.ReceivingTimedOut")' false);                      break;                  }                Continue:                  Thread.Sleep(200);              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,Monitor,The following statement contains a magic number: while (!Volatile.Read(ref _teminateMonitorTask)) {                  long last = Interlocked.Read(ref _lastBlockTimeUtcTicks);                  int elapsedMsec = (int)((DateTime.UtcNow.Ticks - last) / TimeSpan.TicksPerMillisecond);                    int mode = Volatile.Read(ref _mode);                  int sn = Volatile.Read(ref _nextSequenceNumber);                    if (mode == MODE_CRC && sn == 1 && elapsedMsec > WAIT_CRCBLOCK_TIMEOUT) {                      if (crcModeRetries < 3) {                          crcModeRetries++;                          Interlocked.Exchange(ref _lastBlockTimeUtcTicks' DateTime.UtcNow.Ticks);                          Trace("<-- Retry: C");                          Send(LETTER_C);                      }                      else {                          Interlocked.Exchange(ref _lastBlockTimeUtcTicks' DateTime.UtcNow.Ticks);                          Volatile.Write(ref _mode' MODE_CHECKSUM);                          Trace("<-- Retry: NAK");                          Send(NAK);  // fallback into checksum mode                      }                      goto Continue;                  }                    if (elapsedMsec > WAIT_BLOCK_TIMEOUT) {                      Abort(XZModemPlugin.Instance.Strings.GetString("Message.XModem.ReceivingTimedOut")' false);                      break;                  }                Continue:                  Thread.Sleep(200);              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,OnAbort,The following statement contains a magic number: Task.Run(() => {                  _aborting = true;                  Thread.MemoryBarrier();                  Thread.Sleep(200);                  Trace("<-- CAN");                  Send(CAN);                  Send(CAN);                  DiscardAllIncomingData();                  Completed(true' closeDialog' message);              });
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,OnReception,The following statement contains a magic number: if (_recvBuff[1] != _nextSequenceNumber || _recvBuff[2] != (255 - _nextSequenceNumber)) {                  Trace("<-- NAK (bad seq)");                  goto Error;              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,OnReception,The following statement contains a magic number: if (_recvBuff[1] != _nextSequenceNumber || _recvBuff[2] != (255 - _nextSequenceNumber)) {                  Trace("<-- NAK (bad seq)");                  goto Error;              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,OnReception,The following statement contains a magic number: if (blockInfo.HasCRC) {                  ushort crc = Crc16.Update(Crc16.InitialValue' _recvBuff' blockInfo.DataOffset' blockInfo.DataLength);                  int crcIndex = blockInfo.DataOffset + blockInfo.DataLength;                  if (_recvBuff[crcIndex] != (byte)(crc >> 8) || _recvBuff[crcIndex + 1] != (byte)crc) {                      // CRC error                      Trace("<-- NAK (CRC error)");                      goto Error;                  }              }              else {                  byte checksum = 0;                  int index = blockInfo.DataOffset;                  for (int n = 0; n < blockInfo.DataLength; ++n) {                      checksum += _recvBuff[index++];                  }                  if (_recvBuff[index] != checksum) {                      // checksum error                      Trace("<-- NAK (checksum error)");                      goto Error;                  }              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,GetBlockTypeInfo,The following statement contains a magic number: if (firstByte == STX) {                  // XMODEM/1k                  return new BlockTypeInfo(true' 1029' 3' 1024);              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,GetBlockTypeInfo,The following statement contains a magic number: if (firstByte == STX) {                  // XMODEM/1k                  return new BlockTypeInfo(true' 1029' 3' 1024);              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,GetBlockTypeInfo,The following statement contains a magic number: if (firstByte == STX) {                  // XMODEM/1k                  return new BlockTypeInfo(true' 1029' 3' 1024);              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,GetBlockTypeInfo,The following statement contains a magic number: if (mode == MODE_CRC) {                  // XMODEM/CRC                  return new BlockTypeInfo(true' 133' 3' 128);              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,GetBlockTypeInfo,The following statement contains a magic number: if (mode == MODE_CRC) {                  // XMODEM/CRC                  return new BlockTypeInfo(true' 133' 3' 128);              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,GetBlockTypeInfo,The following statement contains a magic number: if (mode == MODE_CRC) {                  // XMODEM/CRC                  return new BlockTypeInfo(true' 133' 3' 128);              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,GetBlockTypeInfo,The following statement contains a magic number: return new BlockTypeInfo(false' 132' 3' 128);
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,GetBlockTypeInfo,The following statement contains a magic number: return new BlockTypeInfo(false' 132' 3' 128);
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,GetBlockTypeInfo,The following statement contains a magic number: return new BlockTypeInfo(false' 132' 3' 128);
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,DiscardAllIncomingData,The following statement contains a magic number: while (true) {                  long last = Interlocked.Read(ref _lastReceptionTimeUtcTicks);                  if ((DateTime.UtcNow.Ticks - last) > 500 * TimeSpan.TicksPerMillisecond) {                      return;                  }                  Thread.Sleep(100);              }
Magic Number,Poderosa.XZModem,XModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,DiscardAllIncomingData,The following statement contains a magic number: while (true) {                  long last = Interlocked.Read(ref _lastReceptionTimeUtcTicks);                  if ((DateTime.UtcNow.Ticks - last) > 500 * TimeSpan.TicksPerMillisecond) {                      return;                  }                  Thread.Sleep(100);              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,Monitor,The following statement contains a magic number: while (!Volatile.Read(ref _teminateMonitorTask)) {                  long last = Interlocked.Read(ref _lastResponseTimeUtcTicks);                  if (DateTime.UtcNow.Ticks - last > RESPONSE_TIMEOUT * TimeSpan.TicksPerMillisecond) {                      Abort(XZModemPlugin.Instance.Strings.GetString("Message.XModem.NoResponse")' false);                      break;                  }                  Thread.Sleep(200);              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,OnAbort,The following statement contains a magic number: Task.Run(() => {                  _state = State.Aborting;                  Thread.MemoryBarrier();                  // CAN mast be sent after the ACK or NAK from peer                  DateTime limit = DateTime.UtcNow.AddMilliseconds(3000);                  SpinWait.SpinUntil(() => {                      if (DateTime.UtcNow > limit) {                          // timeout                          return true;                      }                      if (_state == State.Stopped) {                          // CAN has been sent                          return true;                      }                      return false;                  });                  Thread.MemoryBarrier();                  if (_state != State.Stopped) {                      // no response ?                      Send(CAN);                      Send(CAN);                      Thread.Sleep(500);                  }                  Completed(true' closeDialog' message);              });
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,OnAbort,The following statement contains a magic number: Task.Run(() => {                  _state = State.Aborting;                  Thread.MemoryBarrier();                  // CAN mast be sent after the ACK or NAK from peer                  DateTime limit = DateTime.UtcNow.AddMilliseconds(3000);                  SpinWait.SpinUntil(() => {                      if (DateTime.UtcNow > limit) {                          // timeout                          return true;                      }                      if (_state == State.Stopped) {                          // CAN has been sent                          return true;                      }                      return false;                  });                  Thread.MemoryBarrier();                  if (_state != State.Stopped) {                      // no response ?                      Send(CAN);                      Send(CAN);                      Thread.Sleep(500);                  }                  Completed(true' closeDialog' message);              });
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: if (useCrc) {                  dataLength = (_fileSize - _prevPos < 1024L) ? 128 : 1024;              }              else {                  dataLength = 128;              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: if (useCrc) {                  dataLength = (_fileSize - _prevPos < 1024L) ? 128 : 1024;              }              else {                  dataLength = 128;              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: if (useCrc) {                  dataLength = (_fileSize - _prevPos < 1024L) ? 128 : 1024;              }              else {                  dataLength = 128;              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: int readLen = _input.Read(_sendBuff' 3' dataLength);
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: _sendBuff[0] = (dataLength == 1024) ? STX : SOH;
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: _sendBuff[2] = (byte)(255 - _sequenceNumber);
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: _sendBuff[2] = (byte)(255 - _sequenceNumber);
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: for (int i = 3 + readLen; i < 3 + dataLength; ++i) {                  _sendBuff[i] = CPMEOF;              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: for (int i = 3 + readLen; i < 3 + dataLength; ++i) {                  _sendBuff[i] = CPMEOF;              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: int blockLen = 3 + dataLength;
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: if (useCrc) {                  ushort crc = Crc16.Update(Crc16.InitialValue' _sendBuff' 3' dataLength);                  _sendBuff[blockLen++] = (byte)(crc >> 8);                  _sendBuff[blockLen++] = (byte)crc;              }              else {                  byte checksum = 0;                  for (int i = 3; i < 3 + dataLength; ++i) {                      checksum += _sendBuff[i];                  }                  _sendBuff[blockLen++] = checksum;              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: if (useCrc) {                  ushort crc = Crc16.Update(Crc16.InitialValue' _sendBuff' 3' dataLength);                  _sendBuff[blockLen++] = (byte)(crc >> 8);                  _sendBuff[blockLen++] = (byte)crc;              }              else {                  byte checksum = 0;                  for (int i = 3; i < 3 + dataLength; ++i) {                      checksum += _sendBuff[i];                  }                  _sendBuff[blockLen++] = checksum;              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: if (useCrc) {                  ushort crc = Crc16.Update(Crc16.InitialValue' _sendBuff' 3' dataLength);                  _sendBuff[blockLen++] = (byte)(crc >> 8);                  _sendBuff[blockLen++] = (byte)crc;              }              else {                  byte checksum = 0;                  for (int i = 3; i < 3 + dataLength; ++i) {                      checksum += _sendBuff[i];                  }                  _sendBuff[blockLen++] = checksum;              }
Magic Number,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,SendBlock,The following statement contains a magic number: if (useCrc) {                  ushort crc = Crc16.Update(Crc16.InitialValue' _sendBuff' 3' dataLength);                  _sendBuff[blockLen++] = (byte)(crc >> 8);                  _sendBuff[blockLen++] = (byte)crc;              }              else {                  byte checksum = 0;                  for (int i = 3; i < 3 + dataLength; ++i) {                      checksum += _sendBuff[i];                  }                  _sendBuff[blockLen++] = checksum;              }
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,Initialize,The following statement contains a magic number: this.Location = new Point(r.Left + r.Width / 2 - this.Width / 2' r.Top + r.Height / 2 - this.Height / 2);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,Initialize,The following statement contains a magic number: this.Location = new Point(r.Left + r.Width / 2 - this.Width / 2' r.Top + r.Height / 2 - this.Height / 2);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,Initialize,The following statement contains a magic number: this.Location = new Point(r.Left + r.Width / 2 - this.Width / 2' r.Top + r.Height / 2 - this.Height / 2);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,Initialize,The following statement contains a magic number: this.Location = new Point(r.Left + r.Width / 2 - this.Width / 2' r.Top + r.Height / 2 - this.Height / 2);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Location = new System.Drawing.Point(200' 92);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Location = new System.Drawing.Point(200' 92);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._cancelButton.Location = new System.Drawing.Point(288' 92);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._cancelButton.Location = new System.Drawing.Point(288' 92);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionLabel.Location = new System.Drawing.Point(8' 8);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionLabel.Location = new System.Drawing.Point(8' 8);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionLabel.Size = new System.Drawing.Size(80' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionLabel.Size = new System.Drawing.Size(80' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionLabel.TabIndex = 2;
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionBox.Location = new System.Drawing.Point(88' 8);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionBox.Location = new System.Drawing.Point(88' 8);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionBox.Size = new System.Drawing.Size(120' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionBox.Size = new System.Drawing.Size(120' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._directionBox.TabIndex = 3;
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolLabel.Location = new System.Drawing.Point(216' 8);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolLabel.Location = new System.Drawing.Point(216' 8);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolLabel.Size = new System.Drawing.Size(64' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolLabel.Size = new System.Drawing.Size(64' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolLabel.TabIndex = 4;
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolBox.Location = new System.Drawing.Point(280' 8);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolBox.Location = new System.Drawing.Point(280' 8);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolBox.Size = new System.Drawing.Size(80' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolBox.Size = new System.Drawing.Size(80' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._protocolBox.TabIndex = 5;
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameLabel.Location = new System.Drawing.Point(8' 32);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameLabel.Location = new System.Drawing.Point(8' 32);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameLabel.Size = new System.Drawing.Size(80' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameLabel.Size = new System.Drawing.Size(80' 16);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameLabel.TabIndex = 6;
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameBox.Location = new System.Drawing.Point(88' 32);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameBox.Location = new System.Drawing.Point(88' 32);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameBox.Size = new System.Drawing.Size(252' 19);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameBox.Size = new System.Drawing.Size(252' 19);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._fileNameBox.TabIndex = 7;
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._selectButton.Location = new System.Drawing.Point(340' 32);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._selectButton.Location = new System.Drawing.Point(340' 32);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._selectButton.Size = new System.Drawing.Size(19' 19);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._selectButton.Size = new System.Drawing.Size(19' 19);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._selectButton.TabIndex = 8;
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._progressText.Location = new System.Drawing.Point(8' 52);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._progressText.Location = new System.Drawing.Point(8' 52);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._progressText.Size = new System.Drawing.Size(296' 32);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._progressText.Size = new System.Drawing.Size(296' 32);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this._progressText.TabIndex = 5;
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 12);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 12);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(376' 118);
Magic Number,Poderosa.XZModem,XZModemDialog,C:\repos\poderosaproject_poderosa\XZModem\XZModemDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(376' 118);
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,PutHex,The following statement contains a magic number: if (b <= 0x9f) {                  data[index] = (byte)((b >> 4) + 0x30);              }              else {                  data[index] = (byte)((b >> 4) + 0x57);              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,PutHex,The following statement contains a magic number: if (b <= 0x9f) {                  data[index] = (byte)((b >> 4) + 0x30);              }              else {                  data[index] = (byte)((b >> 4) + 0x57);              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,PutCRC16,The following statement contains a magic number: index = PutBin(data' index' (byte)(crc >> 8));
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,PutCRC32,The following statement contains a magic number: index = PutBin(data' index' (byte)(crc >> 8));
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,PutCRC32,The following statement contains a magic number: index = PutBin(data' index' (byte)(crc >> 16));
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,PutCRC32,The following statement contains a magic number: index = PutBin(data' index' (byte)(crc >> 24));
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnReception,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  if (Volatile.Read(ref _aborting)) {                      return;                  }                    byte c = data[offset + i];                    // abort sequence detection                  if (c == CAN) {                      _canCount++;                      if (_canCount > 5) {                          _state = State.None;    // don't accept any more                          ProcessAbortByPeer();                          return;                      }                  }                  else {                      _canCount = 0;                  }                    // 0x11' 0x13' 0x81' 0x83は無視する                  if ((c & 0x7f) == XON || (c & 0x7f) == XOFF)                      continue;                CheckByte:                  switch (_state) {                      case State.WaitingZPAD: {                              switch (c) {                                  case ZPAD:                                      _state = State.WaitingZDLE;                                      break;                                  default:                                      break;                              }                          }                          break;                      case State.WaitingZDLE: {                              switch (c) {                                  case ZPAD:                                      break;                                  case ZDLE:                                      _state = State.GetHeaderFormat;                                      break;                                  default:                                      _state = State.WaitingZPAD;                                      break;                              }                          }                          break;                      case State.GetHeaderFormat: {                              switch (c) {                                  case ZBIN:                                      //Debug.WriteLine("ZBIN");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetBinaryData;                                      break;                                    case ZHEX:                                      //Debug.WriteLine("ZHEX");                                      _crcType = CRCType.CRC16;                                      _bytesNeeded = 7;                                      _state = State.GetHexData;                                      break;                                    case ZBIN32:                                      //Debug.WriteLine("ZBIN32");                                      _crcType = CRCType.CRC32;                                      _bytesNeeded = 9;                                      _state = State.GetBinaryData;                                      break;                                    default:                                      _state = State.WaitingZPAD;                                      break;                              }                              // initialize variables                              _rcvPacketLen = 0;                              _hexLo = false;                              _gotZDLE = false;                          }                          break;                      case State.GetBinaryData: { // binary('A') or binary('C') data                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  _state = State.WaitingZPAD;                                  Header hdr;                                  if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                      ProcessHeader(hdr);                                      if (hdr.Type == ZDATA) {                                          _state = State.GetFileData;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                      else if (hdr.Type == ZFILE) {                                          _state = State.GetFileInfo;                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                      }                                  }                              }                          }                          break;                      case State.GetHexData: {  // HEX('B') data                              if ((c >= '0') && (c <= '9')) {                                  c -= 0x30;                              }                              else if ((c >= 'a') && (c <= 'f')) {                                  c -= 0x57;                              }                              else {                                  Debug.WriteLine("Unexpected character in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.InvalidHeader");                                  goto Error;                              }                                if (_hexLo) {  // lower                                  _rcvPacket[_rcvPacketLen++] |= c;                                  _hexLo = false;                                  _bytesNeeded--;                                    if (_bytesNeeded <= 0) {                                      Header hdr;                                      if (CheckHeader(_crcType' _rcvPacket' _rcvPacketLen' out hdr)) {                                          ProcessHeader(hdr);                                          _state = State.GetHexEOL;                                          _bytesNeeded = 2;    // CR LF                                      }                                      else {                                          _state = State.WaitingZPAD;                                      }                                  }                              }                              else {  // upper                                  _rcvPacket[_rcvPacketLen] = (byte)(c << 4);                                  _hexLo = true;                              }                          }                          break;                      case State.GetHexEOL: {                              byte cc = (byte)(c & 0x7f); // sz sends { 0x0d' 0x8a } as CR/LF                              if (cc == 0x0a || cc == 0x0d) {                                  _bytesNeeded--;                                  if (_bytesNeeded <= 0) {                                      _state = State.WaitingZPAD;                                  }                              }                              else {                                  _state = State.WaitingZPAD;                                  goto CheckByte;                              }                          }                          break;                        case State.GetFileInfo:                      case State.GetFileData: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  if (c == ZCRCE || c == ZCRCG || c == ZCRCQ || c == ZCRCW) {                                      // end of frame. need CRC bytes.                                      _rcvPacket[_rcvPacketLen++] = c;                                      _gotZDLE = false;                                      _bytesNeeded = (_crcType == CRCType.CRC32) ? 4 : 2;    // CRC bytes                                      _state = (_state == State.GetFileInfo) ? State.GetFileInfoCRC :                                              (_state == State.GetFileData) ? State.GetFileDataCRC : State.Error;                                  }                                  else {                                      // unescape                                      _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                      _gotZDLE = false;                                  }                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _gotZDLE = false;                              }                          }                          break;                      case State.GetFileInfoCRC:                      case State.GetFileDataCRC: {                              if (_rcvPacketLen >= _rcvPacket.Length) {                                  Debug.WriteLine("Buffer full in {0}"' _state);                                  errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.BufferFull");                                  goto Error;                              }                              if (_gotZDLE) {                                  // unescape                                  _rcvPacket[_rcvPacketLen++] = (byte)(c ^ 0x40);                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                              else if (c == ZDLE) {                                  _gotZDLE = true;                              }                              else {                                  _rcvPacket[_rcvPacketLen++] = c;                                  _bytesNeeded--;                                  _gotZDLE = false;                              }                                if (_bytesNeeded <= 0) {                                  int dataLen = _rcvPacketLen - (_crcType == CRCType.CRC32 ? 5 : 3);                                  if (_state == State.GetFileInfoCRC) {                                      if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ParseFileInfo(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          _state = State.WaitingZPAD;                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                                  else if (_state == State.GetFileDataCRC) {                                      byte frameType = _rcvPacket[dataLen];                                      //Debug.WriteLine("frameType = 0x{0:x2}"' frameType);                                        if (CheckCRC(_crcType' _rcvPacket' _rcvPacketLen)) {                                          ProcessFileData(_rcvPacket' 0' dataLen);                                          _rcvPacketLen = 0;                                          _gotZDLE = false;                                          if (frameType == ZCRCE) {                                              // finished                                              _state = State.WaitingZPAD;                                          }                                          else if (frameType == ZCRCW) {                                              SendACK();                                              // read next subpacket                                              _state = State.WaitingZPAD;                                          }                                          else {                                              // read next subpacket                                              _state = State.GetFileData;                                          }                                      }                                      else {                                          Debug.WriteLine("CRC Error in {0}"' _state);                                          errorMessage = XZModemPlugin.Instance.Strings.GetString("Message.ZModem.CRCError");                                          goto Error;                                      }                                  }                              }                          }                          break;                  }              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,CheckCRC,The following statement contains a magic number: if (crcType == CRCType.CRC32) {                  uint crc = Crc32.Update(Crc32.InitialValue' data' 0' len - 4) ^ Crc32.XorValue;                  //Debug.WriteLine("CRC32: {0:x8}"' crc);                  uint crcfld = (((uint)data[len - 4]) |                                 ((uint)data[len - 3] << 8) |                                 ((uint)data[len - 2] << 16) |                                 ((uint)data[len - 1] << 24));                  return crc == crcfld;              }              else {                  // CRC16                  ushort crc = Crc16.Update(Crc16.InitialValue' data' 0' len - 2);                  //Debug.WriteLine("CRC16: {0:x4}"' crc);                  ushort crcfld = (ushort)((data[len - 2] << 8) | data[len - 1]);                  return crc == crcfld;              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,BuildHEXHeader,The following statement contains a magic number: data[2] = ZDLE;
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,BuildHEXHeader,The following statement contains a magic number: data[3] = ZHEX;
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,BuildHEXHeader,The following statement contains a magic number: int index = 4;
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,BuildHEXHeader,The following statement contains a magic number: index = PutHex(data' index' (byte)(crc >> 8));
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,BuildBin16Header,The following statement contains a magic number: data[2] = ZBIN;
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,BuildBin16Header,The following statement contains a magic number: int index = 3;
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,BuildBin32Header,The following statement contains a magic number: data[2] = ZBIN32;
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,BuildBin32Header,The following statement contains a magic number: int index = 3;
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,DiscardAllIncomingData,The following statement contains a magic number: while (true) {                  long last = Interlocked.Read(ref _lastReceptionTimeUtcTicks);                  if (DateTime.UtcNow.Ticks - last > 1000 * TimeSpan.TicksPerMillisecond) {                      return;                  }                  Thread.Sleep(100);              }
Magic Number,Poderosa.XZModem,ZModem,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,DiscardAllIncomingData,The following statement contains a magic number: while (true) {                  long last = Interlocked.Read(ref _lastReceptionTimeUtcTicks);                  if (DateTime.UtcNow.Ticks - last > 1000 * TimeSpan.TicksPerMillisecond) {                      return;                  }                  Thread.Sleep(100);              }
Magic Number,Poderosa.XZModem,Header,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,Header,The following statement contains a magic number: ZP1 = buf[2];
Magic Number,Poderosa.XZModem,Header,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,Header,The following statement contains a magic number: ZP2 = buf[3];
Magic Number,Poderosa.XZModem,Header,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,Header,The following statement contains a magic number: ZP3 = buf[4];
Magic Number,Poderosa.XZModem,Header,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,Header,The following statement contains a magic number: ZP1 = (byte)(pos >> 8);
Magic Number,Poderosa.XZModem,Header,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,Header,The following statement contains a magic number: ZP2 = (byte)(pos >> 16);
Magic Number,Poderosa.XZModem,Header,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,Header,The following statement contains a magic number: ZP3 = (byte)(pos >> 24);
Magic Number,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnStart,The following statement contains a magic number: Task.Run(() => {                  SendRZ();                  Thread.Sleep(500);                  SendZRQInit();              });
Magic Number,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,OnAbort,The following statement contains a magic number: Task.Run(() => {                  IgnoreAllIncomingData();                  Thread.Sleep(200);                  SendAbortSequence();                  DiscardAllIncomingData();                  Completed(true' closeDialog' message);              });
Magic Number,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,SendRZ,The following statement contains a magic number: if (!_stopped) {                  _sndBuff[0] = (byte)'r';                  _sndBuff[1] = (byte)'z';                  _sndBuff[2] = (byte)'\r';                  SendPacket(_sndBuff' 3);              }
Magic Number,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,SendRZ,The following statement contains a magic number: if (!_stopped) {                  _sndBuff[0] = (byte)'r';                  _sndBuff[1] = (byte)'z';                  _sndBuff[2] = (byte)'\r';                  SendPacket(_sndBuff' 3);              }
Magic Number,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,SendOverAndOut,The following statement contains a magic number: SendPacket(_sndBuff' 2);
Magic Number,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,ProcessHeader,The following statement contains a magic number: switch (hdr.Type) {                    case ZRINIT:                      Debug.WriteLine("Got ZRINIT");                      if (_afterZRPOS) {                          Debug.WriteLine("--> ZFIN");                          SendZFIN();                      }                      else {                          int bufSize = (hdr.ZP1 << 8) | hdr.ZP0;                          _frameSize = Math.Min(Math.Max(_frameSize' bufSize)' MAX_BLOCK);                          _txCrcType = ((hdr.ZF0 & CANFC32) != 0) ? CRCType.CRC32 : CRCType.CRC16;                            SendZFILE();                      }                      break;                    case ZRPOS: {                          Debug.WriteLine("Got ZRPOS");                          _afterZRPOS = true;                          uint pos = ((uint)hdr.ZP3 << 24)                                   | ((uint)hdr.ZP2 << 16)                                   | ((uint)hdr.ZP1 << 8)                                   | ((uint)hdr.ZP0);                          Volatile.Write(ref _filePosReq' (uint)Math.Min(Math.Max(0' pos)' _fileSize));                          Debug.WriteLine("_filePosReq = {0}"' _filePosReq);                          Volatile.Write(ref _filePosReqChanged' true);                          if (_sendingTask == null) {                              _sendingTask = Task.Run(() => SendZDATA(_cancellation.Token)' _cancellation.Token);                          }                      }                      break;                    case ZFIN:                      Debug.WriteLine("Got ZFIN");                      SendOverAndOut();                      Completed(false' true'                          _fileSkipped ?                              XZModemPlugin.Instance.Strings.GetString("Message.ZModem.FileSkipped") :                              XZModemPlugin.Instance.Strings.GetString("Message.XModem.SendComplete"));                      break;                    case ZSKIP:                      Debug.WriteLine("Got ZSKIP");                      _fileSkipped = true;                      SendZFIN();                      break;                    case ZACK:                      Debug.WriteLine("Got ZACK");                      break;                    default:                      Debug.WriteLine("Unknown Header : 0x{0:x2}"' hdr.Type);                      break;              }
Magic Number,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,ProcessHeader,The following statement contains a magic number: switch (hdr.Type) {                    case ZRINIT:                      Debug.WriteLine("Got ZRINIT");                      if (_afterZRPOS) {                          Debug.WriteLine("--> ZFIN");                          SendZFIN();                      }                      else {                          int bufSize = (hdr.ZP1 << 8) | hdr.ZP0;                          _frameSize = Math.Min(Math.Max(_frameSize' bufSize)' MAX_BLOCK);                          _txCrcType = ((hdr.ZF0 & CANFC32) != 0) ? CRCType.CRC32 : CRCType.CRC16;                            SendZFILE();                      }                      break;                    case ZRPOS: {                          Debug.WriteLine("Got ZRPOS");                          _afterZRPOS = true;                          uint pos = ((uint)hdr.ZP3 << 24)                                   | ((uint)hdr.ZP2 << 16)                                   | ((uint)hdr.ZP1 << 8)                                   | ((uint)hdr.ZP0);                          Volatile.Write(ref _filePosReq' (uint)Math.Min(Math.Max(0' pos)' _fileSize));                          Debug.WriteLine("_filePosReq = {0}"' _filePosReq);                          Volatile.Write(ref _filePosReqChanged' true);                          if (_sendingTask == null) {                              _sendingTask = Task.Run(() => SendZDATA(_cancellation.Token)' _cancellation.Token);                          }                      }                      break;                    case ZFIN:                      Debug.WriteLine("Got ZFIN");                      SendOverAndOut();                      Completed(false' true'                          _fileSkipped ?                              XZModemPlugin.Instance.Strings.GetString("Message.ZModem.FileSkipped") :                              XZModemPlugin.Instance.Strings.GetString("Message.XModem.SendComplete"));                      break;                    case ZSKIP:                      Debug.WriteLine("Got ZSKIP");                      _fileSkipped = true;                      SendZFIN();                      break;                    case ZACK:                      Debug.WriteLine("Got ZACK");                      break;                    default:                      Debug.WriteLine("Unknown Header : 0x{0:x2}"' hdr.Type);                      break;              }
Magic Number,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,ProcessHeader,The following statement contains a magic number: switch (hdr.Type) {                    case ZRINIT:                      Debug.WriteLine("Got ZRINIT");                      if (_afterZRPOS) {                          Debug.WriteLine("--> ZFIN");                          SendZFIN();                      }                      else {                          int bufSize = (hdr.ZP1 << 8) | hdr.ZP0;                          _frameSize = Math.Min(Math.Max(_frameSize' bufSize)' MAX_BLOCK);                          _txCrcType = ((hdr.ZF0 & CANFC32) != 0) ? CRCType.CRC32 : CRCType.CRC16;                            SendZFILE();                      }                      break;                    case ZRPOS: {                          Debug.WriteLine("Got ZRPOS");                          _afterZRPOS = true;                          uint pos = ((uint)hdr.ZP3 << 24)                                   | ((uint)hdr.ZP2 << 16)                                   | ((uint)hdr.ZP1 << 8)                                   | ((uint)hdr.ZP0);                          Volatile.Write(ref _filePosReq' (uint)Math.Min(Math.Max(0' pos)' _fileSize));                          Debug.WriteLine("_filePosReq = {0}"' _filePosReq);                          Volatile.Write(ref _filePosReqChanged' true);                          if (_sendingTask == null) {                              _sendingTask = Task.Run(() => SendZDATA(_cancellation.Token)' _cancellation.Token);                          }                      }                      break;                    case ZFIN:                      Debug.WriteLine("Got ZFIN");                      SendOverAndOut();                      Completed(false' true'                          _fileSkipped ?                              XZModemPlugin.Instance.Strings.GetString("Message.ZModem.FileSkipped") :                              XZModemPlugin.Instance.Strings.GetString("Message.XModem.SendComplete"));                      break;                    case ZSKIP:                      Debug.WriteLine("Got ZSKIP");                      _fileSkipped = true;                      SendZFIN();                      break;                    case ZACK:                      Debug.WriteLine("Got ZACK");                      break;                    default:                      Debug.WriteLine("Unknown Header : 0x{0:x2}"' hdr.Type);                      break;              }
Magic Number,Poderosa.XZModem,ZModemSender,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,ProcessHeader,The following statement contains a magic number: switch (hdr.Type) {                    case ZRINIT:                      Debug.WriteLine("Got ZRINIT");                      if (_afterZRPOS) {                          Debug.WriteLine("--> ZFIN");                          SendZFIN();                      }                      else {                          int bufSize = (hdr.ZP1 << 8) | hdr.ZP0;                          _frameSize = Math.Min(Math.Max(_frameSize' bufSize)' MAX_BLOCK);                          _txCrcType = ((hdr.ZF0 & CANFC32) != 0) ? CRCType.CRC32 : CRCType.CRC16;                            SendZFILE();                      }                      break;                    case ZRPOS: {                          Debug.WriteLine("Got ZRPOS");                          _afterZRPOS = true;                          uint pos = ((uint)hdr.ZP3 << 24)                                   | ((uint)hdr.ZP2 << 16)                                   | ((uint)hdr.ZP1 << 8)                                   | ((uint)hdr.ZP0);                          Volatile.Write(ref _filePosReq' (uint)Math.Min(Math.Max(0' pos)' _fileSize));                          Debug.WriteLine("_filePosReq = {0}"' _filePosReq);                          Volatile.Write(ref _filePosReqChanged' true);                          if (_sendingTask == null) {                              _sendingTask = Task.Run(() => SendZDATA(_cancellation.Token)' _cancellation.Token);                          }                      }                      break;                    case ZFIN:                      Debug.WriteLine("Got ZFIN");                      SendOverAndOut();                      Completed(false' true'                          _fileSkipped ?                              XZModemPlugin.Instance.Strings.GetString("Message.ZModem.FileSkipped") :                              XZModemPlugin.Instance.Strings.GetString("Message.XModem.SendComplete"));                      break;                    case ZSKIP:                      Debug.WriteLine("Got ZSKIP");                      _fileSkipped = true;                      SendZFIN();                      break;                    case ZACK:                      Debug.WriteLine("Got ZACK");                      break;                    default:                      Debug.WriteLine("Unknown Header : 0x{0:x2}"' hdr.Type);                      break;              }
Magic Number,Poderosa.XZModem,ZModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,ProcessFileData,The following statement contains a magic number: if ((oldPos / 1024) != (_filePos / 1024)) {                  if (!_stopped) {                      _parent.SetProgressValue(_filePos);                  }              }
Magic Number,Poderosa.XZModem,ZModemReceiver,C:\repos\poderosaproject_poderosa\XZModem\zmodem.cs,ProcessFileData,The following statement contains a magic number: if ((oldPos / 1024) != (_filePos / 1024)) {                  if (!_stopped) {                      _parent.SetProgressValue(_filePos);                  }              }
Missing Default,Poderosa.XZModem,XModemSender,C:\repos\poderosaproject_poderosa\XZModem\xmodem.cs,OnReception,The following switch statement is missing a default case: switch (response) {                  case NAK:                      Trace("--> NAK");                  Resend:                      if (_state == State.AfterEOT) {                          Trace("<-- EOT(resend)");                          Send(EOT);                      }                      else {                          SendBlock(_crcMode' true);                      }                      break;                  case LETTER_C:                      Trace("--> C");                      _crcMode = true;                      goto Resend;                  case ACK:                      Trace("--> ACK");                      if (_state == State.AfterEOT) {                          _state = State.Stopped;                          Completed(false' true' XZModemPlugin.Instance.Strings.GetString("Message.XModem.SendComplete"));                      }                      else {                          SendBlock(_crcMode' false);                      }                      break;                  case CAN:                      Trace("--> CAN");                      _state = State.Stopped;                      Abort(XZModemPlugin.Instance.Strings.GetString("Message.ZModem.Aborted")' false);                      break;              }
