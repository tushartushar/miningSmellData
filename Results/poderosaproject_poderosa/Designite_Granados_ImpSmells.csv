Implementation smell,Namespace,Class,File,Method,Description
Long Method,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The method has 111 lines of code.
Long Method,Granados.PKI,EllipticCurve,C:\repos\poderosaproject_poderosa\Granados\EC.cs,FindByName,The method has 103 lines of code.
Long Method,Granados.PKI,EllipticCurveFp,C:\repos\poderosaproject_poderosa\Granados\EC.cs,PointMul,The method has 128 lines of code.
Long Method,Granados.X11,X11ConnectionManager,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,GetUntrustedAccessCookie,The method has 134 lines of code.
Long Method,Granados.SSH2,SSH2ChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,ProcessPacket,The method has 135 lines of code.
Long Method,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,GetDiffieHellmanPrime,The method has 117 lines of code.
Long Method,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The method has 175 lines of code.
Long Method,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The method has 193 lines of code.
Long Method,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,Load,The method has 137 lines of code.
Long Method,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,DownloadFile,The method has 123 lines of code.
Long Method,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,UploadFile,The method has 123 lines of code.
Complex Method,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,Cyclomatic complexity of the method is 12
Complex Method,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,Cyclomatic complexity of the method is 12
Complex Method,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,Cyclomatic complexity of the method is 28
Complex Method,Granados.PKI,EllipticCurveFp,C:\repos\poderosaproject_poderosa\Granados\EC.cs,PointMul,Cyclomatic complexity of the method is 18
Complex Method,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,findRandomStrongPrime,Cyclomatic complexity of the method is 14
Complex Method,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,StripPKCS1Pad,Cyclomatic complexity of the method is 11
Complex Method,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,Cyclomatic complexity of the method is 9
Complex Method,Granados.SSH1,SSH1Packetizer,C:\repos\poderosaproject_poderosa\Granados\SSH1Packet.cs,ConstructPacket,Cyclomatic complexity of the method is 9
Complex Method,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,gcd,Cyclomatic complexity of the method is 8
Complex Method,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,RabinMillerTest,Cyclomatic complexity of the method is 8
Complex Method,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,Cyclomatic complexity of the method is 16
Complex Method,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadTag,Cyclomatic complexity of the method is 9
Complex Method,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,Load,Cyclomatic complexity of the method is 8
Complex Method,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,UploadDirectory,Cyclomatic complexity of the method is 11
Long Parameter List,Granados.AgentForwarding,OpenSSHAgentForwardingMessageHandler,C:\repos\poderosaproject_poderosa\Granados\AgentForwarding.cs,SSH1IRSAChallenge,The method has 5 parameters. Parameters: e' n' encryptedChallenge' sessionId' responseType
Long Parameter List,Granados.Crypto,Cipher,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' result_offset
Long Parameter List,Granados.Crypto,Cipher,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' result_offset
Long Parameter List,Granados.Crypto,BlowfishCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,BlowfishCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,BlowfishCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,BlowfishCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,RijindaelCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,RijindaelCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,BlockXor,The method has 5 parameters. Parameters: src' s_offset' len' dest' d_offset
Long Parameter List,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,memcmp,The method has 5 parameters. Parameters: d1' o1' d2' o2' len
Long Parameter List,Granados.Crypto.SSH1,Cipher,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' result_offset
Long Parameter List,Granados.Crypto.SSH1,Cipher,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' result_offset
Long Parameter List,Granados.Crypto.SSH1,BlowfishCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH1,BlowfishCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH1,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH1,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH1,BlowfishCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH1,BlowfishCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH1,RijindaelCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH1,RijindaelCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,Cipher,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' result_offset
Long Parameter List,Granados.Crypto.SSH2,Cipher,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' result_offset
Long Parameter List,Granados.Crypto.SSH2,BlowfishCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,BlowfishCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,BlowfishCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,BlowfishCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,RijindaelCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Crypto.SSH2,RijindaelCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The method has 5 parameters. Parameters: data' offset' len' result' ro
Long Parameter List,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ByteArrayEqual,The method has 5 parameters. Parameters: d1' o1' d2' o2' len
Long Parameter List,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The method has 5 parameters. Parameters: src' srcOff' len' dest' destOff
Long Parameter List,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The method has 5 parameters. Parameters: src' srcOff' len' dest' destOff
Long Parameter List,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptCBC,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptCBC,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,EncryptCBC,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,DecryptCBC,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,encryptCBC,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,decryptCBC,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,encryptCTR,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,decryptCTR,The method has 5 parameters. Parameters: input' inputOffset' inputLen' output' outputOffset
Long Parameter List,Granados.PKI,EllipticCurveFp,C:\repos\poderosaproject_poderosa\Granados\EC.cs,EllipticCurveFp,The method has 8 parameters. Parameters: algorithm' curveName' p' a' b' G' n' h
Long Parameter List,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,DSAKeyPair,The method has 5 parameters. Parameters: p' g' q' y' x
Long Parameter List,Granados.PKI,RSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,RSAKeyPair,The method has 6 parameters. Parameters: e' d' n' u' p' q
Long Parameter List,Granados.X11,XauthorityEntry,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,XauthorityEntry,The method has 5 parameters. Parameters: family' address' number' name' data
Long Parameter List,Granados.X11,AbstractX11Socket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,SendBytes,The method has 5 parameters. Parameters: sock' buffer' offset' length' timeoutMillisec
Long Parameter List,Granados.X11,AbstractX11Socket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,ReceiveBytes,The method has 5 parameters. Parameters: sock' buffer' offset' length' timeoutMillisec
Long Parameter List,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,X11ChannelHandler,The method has 6 parameters. Parameters: channel' x11sock' spoofedAuthProtocolName' spoofedAuthCookie' authProtocolName' authCookie
Long Parameter List,Granados.SSH1,SSH1ChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,SSH1ChannelBase,The method has 7 parameters. Parameters: timeouts' packetSender' protocolEventManager' localChannel' remoteChannel' channelType' channelTypeString
Long Parameter List,Granados.SSH1,SSH1InteractiveSession,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,SSH1InteractiveSession,The method has 6 parameters. Parameters: timeouts' packetSender' protocolEventManager' localChannel' channelType' channelTypeString
Long Parameter List,Granados.SSH1,SSH1SubChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,SSH1SubChannelBase,The method has 7 parameters. Parameters: timeouts' packetSender' protocolEventManager' localChannel' remoteChannel' channelType' channelTypeString
Long Parameter List,Granados.SSH1,SSH1SubChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,SSH1SubChannelBase,The method has 6 parameters. Parameters: timeouts' packetSender' protocolEventManager' localChannel' channelType' channelTypeString
Long Parameter List,Granados.SSH1,SSH1LocalPortForwardingChannel,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,SSH1LocalPortForwardingChannel,The method has 8 parameters. Parameters: timeouts' packetSender' protocolEventManager' localChannel' remoteHost' remotePort' originatorIp' originatorPort
Long Parameter List,Granados.SSH1,SSH1RemotePortForwardingChannel,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,SSH1RemotePortForwardingChannel,The method has 5 parameters. Parameters: timeouts' packetSender' protocolEventManager' localChannel' remoteChannel
Long Parameter List,Granados.SSH1,SSH1AgentForwardingChannel,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,SSH1AgentForwardingChannel,The method has 5 parameters. Parameters: timeouts' packetSender' protocolEventManager' localChannel' remoteChannel
Long Parameter List,Granados.SSH1,SSH1X11ForwardingChannel,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,SSH1X11ForwardingChannel,The method has 5 parameters. Parameters: timeouts' packetSender' protocolEventManager' localChannel' remoteChannel
Long Parameter List,Granados.SSH1,SSH1Connection,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,SSH1Connection,The method has 6 parameters. Parameters: socket' param' serverVersion' clientVersion' connectionEventHandlerCreator' protocolEventLoggerCreator
Long Parameter List,Granados.SSH1,SSH1Connection,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,ForwardPort,The method has 5 parameters. Parameters: handlerCreator' remoteHost' remotePort' originatorIp' originatorPort
Long Parameter List,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,SSH1KeyExchanger,The method has 7 parameters. Parameters: connection' timeouts' syncHandler' param' info' updateClientKey' updateServerKey
Long Parameter List,Granados.SSH1,SSH1UserAuthentication,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,SSH1UserAuthentication,The method has 5 parameters. Parameters: connection' param' timeouts' syncHandler' sessionID
Long Parameter List,Granados.SSH1,SSH1RemotePortForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,ListenForwardedPort,The method has 6 parameters. Parameters: requestHandler' createChannel' registerChannel' portNumberToBind' hostToConnect' portNumberToConnect
Long Parameter List,Granados.SSH1,SSH1RemotePortForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,ListenForwardedPortCore,The method has 6 parameters. Parameters: requestHandler' createChannel' registerChannel' portNumberToBind' hostToConnect' portNumberToConnect
Long Parameter List,Granados.SSH1,SSH1AgentForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,SSH1AgentForwarding,The method has 5 parameters. Parameters: timeouts' syncHandler' authKeyProvider' createChannel' registerChannel
Long Parameter List,Granados.SSH1,SSH1X11Forwarding,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,SSH1X11Forwarding,The method has 6 parameters. Parameters: timeouts' syncHandler' connectionInfo' protocolEventManager' createChannel' registerChannel
Long Parameter List,Granados.SSH2,SSH2ChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2ChannelBase,The method has 10 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel' remoteChannel' channelType' channelTypeString' serverWindowSize' serverMaxPacketSize
Long Parameter List,Granados.SSH2,SSH2ChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2ChannelBase,The method has 7 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel' channelType' channelTypeString
Long Parameter List,Granados.SSH2,SSH2SessionChannel,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2SessionChannel,The method has 5 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel
Long Parameter List,Granados.SSH2,SSH2ShellChannel,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2ShellChannel,The method has 6 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel' x11ConnectionManager
Long Parameter List,Granados.SSH2,SSH2ExecChannel,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2ExecChannel,The method has 6 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel' command
Long Parameter List,Granados.SSH2,SSH2SubsystemChannel,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2SubsystemChannel,The method has 6 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel' subsystemName
Long Parameter List,Granados.SSH2,SSH2LocalPortForwardingChannel,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2LocalPortForwardingChannel,The method has 9 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel' remoteHost' remotePort' originatorIp' originatorPort
Long Parameter List,Granados.SSH2,SSH2RemotePortForwardingChannel,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2RemotePortForwardingChannel,The method has 8 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel' remoteChannel' serverWindowSize' serverMaxPacketSize
Long Parameter List,Granados.SSH2,SSH2OpenSSHAgentForwardingChannel,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2OpenSSHAgentForwardingChannel,The method has 8 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel' remoteChannel' serverWindowSize' serverMaxPacketSize
Long Parameter List,Granados.SSH2,SSH2X11ForwardingChannel,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,SSH2X11ForwardingChannel,The method has 8 parameters. Parameters: timeouts' packetSender' param' protocolEventManager' localChannel' remoteChannel' serverWindowSize' serverMaxPacketSize
Long Parameter List,Granados.SSH2,SSH2Connection,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,SSH2Connection,The method has 6 parameters. Parameters: socket' param' serverVersion' clientVersion' connectionEventHandlerCreator' protocolEventLoggerCreator
Long Parameter List,Granados.SSH2,SSH2Connection,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,ForwardPort,The method has 5 parameters. Parameters: handlerCreator' remoteHost' remotePort' originatorIp' originatorPort
Long Parameter List,Granados.SSH2,SSH2Connection,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,UpdateKey,The method has 5 parameters. Parameters: sessionID' cipherServer' cipherClient' macServer' macClient
Long Parameter List,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,SSH2KeyExchanger,The method has 6 parameters. Parameters: timeouts' syncHandler' param' protocolEventManager' info' updateKey
Long Parameter List,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,DeriveKey,The method has 5 parameters. Parameters: k' h' letter' length' hashAlgorithm
Long Parameter List,Granados.SSH2,SSH2UserAuthentication,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,SSH2UserAuthentication,The method has 6 parameters. Parameters: connection' param' protocolEventManager' timeouts' syncHandler' sessionID
Long Parameter List,Granados.SSH2,SSH2RemotePortForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,ListenForwardedPort,The method has 5 parameters. Parameters: requestHandler' createChannel' registerChannel' addressToBind' portNumberToBind
Long Parameter List,Granados.SSH2,SSH2RemotePortForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,ListenForwardedPortCore,The method has 6 parameters. Parameters: requestHandler' createChannel' registerChannel' addressToBind' portNumberToBind' portNumberBound
Long Parameter List,Granados.SSH2,SSH2OpenSSHAgentForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,SSH2OpenSSHAgentForwarding,The method has 5 parameters. Parameters: syncHandler' authKeyProvider' protocolEventManager' createChannel' registerChannel
Long Parameter List,Granados.SSH2,SSH2X11Forwarding,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,SSH2X11Forwarding,The method has 5 parameters. Parameters: syncHandler' protocolEventManager' x11ConnectionManager' createChannel' registerChannel
Long Parameter List,Granados,SSHConnectionParameter,C:\repos\poderosaproject_poderosa\Granados\ConnectionParameter.cs,SSHConnectionParameter,The method has 6 parameters. Parameters: hostName' portNumber' protocol' authType' userName' password
Long Parameter List,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ByteArrayEqual,The method has 5 parameters. Parameters: d1' o1' d2' o2' len
Long Parameter List,Granados,ISSHConnection,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,ForwardPort,The method has 5 parameters. Parameters: handlerCreator' remoteHost' remotePort' originatorIp' originatorPort
Long Parameter List,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,Multiply,The method has 8 parameters. Parameters: x' xOffset' xLen' y' yOffset' yLen' d' dOffset
Long Parameter List,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,MultiplyMod2p32pmod,The method has 9 parameters. Parameters: x' xOffset' xLen' y' yOffest' yLen' d' dOffset' mod
Long Parameter List,Granados.Poderosa.KeyFormat,ISSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\ISSH1PrivateKeyLoader.cs,Load,The method has 8 parameters. Parameters: passphrase' modulus' publicExponent' privateExponent' primeP' primeQ' crtCoefficient' comment
Long Parameter List,Granados.Poderosa.KeyFormat,PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PrivateKeyLoader.cs,LoadSSH1PrivateKey,The method has 8 parameters. Parameters: passphrase' modulus' publicExponent' privateExponent' primeP' primeQ' crtCoefficient' comment
Long Parameter List,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,Verify,The method has 9 parameters. Parameters: version' privateMac' privateHash' passphrase' keyTypeName' encryptionName' comment' publicBlob' privateBlob
Long Parameter List,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,Load,The method has 8 parameters. Parameters: passphrase' modulus' publicExponent' privateExponent' primeP' primeQ' crtCoefficient' comment
Long Parameter List,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,Upload,The method has 6 parameters. Parameters: localPath' remotePath' recursive' preserveTime' cancellation' progressDelegate
Long Parameter List,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,UploadDirectory,The method has 5 parameters. Parameters: fullPath' stream' preserveTime' cancellation' progressDelegate
Long Parameter List,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,UploadFile,The method has 5 parameters. Parameters: fullPath' stream' preserveTime' cancellation' progressDelegate
Long Parameter List,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,Download,The method has 6 parameters. Parameters: remotePath' localPath' recursive' preserveTime' cancellation' progressDelegate
Long Parameter List,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,CreateDirectory,The method has 5 parameters. Parameters: stream' directoryPath' modTime' cancellation' progressDelegate
Long Parameter List,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,CreateFile,The method has 6 parameters. Parameters: stream' filePath' entry' modTime' cancellation' progressDelegate
Long Parameter List,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,ReadFile,The method has 5 parameters. Parameters: requestId' handle' offset' length' buffer
Long Parameter List,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,WriteFile,The method has 5 parameters. Parameters: requestId' handle' offset' buff' length
Long Parameter List,Granados.Poderosa.SFTP,SFTPFileAttributes,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPFileAttributes.cs,SFTPFileAttributes,The method has 6 parameters. Parameters: fileSize' uid' gid' permissions' atime' mtime
Long Parameter List,Granados.SSH,ISSHConnection,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,ForwardPort,The method has 5 parameters. Parameters: handlerCreator' remoteHost' remotePort' originatorIp' originatorPort
Long Identifier,Granados.SSH2,SSH2ChannelOpenFailureCode,C:\repos\poderosaproject_poderosa\Granados\SSH2Util.cs,,The length of the parameter SSH_OPEN_ADMINISTRATIVELY_PROHIBITED is 36.
Long Statement,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,ParseDomainSocketFile,The length of the statement  "            var match = Regex.Match(line' @"^!<socket\s*>(\d+)\s+s\s+([a-fA-F0-9]{8})-([a-fA-F0-9]{8})-([a-fA-F0-9]{8})-([a-fA-F0-9]{8})"); " is 127.
Long Statement,Granados.X11,X11ConnectionManager,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,CreateChannelHandler,The length of the statement  "            return new X11ChannelHandler(channel' socket' _spoofedAuthProtocolName' _spoofedAuthCookie' _xAuthProtocolName' _xAuthCookie); " is 126.
Long Statement,Granados.SSH1,SSH1Connection,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,ListenForwardedPort,The length of the statement  "            string hostToConnect = "granados" + Interlocked.Increment(ref _remotePortForwardCount).ToString(NumberFormatInfo.InvariantInfo); " is 128.
Long Statement,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The length of the statement  "            BigInteger firstResult = RSAUtil.PKCS1PadType2(sessionKeyXor' firstKeyByteLen' rng).ModPow(firstEncryption.Exponent' firstEncryption.Modulus); " is 142.
Long Statement,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The length of the statement  "            BigInteger secondResult = RSAUtil.PKCS1PadType2(firstResult.GetBytes()' secondKeyByteLen' rng).ModPow(secondEncryption.Exponent' secondEncryption.Modulus); " is 155.
Long Statement,Granados.SSH2,SSH2Connection,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,DoProcessPacket,The length of the statement  "            if (packetType >= SSH2PacketType.SSH_MSG_CHANNEL_OPEN_CONFIRMATION && packetType <= SSH2PacketType.SSH_MSG_CHANNEL_FAILURE) { " is 125.
Long Statement,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,KexDiffieHellman,The length of the statement  "                Debug.Assert(_sequenceStatus == SequenceStatus.WaitNewKeys || _sequenceStatus == SequenceStatus.WaitUpdateCipher);    // already set in FeedReceivedPacket " is 154.
Long Statement,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,GetCipherSettings,The length of the statement  "                    DeriveKey(state.secret' state.hash' 'C'' CipherFactory.GetKeySize(_cInfo.OutgoingPacketCipher.Value)' state.hashAlgorithm)' " is 123.
Long Statement,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,GetCipherSettings,The length of the statement  "                    DeriveKey(state.secret' state.hash' 'A'' CipherFactory.GetBlockSize(_cInfo.OutgoingPacketCipher.Value)' state.hashAlgorithm) " is 124.
Long Statement,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,GetCipherSettings,The length of the statement  "                    DeriveKey(state.secret' state.hash' 'D'' CipherFactory.GetKeySize(_cInfo.IncomingPacketCipher.Value)' state.hashAlgorithm)' " is 123.
Long Statement,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,GetCipherSettings,The length of the statement  "                    DeriveKey(state.secret' state.hash' 'B'' CipherFactory.GetBlockSize(_cInfo.IncomingPacketCipher.Value)' state.hashAlgorithm) " is 124.
Long Statement,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,GetCipherSettings,The length of the statement  "                    DeriveKey(state.secret' state.hash' 'E'' MACFactory.GetSize(_cInfo.OutgoingPacketMacAlgorithm.Value)' state.hashAlgorithm) " is 122.
Long Statement,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,GetCipherSettings,The length of the statement  "                    DeriveKey(state.secret' state.hash' 'F'' MACFactory.GetSize(_cInfo.IncomingPacketMacAlgorithm.Value)' state.hashAlgorithm) " is 122.
Long Statement,Granados.SSH2,SSH2RemotePortForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,CheckForwardedTcpIpPacket,The length of the statement  "            _protocolEventManager.Trace("new port-forwarding channel : local={0} remote={1}"' channel.LocalChannel' channel.RemoteChannel); " is 127.
Long Statement,Granados.SSH2,SSH2OpenSSHAgentForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,InterceptPacket,The length of the statement  "            _protocolEventManager.Trace("new agent forwarding channel : local={0} remote={1}"' channel.LocalChannel' channel.RemoteChannel); " is 128.
Long Statement,Granados.SSH2,SSH2X11Forwarding,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,InterceptPacket,The length of the statement  "            _protocolEventManager.Trace("new X11 forwarding channel : local={0} remote={1}"' channel.LocalChannel' channel.RemoteChannel); " is 126.
Long Statement,Granados.Mono.Math,ModulusRing,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BarrettReduction,The length of the statement  "				Kernel.MultiplyMod2p32pmod (q3.data' (int)kPlusOne' (int)q3.length - (int)kPlusOne' n.data' 0' (int)n.length' r2.data' 0' (int)kPlusOne); " is 137.
Long Statement,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadTagInfo,The length of the statement  "            return ReadTag(ref tagInfo.ClassBits' ref tagInfo.IsConstructed' ref tagInfo.TagNumber) && ReadLength(ref tagInfo.Length); " is 122.
Long Statement,Granados.Poderosa.KeyFormat,PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PrivateKeyLoader.cs,ProbeFormat,The length of the statement  "                || ByteArrayUtil.ByteArrayStartsWith(keyFile' Encoding.ASCII.GetBytes(PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_OPENSSH))) " is 121.
Long Statement,Granados.Poderosa.KeyFormat,PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PrivateKeyLoader.cs,LoadSSH1PrivateKey,The length of the statement  "            loader.Load(passphrase' out modulus' out publicExponent' out privateExponent' out primeP' out primeQ' out crtCoefficient' out comment); " is 135.
Long Statement,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,ConnectAndOpenShell,The length of the statement  "            SSHConnectionParameter f = new SSHConnectionParameter("172.22.1.15"' 22' SSHProtocol.SSH2' AuthenticationType.PublicKey' "okajima"' "aaa"); " is 139.
Long Statement,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,ConnectSSH2AndPortforwarding,The length of the statement  "            SSHConnectionParameter f = new SSHConnectionParameter("10.10.9.8"' 22' SSHProtocol.SSH2' AuthenticationType.Password' "root"' ""); " is 130.
Long Statement,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,AgentForward,The length of the statement  "            SSHConnectionParameter f = new SSHConnectionParameter("172.22.1.15"' 22' SSHProtocol.SSH2' AuthenticationType.Password' "root"' ""); " is 132.
Complex Conditional,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The conditional expression  "pass.Length == 0 || salt.Length == 0 || keylen <= 0 || keylen > 1024"  is complex.
Complex Conditional,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The conditional expression  "pass.Length == 0 || salt.Length == 0 || keylen <= 0 || keylen > 1024"  is complex.
Complex Conditional,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The conditional expression  "pass.Length == 0 || salt.Length == 0 || keylen <= 0 || keylen > 1024"  is complex.
Complex Conditional,Granados.Algorithms,BlowfishTest,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Test,The conditional expression  "w.Length < 3 || w[0].Length != 16 || w[1].Length != 16 || w[2].Length != 16"  is complex.
Complex Conditional,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestSignatureVerification,The conditional expression  "msg != null && qx != null && qy != null && r != null && s != null"  is complex.
Complex Conditional,Granados.PKI,EllipticCurveFp,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ValidatePoint,The conditional expression  "x == 0 || x >= p || y == 0 || y >= p"  is complex.
Complex Conditional,Granados.PKI,ECDSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\EC.cs,Verify,The conditional expression  "r == 0 || r >= _curve.Order || s == 0 || s >= _curve.Order"  is complex.
Complex Conditional,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadTag,The conditional expression  "ReadTagInfo(ref tagInfo)                  && tagInfo.ClassBits == (int)tagClass                  && tagInfo.IsConstructed == isConstructed                  && tagInfo.TagNumber == tagNumber"  is complex.
Complex Conditional,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The conditional expression  "!reader.ReadInteger(out v) ||                          !reader.ReadInteger(out n) ||                          !reader.ReadInteger(out e) ||                          !reader.ReadInteger(out d) ||                          !reader.ReadInteger(out p) ||                          !reader.ReadInteger(out q) ||                          !reader.ReadInteger(out dmp1) ||                          !reader.ReadInteger(out dmq1) ||                          !reader.ReadInteger(out iqmp)"  is complex.
Complex Conditional,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The conditional expression  "!reader.ReadInteger(out v) ||                          !reader.ReadInteger(out p) ||                          !reader.ReadInteger(out q) ||                          !reader.ReadInteger(out g) ||                          !reader.ReadInteger(out y) ||                          !reader.ReadInteger(out x)"  is complex.
Complex Conditional,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The conditional expression  "!reader.ReadInteger(out v) ||                          !reader.ReadOctetString(out privateKey) ||                          !reader.ReadTag(BERReader.TagClass.ContextSpecific' true' 0' out len) ||                          !reader.ReadObjectIdentifier(out namedCurve) ||                          !reader.ReadTag(BERReader.TagClass.ContextSpecific' true' 1' out len) ||                          !reader.ReadBitString(out publicKey)"  is complex.
Complex Conditional,Granados.Poderosa.KeyFormat,PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PrivateKeyLoader.cs,ProbeFormat,The conditional expression  "ByteArrayUtil.ByteArrayStartsWith(keyFile' Encoding.ASCII.GetBytes(PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_RSA))                  || ByteArrayUtil.ByteArrayStartsWith(keyFile' Encoding.ASCII.GetBytes(PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_DSA))                  || ByteArrayUtil.ByteArrayStartsWith(keyFile' Encoding.ASCII.GetBytes(PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_ECDSA))                  || ByteArrayUtil.ByteArrayStartsWith(keyFile' Encoding.ASCII.GetBytes(PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_OPENSSH))"  is complex.
Empty Catch Block,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,OnDataFromXServer,The method has an empty catch block.
Magic Number,Granados.AgentForwarding,OpenSSHAgentForwardingMessage,C:\repos\poderosaproject_poderosa\Granados\AgentForwarding.cs,GetImage,The following statement contains a magic number: int messageLength = _payload.Length - 4;
Magic Number,Granados.AgentForwarding,OpenSSHAgentForwardingMessageHandler,C:\repos\poderosaproject_poderosa\Granados\AgentForwarding.cs,OnData,The following statement contains a magic number: if (_buffer.Length >= 4) {                  uint messageLength = SSHUtil.ReadUInt32(_buffer.RawBuffer' _buffer.RawBufferOffset);                  if (_buffer.Length >= 4 + messageLength) {                      DataFragment message = new DataFragment(_buffer.RawBuffer' _buffer.RawBufferOffset + 4' (int)messageLength);                      try {                          ProcessMessage(message);                      }                      catch (Exception e) {                          Debug.WriteLine(e.Message);                          Debug.WriteLine(e.StackTrace);                      }                      _buffer.RemoveHead(4 + (int)messageLength);                  }              }
Magic Number,Granados.AgentForwarding,OpenSSHAgentForwardingMessageHandler,C:\repos\poderosaproject_poderosa\Granados\AgentForwarding.cs,OnData,The following statement contains a magic number: if (_buffer.Length >= 4) {                  uint messageLength = SSHUtil.ReadUInt32(_buffer.RawBuffer' _buffer.RawBufferOffset);                  if (_buffer.Length >= 4 + messageLength) {                      DataFragment message = new DataFragment(_buffer.RawBuffer' _buffer.RawBufferOffset + 4' (int)messageLength);                      try {                          ProcessMessage(message);                      }                      catch (Exception e) {                          Debug.WriteLine(e.Message);                          Debug.WriteLine(e.StackTrace);                      }                      _buffer.RemoveHead(4 + (int)messageLength);                  }              }
Magic Number,Granados.AgentForwarding,OpenSSHAgentForwardingMessageHandler,C:\repos\poderosaproject_poderosa\Granados\AgentForwarding.cs,OnData,The following statement contains a magic number: if (_buffer.Length >= 4) {                  uint messageLength = SSHUtil.ReadUInt32(_buffer.RawBuffer' _buffer.RawBufferOffset);                  if (_buffer.Length >= 4 + messageLength) {                      DataFragment message = new DataFragment(_buffer.RawBuffer' _buffer.RawBufferOffset + 4' (int)messageLength);                      try {                          ProcessMessage(message);                      }                      catch (Exception e) {                          Debug.WriteLine(e.Message);                          Debug.WriteLine(e.StackTrace);                      }                      _buffer.RemoveHead(4 + (int)messageLength);                  }              }
Magic Number,Granados.AgentForwarding,OpenSSHAgentForwardingMessageHandler,C:\repos\poderosaproject_poderosa\Granados\AgentForwarding.cs,OnData,The following statement contains a magic number: if (_buffer.Length >= 4) {                  uint messageLength = SSHUtil.ReadUInt32(_buffer.RawBuffer' _buffer.RawBufferOffset);                  if (_buffer.Length >= 4 + messageLength) {                      DataFragment message = new DataFragment(_buffer.RawBuffer' _buffer.RawBufferOffset + 4' (int)messageLength);                      try {                          ProcessMessage(message);                      }                      catch (Exception e) {                          Debug.WriteLine(e.Message);                          Debug.WriteLine(e.StackTrace);                      }                      _buffer.RemoveHead(4 + (int)messageLength);                  }              }
Magic Number,Granados.AgentForwarding,OpenSSHAgentForwardingMessageHandler,C:\repos\poderosaproject_poderosa\Granados\AgentForwarding.cs,ProcessMessage,The following statement contains a magic number: switch (messageType) {                  // for SSH1 keys                  case OpenSSHAgentForwardingMessageType.SSH_AGENTC_REQUEST_RSA_IDENTITIES:                      SSH1Identities();                      break;                  case OpenSSHAgentForwardingMessageType.SSH_AGENTC_RSA_CHALLENGE: {                          reader.ReadUInt32();    // ignored                          BigInteger e = reader.ReadMPInt();                          BigInteger n = reader.ReadMPInt();                          BigInteger encryptedChallenge = reader.ReadMPInt();                          byte[] sessionId = reader.Read(16);                          uint responseType = reader.ReadUInt32();                            SSH1IRSAChallenge(e' n' encryptedChallenge' sessionId' responseType);                      }                      break;                  // for SSH2 keys                  case OpenSSHAgentForwardingMessageType.SSH2_AGENTC_REQUEST_IDENTITIES:                      SSH2Identities();                      break;                  case OpenSSHAgentForwardingMessageType.SSH2_AGENTC_SIGN_REQUEST: {                          byte[] blob = reader.ReadByteString();                          byte[] data = reader.ReadByteString();                          uint flags = reader.ReadUInt32();                            SSH2Sign(blob' data' flags);                      }                      break;                  default:                      SendFailure();                      break;              }
Magic Number,Granados.AgentForwarding,OpenSSHAgentForwardingMessageHandler,C:\repos\poderosaproject_poderosa\Granados\AgentForwarding.cs,SSH1IRSAChallenge,The following statement contains a magic number: byte[] rawchallenge = RSAUtil.StripPKCS1Pad(challenge' 2).GetBytes();
Magic Number,Granados.Crypto,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetBlockSize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                  case CipherAlgorithm.Blowfish:                      return 8;                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES128CTR:                  case CipherAlgorithm.AES192CTR:                  case CipherAlgorithm.AES256CTR:                      return 16;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetBlockSize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                  case CipherAlgorithm.Blowfish:                      return 8;                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES128CTR:                  case CipherAlgorithm.AES192CTR:                  case CipherAlgorithm.AES256CTR:                      return 16;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto,MACFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetSize,The following statement contains a magic number: switch (algorithm) {                  case MACAlgorithm.HMACSHA1:                      return 20;                  case MACAlgorithm.HMACSHA256:                      return 32;                  case MACAlgorithm.HMACSHA512:                      return 64;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto,MACFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetSize,The following statement contains a magic number: switch (algorithm) {                  case MACAlgorithm.HMACSHA1:                      return 20;                  case MACAlgorithm.HMACSHA256:                      return 32;                  case MACAlgorithm.HMACSHA512:                      return 64;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto,MACFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetSize,The following statement contains a magic number: switch (algorithm) {                  case MACAlgorithm.HMACSHA1:                      return 20;                  case MACAlgorithm.HMACSHA256:                      return 32;                  case MACAlgorithm.HMACSHA512:                      return 64;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: const int BLOCKSIZE = 8;
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {                  blowfish.ExpandState(sha2salt);                  blowfish.ExpandState(sha2pass);              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {                  for (int j = 0; j < 32; j += BLOCKSIZE) {                      blowfish.BlockEncrypt(cdata' j' cdata' j);                  }              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {                  for (int j = 0; j < 32; j += BLOCKSIZE) {                      blowfish.BlockEncrypt(cdata' j' cdata' j);                  }              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: if (pass.Length == 0 || salt.Length == 0 || keylen <= 0 || keylen > 1024) {                  return null;              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: int stride = (keylen + 32 - 1) / 32;
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: int stride = (keylen + 32 - 1) / 32;
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto,BlowfishCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BlowfishCipher1,The following statement contains a magic number: Debug.Assert(key.Length == 32);
Magic Number,Granados.Crypto,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher1,The following statement contains a magic number: Debug.Assert(key.Length == 24);
Magic Number,Granados.Crypto,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher1,The following statement contains a magic number: _DESCipher2.InitializeKey(key' 8);
Magic Number,Granados.Crypto,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher1,The following statement contains a magic number: _DESCipher3.InitializeKey(key' 16);
Magic Number,Granados.Crypto,BlowfishCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BlowfishCipher2,The following statement contains a magic number: Debug.Assert(key.Length == 32);
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher2,The following statement contains a magic number: _DESCipher2.InitializeKey(key' 8);
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher2,The following statement contains a magic number: _DESCipher3.InitializeKey(key' 16);
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: Debug.Assert(key.Length == 24);
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _buffer = new byte[8];
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _ivSave = new byte[8];
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _DESCipher2.InitializeKey(key' 8);
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _DESCipher3.InitializeKey(key' 16);
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntLE,The following statement contains a magic number: return ((uint)src[offset] |                  ((uint)(src[offset + 1]) << 8) |                  ((uint)(src[offset + 2]) << 16) |                  ((uint)(src[offset + 3]) << 24));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntLE,The following statement contains a magic number: return ((uint)src[offset] |                  ((uint)(src[offset + 1]) << 8) |                  ((uint)(src[offset + 2]) << 16) |                  ((uint)(src[offset + 3]) << 24));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntLE,The following statement contains a magic number: return ((uint)src[offset] |                  ((uint)(src[offset + 1]) << 8) |                  ((uint)(src[offset + 2]) << 16) |                  ((uint)(src[offset + 3]) << 24));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntLE,The following statement contains a magic number: return ((uint)src[offset] |                  ((uint)(src[offset + 1]) << 8) |                  ((uint)(src[offset + 2]) << 16) |                  ((uint)(src[offset + 3]) << 24));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntLE,The following statement contains a magic number: return ((uint)src[offset] |                  ((uint)(src[offset + 1]) << 8) |                  ((uint)(src[offset + 2]) << 16) |                  ((uint)(src[offset + 3]) << 24));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntLE,The following statement contains a magic number: dest[offset + 1] = (byte)((val >> 8) & 0xff);
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntLE,The following statement contains a magic number: dest[offset + 2] = (byte)((val >> 16) & 0xff);
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntLE,The following statement contains a magic number: dest[offset + 2] = (byte)((val >> 16) & 0xff);
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntLE,The following statement contains a magic number: dest[offset + 3] = (byte)((val >> 24) & 0xff);
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntLE,The following statement contains a magic number: dest[offset + 3] = (byte)((val >> 24) & 0xff);
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntBE,The following statement contains a magic number: return (((uint)(src[offset]) << 24) |                  ((uint)(src[offset + 1]) << 16) |                  ((uint)(src[offset + 2]) << 8) |                  ((uint)src[offset + 3]));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntBE,The following statement contains a magic number: return (((uint)(src[offset]) << 24) |                  ((uint)(src[offset + 1]) << 16) |                  ((uint)(src[offset + 2]) << 8) |                  ((uint)src[offset + 3]));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntBE,The following statement contains a magic number: return (((uint)(src[offset]) << 24) |                  ((uint)(src[offset + 1]) << 16) |                  ((uint)(src[offset + 2]) << 8) |                  ((uint)src[offset + 3]));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntBE,The following statement contains a magic number: return (((uint)(src[offset]) << 24) |                  ((uint)(src[offset + 1]) << 16) |                  ((uint)(src[offset + 2]) << 8) |                  ((uint)src[offset + 3]));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,GetIntBE,The following statement contains a magic number: return (((uint)(src[offset]) << 24) |                  ((uint)(src[offset + 1]) << 16) |                  ((uint)(src[offset + 2]) << 8) |                  ((uint)src[offset + 3]));
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntBE,The following statement contains a magic number: dest[offset] = (byte)((val >> 24) & 0xff);
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntBE,The following statement contains a magic number: dest[offset + 1] = (byte)((val >> 16) & 0xff);
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntBE,The following statement contains a magic number: dest[offset + 2] = (byte)((val >> 8) & 0xff);
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntBE,The following statement contains a magic number: dest[offset + 2] = (byte)((val >> 8) & 0xff);
Magic Number,Granados.Crypto,CipherUtil,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,PutIntBE,The following statement contains a magic number: dest[offset + 3] = (byte)(val & 0xff);
Magic Number,Granados.Crypto,BigIntegerConverter,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,ParseBinary,The following statement contains a magic number: int bytes = (s.Length + 7) / 8;
Magic Number,Granados.Crypto,BigIntegerConverter,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,ParseBinary,The following statement contains a magic number: int bytes = (s.Length + 7) / 8;
Magic Number,Granados.Crypto,BigIntegerConverter,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,ParseBinary,The following statement contains a magic number: byte mask = (byte)(1 << ((s.Length - 1) % 8));
Magic Number,Granados.Crypto,BigIntegerConverter,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,ParseHex,The following statement contains a magic number: int bytes = (s.Length + 1) / 2;
Magic Number,Granados.Crypto,BigIntegerConverter,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,ParseHex,The following statement contains a magic number: bool highbits = (s.Length % 2 == 0);
Magic Number,Granados.Crypto,BigIntegerConverter,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,ParseHex,The following statement contains a magic number: foreach (char ch in s) {                  byte v;                  switch (ch) {                      case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          v = (byte)(ch - '0');                          break;                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                          v = (byte)(ch - 'a' + 10);                          break;                      case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                          v = (byte)(ch - 'A' + 10);                          break;                      default:                          throw new ArgumentException("invalid hex number");                  }                    if (highbits) {                      b |= (byte)(v << 4);                      highbits = false;                  }                  else {                      b |= v;                      data[dataIndex] = b;                      b = 0;                      highbits = true;                      ++dataIndex;                  }              }
Magic Number,Granados.Crypto,BigIntegerConverter,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,ParseHex,The following statement contains a magic number: foreach (char ch in s) {                  byte v;                  switch (ch) {                      case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          v = (byte)(ch - '0');                          break;                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                          v = (byte)(ch - 'a' + 10);                          break;                      case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                          v = (byte)(ch - 'A' + 10);                          break;                      default:                          throw new ArgumentException("invalid hex number");                  }                    if (highbits) {                      b |= (byte)(v << 4);                      highbits = false;                  }                  else {                      b |= v;                      data[dataIndex] = b;                      b = 0;                      highbits = true;                      ++dataIndex;                  }              }
Magic Number,Granados.Crypto,BigIntegerConverter,C:\repos\poderosaproject_poderosa\Granados\CipherUtil.cs,ParseHex,The following statement contains a magic number: foreach (char ch in s) {                  byte v;                  switch (ch) {                      case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          v = (byte)(ch - '0');                          break;                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                          v = (byte)(ch - 'a' + 10);                          break;                      case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                          v = (byte)(ch - 'A' + 10);                          break;                      default:                          throw new ArgumentException("invalid hex number");                  }                    if (highbits) {                      b |= (byte)(v << 4);                      highbits = false;                  }                  else {                      b |= v;                      data[dataIndex] = b;                      b = 0;                      highbits = true;                      ++dataIndex;                  }              }
Magic Number,Granados.Crypto.SSH1,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH1,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH1,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH1,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH1,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetBlockSize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                  case CipherAlgorithm.Blowfish:                      return 8;                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES128CTR:                  case CipherAlgorithm.AES192CTR:                  case CipherAlgorithm.AES256CTR:                      return 16;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH1,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetBlockSize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                  case CipherAlgorithm.Blowfish:                      return 8;                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES128CTR:                  case CipherAlgorithm.AES192CTR:                  case CipherAlgorithm.AES256CTR:                      return 16;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH1,MACFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetSize,The following statement contains a magic number: switch (algorithm) {                  case MACAlgorithm.HMACSHA1:                      return 20;                  case MACAlgorithm.HMACSHA256:                      return 32;                  case MACAlgorithm.HMACSHA512:                      return 64;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH1,MACFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetSize,The following statement contains a magic number: switch (algorithm) {                  case MACAlgorithm.HMACSHA1:                      return 20;                  case MACAlgorithm.HMACSHA256:                      return 32;                  case MACAlgorithm.HMACSHA512:                      return 64;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH1,MACFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetSize,The following statement contains a magic number: switch (algorithm) {                  case MACAlgorithm.HMACSHA1:                      return 20;                  case MACAlgorithm.HMACSHA256:                      return 32;                  case MACAlgorithm.HMACSHA512:                      return 64;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: const int BLOCKSIZE = 8;
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {                  blowfish.ExpandState(sha2salt);                  blowfish.ExpandState(sha2pass);              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {                  for (int j = 0; j < 32; j += BLOCKSIZE) {                      blowfish.BlockEncrypt(cdata' j' cdata' j);                  }              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {                  for (int j = 0; j < 32; j += BLOCKSIZE) {                      blowfish.BlockEncrypt(cdata' j' cdata' j);                  }              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: if (pass.Length == 0 || salt.Length == 0 || keylen <= 0 || keylen > 1024) {                  return null;              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: int stride = (keylen + 32 - 1) / 32;
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: int stride = (keylen + 32 - 1) / 32;
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH1,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH1,BlowfishCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BlowfishCipher1,The following statement contains a magic number: Debug.Assert(key.Length == 32);
Magic Number,Granados.Crypto.SSH1,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher1,The following statement contains a magic number: Debug.Assert(key.Length == 24);
Magic Number,Granados.Crypto.SSH1,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher1,The following statement contains a magic number: _DESCipher2.InitializeKey(key' 8);
Magic Number,Granados.Crypto.SSH1,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher1,The following statement contains a magic number: _DESCipher3.InitializeKey(key' 16);
Magic Number,Granados.Crypto.SSH1,BlowfishCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BlowfishCipher2,The following statement contains a magic number: Debug.Assert(key.Length == 32);
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher2,The following statement contains a magic number: _DESCipher2.InitializeKey(key' 8);
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher2,The following statement contains a magic number: _DESCipher3.InitializeKey(key' 16);
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: Debug.Assert(key.Length == 24);
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _buffer = new byte[8];
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _ivSave = new byte[8];
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _DESCipher2.InitializeKey(key' 8);
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _DESCipher3.InitializeKey(key' 16);
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto.SSH1,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto.SSH2,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH2,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH2,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH2,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetKeySize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                      return 24;                  case CipherAlgorithm.Blowfish:                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES128CTR:                      return 16;                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES192CTR:                      return 24;                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES256CTR:                      return 32;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH2,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetBlockSize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                  case CipherAlgorithm.Blowfish:                      return 8;                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES128CTR:                  case CipherAlgorithm.AES192CTR:                  case CipherAlgorithm.AES256CTR:                      return 16;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH2,CipherFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetBlockSize,The following statement contains a magic number: switch (algorithm) {                  case CipherAlgorithm.TripleDES:                  case CipherAlgorithm.Blowfish:                      return 8;                  case CipherAlgorithm.AES128:                  case CipherAlgorithm.AES192:                  case CipherAlgorithm.AES256:                  case CipherAlgorithm.AES128CTR:                  case CipherAlgorithm.AES192CTR:                  case CipherAlgorithm.AES256CTR:                      return 16;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH2,MACFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetSize,The following statement contains a magic number: switch (algorithm) {                  case MACAlgorithm.HMACSHA1:                      return 20;                  case MACAlgorithm.HMACSHA256:                      return 32;                  case MACAlgorithm.HMACSHA512:                      return 64;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH2,MACFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetSize,The following statement contains a magic number: switch (algorithm) {                  case MACAlgorithm.HMACSHA1:                      return 20;                  case MACAlgorithm.HMACSHA256:                      return 32;                  case MACAlgorithm.HMACSHA512:                      return 64;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH2,MACFactory,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,GetSize,The following statement contains a magic number: switch (algorithm) {                  case MACAlgorithm.HMACSHA1:                      return 20;                  case MACAlgorithm.HMACSHA256:                      return 32;                  case MACAlgorithm.HMACSHA512:                      return 64;                  default:                      throw new SSHException("unknown algorithm " + algorithm);              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: const int BLOCKSIZE = 8;
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {                  blowfish.ExpandState(sha2salt);                  blowfish.ExpandState(sha2pass);              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {                  for (int j = 0; j < 32; j += BLOCKSIZE) {                      blowfish.BlockEncrypt(cdata' j' cdata' j);                  }              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {                  for (int j = 0; j < 32; j += BLOCKSIZE) {                      blowfish.BlockEncrypt(cdata' j' cdata' j);                  }              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptHash,The following statement contains a magic number: for (int i = 0; i < 32; i += 4) {                  byte b0 = cdata[i + 0];                  byte b1 = cdata[i + 1];                  byte b2 = cdata[i + 2];                  byte b3 = cdata[i + 3];                  cdata[i + 3] = b0;                  cdata[i + 2] = b1;                  cdata[i + 1] = b2;                  cdata[i + 0] = b3;              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: if (pass.Length == 0 || salt.Length == 0 || keylen <= 0 || keylen > 1024) {                  return null;              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: int stride = (keylen + 32 - 1) / 32;
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: int stride = (keylen + 32 - 1) / 32;
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH2,Bcrypt,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BcryptPbkdf,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                    // collapse password                  byte[] passData = Encoding.UTF8.GetBytes(pass);                  byte[] sha2pass = sha512.ComputeHash(passData);                    // generate key' sizeof(out) at a time                  byte[] countsalt = new byte[4];                  for (int count = 1; keylen > 0; ++count) {                      countsalt[0] = (byte)(count >> 24);                      countsalt[1] = (byte)(count >> 16);                      countsalt[2] = (byte)(count >> 8);                      countsalt[3] = (byte)(count);                        // first round' salt is salt                      sha512.Initialize();                      sha512.TransformBlock(salt' 0' salt.Length' null' 0);                      sha512.TransformFinalBlock(countsalt' 0' countsalt.Length);                      byte[] sha2salt = sha512.Hash;                      byte[] tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                      byte[] output = (byte[])tmpout.Clone();                        for (uint r = rounds; r > 1; --r) {                          // subsequent rounds' salt is previous output                          sha512.Initialize();                          sha2salt = sha512.ComputeHash(tmpout);                          tmpout = BcryptHash(blowfish' sha2pass' sha2salt);                          for (int i = 0; i < output.Length; ++i) {                              output[i] ^= tmpout[i];                          }                      }                        // pbkdf2 deviation: output the key material non-linearly.                      amt = Math.Min(amt' keylen);                      int k;                      for (k = 0; k < amt; ++k) {                          int dest = k * stride + (count - 1);                          if (dest >= key.Length) {                              break;                          }                          key[dest] = output[k];                      }                      keylen -= k;                  }              }
Magic Number,Granados.Crypto.SSH2,BlowfishCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BlowfishCipher1,The following statement contains a magic number: Debug.Assert(key.Length == 32);
Magic Number,Granados.Crypto.SSH2,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher1,The following statement contains a magic number: Debug.Assert(key.Length == 24);
Magic Number,Granados.Crypto.SSH2,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher1,The following statement contains a magic number: _DESCipher2.InitializeKey(key' 8);
Magic Number,Granados.Crypto.SSH2,TripleDESCipher1,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher1,The following statement contains a magic number: _DESCipher3.InitializeKey(key' 16);
Magic Number,Granados.Crypto.SSH2,BlowfishCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,BlowfishCipher2,The following statement contains a magic number: Debug.Assert(key.Length == 32);
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher2,The following statement contains a magic number: _DESCipher2.InitializeKey(key' 8);
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,TripleDESCipher2,The following statement contains a magic number: _DESCipher3.InitializeKey(key' 16);
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: Debug.Assert(key.Length == 24);
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _buffer = new byte[8];
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _ivSave = new byte[8];
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _DESCipher2.InitializeKey(key' 8);
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Init,The following statement contains a magic number: _DESCipher3.InitializeKey(key' 16);
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Encrypt,The following statement contains a magic number: while (n < len) {                  _DESCipher1.EncryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.DecryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher3.EncryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher1.SetIV(result' ro + n);                  _DESCipher2.SetIV(result' ro + n);                  _DESCipher3.SetIV(result' ro + n);                  n += 8;              }
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Crypto.SSH2,TripleDESCipher2,C:\repos\poderosaproject_poderosa\Granados\AlgorithmSupport.cs,Decrypt,The following statement contains a magic number: while (n < len) {                  Buffer.BlockCopy(data' offset + n' _ivSave' 0' 8);                  _DESCipher3.DecryptCBC(data' offset + n' 8' result' ro + n);                  _DESCipher2.EncryptCBC(result' ro + n' 8' _buffer' 0);                  _DESCipher1.DecryptCBC(_buffer' 0' 8' result' ro + n);                  _DESCipher3.SetIV(_ivSave);                  _DESCipher2.SetIV(_ivSave);                  _DESCipher1.SetIV(_ivSave);                  n += 8;              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Decode,The following statement contains a magic number: byte[] data = new byte[(length * 3) / 4];
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Decode,The following statement contains a magic number: byte[] data = new byte[(length * 3) / 4];
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Decode,The following statement contains a magic number: for (int i = offset; i < n; i++) {                  c = _fromBase64[encoded[i]];                  if (c < 0) {                      if (encoded[i] == _toBase64[PAD])                          break;                      continue;                  }                  v = (v << 6) | c;                  bits += 6;                  if (bits >= 8) {                      bits -= 8;                      data[j++] = (byte)((v >> bits) & 0xff);                  }              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Decode,The following statement contains a magic number: for (int i = offset; i < n; i++) {                  c = _fromBase64[encoded[i]];                  if (c < 0) {                      if (encoded[i] == _toBase64[PAD])                          break;                      continue;                  }                  v = (v << 6) | c;                  bits += 6;                  if (bits >= 8) {                      bits -= 8;                      data[j++] = (byte)((v >> bits) & 0xff);                  }              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Decode,The following statement contains a magic number: for (int i = offset; i < n; i++) {                  c = _fromBase64[encoded[i]];                  if (c < 0) {                      if (encoded[i] == _toBase64[PAD])                          break;                      continue;                  }                  v = (v << 6) | c;                  bits += 6;                  if (bits >= 8) {                      bits -= 8;                      data[j++] = (byte)((v >> bits) & 0xff);                  }              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Decode,The following statement contains a magic number: for (int i = offset; i < n; i++) {                  c = _fromBase64[encoded[i]];                  if (c < 0) {                      if (encoded[i] == _toBase64[PAD])                          break;                      continue;                  }                  v = (v << 6) | c;                  bits += 6;                  if (bits >= 8) {                      bits -= 8;                      data[j++] = (byte)((v >> bits) & 0xff);                  }              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: r = length % 3;
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: encoded = new byte[((length / 3) * 4) + (r != 0 ? 4 : 0)];
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: encoded = new byte[((length / 3) * 4) + (r != 0 ? 4 : 0)];
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: encoded = new byte[((length / 3) * 4) + (r != 0 ? 4 : 0)];
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: for (i = offset' j = 0; i < n; i += 3' j += 4) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (((data[i] & 0x03) << 4) | ((data[i + 1] & 0xf0) >> 4));                  x3 = (((data[i + 1] & 0x0f) << 2) | ((data[i + 2] & 0xc0) >> 6));                  x4 = (data[i + 2] & 0x3f);                  encoded[j] = _toBase64[x1];                  encoded[j + 1] = _toBase64[x2];                  encoded[j + 2] = _toBase64[x3];                  encoded[j + 3] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: if (r != 0) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (data[i] & 0x03) << 4;                  x3 = PAD;                  x4 = PAD;                  if (r == 2) {                      x2 |= ((data[i + 1] & 0xf0) >> 4);                      x3 = (data[i + 1] & 0x0f) << 2;                  }                  encoded[j++] = _toBase64[x1];                  encoded[j++] = _toBase64[x2];                  encoded[j++] = _toBase64[x3];                  encoded[j++] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: if (r != 0) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (data[i] & 0x03) << 4;                  x3 = PAD;                  x4 = PAD;                  if (r == 2) {                      x2 |= ((data[i + 1] & 0xf0) >> 4);                      x3 = (data[i + 1] & 0x0f) << 2;                  }                  encoded[j++] = _toBase64[x1];                  encoded[j++] = _toBase64[x2];                  encoded[j++] = _toBase64[x3];                  encoded[j++] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: if (r != 0) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (data[i] & 0x03) << 4;                  x3 = PAD;                  x4 = PAD;                  if (r == 2) {                      x2 |= ((data[i + 1] & 0xf0) >> 4);                      x3 = (data[i + 1] & 0x0f) << 2;                  }                  encoded[j++] = _toBase64[x1];                  encoded[j++] = _toBase64[x2];                  encoded[j++] = _toBase64[x3];                  encoded[j++] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: if (r != 0) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (data[i] & 0x03) << 4;                  x3 = PAD;                  x4 = PAD;                  if (r == 2) {                      x2 |= ((data[i + 1] & 0xf0) >> 4);                      x3 = (data[i + 1] & 0x0f) << 2;                  }                  encoded[j++] = _toBase64[x1];                  encoded[j++] = _toBase64[x2];                  encoded[j++] = _toBase64[x3];                  encoded[j++] = _toBase64[x4];              }
Magic Number,Granados.Util,Base64,C:\repos\poderosaproject_poderosa\Granados\Base64.cs,Encode,The following statement contains a magic number: if (r != 0) {                  x1 = (data[i] & 0xfc) >> 2;                  x2 = (data[i] & 0x03) << 4;                  x3 = PAD;                  x4 = PAD;                  if (r == 2) {                      x2 |= ((data[i + 1] & 0xf0) >> 4);                      x3 = (data[i + 1] & 0x0f) << 2;                  }                  encoded[j++] = _toBase64[x1];                  encoded[j++] = _toBase64[x2];                  encoded[j++] = _toBase64[x3];                  encoded[j++] = _toBase64[x4];              }
Magic Number,Granados.Util,SecureRng,C:\repos\poderosaproject_poderosa\Granados\Rng.cs,GetInt,The following statement contains a magic number: byte[] rbits = new byte[4];
Magic Number,Granados.Util,SecureRng,C:\repos\poderosaproject_poderosa\Granados\Rng.cs,GetInt,The following statement contains a magic number: return (int)((((long)r) * maxValue) >> 32);
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret <<= 8;
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret <<= 8;
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret |= data[offset + 2];
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret <<= 8;
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret |= data[offset + 3];
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos] = (byte)(data >> 24);
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos + 1] = (byte)(data >> 16);
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos + 2] = (byte)(data >> 8);
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos + 2] = (byte)(data >> 8);
Magic Number,Granados.Util,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos + 3] = (byte)(data);
Magic Number,Granados.Util,DebugUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,DumpByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  bld.Append(data[offset + i].ToString("X2"));                  if ((i % 4) == 3)                      bld.Append(' ');              }
Magic Number,Granados.Util,DebugUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,DumpByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  bld.Append(data[offset + i].ToString("X2"));                  if ((i % 4) == 3)                      bld.Append(' ');              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Blowfish,The following statement contains a magic number: S0 = new uint[256];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Blowfish,The following statement contains a magic number: S1 = new uint[256];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Blowfish,The following statement contains a magic number: S2 = new uint[256];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Blowfish,The following statement contains a magic number: S3 = new uint[256];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Blowfish,The following statement contains a magic number: P = new uint[18];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Blowfish,The following statement contains a magic number: IV = new byte[8];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Blowfish,The following statement contains a magic number: enc = new byte[8];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Blowfish,The following statement contains a magic number: dec = new byte[8];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: byte[] LR = new byte[8];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int i = 0; i < 16 + 2; i += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  P[i] = CipherUtil.GetIntBE(LR' 0);                  P[i + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int i = 0; i < 16 + 2; i += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  P[i] = CipherUtil.GetIntBE(LR' 0);                  P[i + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int i = 0; i < 16 + 2; i += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  P[i] = CipherUtil.GetIntBE(LR' 0);                  P[i + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int i = 0; i < 16 + 2; i += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  P[i] = CipherUtil.GetIntBE(LR' 0);                  P[i + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S0[j] = CipherUtil.GetIntBE(LR' 0);                  S0[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S0[j] = CipherUtil.GetIntBE(LR' 0);                  S0[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S0[j] = CipherUtil.GetIntBE(LR' 0);                  S0[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S1[j] = CipherUtil.GetIntBE(LR' 0);                  S1[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S1[j] = CipherUtil.GetIntBE(LR' 0);                  S1[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S1[j] = CipherUtil.GetIntBE(LR' 0);                  S1[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S2[j] = CipherUtil.GetIntBE(LR' 0);                  S2[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S2[j] = CipherUtil.GetIntBE(LR' 0);                  S2[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S2[j] = CipherUtil.GetIntBE(LR' 0);                  S2[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S3[j] = CipherUtil.GetIntBE(LR' 0);                  S3[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S3[j] = CipherUtil.GetIntBE(LR' 0);                  S3[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  BlockEncrypt(LR' 0' LR' 0);                  S3[j] = CipherUtil.GetIntBE(LR' 0);                  S3[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0' i = 0; i < 16 + 2; i++) {                  uint temp =                      (((uint)(key[j]) << 24) |                      ((uint)(key[(j + 1) % keyLen]) << 16) |                      ((uint)(key[(j + 2) % keyLen]) << 8) |                      ((uint)(key[(j + 3) % keyLen])));                  P[i] = P[i] ^ temp;                  j = (j + 4) % keyLen;              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: byte[] LR = new byte[8];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int i = 0; i < 16 + 2; i += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  P[i] = CipherUtil.GetIntBE(LR' 0);                  P[i + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int i = 0; i < 16 + 2; i += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  P[i] = CipherUtil.GetIntBE(LR' 0);                  P[i + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int i = 0; i < 16 + 2; i += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  P[i] = CipherUtil.GetIntBE(LR' 0);                  P[i + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int i = 0; i < 16 + 2; i += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  P[i] = CipherUtil.GetIntBE(LR' 0);                  P[i + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int i = 0; i < 16 + 2; i += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  P[i] = CipherUtil.GetIntBE(LR' 0);                  P[i + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S0[j] = CipherUtil.GetIntBE(LR' 0);                  S0[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S0[j] = CipherUtil.GetIntBE(LR' 0);                  S0[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S0[j] = CipherUtil.GetIntBE(LR' 0);                  S0[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S0[j] = CipherUtil.GetIntBE(LR' 0);                  S0[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S1[j] = CipherUtil.GetIntBE(LR' 0);                  S1[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S1[j] = CipherUtil.GetIntBE(LR' 0);                  S1[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S1[j] = CipherUtil.GetIntBE(LR' 0);                  S1[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S1[j] = CipherUtil.GetIntBE(LR' 0);                  S1[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S2[j] = CipherUtil.GetIntBE(LR' 0);                  S2[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S2[j] = CipherUtil.GetIntBE(LR' 0);                  S2[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S2[j] = CipherUtil.GetIntBE(LR' 0);                  S2[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S2[j] = CipherUtil.GetIntBE(LR' 0);                  S2[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S3[j] = CipherUtil.GetIntBE(LR' 0);                  S3[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S3[j] = CipherUtil.GetIntBE(LR' 0);                  S3[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S3[j] = CipherUtil.GetIntBE(LR' 0);                  S3[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,ExpandState,The following statement contains a magic number: for (int j = 0; j < 256; j += 2) {                  for (int k = 0; k < 8; ++k) {                      LR[k] ^= data[dataIndex];                      dataIndex = (dataIndex + 1) % dataLen;                  }                    BlockEncrypt(LR' 0' LR' 0);                  S3[j] = CipherUtil.GetIntBE(LR' 0);                  S3[j + 1] = CipherUtil.GetIntBE(LR' 4);              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,InitializeState,The following statement contains a magic number: Array.Copy(blowfish_pbox' 0' P' 0' 18);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,InitializeState,The following statement contains a magic number: Array.Copy(blowfish_sbox' 0' S0' 0' 256);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,InitializeState,The following statement contains a magic number: Array.Copy(blowfish_sbox' 256' S1' 0' 256);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,InitializeState,The following statement contains a magic number: Array.Copy(blowfish_sbox' 256' S1' 0' 256);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,InitializeState,The following statement contains a magic number: Array.Copy(blowfish_sbox' 512' S2' 0' 256);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,InitializeState,The following statement contains a magic number: Array.Copy(blowfish_sbox' 512' S2' 0' 256);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,InitializeState,The following statement contains a magic number: Array.Copy(blowfish_sbox' 768' S3' 0' 256);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,InitializeState,The following statement contains a magic number: Array.Copy(blowfish_sbox' 768' S3' 0' 256);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R = CipherUtil.GetIntBE(input' inOffset + 4);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[1]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[1]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[1]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[2]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[2]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[2]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[2]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[3]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[3]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[3]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[3]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[4]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[4]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[4]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[4]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[5]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[5]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[5]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[5]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[6]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[6]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[6]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[6]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[7]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[7]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[7]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[7]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[8]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[8]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[8]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[8]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[9]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[9]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[9]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[9]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[10]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[10]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[10]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[10]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[11]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[11]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[11]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[11]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[12]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[12]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[12]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[12]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[13]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[13]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[13]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[13]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[14]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[14]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[14]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[14]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[15]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[15]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[15]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[15]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[16]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[16]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[16]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[16]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: R ^= P[17];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockEncrypt,The following statement contains a magic number: CipherUtil.PutIntBE(L' output' outOffset + 4);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R = CipherUtil.GetIntBE(input' inOffset + 4);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= P[17];
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[16]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[16]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[16]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[16]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[15]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[15]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[15]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[15]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[14]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[14]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[14]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[14]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[13]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[13]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[13]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[13]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[12]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[12]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[12]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[12]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[11]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[11]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[11]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[11]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[10]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[10]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[10]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[10]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[9]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[9]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[9]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[9]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[8]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[8]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[8]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[8]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[7]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[7]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[7]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[7]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[6]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[6]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[6]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[6]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[5]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[5]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[5]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[5]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[4]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[4]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[4]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[4]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[3]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[3]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[3]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[3]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[2]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[2]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[2]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^                  S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[2]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[1]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[1]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^                  S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[1]);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,BlockDecrypt,The following statement contains a magic number: CipherUtil.PutIntBE(L' output' outOffset + 4);
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,EncryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      IV[i] ^= src[si + j];                      IV[i + 4] ^= src[si + 4 + j];                  }                  BlockEncrypt(IV' 0' IV' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = IV[j];                      dest[di + i + 4] = IV[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,Blowfish,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,DecryptSSH1Style,The following statement contains a magic number: for (int si = srcOff' di = destOff; si < end; si += 8' di += 8) {                  for (i = 0; i < 4; i++) {                      j = (3 - i);                      enc[i] = src[si + j];                      enc[i + 4] = src[si + 4 + j];                  }                  BlockDecrypt(enc' 0' dec' 0);                  for (i = 0; i < 4; i++) {                      j = 3 - i;                      dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);                      IV[j] = enc[j];                      dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);                      IV[4 + j] = enc[4 + j];                  }              }
Magic Number,Granados.Algorithms,BlowfishTest,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"vectors.txt")) {                  string line;                  do {                      line = reader.ReadLine();                  } while (line != null && !line.StartsWith("key bytes"));                    var blowfish = new Blowfish();                  int count = 0;                  while (true) {                      line = reader.ReadLine();                      if (line == null) {                          break;                      }                      string[] w = System.Text.RegularExpressions.Regex.Split(line' @"\s\s+");                      if (w.Length < 3 || w[0].Length != 16 || w[1].Length != 16 || w[2].Length != 16) {                          break;                      }                      byte[] key = BigIntegerConverter.ParseHex(w[0]);                      byte[] clear = BigIntegerConverter.ParseHex(w[1]);                      byte[] cipher = BigIntegerConverter.ParseHex(w[2]);                        ++count;                      System.Diagnostics.Debug.WriteLine("Test ECB #{0}"' count);                        blowfish.InitializeKey(key);                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] encrypted = new byte[cipher.Length];                          blowfish.BlockEncrypt(clear' 0' encrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (encrypted[i] != cipher[i]) {                                  throw new Exception("encryption failed");                              }                          }                      }                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] decrypted = new byte[clear.Length];                          blowfish.BlockDecrypt(cipher' 0' decrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (decrypted[i] != clear[i]) {                                  throw new Exception("decryption failed");                              }                          }                      }                  }              }
Magic Number,Granados.Algorithms,BlowfishTest,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"vectors.txt")) {                  string line;                  do {                      line = reader.ReadLine();                  } while (line != null && !line.StartsWith("key bytes"));                    var blowfish = new Blowfish();                  int count = 0;                  while (true) {                      line = reader.ReadLine();                      if (line == null) {                          break;                      }                      string[] w = System.Text.RegularExpressions.Regex.Split(line' @"\s\s+");                      if (w.Length < 3 || w[0].Length != 16 || w[1].Length != 16 || w[2].Length != 16) {                          break;                      }                      byte[] key = BigIntegerConverter.ParseHex(w[0]);                      byte[] clear = BigIntegerConverter.ParseHex(w[1]);                      byte[] cipher = BigIntegerConverter.ParseHex(w[2]);                        ++count;                      System.Diagnostics.Debug.WriteLine("Test ECB #{0}"' count);                        blowfish.InitializeKey(key);                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] encrypted = new byte[cipher.Length];                          blowfish.BlockEncrypt(clear' 0' encrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (encrypted[i] != cipher[i]) {                                  throw new Exception("encryption failed");                              }                          }                      }                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] decrypted = new byte[clear.Length];                          blowfish.BlockDecrypt(cipher' 0' decrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (decrypted[i] != clear[i]) {                                  throw new Exception("decryption failed");                              }                          }                      }                  }              }
Magic Number,Granados.Algorithms,BlowfishTest,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"vectors.txt")) {                  string line;                  do {                      line = reader.ReadLine();                  } while (line != null && !line.StartsWith("key bytes"));                    var blowfish = new Blowfish();                  int count = 0;                  while (true) {                      line = reader.ReadLine();                      if (line == null) {                          break;                      }                      string[] w = System.Text.RegularExpressions.Regex.Split(line' @"\s\s+");                      if (w.Length < 3 || w[0].Length != 16 || w[1].Length != 16 || w[2].Length != 16) {                          break;                      }                      byte[] key = BigIntegerConverter.ParseHex(w[0]);                      byte[] clear = BigIntegerConverter.ParseHex(w[1]);                      byte[] cipher = BigIntegerConverter.ParseHex(w[2]);                        ++count;                      System.Diagnostics.Debug.WriteLine("Test ECB #{0}"' count);                        blowfish.InitializeKey(key);                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] encrypted = new byte[cipher.Length];                          blowfish.BlockEncrypt(clear' 0' encrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (encrypted[i] != cipher[i]) {                                  throw new Exception("encryption failed");                              }                          }                      }                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] decrypted = new byte[clear.Length];                          blowfish.BlockDecrypt(cipher' 0' decrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (decrypted[i] != clear[i]) {                                  throw new Exception("decryption failed");                              }                          }                      }                  }              }
Magic Number,Granados.Algorithms,BlowfishTest,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"vectors.txt")) {                  string line;                  do {                      line = reader.ReadLine();                  } while (line != null && !line.StartsWith("key bytes"));                    var blowfish = new Blowfish();                  int count = 0;                  while (true) {                      line = reader.ReadLine();                      if (line == null) {                          break;                      }                      string[] w = System.Text.RegularExpressions.Regex.Split(line' @"\s\s+");                      if (w.Length < 3 || w[0].Length != 16 || w[1].Length != 16 || w[2].Length != 16) {                          break;                      }                      byte[] key = BigIntegerConverter.ParseHex(w[0]);                      byte[] clear = BigIntegerConverter.ParseHex(w[1]);                      byte[] cipher = BigIntegerConverter.ParseHex(w[2]);                        ++count;                      System.Diagnostics.Debug.WriteLine("Test ECB #{0}"' count);                        blowfish.InitializeKey(key);                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] encrypted = new byte[cipher.Length];                          blowfish.BlockEncrypt(clear' 0' encrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (encrypted[i] != cipher[i]) {                                  throw new Exception("encryption failed");                              }                          }                      }                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] decrypted = new byte[clear.Length];                          blowfish.BlockDecrypt(cipher' 0' decrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (decrypted[i] != clear[i]) {                                  throw new Exception("decryption failed");                              }                          }                      }                  }              }
Magic Number,Granados.Algorithms,BlowfishTest,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"vectors.txt")) {                  string line;                  do {                      line = reader.ReadLine();                  } while (line != null && !line.StartsWith("key bytes"));                    var blowfish = new Blowfish();                  int count = 0;                  while (true) {                      line = reader.ReadLine();                      if (line == null) {                          break;                      }                      string[] w = System.Text.RegularExpressions.Regex.Split(line' @"\s\s+");                      if (w.Length < 3 || w[0].Length != 16 || w[1].Length != 16 || w[2].Length != 16) {                          break;                      }                      byte[] key = BigIntegerConverter.ParseHex(w[0]);                      byte[] clear = BigIntegerConverter.ParseHex(w[1]);                      byte[] cipher = BigIntegerConverter.ParseHex(w[2]);                        ++count;                      System.Diagnostics.Debug.WriteLine("Test ECB #{0}"' count);                        blowfish.InitializeKey(key);                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] encrypted = new byte[cipher.Length];                          blowfish.BlockEncrypt(clear' 0' encrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (encrypted[i] != cipher[i]) {                                  throw new Exception("encryption failed");                              }                          }                      }                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] decrypted = new byte[clear.Length];                          blowfish.BlockDecrypt(cipher' 0' decrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (decrypted[i] != clear[i]) {                                  throw new Exception("decryption failed");                              }                          }                      }                  }              }
Magic Number,Granados.Algorithms,BlowfishTest,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"vectors.txt")) {                  string line;                  do {                      line = reader.ReadLine();                  } while (line != null && !line.StartsWith("key bytes"));                    var blowfish = new Blowfish();                  int count = 0;                  while (true) {                      line = reader.ReadLine();                      if (line == null) {                          break;                      }                      string[] w = System.Text.RegularExpressions.Regex.Split(line' @"\s\s+");                      if (w.Length < 3 || w[0].Length != 16 || w[1].Length != 16 || w[2].Length != 16) {                          break;                      }                      byte[] key = BigIntegerConverter.ParseHex(w[0]);                      byte[] clear = BigIntegerConverter.ParseHex(w[1]);                      byte[] cipher = BigIntegerConverter.ParseHex(w[2]);                        ++count;                      System.Diagnostics.Debug.WriteLine("Test ECB #{0}"' count);                        blowfish.InitializeKey(key);                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] encrypted = new byte[cipher.Length];                          blowfish.BlockEncrypt(clear' 0' encrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (encrypted[i] != cipher[i]) {                                  throw new Exception("encryption failed");                              }                          }                      }                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] decrypted = new byte[clear.Length];                          blowfish.BlockDecrypt(cipher' 0' decrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (decrypted[i] != clear[i]) {                                  throw new Exception("decryption failed");                              }                          }                      }                  }              }
Magic Number,Granados.Algorithms,BlowfishTest,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"vectors.txt")) {                  string line;                  do {                      line = reader.ReadLine();                  } while (line != null && !line.StartsWith("key bytes"));                    var blowfish = new Blowfish();                  int count = 0;                  while (true) {                      line = reader.ReadLine();                      if (line == null) {                          break;                      }                      string[] w = System.Text.RegularExpressions.Regex.Split(line' @"\s\s+");                      if (w.Length < 3 || w[0].Length != 16 || w[1].Length != 16 || w[2].Length != 16) {                          break;                      }                      byte[] key = BigIntegerConverter.ParseHex(w[0]);                      byte[] clear = BigIntegerConverter.ParseHex(w[1]);                      byte[] cipher = BigIntegerConverter.ParseHex(w[2]);                        ++count;                      System.Diagnostics.Debug.WriteLine("Test ECB #{0}"' count);                        blowfish.InitializeKey(key);                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] encrypted = new byte[cipher.Length];                          blowfish.BlockEncrypt(clear' 0' encrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (encrypted[i] != cipher[i]) {                                  throw new Exception("encryption failed");                              }                          }                      }                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] decrypted = new byte[clear.Length];                          blowfish.BlockDecrypt(cipher' 0' decrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (decrypted[i] != clear[i]) {                                  throw new Exception("decryption failed");                              }                          }                      }                  }              }
Magic Number,Granados.Algorithms,BlowfishTest,C:\repos\poderosaproject_poderosa\Granados\Blowfish.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"vectors.txt")) {                  string line;                  do {                      line = reader.ReadLine();                  } while (line != null && !line.StartsWith("key bytes"));                    var blowfish = new Blowfish();                  int count = 0;                  while (true) {                      line = reader.ReadLine();                      if (line == null) {                          break;                      }                      string[] w = System.Text.RegularExpressions.Regex.Split(line' @"\s\s+");                      if (w.Length < 3 || w[0].Length != 16 || w[1].Length != 16 || w[2].Length != 16) {                          break;                      }                      byte[] key = BigIntegerConverter.ParseHex(w[0]);                      byte[] clear = BigIntegerConverter.ParseHex(w[1]);                      byte[] cipher = BigIntegerConverter.ParseHex(w[2]);                        ++count;                      System.Diagnostics.Debug.WriteLine("Test ECB #{0}"' count);                        blowfish.InitializeKey(key);                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] encrypted = new byte[cipher.Length];                          blowfish.BlockEncrypt(clear' 0' encrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (encrypted[i] != cipher[i]) {                                  throw new Exception("encryption failed");                              }                          }                      }                      for (int tries = 1; tries <= 3; ++tries) {                          byte[] decrypted = new byte[clear.Length];                          blowfish.BlockDecrypt(cipher' 0' decrypted' 0);                          for (int i = 0; i < cipher.Length; ++i) {                              if (decrypted[i] != clear[i]) {                                  throw new Exception("decryption failed");                              }                          }                      }                  }              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,DES,The following statement contains a magic number: _key = new uint[32];
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,DES,The following statement contains a magic number: _iv = new byte[8];
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,DES,The following statement contains a magic number: _temp = new byte[8];
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: d = CipherUtil.GetIntLE(key' offset + 4);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: t = ((d >> 4) ^ c) & 0x0f0f0f0f;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: d ^= t << 4;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: t = (((c << (16 - (-2))) ^ c) & 0xcccc0000);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: t = (((c << (16 - (-2))) ^ c) & 0xcccc0000);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: c = c ^ t ^ (t >> (16 - (-2)));
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: c = c ^ t ^ (t >> (16 - (-2)));
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: t = (((d << (16 - (-2))) ^ d) & 0xcccc0000);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: t = (((d << (16 - (-2))) ^ d) & 0xcccc0000);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: d = d ^ t ^ (t >> (16 - (-2)));
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: d = d ^ t ^ (t >> (16 - (-2)));
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: t = ((c >> 8) ^ d) & 0x00ff00ff;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: c ^= t << 8;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: d = ((d & 0xff) << 16) | (d & 0xff00) |                  ((d >> 16) & 0xff) | ((c >> 4) & 0xf000000);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: d = ((d & 0xff) << 16) | (d & 0xff00) |                  ((d >> 16) & 0xff) | ((c >> 4) & 0xf000000);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: d = ((d & 0xff) << 16) | (d & 0xff00) |                  ((d >> 16) & 0xff) | ((c >> 4) & 0xf000000);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,InitializeKey,The following statement contains a magic number: for (i = 0; i < 16; i++) {                  if ((shifts & 1) != 0) {                      c = ((c >> 2) | (c << 26));                      d = ((d >> 2) | (d << 26));                  }                  else {                      c = ((c >> 1) | (c << 27));                      d = ((d >> 1) | (d << 27));                  }                  shifts >>= 1;                  c &= 0x0fffffff;                  d &= 0x0fffffff;                    s = SKB[0' (c) & 0x3f] |                  SKB[1' ((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |                  SKB[2' ((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |                  SKB[3' ((c >> 20) & 0x01) | ((c >> 21) & 0x06) | ((c >> 22) & 0x38)];                    t = SKB[4' (d) & 0x3f] |                  SKB[5' ((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |                  SKB[6' (d >> 15) & 0x3f] |                  SKB[7' ((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];                    _key[i * 2] = ((t << 16) | (s & 0xffff));                  s = ((s >> 16) | (t & 0xffff0000));                  _key[(i * 2) + 1] = (s << 4) | (s >> 28);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: uint[] lr = new uint[2];
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: lr[1] = CipherUtil.GetIntLE(input' inOffset + 4);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: t = (lr[1] << 1) | (lr[1] >> 31);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: lr[1] = (lr[0] << 1) | (lr[0] >> 31);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: for (i = 0; i < 32; i += 4) {                  desCipher1(lr' i);                  desCipher2(lr' i + 2);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: for (i = 0; i < 32; i += 4) {                  desCipher1(lr' i);                  desCipher2(lr' i + 2);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: for (i = 0; i < 32; i += 4) {                  desCipher1(lr' i);                  desCipher2(lr' i + 2);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: lr[0] = (lr[0] >> 1) | (lr[0] << 31);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: lr[1] = (lr[1] >> 1) | (lr[1] << 31);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockEncrypt,The following statement contains a magic number: CipherUtil.PutIntLE(lr[1]' output' outOffset + 4);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: uint[] lr = new uint[2];
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: lr[1] = CipherUtil.GetIntLE(input' inOffset + 4);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: t = (lr[1] << 1) | (lr[1] >> 31);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: lr[1] = (lr[0] << 1) | (lr[0] >> 31);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: for (i = 30; i > 0; i -= 4) {                  desCipher1(lr' i);                  desCipher2(lr' i - 2);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: for (i = 30; i > 0; i -= 4) {                  desCipher1(lr' i);                  desCipher2(lr' i - 2);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: for (i = 30; i > 0; i -= 4) {                  desCipher1(lr' i);                  desCipher2(lr' i - 2);              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: lr[0] = (lr[0] >> 1) | (lr[0] << 31);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: lr[1] = (lr[1] >> 1) | (lr[1] << 31);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,BlockDecrypt,The following statement contains a magic number: CipherUtil.PutIntLE(lr[1]' output' outOffset + 4);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: t = ((t >> 4) + (t << 28));
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: t = ((t >> 4) + (t << 28));
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher1,The following statement contains a magic number: lr[0] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: t = ((t >> 4) + (t << 28));
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: t = ((t >> 4) + (t << 28));
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,desCipher2,The following statement contains a magic number: lr[1] ^= (SPTRANS[1' (t) & 0x3f] |                  SPTRANS[3' (t >> 8) & 0x3f] |                  SPTRANS[5' (t >> 16) & 0x3f] |                  SPTRANS[7' (t >> 24) & 0x3f] |                  SPTRANS[0' (u) & 0x3f] |                  SPTRANS[2' (u >> 8) & 0x3f] |                  SPTRANS[4' (u >> 16) & 0x3f] |                  SPTRANS[6' (u >> 24) & 0x3f]);
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,initPerm,The following statement contains a magic number: uint t = ((lr[1] >> 4) ^ lr[0]) & 0x0f0f0f0f;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,initPerm,The following statement contains a magic number: lr[1] ^= t << 4;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,initPerm,The following statement contains a magic number: t = ((lr[0] >> 16) ^ lr[1]) & 0x0000ffff;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,initPerm,The following statement contains a magic number: lr[0] ^= t << 16;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,initPerm,The following statement contains a magic number: t = ((lr[1] >> 2) ^ lr[0]) & 0x33333333;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,initPerm,The following statement contains a magic number: lr[1] ^= t << 2;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,initPerm,The following statement contains a magic number: t = ((lr[0] >> 8) ^ lr[1]) & 0x00ff00ff;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,initPerm,The following statement contains a magic number: lr[0] ^= t << 8;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,finalPerm,The following statement contains a magic number: t = ((lr[0] >> 8) ^ lr[1]) & 0x00ff00ff;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,finalPerm,The following statement contains a magic number: lr[0] ^= t << 8;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,finalPerm,The following statement contains a magic number: t = ((lr[1] >> 2) ^ lr[0]) & 0x33333333;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,finalPerm,The following statement contains a magic number: lr[1] ^= t << 2;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,finalPerm,The following statement contains a magic number: t = ((lr[0] >> 16) ^ lr[1]) & 0x0000ffff;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,finalPerm,The following statement contains a magic number: lr[0] ^= t << 16;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,finalPerm,The following statement contains a magic number: t = ((lr[1] >> 4) ^ lr[0]) & 0x0f0f0f0f;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,finalPerm,The following statement contains a magic number: lr[1] ^= t << 4;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,EncryptCBC,The following statement contains a magic number: int nBlocks = inputLen / 8;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,EncryptCBC,The following statement contains a magic number: for (int bc = 0; bc < nBlocks; bc++) {                  CipherUtil.BlockXor(input' inputOffset' 8' _iv' 0);                  BlockEncrypt(_iv' 0' output' outputOffset);                  Array.Copy(output' outputOffset' _iv' 0' 8);                  inputOffset += 8;                  outputOffset += 8;              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,EncryptCBC,The following statement contains a magic number: for (int bc = 0; bc < nBlocks; bc++) {                  CipherUtil.BlockXor(input' inputOffset' 8' _iv' 0);                  BlockEncrypt(_iv' 0' output' outputOffset);                  Array.Copy(output' outputOffset' _iv' 0' 8);                  inputOffset += 8;                  outputOffset += 8;              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,EncryptCBC,The following statement contains a magic number: for (int bc = 0; bc < nBlocks; bc++) {                  CipherUtil.BlockXor(input' inputOffset' 8' _iv' 0);                  BlockEncrypt(_iv' 0' output' outputOffset);                  Array.Copy(output' outputOffset' _iv' 0' 8);                  inputOffset += 8;                  outputOffset += 8;              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,EncryptCBC,The following statement contains a magic number: for (int bc = 0; bc < nBlocks; bc++) {                  CipherUtil.BlockXor(input' inputOffset' 8' _iv' 0);                  BlockEncrypt(_iv' 0' output' outputOffset);                  Array.Copy(output' outputOffset' _iv' 0' 8);                  inputOffset += 8;                  outputOffset += 8;              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,DecryptCBC,The following statement contains a magic number: int nBlocks = inputLen / 8;
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,DecryptCBC,The following statement contains a magic number: for (int bc = 0; bc < nBlocks; bc++) {                  BlockDecrypt(input' inputOffset' _temp' 0);                  for (int i = 0; i < 8; i++) {                      _temp[i] ^= _iv[i];                      _iv[i] = input[inputOffset + i];                      output[outputOffset + i] = _temp[i];                  }                  inputOffset += 8;                  outputOffset += 8;              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,DecryptCBC,The following statement contains a magic number: for (int bc = 0; bc < nBlocks; bc++) {                  BlockDecrypt(input' inputOffset' _temp' 0);                  for (int i = 0; i < 8; i++) {                      _temp[i] ^= _iv[i];                      _iv[i] = input[inputOffset + i];                      output[outputOffset + i] = _temp[i];                  }                  inputOffset += 8;                  outputOffset += 8;              }
Magic Number,Granados.Algorithms,DES,C:\repos\poderosaproject_poderosa\Granados\DES.cs,DecryptCBC,The following statement contains a magic number: for (int bc = 0; bc < nBlocks; bc++) {                  BlockDecrypt(input' inputOffset' _temp' 0);                  for (int i = 0; i < 8; i++) {                      _temp[i] ^= _iv[i];                      _iv[i] = input[inputOffset + i];                      output[outputOffset + i] = _temp[i];                  }                  inputOffset += 8;                  outputOffset += 8;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: if (!(key.Length == 16 || key.Length == 24 || key.Length == 32))                  throw new Exception("Incorrect key length");
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: if (!(key.Length == 16 || key.Length == 24 || key.Length == 32))                  throw new Exception("Incorrect key length");
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: if (!(key.Length == 16 || key.Length == 24 || key.Length == 32))                  throw new Exception("Incorrect key length");
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: int KC = key.Length / 4;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: for (i = 0' j = 0; i < KC; ) {                  tk[i++] = (key[j++] & 0xFF) << 24 |                            (key[j++] & 0xFF) << 16 |                            (key[j++] & 0xFF) << 8 |                            (key[j++] & 0xFF);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: for (i = 0' j = 0; i < KC; ) {                  tk[i++] = (key[j++] & 0xFF) << 24 |                            (key[j++] & 0xFF) << 16 |                            (key[j++] & 0xFF) << 8 |                            (key[j++] & 0xFF);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: for (i = 0' j = 0; i < KC; ) {                  tk[i++] = (key[j++] & 0xFF) << 24 |                            (key[j++] & 0xFF) << 16 |                            (key[j++] & 0xFF) << 8 |                            (key[j++] & 0xFF);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: while (t < ROUND_KEY_COUNT) {                  tt = tk[KC - 1];                  tk[0] ^= (S[(tt >> 16) & 0xFF] & 0xFF) << 24 ^                           (S[(tt >> 8) & 0xFF] & 0xFF) << 16 ^                           (S[tt & 0xFF] & 0xFF) << 8 ^                           (S[(tt >> 24) & 0xFF] & 0xFF) ^                           (rcon[rconpointer++] & 0xFF) << 24;                    if (KC != 8) {                      for (i = 1' j = 0; i < KC; )                          tk[i++] ^= tk[j++];                  }                  else {                      for (i = 1' j = 0; i < KC / 2; )                          tk[i++] ^= tk[j++];                      tt = tk[KC / 2 - 1];                      tk[KC / 2] ^= (S[tt & 0xFF] & 0xFF) ^                                    (S[(tt >> 8) & 0xFF] & 0xFF) << 8 ^                                    (S[(tt >> 16) & 0xFF] & 0xFF) << 16 ^                                    (S[(tt >> 24) & 0xFF] & 0xFF) << 24;                      for (j = KC / 2' i = j + 1; i < KC; )                          tk[i++] ^= tk[j++];                  }                  for (j = 0; (j < KC) && (t < ROUND_KEY_COUNT); j++' t++) {                      _Ke[t / BC][t % BC] = tk[j];                      _Kd[_rounds - (t / BC)][t % BC] = tk[j];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  for (j = 0; j < BC; j++) {                      tt = _Kd[r][j];                      _Kd[r][j] = U1[(tt >> 24) & 0xFF] ^                                 U2[(tt >> 16) & 0xFF] ^                                 U3[(tt >> 8) & 0xFF] ^                                 U4[tt & 0xFF];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  for (j = 0; j < BC; j++) {                      tt = _Kd[r][j];                      _Kd[r][j] = U1[(tt >> 24) & 0xFF] ^                                 U2[(tt >> 16) & 0xFF] ^                                 U3[(tt >> 8) & 0xFF] ^                                 U4[tt & 0xFF];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,InitializeKey,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  for (j = 0; j < BC; j++) {                      tt = _Kd[r][j];                      _Kd[r][j] = U1[(tt >> 24) & 0xFF] ^                                 U2[(tt >> 16) & 0xFF] ^                                 U3[(tt >> 8) & 0xFF] ^                                 U4[tt & 0xFF];                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,getRounds,The following statement contains a magic number: switch (keySize) {                  case 16:                      return blockSize == 16 ? 10 : (blockSize == 24 ? 12 : 14);                  case 24:                      return blockSize != 32 ? 12 : 14;                  default:                      return 14;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t0 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[0];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t0 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[0];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t0 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[0];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t1 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[1];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t1 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[1];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t1 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[1];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t2 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t2 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t2 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t2 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t3 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t3 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t3 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: int t3 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Ker[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Ker = _Ke[r];                  a0 = (T1[(t0 >> 24) & 0xFF] ^                        T2[(t1 >> 16) & 0xFF] ^                        T3[(t2 >> 8) & 0xFF] ^                        T4[t3 & 0xFF]) ^ Ker[0];                  a1 = (T1[(t1 >> 24) & 0xFF] ^                        T2[(t2 >> 16) & 0xFF] ^                        T3[(t3 >> 8) & 0xFF] ^                        T4[t0 & 0xFF]) ^ Ker[1];                  a2 = (T1[(t2 >> 24) & 0xFF] ^                        T2[(t3 >> 16) & 0xFF] ^                        T3[(t0 >> 8) & 0xFF] ^                        T4[t1 & 0xFF]) ^ Ker[2];                  a3 = (T1[(t3 >> 24) & 0xFF] ^                        T2[(t0 >> 16) & 0xFF] ^                        T3[(t1 >> 8) & 0xFF] ^                        T4[t2 & 0xFF]) ^ Ker[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 0] = (byte)(S[(t0 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 0] = (byte)(S[(t0 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 1] = (byte)(S[(t1 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 1] = (byte)(S[(t1 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 2] = (byte)(S[(t2 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 2] = (byte)(S[(t2 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 2] = (byte)(S[(t2 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 3] = (byte)(S[t3 & 0xFF] ^ tt);
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 4] = (byte)(S[(t1 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 4] = (byte)(S[(t1 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 4] = (byte)(S[(t1 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 5] = (byte)(S[(t2 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 5] = (byte)(S[(t2 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 5] = (byte)(S[(t2 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 6] = (byte)(S[(t3 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 6] = (byte)(S[(t3 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 6] = (byte)(S[(t3 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 7] = (byte)(S[t0 & 0xFF] ^ tt);
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: tt = Ker[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 8] = (byte)(S[(t2 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 8] = (byte)(S[(t2 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 8] = (byte)(S[(t2 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 9] = (byte)(S[(t3 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 9] = (byte)(S[(t3 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 9] = (byte)(S[(t3 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 10] = (byte)(S[(t0 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 10] = (byte)(S[(t0 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 10] = (byte)(S[(t0 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 11] = (byte)(S[t1 & 0xFF] ^ tt);
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: tt = Ker[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 12] = (byte)(S[(t3 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 12] = (byte)(S[(t3 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 12] = (byte)(S[(t3 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 13] = (byte)(S[(t0 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 13] = (byte)(S[(t0 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 13] = (byte)(S[(t0 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 14] = (byte)(S[(t1 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 14] = (byte)(S[(t1 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 14] = (byte)(S[(t1 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockEncrypt,The following statement contains a magic number: dst[outOffset + 15] = (byte)(S[t2 & 0xFF] ^ tt);
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t0 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[0];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t0 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[0];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t0 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[0];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t1 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[1];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t1 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[1];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t1 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[1];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t2 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t2 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t2 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t2 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t3 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t3 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t3 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: int t3 = ((src[inOffset++] & 0xFF) << 24 |                        (src[inOffset++] & 0xFF) << 16 |                        (src[inOffset++] & 0xFF) << 8 |                        (src[inOffset++] & 0xFF)) ^ Kdr[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: for (int r = 1; r < _rounds; r++) {                  Kdr = _Kd[r];                  a0 = (T5[(t0 >> 24) & 0xFF] ^                        T6[(t3 >> 16) & 0xFF] ^                        T7[(t2 >> 8) & 0xFF] ^                        T8[t1 & 0xFF]) ^ Kdr[0];                  a1 = (T5[(t1 >> 24) & 0xFF] ^                        T6[(t0 >> 16) & 0xFF] ^                        T7[(t3 >> 8) & 0xFF] ^                        T8[t2 & 0xFF]) ^ Kdr[1];                  a2 = (T5[(t2 >> 24) & 0xFF] ^                        T6[(t1 >> 16) & 0xFF] ^                        T7[(t0 >> 8) & 0xFF] ^                        T8[t3 & 0xFF]) ^ Kdr[2];                  a3 = (T5[(t3 >> 24) & 0xFF] ^                        T6[(t2 >> 16) & 0xFF] ^                        T7[(t1 >> 8) & 0xFF] ^                        T8[t0 & 0xFF]) ^ Kdr[3];                  t0 = a0;                  t1 = a1;                  t2 = a2;                  t3 = a3;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 0] = (byte)(Si[(t0 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 0] = (byte)(Si[(t0 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 1] = (byte)(Si[(t3 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 1] = (byte)(Si[(t3 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 2] = (byte)(Si[(t2 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 2] = (byte)(Si[(t2 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 2] = (byte)(Si[(t2 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 3] = (byte)(Si[t1 & 0xFF] ^ tt);
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 4] = (byte)(Si[(t1 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 4] = (byte)(Si[(t1 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 4] = (byte)(Si[(t1 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 5] = (byte)(Si[(t0 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 5] = (byte)(Si[(t0 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 5] = (byte)(Si[(t0 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 6] = (byte)(Si[(t3 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 6] = (byte)(Si[(t3 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 6] = (byte)(Si[(t3 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 7] = (byte)(Si[t2 & 0xFF] ^ tt);
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: tt = Kdr[2];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 8] = (byte)(Si[(t2 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 8] = (byte)(Si[(t2 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 8] = (byte)(Si[(t2 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 9] = (byte)(Si[(t1 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 9] = (byte)(Si[(t1 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 9] = (byte)(Si[(t1 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 10] = (byte)(Si[(t0 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 10] = (byte)(Si[(t0 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 10] = (byte)(Si[(t0 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 11] = (byte)(Si[t3 & 0xFF] ^ tt);
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: tt = Kdr[3];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 12] = (byte)(Si[(t3 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 12] = (byte)(Si[(t3 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 12] = (byte)(Si[(t3 >> 24) & 0xFF] ^ (tt >> 24));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 13] = (byte)(Si[(t2 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 13] = (byte)(Si[(t2 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 13] = (byte)(Si[(t2 >> 16) & 0xFF] ^ (tt >> 16));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 14] = (byte)(Si[(t1 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 14] = (byte)(Si[(t1 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 14] = (byte)(Si[(t1 >> 8) & 0xFF] ^ (tt >> 8));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,blockDecrypt,The following statement contains a magic number: dst[outOffset + 15] = (byte)(Si[t0 & 0xFF] ^ tt);
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 1; i < 256; i++) {                  j = (alog[i - 1] << 1) ^ alog[i - 1];                  if ((j & 0x100) != 0)                      j ^= ROOT;                  alog[i] = j;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 1; i < 255; i++)                  log[alog[i]] = i;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: byte['] box = new byte[256' 8];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: byte['] box = new byte[256' 8];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: box[1' 7] = 1;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 2; i < 256; i++) {                  j = alog[255 - log[i]];                  for (t = 0; t < 8; t++) {                      box[i' t] = (byte)((j >> (7 - t)) & 0x01);                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 2; i < 256; i++) {                  j = alog[255 - log[i]];                  for (t = 0; t < 8; t++) {                      box[i' t] = (byte)((j >> (7 - t)) & 0x01);                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 2; i < 256; i++) {                  j = alog[255 - log[i]];                  for (t = 0; t < 8; t++) {                      box[i' t] = (byte)((j >> (7 - t)) & 0x01);                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 2; i < 256; i++) {                  j = alog[255 - log[i]];                  for (t = 0; t < 8; t++) {                      box[i' t] = (byte)((j >> (7 - t)) & 0x01);                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 2; i < 256; i++) {                  j = alog[255 - log[i]];                  for (t = 0; t < 8; t++) {                      box[i' t] = (byte)((j >> (7 - t)) & 0x01);                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: byte['] cox = new byte[256' 8];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: byte['] cox = new byte[256' 8];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 256; i++) {                  for (t = 0; t < 8; t++) {                      cox[i' t] = B[t];                      for (j = 0; j < 8; j++)                          cox[i' t] ^= (byte)(A[t' j] * box[i' j]);                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 256; i++) {                  for (t = 0; t < 8; t++) {                      cox[i' t] = B[t];                      for (j = 0; j < 8; j++)                          cox[i' t] ^= (byte)(A[t' j] * box[i' j]);                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 256; i++) {                  for (t = 0; t < 8; t++) {                      cox[i' t] = B[t];                      for (j = 0; j < 8; j++)                          cox[i' t] ^= (byte)(A[t' j] * box[i' j]);                  }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 256; i++) {                  S[i] = (byte)(cox[i' 0] << 7);                  for (t = 1; t < 8; t++)                      S[i] ^= (byte)(cox[i' t] << (7 - t));                  Si[S[i] & 0xFF] = (byte)i;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 256; i++) {                  S[i] = (byte)(cox[i' 0] << 7);                  for (t = 1; t < 8; t++)                      S[i] ^= (byte)(cox[i' t] << (7 - t));                  Si[S[i] & 0xFF] = (byte)i;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 256; i++) {                  S[i] = (byte)(cox[i' 0] << 7);                  for (t = 1; t < 8; t++)                      S[i] ^= (byte)(cox[i' t] << (7 - t));                  Si[S[i] & 0xFF] = (byte)i;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 256; i++) {                  S[i] = (byte)(cox[i' 0] << 7);                  for (t = 1; t < 8; t++)                      S[i] ^= (byte)(cox[i' t] << (7 - t));                  Si[S[i] & 0xFF] = (byte)i;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: byte[][] G = new byte[4][];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[0] = new byte[] { 2' 1' 1' 3 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[0] = new byte[] { 2' 1' 1' 3 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[1] = new byte[] { 3' 2' 1' 1 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[1] = new byte[] { 3' 2' 1' 1 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[2] = new byte[] { 1' 3' 2' 1 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[2] = new byte[] { 1' 3' 2' 1 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[2] = new byte[] { 1' 3' 2' 1 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[3] = new byte[] { 1' 1' 3' 2 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[3] = new byte[] { 1' 1' 3' 2 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: G[3] = new byte[] { 1' 1' 3' 2 };
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: byte['] AA = new byte[4' 8];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: byte['] AA = new byte[4' 8];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  for (j = 0; j < 4; j++)                      AA[i' j] = G[i][j];                  AA[i' i + 4] = 1;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  for (j = 0; j < 4; j++)                      AA[i' j] = G[i][j];                  AA[i' i + 4] = 1;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  for (j = 0; j < 4; j++)                      AA[i' j] = G[i][j];                  AA[i' i + 4] = 1;              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: byte[][] iG = new byte[4][];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++)                  iG[i] = new byte[4];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++)                  iG[i] = new byte[4];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  pivot = AA[i' i];                  if (pivot == 0) {                      t = i + 1;                      while ((AA[t' i] == 0) && (t < 4))                          t++;                      if (t != 4) {                          for (j = 0; j < 8; j++) {                              tmp = AA[i' j];                              AA[i' j] = AA[t' j];                              AA[t' j] = (byte)tmp;                          }                          pivot = AA[i' i];                      }                  }                  for (j = 0; j < 8; j++)                      if (AA[i' j] != 0)                          AA[i' j] = (byte)                              alog[(255 + log[AA[i' j] & 0xFF] - log[pivot & 0xFF]) % 255];                  for (t = 0; t < 4; t++)                      if (i != t) {                          for (j = i + 1; j < 8; j++)                              AA[t' j] ^= (byte)mul(AA[i' j]' AA[t' i]);                          AA[t' i] = 0;                      }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  pivot = AA[i' i];                  if (pivot == 0) {                      t = i + 1;                      while ((AA[t' i] == 0) && (t < 4))                          t++;                      if (t != 4) {                          for (j = 0; j < 8; j++) {                              tmp = AA[i' j];                              AA[i' j] = AA[t' j];                              AA[t' j] = (byte)tmp;                          }                          pivot = AA[i' i];                      }                  }                  for (j = 0; j < 8; j++)                      if (AA[i' j] != 0)                          AA[i' j] = (byte)                              alog[(255 + log[AA[i' j] & 0xFF] - log[pivot & 0xFF]) % 255];                  for (t = 0; t < 4; t++)                      if (i != t) {                          for (j = i + 1; j < 8; j++)                              AA[t' j] ^= (byte)mul(AA[i' j]' AA[t' i]);                          AA[t' i] = 0;                      }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  pivot = AA[i' i];                  if (pivot == 0) {                      t = i + 1;                      while ((AA[t' i] == 0) && (t < 4))                          t++;                      if (t != 4) {                          for (j = 0; j < 8; j++) {                              tmp = AA[i' j];                              AA[i' j] = AA[t' j];                              AA[t' j] = (byte)tmp;                          }                          pivot = AA[i' i];                      }                  }                  for (j = 0; j < 8; j++)                      if (AA[i' j] != 0)                          AA[i' j] = (byte)                              alog[(255 + log[AA[i' j] & 0xFF] - log[pivot & 0xFF]) % 255];                  for (t = 0; t < 4; t++)                      if (i != t) {                          for (j = i + 1; j < 8; j++)                              AA[t' j] ^= (byte)mul(AA[i' j]' AA[t' i]);                          AA[t' i] = 0;                      }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  pivot = AA[i' i];                  if (pivot == 0) {                      t = i + 1;                      while ((AA[t' i] == 0) && (t < 4))                          t++;                      if (t != 4) {                          for (j = 0; j < 8; j++) {                              tmp = AA[i' j];                              AA[i' j] = AA[t' j];                              AA[t' j] = (byte)tmp;                          }                          pivot = AA[i' i];                      }                  }                  for (j = 0; j < 8; j++)                      if (AA[i' j] != 0)                          AA[i' j] = (byte)                              alog[(255 + log[AA[i' j] & 0xFF] - log[pivot & 0xFF]) % 255];                  for (t = 0; t < 4; t++)                      if (i != t) {                          for (j = i + 1; j < 8; j++)                              AA[t' j] ^= (byte)mul(AA[i' j]' AA[t' i]);                          AA[t' i] = 0;                      }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  pivot = AA[i' i];                  if (pivot == 0) {                      t = i + 1;                      while ((AA[t' i] == 0) && (t < 4))                          t++;                      if (t != 4) {                          for (j = 0; j < 8; j++) {                              tmp = AA[i' j];                              AA[i' j] = AA[t' j];                              AA[t' j] = (byte)tmp;                          }                          pivot = AA[i' i];                      }                  }                  for (j = 0; j < 8; j++)                      if (AA[i' j] != 0)                          AA[i' j] = (byte)                              alog[(255 + log[AA[i' j] & 0xFF] - log[pivot & 0xFF]) % 255];                  for (t = 0; t < 4; t++)                      if (i != t) {                          for (j = i + 1; j < 8; j++)                              AA[t' j] ^= (byte)mul(AA[i' j]' AA[t' i]);                          AA[t' i] = 0;                      }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  pivot = AA[i' i];                  if (pivot == 0) {                      t = i + 1;                      while ((AA[t' i] == 0) && (t < 4))                          t++;                      if (t != 4) {                          for (j = 0; j < 8; j++) {                              tmp = AA[i' j];                              AA[i' j] = AA[t' j];                              AA[t' j] = (byte)tmp;                          }                          pivot = AA[i' i];                      }                  }                  for (j = 0; j < 8; j++)                      if (AA[i' j] != 0)                          AA[i' j] = (byte)                              alog[(255 + log[AA[i' j] & 0xFF] - log[pivot & 0xFF]) % 255];                  for (t = 0; t < 4; t++)                      if (i != t) {                          for (j = i + 1; j < 8; j++)                              AA[t' j] ^= (byte)mul(AA[i' j]' AA[t' i]);                          AA[t' i] = 0;                      }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  pivot = AA[i' i];                  if (pivot == 0) {                      t = i + 1;                      while ((AA[t' i] == 0) && (t < 4))                          t++;                      if (t != 4) {                          for (j = 0; j < 8; j++) {                              tmp = AA[i' j];                              AA[i' j] = AA[t' j];                              AA[t' j] = (byte)tmp;                          }                          pivot = AA[i' i];                      }                  }                  for (j = 0; j < 8; j++)                      if (AA[i' j] != 0)                          AA[i' j] = (byte)                              alog[(255 + log[AA[i' j] & 0xFF] - log[pivot & 0xFF]) % 255];                  for (t = 0; t < 4; t++)                      if (i != t) {                          for (j = i + 1; j < 8; j++)                              AA[t' j] ^= (byte)mul(AA[i' j]' AA[t' i]);                          AA[t' i] = 0;                      }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  pivot = AA[i' i];                  if (pivot == 0) {                      t = i + 1;                      while ((AA[t' i] == 0) && (t < 4))                          t++;                      if (t != 4) {                          for (j = 0; j < 8; j++) {                              tmp = AA[i' j];                              AA[i' j] = AA[t' j];                              AA[t' j] = (byte)tmp;                          }                          pivot = AA[i' i];                      }                  }                  for (j = 0; j < 8; j++)                      if (AA[i' j] != 0)                          AA[i' j] = (byte)                              alog[(255 + log[AA[i' j] & 0xFF] - log[pivot & 0xFF]) % 255];                  for (t = 0; t < 4; t++)                      if (i != t) {                          for (j = i + 1; j < 8; j++)                              AA[t' j] ^= (byte)mul(AA[i' j]' AA[t' i]);                          AA[t' i] = 0;                      }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++) {                  pivot = AA[i' i];                  if (pivot == 0) {                      t = i + 1;                      while ((AA[t' i] == 0) && (t < 4))                          t++;                      if (t != 4) {                          for (j = 0; j < 8; j++) {                              tmp = AA[i' j];                              AA[i' j] = AA[t' j];                              AA[t' j] = (byte)tmp;                          }                          pivot = AA[i' i];                      }                  }                  for (j = 0; j < 8; j++)                      if (AA[i' j] != 0)                          AA[i' j] = (byte)                              alog[(255 + log[AA[i' j] & 0xFF] - log[pivot & 0xFF]) % 255];                  for (t = 0; t < 4; t++)                      if (i != t) {                          for (j = i + 1; j < 8; j++)                              AA[t' j] ^= (byte)mul(AA[i' j]' AA[t' i]);                          AA[t' i] = 0;                      }              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++)                  for (j = 0; j < 4; j++)                      iG[i][j] = AA[i' j + 4];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++)                  for (j = 0; j < 4; j++)                      iG[i][j] = AA[i' j + 4];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (i = 0; i < 4; i++)                  for (j = 0; j < 4; j++)                      iG[i][j] = AA[i' j + 4];
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (t = 0; t < 256; t++) {                  s = S[t];                  T1[t] = mul4(s' G[0]);                  T2[t] = mul4(s' G[1]);                  T3[t] = mul4(s' G[2]);                  T4[t] = mul4(s' G[3]);                    s = Si[t];                  T5[t] = mul4(s' iG[0]);                  T6[t] = mul4(s' iG[1]);                  T7[t] = mul4(s' iG[2]);                  T8[t] = mul4(s' iG[3]);                    U1[t] = mul4(t' iG[0]);                  U2[t] = mul4(t' iG[1]);                  U3[t] = mul4(t' iG[2]);                  U4[t] = mul4(t' iG[3]);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (t = 0; t < 256; t++) {                  s = S[t];                  T1[t] = mul4(s' G[0]);                  T2[t] = mul4(s' G[1]);                  T3[t] = mul4(s' G[2]);                  T4[t] = mul4(s' G[3]);                    s = Si[t];                  T5[t] = mul4(s' iG[0]);                  T6[t] = mul4(s' iG[1]);                  T7[t] = mul4(s' iG[2]);                  T8[t] = mul4(s' iG[3]);                    U1[t] = mul4(t' iG[0]);                  U2[t] = mul4(t' iG[1]);                  U3[t] = mul4(t' iG[2]);                  U4[t] = mul4(t' iG[3]);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (t = 0; t < 256; t++) {                  s = S[t];                  T1[t] = mul4(s' G[0]);                  T2[t] = mul4(s' G[1]);                  T3[t] = mul4(s' G[2]);                  T4[t] = mul4(s' G[3]);                    s = Si[t];                  T5[t] = mul4(s' iG[0]);                  T6[t] = mul4(s' iG[1]);                  T7[t] = mul4(s' iG[2]);                  T8[t] = mul4(s' iG[3]);                    U1[t] = mul4(t' iG[0]);                  U2[t] = mul4(t' iG[1]);                  U3[t] = mul4(t' iG[2]);                  U4[t] = mul4(t' iG[3]);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (t = 0; t < 256; t++) {                  s = S[t];                  T1[t] = mul4(s' G[0]);                  T2[t] = mul4(s' G[1]);                  T3[t] = mul4(s' G[2]);                  T4[t] = mul4(s' G[3]);                    s = Si[t];                  T5[t] = mul4(s' iG[0]);                  T6[t] = mul4(s' iG[1]);                  T7[t] = mul4(s' iG[2]);                  T8[t] = mul4(s' iG[3]);                    U1[t] = mul4(t' iG[0]);                  U2[t] = mul4(t' iG[1]);                  U3[t] = mul4(t' iG[2]);                  U4[t] = mul4(t' iG[3]);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (t = 0; t < 256; t++) {                  s = S[t];                  T1[t] = mul4(s' G[0]);                  T2[t] = mul4(s' G[1]);                  T3[t] = mul4(s' G[2]);                  T4[t] = mul4(s' G[3]);                    s = Si[t];                  T5[t] = mul4(s' iG[0]);                  T6[t] = mul4(s' iG[1]);                  T7[t] = mul4(s' iG[2]);                  T8[t] = mul4(s' iG[3]);                    U1[t] = mul4(t' iG[0]);                  U2[t] = mul4(t' iG[1]);                  U3[t] = mul4(t' iG[2]);                  U4[t] = mul4(t' iG[3]);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (t = 0; t < 256; t++) {                  s = S[t];                  T1[t] = mul4(s' G[0]);                  T2[t] = mul4(s' G[1]);                  T3[t] = mul4(s' G[2]);                  T4[t] = mul4(s' G[3]);                    s = Si[t];                  T5[t] = mul4(s' iG[0]);                  T6[t] = mul4(s' iG[1]);                  T7[t] = mul4(s' iG[2]);                  T8[t] = mul4(s' iG[3]);                    U1[t] = mul4(t' iG[0]);                  U2[t] = mul4(t' iG[1]);                  U3[t] = mul4(t' iG[2]);                  U4[t] = mul4(t' iG[3]);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (t = 0; t < 256; t++) {                  s = S[t];                  T1[t] = mul4(s' G[0]);                  T2[t] = mul4(s' G[1]);                  T3[t] = mul4(s' G[2]);                  T4[t] = mul4(s' G[3]);                    s = Si[t];                  T5[t] = mul4(s' iG[0]);                  T6[t] = mul4(s' iG[1]);                  T7[t] = mul4(s' iG[2]);                  T8[t] = mul4(s' iG[3]);                    U1[t] = mul4(t' iG[0]);                  U2[t] = mul4(t' iG[1]);                  U3[t] = mul4(t' iG[2]);                  U4[t] = mul4(t' iG[3]);              }
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (t = 1; t < 30; )                  rcon[t++] = (byte)(r = mul(2' r));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,Rijndael,The following statement contains a magic number: for (t = 1; t < 30; )                  rcon[t++] = (byte)(r = mul(2' r));
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul,The following statement contains a magic number: return (a != 0 && b != 0) ?                      alog[(log[a & 0xFF] + log[b & 0xFF]) % 255] :                      0;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: int a0 = (b[0] != 0) ? alog[(a + log[b[0] & 0xFF]) % 255] & 0xFF : 0;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: int a1 = (b[1] != 0) ? alog[(a + log[b[1] & 0xFF]) % 255] & 0xFF : 0;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: int a2 = (b[2] != 0) ? alog[(a + log[b[2] & 0xFF]) % 255] & 0xFF : 0;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: int a2 = (b[2] != 0) ? alog[(a + log[b[2] & 0xFF]) % 255] & 0xFF : 0;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: int a2 = (b[2] != 0) ? alog[(a + log[b[2] & 0xFF]) % 255] & 0xFF : 0;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: int a3 = (b[3] != 0) ? alog[(a + log[b[3] & 0xFF]) % 255] & 0xFF : 0;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: int a3 = (b[3] != 0) ? alog[(a + log[b[3] & 0xFF]) % 255] & 0xFF : 0;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: int a3 = (b[3] != 0) ? alog[(a + log[b[3] & 0xFF]) % 255] & 0xFF : 0;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: return a0 << 24 | a1 << 16 | a2 << 8 | a3;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: return a0 << 24 | a1 << 16 | a2 << 8 | a3;
Magic Number,Granados.Algorithms,Rijndael,C:\repos\poderosaproject_poderosa\Granados\Rijndael.cs,mul4,The following statement contains a magic number: return a0 << 24 | a1 << 16 | a2 << 8 | a3;
Magic Number,Granados.IO,SimpleMemoryStream,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,SimpleMemoryStream,The following statement contains a magic number: Init(512);
Magic Number,Granados.IO,SimpleMemoryStream,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,AssureSize,The following statement contains a magic number: if (_buffer.Length < size) {                  byte[] t = new byte[Math.Max(size' _buffer.Length * 2)];                  Buffer.BlockCopy(_buffer' 0' t' 0' _buffer.Length);                  _buffer = t;              }
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,RoundUp,The following statement contains a magic number: if (size <= 16)                  return 16;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,RoundUp,The following statement contains a magic number: if (size <= 16)                  return 16;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,RoundUp,The following statement contains a magic number: size |= size >> 2;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,RoundUp,The following statement contains a magic number: size |= size >> 4;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,RoundUp,The following statement contains a magic number: size |= size >> 8;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,RoundUp,The following statement contains a magic number: size |= size >> 16;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt16,The following statement contains a magic number: const int LENGTH = 2;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt16,The following statement contains a magic number: _buff[index + 0] = (byte)(val >> 8);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt32,The following statement contains a magic number: const int LENGTH = 4;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt32,The following statement contains a magic number: _buff[index + 0] = (byte)(val >> 24);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt32,The following statement contains a magic number: _buff[index + 1] = (byte)(val >> 16);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt32,The following statement contains a magic number: _buff[index + 2] = (byte)(val >> 8);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt32,The following statement contains a magic number: _buff[index + 2] = (byte)(val >> 8);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt32,The following statement contains a magic number: _buff[index + 3] = (byte)(val);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,OverwriteUInt32,The following statement contains a magic number: const int LENGTH = 4;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,OverwriteUInt32,The following statement contains a magic number: _buff[index + 0] = (byte)(val >> 24);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,OverwriteUInt32,The following statement contains a magic number: _buff[index + 1] = (byte)(val >> 16);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,OverwriteUInt32,The following statement contains a magic number: _buff[index + 2] = (byte)(val >> 8);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,OverwriteUInt32,The following statement contains a magic number: _buff[index + 2] = (byte)(val >> 8);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,OverwriteUInt32,The following statement contains a magic number: _buff[index + 3] = (byte)(val);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: const int LENGTH = 8;
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 0] = (byte)(val >> 56);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 1] = (byte)(val >> 48);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 2] = (byte)(val >> 40);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 2] = (byte)(val >> 40);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 3] = (byte)(val >> 32);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 3] = (byte)(val >> 32);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 4] = (byte)(val >> 24);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 4] = (byte)(val >> 24);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 5] = (byte)(val >> 16);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 5] = (byte)(val >> 16);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 6] = (byte)(val >> 8);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 6] = (byte)(val >> 8);
Magic Number,Granados.IO,ByteBuffer,C:\repos\poderosaproject_poderosa\Granados\DataFragment.cs,WriteUInt64,The following statement contains a magic number: _buff[index + 7] = (byte)(val);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt16,The following statement contains a magic number: const int LENGTH = 2;
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt16,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 8)                  | ((uint)_data[_currentIndex + 1]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: const int LENGTH = 4;
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: const int LENGTH = 8;
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: ulong ret = ((ulong)i1 << 32) | i2;
Magic Number,Granados.IO,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt32,The following statement contains a magic number: _strm.WriteByte((byte)(data >> 24));
Magic Number,Granados.IO,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt32,The following statement contains a magic number: _strm.WriteByte((byte)(data >> 16));
Magic Number,Granados.IO,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt32,The following statement contains a magic number: _strm.WriteByte((byte)(data >> 8));
Magic Number,Granados.IO,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt64,The following statement contains a magic number: WriteUInt32((uint)(data >> 32));
Magic Number,Granados.IO,SSH1DataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadMPInt,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.IO,SSH1DataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadMPInt,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.PKI,ECPoint,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ParseUncompressed,The following statement contains a magic number: if (data.Length < 3) {                  // invalid length                  return null;              }
Magic Number,Granados.PKI,ECPoint,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ParseUncompressed,The following statement contains a magic number: if ((data.Length - 1) % 2 != 0) {                  // invalid length                  return null;              }
Magic Number,Granados.PKI,ECPoint,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ParseUncompressed,The following statement contains a magic number: int elementLen = (data.Length - 1) / 2;
Magic Number,Granados.PKI,ECPoint,C:\repos\poderosaproject_poderosa\Granados\EC.cs,Parse,The following statement contains a magic number: if (data.Length < 2) {                  // invalid length                  p = null;                  return false;              }
Magic Number,Granados.PKI,EllipticCurve,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ConvertPointToOctetString,The following statement contains a magic number: int byteLength = (this.Order.BitCount() + 7) / 8;
Magic Number,Granados.PKI,EllipticCurve,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ConvertPointToOctetString,The following statement contains a magic number: int byteLength = (this.Order.BitCount() + 7) / 8;
Magic Number,Granados.PKI,EllipticCurve,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ConvertPointToOctetString,The following statement contains a magic number: byte[] buff = new byte[1 + byteLength * 2];
Magic Number,Granados.PKI,EllipticCurve,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ConvertPointToOctetString,The following statement contains a magic number: Buffer.BlockCopy(y' 0' buff' 1 + byteLength * 2 - y.Length' y.Length);
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestPointMultiplication,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"nisttv")) {                  EllipticCurve curve = null;                  string ks = null;                  BigInteger k = null;                  BigInteger x = null;                  BigInteger y = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"Curve:\s+(\w+)");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant();                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              Debug.WriteLine("Test " + curve.CurveName);                          }                          ks = null;                          k = x = y = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("k = ") && curve != null) {                          ks = line.Substring(4).Trim();                          k = BigInteger.Parse(ks);                          continue;                      }                        if (line.StartsWith("x = ") && curve != null) {                          x = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("y = ") && curve != null) {                          y = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                            if (k != null && x != null) {                              ECPoint p = curve.PointMul(k' curve.BasePoint' true);                              if (p == null || p is ECPointAtInfinity) {                                  throw new Exception("test failed");                              }                              if (p.X != x) {                                  throw new Exception("test failed: X doesn't match");                              }                              if (p.Y != y) {                                  throw new Exception("test failed: Y doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0} : {1}"' testCount' ks);                          }                            k = x = y = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestPointMultiplication,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"nisttv")) {                  EllipticCurve curve = null;                  string ks = null;                  BigInteger k = null;                  BigInteger x = null;                  BigInteger y = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"Curve:\s+(\w+)");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant();                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              Debug.WriteLine("Test " + curve.CurveName);                          }                          ks = null;                          k = x = y = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("k = ") && curve != null) {                          ks = line.Substring(4).Trim();                          k = BigInteger.Parse(ks);                          continue;                      }                        if (line.StartsWith("x = ") && curve != null) {                          x = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("y = ") && curve != null) {                          y = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                            if (k != null && x != null) {                              ECPoint p = curve.PointMul(k' curve.BasePoint' true);                              if (p == null || p is ECPointAtInfinity) {                                  throw new Exception("test failed");                              }                              if (p.X != x) {                                  throw new Exception("test failed: X doesn't match");                              }                              if (p.Y != y) {                                  throw new Exception("test failed: Y doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0} : {1}"' testCount' ks);                          }                            k = x = y = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestPointMultiplication,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"nisttv")) {                  EllipticCurve curve = null;                  string ks = null;                  BigInteger k = null;                  BigInteger x = null;                  BigInteger y = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"Curve:\s+(\w+)");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant();                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              Debug.WriteLine("Test " + curve.CurveName);                          }                          ks = null;                          k = x = y = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("k = ") && curve != null) {                          ks = line.Substring(4).Trim();                          k = BigInteger.Parse(ks);                          continue;                      }                        if (line.StartsWith("x = ") && curve != null) {                          x = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("y = ") && curve != null) {                          y = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                            if (k != null && x != null) {                              ECPoint p = curve.PointMul(k' curve.BasePoint' true);                              if (p == null || p is ECPointAtInfinity) {                                  throw new Exception("test failed");                              }                              if (p.X != x) {                                  throw new Exception("test failed: X doesn't match");                              }                              if (p.Y != y) {                                  throw new Exception("test failed: Y doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0} : {1}"' testCount' ks);                          }                            k = x = y = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestPKV,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\PKV.rsp")) {                  EllipticCurve curve = null;                  string qxs = null;                  BigInteger qx = null;                  BigInteger qy = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              Debug.WriteLine("Test " + curve.CurveName);                          }                          qx = qy = null;                          qxs = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qxs = line.Substring(5).Trim();                          qx = new BigInteger(BigIntegerConverter.ParseHex(qxs));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (qx != null && qy != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              string r = pk.IsValid() ? "P" : "F";                              if (r != result) {                                  throw new Exception("validation result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0} : {1}"' testCount' qxs);                          }                            qx = qy = null;                          qxs = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestPKV,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\PKV.rsp")) {                  EllipticCurve curve = null;                  string qxs = null;                  BigInteger qx = null;                  BigInteger qy = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              Debug.WriteLine("Test " + curve.CurveName);                          }                          qx = qy = null;                          qxs = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qxs = line.Substring(5).Trim();                          qx = new BigInteger(BigIntegerConverter.ParseHex(qxs));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (qx != null && qy != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              string r = pk.IsValid() ? "P" : "F";                              if (r != result) {                                  throw new Exception("validation result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0} : {1}"' testCount' qxs);                          }                            qx = qy = null;                          qxs = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestPKV,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\PKV.rsp")) {                  EllipticCurve curve = null;                  string qxs = null;                  BigInteger qx = null;                  BigInteger qy = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              Debug.WriteLine("Test " + curve.CurveName);                          }                          qx = qy = null;                          qxs = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qxs = line.Substring(5).Trim();                          qx = new BigInteger(BigIntegerConverter.ParseHex(qxs));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (qx != null && qy != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              string r = pk.IsValid() ? "P" : "F";                              if (r != result) {                                  throw new Exception("validation result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0} : {1}"' testCount' qxs);                          }                            qx = qy = null;                          qxs = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestKeyPair,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\KeyPair.rsp")) {                  EllipticCurve curve = null;                  string ds = null;                  BigInteger d = null;                  BigInteger qx = null;                  BigInteger qy = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              Debug.WriteLine("Test " + curve.CurveName);                          }                          d = qx = qy = null;                          ds = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("d = ") && curve != null) {                          ds = line.Substring(4).Trim();                          d = new BigInteger(BigIntegerConverter.ParseHex(ds));                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                            if (d != null && qx != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var kp = new ECDSAKeyPair(curve' pk' d);                              if (!kp.CheckKeyConsistency()) {                                  throw new Exception("validation failed");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0} : {1}"' testCount' ds);                          }                            d = qx = qy = null;                          ds = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestKeyPair,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\KeyPair.rsp")) {                  EllipticCurve curve = null;                  string ds = null;                  BigInteger d = null;                  BigInteger qx = null;                  BigInteger qy = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              Debug.WriteLine("Test " + curve.CurveName);                          }                          d = qx = qy = null;                          ds = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("d = ") && curve != null) {                          ds = line.Substring(4).Trim();                          d = new BigInteger(BigIntegerConverter.ParseHex(ds));                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                            if (d != null && qx != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var kp = new ECDSAKeyPair(curve' pk' d);                              if (!kp.CheckKeyConsistency()) {                                  throw new Exception("validation failed");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0} : {1}"' testCount' ds);                          }                            d = qx = qy = null;                          ds = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestKeyPair,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\KeyPair.rsp")) {                  EllipticCurve curve = null;                  string ds = null;                  BigInteger d = null;                  BigInteger qx = null;                  BigInteger qy = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              Debug.WriteLine("Test " + curve.CurveName);                          }                          d = qx = qy = null;                          ds = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("d = ") && curve != null) {                          ds = line.Substring(4).Trim();                          d = new BigInteger(BigIntegerConverter.ParseHex(ds));                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                            if (d != null && qx != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var kp = new ECDSAKeyPair(curve' pk' d);                              if (!kp.CheckKeyConsistency()) {                                  throw new Exception("validation failed");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0} : {1}"' testCount' ds);                          }                            d = qx = qy = null;                          ds = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestSignatureVerification,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\SigVer.rsp")) {                  EllipticCurve curve = null;                  byte[] msg = null;                  BigInteger qx = null;                  BigInteger qy = null;                  BigInteger r = null;                  BigInteger s = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)'(SHA-\d+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              using (var hashFunc = ECDSAHashAlgorithmChooser.Choose(curve)) {                                  var hashName = "SHA-" + hashFunc.HashSize.ToString();                                  if (hashName == match.Groups[2].Value) {                                      Debug.WriteLine("Test " + curve.CurveName);                                  }                                  else {                                      // hash function doesn't match                                      curve = null;                                  }                              }                          }                          msg = null;                          qx = qy = r = s = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Msg = ") && curve != null) {                          msg = BigIntegerConverter.ParseHex(line.Substring(6).Trim());                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("R = ") && curve != null) {                          r = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("S = ") && curve != null) {                          s = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (msg != null && qx != null && qy != null && r != null && s != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var buf = new SSH2DataWriter();                              buf.WriteBigInteger(r);                              buf.WriteBigInteger(s);                              var sig = buf.ToByteArray();                              string verRes;                              try {                                  pk.Verify(sig' msg);                                  verRes = "P";                              }                              catch (VerifyException) {                                  verRes = "F";                              }                              if (verRes != result) {                                  throw new Exception("verification result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0}"' testCount);                          }                            msg = null;                          qx = qy = r = s = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestSignatureVerification,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\SigVer.rsp")) {                  EllipticCurve curve = null;                  byte[] msg = null;                  BigInteger qx = null;                  BigInteger qy = null;                  BigInteger r = null;                  BigInteger s = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)'(SHA-\d+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              using (var hashFunc = ECDSAHashAlgorithmChooser.Choose(curve)) {                                  var hashName = "SHA-" + hashFunc.HashSize.ToString();                                  if (hashName == match.Groups[2].Value) {                                      Debug.WriteLine("Test " + curve.CurveName);                                  }                                  else {                                      // hash function doesn't match                                      curve = null;                                  }                              }                          }                          msg = null;                          qx = qy = r = s = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Msg = ") && curve != null) {                          msg = BigIntegerConverter.ParseHex(line.Substring(6).Trim());                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("R = ") && curve != null) {                          r = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("S = ") && curve != null) {                          s = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (msg != null && qx != null && qy != null && r != null && s != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var buf = new SSH2DataWriter();                              buf.WriteBigInteger(r);                              buf.WriteBigInteger(s);                              var sig = buf.ToByteArray();                              string verRes;                              try {                                  pk.Verify(sig' msg);                                  verRes = "P";                              }                              catch (VerifyException) {                                  verRes = "F";                              }                              if (verRes != result) {                                  throw new Exception("verification result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0}"' testCount);                          }                            msg = null;                          qx = qy = r = s = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestSignatureVerification,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\SigVer.rsp")) {                  EllipticCurve curve = null;                  byte[] msg = null;                  BigInteger qx = null;                  BigInteger qy = null;                  BigInteger r = null;                  BigInteger s = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)'(SHA-\d+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              using (var hashFunc = ECDSAHashAlgorithmChooser.Choose(curve)) {                                  var hashName = "SHA-" + hashFunc.HashSize.ToString();                                  if (hashName == match.Groups[2].Value) {                                      Debug.WriteLine("Test " + curve.CurveName);                                  }                                  else {                                      // hash function doesn't match                                      curve = null;                                  }                              }                          }                          msg = null;                          qx = qy = r = s = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Msg = ") && curve != null) {                          msg = BigIntegerConverter.ParseHex(line.Substring(6).Trim());                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("R = ") && curve != null) {                          r = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("S = ") && curve != null) {                          s = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (msg != null && qx != null && qy != null && r != null && s != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var buf = new SSH2DataWriter();                              buf.WriteBigInteger(r);                              buf.WriteBigInteger(s);                              var sig = buf.ToByteArray();                              string verRes;                              try {                                  pk.Verify(sig' msg);                                  verRes = "P";                              }                              catch (VerifyException) {                                  verRes = "F";                              }                              if (verRes != result) {                                  throw new Exception("verification result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0}"' testCount);                          }                            msg = null;                          qx = qy = r = s = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestSignatureVerification,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\SigVer.rsp")) {                  EllipticCurve curve = null;                  byte[] msg = null;                  BigInteger qx = null;                  BigInteger qy = null;                  BigInteger r = null;                  BigInteger s = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)'(SHA-\d+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              using (var hashFunc = ECDSAHashAlgorithmChooser.Choose(curve)) {                                  var hashName = "SHA-" + hashFunc.HashSize.ToString();                                  if (hashName == match.Groups[2].Value) {                                      Debug.WriteLine("Test " + curve.CurveName);                                  }                                  else {                                      // hash function doesn't match                                      curve = null;                                  }                              }                          }                          msg = null;                          qx = qy = r = s = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Msg = ") && curve != null) {                          msg = BigIntegerConverter.ParseHex(line.Substring(6).Trim());                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("R = ") && curve != null) {                          r = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("S = ") && curve != null) {                          s = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (msg != null && qx != null && qy != null && r != null && s != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var buf = new SSH2DataWriter();                              buf.WriteBigInteger(r);                              buf.WriteBigInteger(s);                              var sig = buf.ToByteArray();                              string verRes;                              try {                                  pk.Verify(sig' msg);                                  verRes = "P";                              }                              catch (VerifyException) {                                  verRes = "F";                              }                              if (verRes != result) {                                  throw new Exception("verification result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0}"' testCount);                          }                            msg = null;                          qx = qy = r = s = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestSignatureVerification,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\SigVer.rsp")) {                  EllipticCurve curve = null;                  byte[] msg = null;                  BigInteger qx = null;                  BigInteger qy = null;                  BigInteger r = null;                  BigInteger s = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)'(SHA-\d+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              using (var hashFunc = ECDSAHashAlgorithmChooser.Choose(curve)) {                                  var hashName = "SHA-" + hashFunc.HashSize.ToString();                                  if (hashName == match.Groups[2].Value) {                                      Debug.WriteLine("Test " + curve.CurveName);                                  }                                  else {                                      // hash function doesn't match                                      curve = null;                                  }                              }                          }                          msg = null;                          qx = qy = r = s = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Msg = ") && curve != null) {                          msg = BigIntegerConverter.ParseHex(line.Substring(6).Trim());                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("R = ") && curve != null) {                          r = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("S = ") && curve != null) {                          s = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (msg != null && qx != null && qy != null && r != null && s != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var buf = new SSH2DataWriter();                              buf.WriteBigInteger(r);                              buf.WriteBigInteger(s);                              var sig = buf.ToByteArray();                              string verRes;                              try {                                  pk.Verify(sig' msg);                                  verRes = "P";                              }                              catch (VerifyException) {                                  verRes = "F";                              }                              if (verRes != result) {                                  throw new Exception("verification result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0}"' testCount);                          }                            msg = null;                          qx = qy = r = s = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestSignatureVerification,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\SigVer.rsp")) {                  EllipticCurve curve = null;                  byte[] msg = null;                  BigInteger qx = null;                  BigInteger qy = null;                  BigInteger r = null;                  BigInteger s = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)'(SHA-\d+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              using (var hashFunc = ECDSAHashAlgorithmChooser.Choose(curve)) {                                  var hashName = "SHA-" + hashFunc.HashSize.ToString();                                  if (hashName == match.Groups[2].Value) {                                      Debug.WriteLine("Test " + curve.CurveName);                                  }                                  else {                                      // hash function doesn't match                                      curve = null;                                  }                              }                          }                          msg = null;                          qx = qy = r = s = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Msg = ") && curve != null) {                          msg = BigIntegerConverter.ParseHex(line.Substring(6).Trim());                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("R = ") && curve != null) {                          r = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("S = ") && curve != null) {                          s = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (msg != null && qx != null && qy != null && r != null && s != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var buf = new SSH2DataWriter();                              buf.WriteBigInteger(r);                              buf.WriteBigInteger(s);                              var sig = buf.ToByteArray();                              string verRes;                              try {                                  pk.Verify(sig' msg);                                  verRes = "P";                              }                              catch (VerifyException) {                                  verRes = "F";                              }                              if (verRes != result) {                                  throw new Exception("verification result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0}"' testCount);                          }                            msg = null;                          qx = qy = r = s = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveTest,C:\repos\poderosaproject_poderosa\Granados\EC.cs,TestSignatureVerification,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"186-3ecdsatestvectors\SigVer.rsp")) {                  EllipticCurve curve = null;                  byte[] msg = null;                  BigInteger qx = null;                  BigInteger qy = null;                  BigInteger r = null;                  BigInteger s = null;                  string result = null;                  int testCount = 0;                    while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      var match = System.Text.RegularExpressions.Regex.Match(line' @"\[([-\w]+)'(SHA-\d+)\]");                      if (match.Success) {                          string curveName = "nist" + match.Groups[1].Value.ToLowerInvariant().Replace("-"' "");                          curve = EllipticCurve.FindByName(curveName);                          if (curve != null) {                              using (var hashFunc = ECDSAHashAlgorithmChooser.Choose(curve)) {                                  var hashName = "SHA-" + hashFunc.HashSize.ToString();                                  if (hashName == match.Groups[2].Value) {                                      Debug.WriteLine("Test " + curve.CurveName);                                  }                                  else {                                      // hash function doesn't match                                      curve = null;                                  }                              }                          }                          msg = null;                          qx = qy = r = s = null;                          result = null;                          testCount = 0;                          continue;                      }                        if (line.StartsWith("Msg = ") && curve != null) {                          msg = BigIntegerConverter.ParseHex(line.Substring(6).Trim());                          continue;                      }                        if (line.StartsWith("Qx = ") && curve != null) {                          qx = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("Qy = ") && curve != null) {                          qy = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(5).Trim()));                          continue;                      }                        if (line.StartsWith("R = ") && curve != null) {                          r = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("S = ") && curve != null) {                          s = new BigInteger(BigIntegerConverter.ParseHex(line.Substring(4).Trim()));                          continue;                      }                        if (line.StartsWith("Result = ") && curve != null) {                          result = line.Substring(9' 1);                            if (msg != null && qx != null && qy != null && r != null && s != null) {                              var pk = new ECDSAPublicKey(curve' new ECPoint(qx' qy));                              var buf = new SSH2DataWriter();                              buf.WriteBigInteger(r);                              buf.WriteBigInteger(s);                              var sig = buf.ToByteArray();                              string verRes;                              try {                                  pk.Verify(sig' msg);                                  verRes = "P";                              }                              catch (VerifyException) {                                  verRes = "F";                              }                              if (verRes != result) {                                  throw new Exception("verification result doesn't match");                              }                              ++testCount;                              Debug.WriteLine("Pass #{0}"' testCount);                          }                            msg = null;                          qx = qy = r = s = null;                          result = null;                      }                  }              }
Magic Number,Granados.PKI,EllipticCurveFp,C:\repos\poderosaproject_poderosa\Granados\EC.cs,PointMul,The following statement contains a magic number: const int W = 6;
Magic Number,Granados.PKI,EllipticCurveFp,C:\repos\poderosaproject_poderosa\Granados\EC.cs,PointMul,The following statement contains a magic number: {                  ECPoint t = p1;                  ECPoint t2;                  if (!PointDouble(ring' t' out t2)) {                      goto Failure;                  }                  for (uint i = 1; i < TPWD; i += 2) {                      if (i != 1) {                          if (!PointAdd(ring' t' t2' out t)) {                              goto Failure;                          }                      }                      precomp[i] = t;                  }              }
Magic Number,Granados.PKI,EllipticCurveFp,C:\repos\poderosaproject_poderosa\Granados\EC.cs,PointMul,The following statement contains a magic number: {                  byte[] d = k.GetBytes();                  int bitCount = k.BitCount();                  int bitIndex = 0;                  int byteOffset = d.Length - 1;                  bool noMoreBits = false;                  uint bitBuffer = 0;                  const uint WMASK = (1u << W) - 1;                    precompIndex = new Stack<sbyte>(bitCount + 1);                    if (bitIndex < bitCount) {                      bitBuffer = (uint)(d[byteOffset] & WMASK);                      bitIndex += W;                  }                  else {                      noMoreBits = true;                  }                    while (!noMoreBits || bitBuffer != 0) {                      if ((bitBuffer & 1) != 0) { // bits % 2 == 1                          uint m = bitBuffer & WMASK; // m = bits % TPW;                          if ((m & TPWD) != 0) {  // test m >= 2^(W-1)                              // m is odd; thus                              // (2^(W-1) + 1) <= m <= (2^W - 1)                              sbyte index = (sbyte)((int)m - (int)TPW);  // -2^(W-1)+1 .. -1                              precompIndex.Push(index);                              bitBuffer = (bitBuffer & ~WMASK) + TPW; // bits -= m - 2^W                              // a carried bit by adding 2^W is retained in the bit buffer                          }                          else {                              // 1 <= m <= (2^(W-1) - 1)                              sbyte index = (sbyte)m; // odd index                              precompIndex.Push(index);                              bitBuffer = (bitBuffer & ~WMASK); // bits -= m                          }                      }                      else {                          precompIndex.Push(0);                      }                        // shift bits                      if (bitIndex < bitCount) {                          // load next bit into the bit buffer (add to the carried bits in the bit buffer)                          bitBuffer += (uint)((d[byteOffset - bitIndex / 8] >> (bitIndex % 8)) & 1) << W;                          ++bitIndex;                      }                      else {                          noMoreBits = true;                      }                      bitBuffer >>= 1;                  }              }
Magic Number,Granados.PKI,EllipticCurveFp,C:\repos\poderosaproject_poderosa\Granados\EC.cs,PointMul,The following statement contains a magic number: {                  byte[] d = k.GetBytes();                  int bitCount = k.BitCount();                  int bitIndex = 0;                  int byteOffset = d.Length - 1;                  bool noMoreBits = false;                  uint bitBuffer = 0;                  const uint WMASK = (1u << W) - 1;                    precompIndex = new Stack<sbyte>(bitCount + 1);                    if (bitIndex < bitCount) {                      bitBuffer = (uint)(d[byteOffset] & WMASK);                      bitIndex += W;                  }                  else {                      noMoreBits = true;                  }                    while (!noMoreBits || bitBuffer != 0) {                      if ((bitBuffer & 1) != 0) { // bits % 2 == 1                          uint m = bitBuffer & WMASK; // m = bits % TPW;                          if ((m & TPWD) != 0) {  // test m >= 2^(W-1)                              // m is odd; thus                              // (2^(W-1) + 1) <= m <= (2^W - 1)                              sbyte index = (sbyte)((int)m - (int)TPW);  // -2^(W-1)+1 .. -1                              precompIndex.Push(index);                              bitBuffer = (bitBuffer & ~WMASK) + TPW; // bits -= m - 2^W                              // a carried bit by adding 2^W is retained in the bit buffer                          }                          else {                              // 1 <= m <= (2^(W-1) - 1)                              sbyte index = (sbyte)m; // odd index                              precompIndex.Push(index);                              bitBuffer = (bitBuffer & ~WMASK); // bits -= m                          }                      }                      else {                          precompIndex.Push(0);                      }                        // shift bits                      if (bitIndex < bitCount) {                          // load next bit into the bit buffer (add to the carried bits in the bit buffer)                          bitBuffer += (uint)((d[byteOffset - bitIndex / 8] >> (bitIndex % 8)) & 1) << W;                          ++bitIndex;                      }                      else {                          noMoreBits = true;                      }                      bitBuffer >>= 1;                  }              }
Magic Number,Granados.PKI,ECDSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ExtractLeftBits,The following statement contains a magic number: if (src.Length * 8 <= bits) {                  return src;              }
Magic Number,Granados.PKI,ECDSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ExtractLeftBits,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.PKI,ECDSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ExtractLeftBits,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.PKI,ECDSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ExtractLeftBits,The following statement contains a magic number: int shift = (8 - bits % 8) % 8;
Magic Number,Granados.PKI,ECDSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ExtractLeftBits,The following statement contains a magic number: int shift = (8 - bits % 8) % 8;
Magic Number,Granados.PKI,ECDSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ExtractLeftBits,The following statement contains a magic number: int shift = (8 - bits % 8) % 8;
Magic Number,Granados.PKI,ECDSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\EC.cs,ExtractLeftBits,The following statement contains a magic number: for (int i = 0; i < bytes; ++i) {                  byte b = src[i];                  buff[i] = (byte)((byte)(prev << (8 - shift)) | (byte)(b >> shift));                  prev = b;              }
Magic Number,Granados.PKI,ECDSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\EC.cs,Sign,The following statement contains a magic number: using (var rng = new RNGCryptoServiceProvider()) {                    BigInteger.ModulusRing nring = new BigInteger.ModulusRing(order);                    for (int tries = 0; tries < 10; ++tries) {                      try {                          ECDSAKeyPair tempKeyPair = _curve.GenerateKeyPair(rng);                            BigInteger r = tempKeyPair.PublicKeyPoint.X % order;                          if (r == 0) {                              continue;                          }                            BigInteger k = tempKeyPair.PrivateKey;                          BigInteger s = nring.Multiply(k.ModInverse(order)' e + nring.Multiply(r' _privateKey));                          if (s == 0) {                              continue;                          }                            SSH2DataWriter writer = new SSH2DataWriter();                          writer.WriteBigInteger(r);                          writer.WriteBigInteger(s);                            return writer.ToByteArray();                      }                      catch (Exception ex) {                          Debug.WriteLine(ex);                      }                  }              }
Magic Number,Granados.PKI,ECDSAHashAlgorithmChooser,C:\repos\poderosaproject_poderosa\Granados\EC.cs,Choose,The following statement contains a magic number: if (orderBits <= 256) {                  return new SHA256CryptoServiceProvider();              }              else if (orderBits <= 384) {                  return new SHA384CryptoServiceProvider();              }              else {                  return new SHA512CryptoServiceProvider();              }
Magic Number,Granados.PKI,ECDSAHashAlgorithmChooser,C:\repos\poderosaproject_poderosa\Granados\EC.cs,Choose,The following statement contains a magic number: if (orderBits <= 256) {                  return new SHA256CryptoServiceProvider();              }              else if (orderBits <= 384) {                  return new SHA384CryptoServiceProvider();              }              else {                  return new SHA512CryptoServiceProvider();              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,IsValidKeyPair,The following statement contains a magic number: if (privateKey.Length != 32) {                  return false;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,IsValidKeyPair,The following statement contains a magic number: if (publicKey.Length != 32) {                  return false;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,IsValidKeyPair,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      return false;                  }                    if (publicKey.Length != A.Length) {                      return false;                  }                  for (int i = 0; i < A.Length; ++i) {                      if (publicKey[i] != A[i]) {                          return false;                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,IsValidKeyPair,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      return false;                  }                    if (publicKey.Length != A.Length) {                      return false;                  }                  for (int i = 0; i < A.Length; ++i) {                      if (publicKey[i] != A[i]) {                          return false;                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,IsValidKeyPair,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      return false;                  }                    if (publicKey.Length != A.Length) {                      return false;                  }                  for (int i = 0; i < A.Length; ++i) {                      if (publicKey[i] != A[i]) {                          return false;                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,IsValidKeyPair,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      return false;                  }                    if (publicKey.Length != A.Length) {                      return false;                  }                  for (int i = 0; i < A.Length; ++i) {                      if (publicKey[i] != A[i]) {                          return false;                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,IsValidKeyPair,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      return false;                  }                    if (publicKey.Length != A.Length) {                      return false;                  }                  for (int i = 0; i < A.Length; ++i) {                      if (publicKey[i] != A[i]) {                          return false;                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,IsValidKeyPair,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      return false;                  }                    if (publicKey.Length != A.Length) {                      return false;                  }                  for (int i = 0; i < A.Length; ++i) {                      if (publicKey[i] != A[i]) {                          return false;                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: if (privateKey.Length != 32) {                  signature = null;                  return false;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Sign,The following statement contains a magic number: using (var sha512 = new SHA512CryptoServiceProvider()) {                  byte[] hash;                  hash = sha512.ComputeHash(privateKey);                    byte[] sdata = new byte[32];                  Buffer.BlockCopy(hash' 0' sdata' 0' 32);                  sdata[0] &= (byte)((0xff << _c) & 0xff);  // clear lower bits                  sdata[31] &= (byte)((1 << (_n % 8)) - 1); // clear higher bits                  sdata[31] |= (byte)(1 << (_n % 8)); // set top bit                  Array.Reverse(sdata);   // to big endian                  var s = new BigInteger(sdata);                    var G = GetBasePoint();                  byte[] A;                  if (!EncodePoint(PointMul(s' G)' out A)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(hash' 32' 32' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] rdata = sha512.Hash;                  Array.Reverse(rdata);   // to big endian                  var r = new BigInteger(rdata) % this._l;                    byte[] R;                  if (!EncodePoint(PointMul(r' G)' out R)) {                      signature = null;                      return false;                  }                    sha512.Initialize();                  sha512.TransformBlock(R' 0' R.Length' null' 0);                  sha512.TransformBlock(A' 0' A.Length' null' 0);                  sha512.TransformFinalBlock(data' 0' data.Length);                  byte[] kdata = sha512.Hash;                  Array.Reverse(kdata);   // to big endian                  var k = new BigInteger(kdata) % this._l;                    var S = (r + k * s) % this._l;                    byte[] sig = new byte[64];                  Buffer.BlockCopy(R' 0' sig' 0' R.Length);   // copy 32 bytes                  byte[] wS = S.GetBytes();                  Array.Reverse(wS);  // to little endian                  Buffer.BlockCopy(wS' 0' sig' 32' wS.Length);                  signature = sig;                  return true;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Verify,The following statement contains a magic number: if (signature.Length != 64) {                  return false;              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Verify,The following statement contains a magic number: byte[] Rs = new byte[32];
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Verify,The following statement contains a magic number: Buffer.BlockCopy(signature' 0' Rs' 0' 32);
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Verify,The following statement contains a magic number: byte[] Ss = new byte[32];
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Verify,The following statement contains a magic number: Buffer.BlockCopy(signature' 32' Ss' 0' 32);
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Verify,The following statement contains a magic number: Buffer.BlockCopy(signature' 32' Ss' 0' 32);
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,EncodePoint,The following statement contains a magic number: const int DATALEN = 32;
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,DecodePoint,The following statement contains a magic number: const int DATALEN = 32;
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,DecodePoint,The following statement contains a magic number: int sign = w[DATALEN - 1] >> 7;
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,DecodePoint,The following statement contains a magic number: if (x2 == 0) {                  if (sign != 0) {                      point = null;                      return false;                  }                  else {                      x = 0;                  }              }              else {                  x = x2.ModPow((this._p + 3) >> 3' this._p);                  if ((x * x) % this._p != x2) {                      // square root of -1                      x = x * (new BigInteger(2)).ModPow((this._p - 1) >> 2' this._p) % this._p;                      if ((x * x) % this._p != x2) {                          point = null;                          return false;                      }                  }                  if ((x % 2u) != (uint)sign) {                     x = _p - x;                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,DecodePoint,The following statement contains a magic number: if (x2 == 0) {                  if (sign != 0) {                      point = null;                      return false;                  }                  else {                      x = 0;                  }              }              else {                  x = x2.ModPow((this._p + 3) >> 3' this._p);                  if ((x * x) % this._p != x2) {                      // square root of -1                      x = x * (new BigInteger(2)).ModPow((this._p - 1) >> 2' this._p) % this._p;                      if ((x * x) % this._p != x2) {                          point = null;                          return false;                      }                  }                  if ((x % 2u) != (uint)sign) {                     x = _p - x;                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,DecodePoint,The following statement contains a magic number: if (x2 == 0) {                  if (sign != 0) {                      point = null;                      return false;                  }                  else {                      x = 0;                  }              }              else {                  x = x2.ModPow((this._p + 3) >> 3' this._p);                  if ((x * x) % this._p != x2) {                      // square root of -1                      x = x * (new BigInteger(2)).ModPow((this._p - 1) >> 2' this._p) % this._p;                      if ((x * x) % this._p != x2) {                          point = null;                          return false;                      }                  }                  if ((x % 2u) != (uint)sign) {                     x = _p - x;                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,DecodePoint,The following statement contains a magic number: if (x2 == 0) {                  if (sign != 0) {                      point = null;                      return false;                  }                  else {                      x = 0;                  }              }              else {                  x = x2.ModPow((this._p + 3) >> 3' this._p);                  if ((x * x) % this._p != x2) {                      // square root of -1                      x = x * (new BigInteger(2)).ModPow((this._p - 1) >> 2' this._p) % this._p;                      if ((x * x) % this._p != x2) {                          point = null;                          return false;                      }                  }                  if ((x % 2u) != (uint)sign) {                     x = _p - x;                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,PointMul,The following statement contains a magic number: for (int i = 0; i < kBitCount; ++i) {                  if (i > 0) {                      mp = PointAdd(mp' mp);                  }                  if ((kBytes[kOffset - i / 8] & (byte)(1 << (i % 8))) != 0) {                      q = PointAdd(q' mp);                  }              }
Magic Number,Granados.PKI,CurveEd25519,C:\repos\poderosaproject_poderosa\Granados\ED.cs,PointMul,The following statement contains a magic number: for (int i = 0; i < kBitCount; ++i) {                  if (i > 0) {                      mp = PointAdd(mp' mp);                  }                  if ((kBytes[kOffset - i / 8] & (byte)(1 << (i % 8))) != 0) {                      q = PointAdd(q' mp);                  }              }
Magic Number,Granados.PKI,CurveEd25519Test,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"sign.input")) {                  int skip = 0;                  int count = 0;                  while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      count++;                      if (count <= skip) {                          continue;                      }                      System.Diagnostics.Debug.WriteLine("Line {0}"' count);                        string[] w = line.Split(':');                      byte[][] b = w.Select(s => BigIntegerConverter.ParseHex(s)).ToArray();                      byte[] privateKey = new byte[32];                      Buffer.BlockCopy(b[0]' 0' privateKey' 0' 32);                      byte[] publicKey = b[1];                      byte[] message = b[2];                      byte[] signature = new byte[64];                      Buffer.BlockCopy(b[3]' 0' signature' 0' 64);                        CurveEd25519 curve = new CurveEd25519();                        byte[] sig;                      if (!curve.Sign(privateKey' message' out sig)) {                          throw new Exception("signing failed");                      }                      if (sig.Length != signature.Length) {                          throw new Exception("invalid sign length");                      }                      for (int i = 0; i < signature.Length; ++i) {                          if (sig[i] != signature[i]) {                              throw new Exception("signs doesn't match");                          }                      }                      if (!curve.Verify(publicKey' signature' message)) {                          throw new Exception("verification failed");                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519Test,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"sign.input")) {                  int skip = 0;                  int count = 0;                  while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      count++;                      if (count <= skip) {                          continue;                      }                      System.Diagnostics.Debug.WriteLine("Line {0}"' count);                        string[] w = line.Split(':');                      byte[][] b = w.Select(s => BigIntegerConverter.ParseHex(s)).ToArray();                      byte[] privateKey = new byte[32];                      Buffer.BlockCopy(b[0]' 0' privateKey' 0' 32);                      byte[] publicKey = b[1];                      byte[] message = b[2];                      byte[] signature = new byte[64];                      Buffer.BlockCopy(b[3]' 0' signature' 0' 64);                        CurveEd25519 curve = new CurveEd25519();                        byte[] sig;                      if (!curve.Sign(privateKey' message' out sig)) {                          throw new Exception("signing failed");                      }                      if (sig.Length != signature.Length) {                          throw new Exception("invalid sign length");                      }                      for (int i = 0; i < signature.Length; ++i) {                          if (sig[i] != signature[i]) {                              throw new Exception("signs doesn't match");                          }                      }                      if (!curve.Verify(publicKey' signature' message)) {                          throw new Exception("verification failed");                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519Test,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"sign.input")) {                  int skip = 0;                  int count = 0;                  while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      count++;                      if (count <= skip) {                          continue;                      }                      System.Diagnostics.Debug.WriteLine("Line {0}"' count);                        string[] w = line.Split(':');                      byte[][] b = w.Select(s => BigIntegerConverter.ParseHex(s)).ToArray();                      byte[] privateKey = new byte[32];                      Buffer.BlockCopy(b[0]' 0' privateKey' 0' 32);                      byte[] publicKey = b[1];                      byte[] message = b[2];                      byte[] signature = new byte[64];                      Buffer.BlockCopy(b[3]' 0' signature' 0' 64);                        CurveEd25519 curve = new CurveEd25519();                        byte[] sig;                      if (!curve.Sign(privateKey' message' out sig)) {                          throw new Exception("signing failed");                      }                      if (sig.Length != signature.Length) {                          throw new Exception("invalid sign length");                      }                      for (int i = 0; i < signature.Length; ++i) {                          if (sig[i] != signature[i]) {                              throw new Exception("signs doesn't match");                          }                      }                      if (!curve.Verify(publicKey' signature' message)) {                          throw new Exception("verification failed");                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519Test,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"sign.input")) {                  int skip = 0;                  int count = 0;                  while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      count++;                      if (count <= skip) {                          continue;                      }                      System.Diagnostics.Debug.WriteLine("Line {0}"' count);                        string[] w = line.Split(':');                      byte[][] b = w.Select(s => BigIntegerConverter.ParseHex(s)).ToArray();                      byte[] privateKey = new byte[32];                      Buffer.BlockCopy(b[0]' 0' privateKey' 0' 32);                      byte[] publicKey = b[1];                      byte[] message = b[2];                      byte[] signature = new byte[64];                      Buffer.BlockCopy(b[3]' 0' signature' 0' 64);                        CurveEd25519 curve = new CurveEd25519();                        byte[] sig;                      if (!curve.Sign(privateKey' message' out sig)) {                          throw new Exception("signing failed");                      }                      if (sig.Length != signature.Length) {                          throw new Exception("invalid sign length");                      }                      for (int i = 0; i < signature.Length; ++i) {                          if (sig[i] != signature[i]) {                              throw new Exception("signs doesn't match");                          }                      }                      if (!curve.Verify(publicKey' signature' message)) {                          throw new Exception("verification failed");                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519Test,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"sign.input")) {                  int skip = 0;                  int count = 0;                  while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      count++;                      if (count <= skip) {                          continue;                      }                      System.Diagnostics.Debug.WriteLine("Line {0}"' count);                        string[] w = line.Split(':');                      byte[][] b = w.Select(s => BigIntegerConverter.ParseHex(s)).ToArray();                      byte[] privateKey = new byte[32];                      Buffer.BlockCopy(b[0]' 0' privateKey' 0' 32);                      byte[] publicKey = b[1];                      byte[] message = b[2];                      byte[] signature = new byte[64];                      Buffer.BlockCopy(b[3]' 0' signature' 0' 64);                        CurveEd25519 curve = new CurveEd25519();                        byte[] sig;                      if (!curve.Sign(privateKey' message' out sig)) {                          throw new Exception("signing failed");                      }                      if (sig.Length != signature.Length) {                          throw new Exception("invalid sign length");                      }                      for (int i = 0; i < signature.Length; ++i) {                          if (sig[i] != signature[i]) {                              throw new Exception("signs doesn't match");                          }                      }                      if (!curve.Verify(publicKey' signature' message)) {                          throw new Exception("verification failed");                      }                  }              }
Magic Number,Granados.PKI,CurveEd25519Test,C:\repos\poderosaproject_poderosa\Granados\ED.cs,Test,The following statement contains a magic number: using (var reader = new System.IO.StreamReader(@"sign.input")) {                  int skip = 0;                  int count = 0;                  while (true) {                      string line = reader.ReadLine();                      if (line == null) {                          break;                      }                      count++;                      if (count <= skip) {                          continue;                      }                      System.Diagnostics.Debug.WriteLine("Line {0}"' count);                        string[] w = line.Split(':');                      byte[][] b = w.Select(s => BigIntegerConverter.ParseHex(s)).ToArray();                      byte[] privateKey = new byte[32];                      Buffer.BlockCopy(b[0]' 0' privateKey' 0' 32);                      byte[] publicKey = b[1];                      byte[] message = b[2];                      byte[] signature = new byte[64];                      Buffer.BlockCopy(b[3]' 0' signature' 0' 64);                        CurveEd25519 curve = new CurveEd25519();                        byte[] sig;                      if (!curve.Sign(privateKey' message' out sig)) {                          throw new Exception("signing failed");                      }                      if (sig.Length != signature.Length) {                          throw new Exception("invalid sign length");                      }                      for (int i = 0; i < signature.Length; ++i) {                          if (sig[i] != signature[i]) {                              throw new Exception("signs doesn't match");                          }                      }                      if (!curve.Verify(publicKey' signature' message)) {                          throw new Exception("verification failed");                      }                  }              }
Magic Number,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,Sign,The following statement contains a magic number: byte[] result = new byte[data.Length * 2];
Magic Number,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,Sign,The following statement contains a magic number: Array.Copy(bs' 0' result' data.Length * 2 - bs.Length' bs.Length);
Magic Number,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,GenerateNew,The following statement contains a magic number: BigInteger[] pq = findRandomStrongPrime(bits' 160' random);
Magic Number,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,findRandomStrongPrime,The following statement contains a magic number: PrimeSieve sieve = new PrimeSieve(16000);
Magic Number,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,findRandomStrongPrime,The following statement contains a magic number: for (uint pN = 2; pN != 0; pN = sieve.getNextPrime(pN)' i++) {                  prime_table[i] = pN;              }
Magic Number,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,findRandomStrongPrime,The following statement contains a magic number: while (true) {                  BigInteger u = BigInteger.GenerateRandom(primeBits);                  BigInteger aux = order << 1;                  BigInteger aux2 = u % aux;                  u = u - aux2;                  u = u + one;                    if (u.BitCount() <= (primeBits - 1))                      continue;                    for (j = 0; j < table_count; j++) {                      table_u[j] =                          AsUInt64(u % new BigInteger(prime_table[j]));                  }                    aux2 = order << 1;                    for (i = 0; i < (1 << 24); i++) {                      ulong cur_p;                      ulong value;                        flag = true;                      for (j = 1; j < table_count; j++) {                          cur_p = prime_table[j];                          value = table_u[j];                          if (value >= cur_p)                              value -= cur_p;                          if (value == 0)                              flag = false;                          table_u[j] = value + table_q[j];                      }                      if (!flag)                          continue;                        aux = aux2 * new BigInteger(i);                      prime = u + aux;                        if (prime.BitCount() > primeBits)                          continue;                        if (prime.IsProbablePrime())                          break;                  }                    if (i < (1 << 24))                      break;              }
Magic Number,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,findRandomStrongPrime,The following statement contains a magic number: while (true) {                  BigInteger u = BigInteger.GenerateRandom(primeBits);                  BigInteger aux = order << 1;                  BigInteger aux2 = u % aux;                  u = u - aux2;                  u = u + one;                    if (u.BitCount() <= (primeBits - 1))                      continue;                    for (j = 0; j < table_count; j++) {                      table_u[j] =                          AsUInt64(u % new BigInteger(prime_table[j]));                  }                    aux2 = order << 1;                    for (i = 0; i < (1 << 24); i++) {                      ulong cur_p;                      ulong value;                        flag = true;                      for (j = 1; j < table_count; j++) {                          cur_p = prime_table[j];                          value = table_u[j];                          if (value >= cur_p)                              value -= cur_p;                          if (value == 0)                              flag = false;                          table_u[j] = value + table_q[j];                      }                      if (!flag)                          continue;                        aux = aux2 * new BigInteger(i);                      prime = u + aux;                        if (prime.BitCount() > primeBits)                          continue;                        if (prime.IsProbablePrime())                          break;                  }                    if (i < (1 << 24))                      break;              }
Magic Number,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,AsUInt64,The following statement contains a magic number: if (bits >= 64)                  throw new ArgumentException("too large BigInteger value");
Magic Number,Granados.PKI,DSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,AsUInt64,The following statement contains a magic number: foreach (byte b in data) {                  val = (val << 8) | b;              }
Magic Number,Granados.PKI,DSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,Verify,The following statement contains a magic number: byte[] first = new byte[data.Length / 2];
Magic Number,Granados.PKI,DSAPublicKey,C:\repos\poderosaproject_poderosa\Granados\DSA.cs,Verify,The following statement contains a magic number: byte[] second = new byte[data.Length / 2];
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: if (x < 4)                  x = 4;
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: if (x < 4)                  x = 4;
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: int len = (x - 3) / (32 * 2);
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: int len = (x - 3) / (32 * 2);
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: int len = (x - 3) / (32 * 2);
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: int max = len * 32;
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: for (int i = 0; i < stop; i++) {                  if ((table[i / 32] & (1 << (i & (32 - 1)))) == 0) {                      int k = 3 + i * 2;                      for (int j = i + k; j < max; j += k) {                          table[j / 32] |= ((uint)1 << (j & (32 - 1)));                      }                  }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: for (int i = 0; i < stop; i++) {                  if ((table[i / 32] & (1 << (i & (32 - 1)))) == 0) {                      int k = 3 + i * 2;                      for (int j = i + k; j < max; j += k) {                          table[j / 32] |= ((uint)1 << (j & (32 - 1)));                      }                  }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: for (int i = 0; i < stop; i++) {                  if ((table[i / 32] & (1 << (i & (32 - 1)))) == 0) {                      int k = 3 + i * 2;                      for (int j = i + k; j < max; j += k) {                          table[j / 32] |= ((uint)1 << (j & (32 - 1)));                      }                  }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: for (int i = 0; i < stop; i++) {                  if ((table[i / 32] & (1 << (i & (32 - 1)))) == 0) {                      int k = 3 + i * 2;                      for (int j = i + k; j < max; j += k) {                          table[j / 32] |= ((uint)1 << (j & (32 - 1)));                      }                  }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: for (int i = 0; i < stop; i++) {                  if ((table[i / 32] & (1 << (i & (32 - 1)))) == 0) {                      int k = 3 + i * 2;                      for (int j = i + k; j < max; j += k) {                          table[j / 32] |= ((uint)1 << (j & (32 - 1)));                      }                  }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,PrimeSieve,The following statement contains a magic number: for (int i = 0; i < stop; i++) {                  if ((table[i / 32] & (1 << (i & (32 - 1)))) == 0) {                      int k = 3 + i * 2;                      for (int j = i + k; j < max; j += k) {                          table[j / 32] |= ((uint)1 << (j & (32 - 1)));                      }                  }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,AvailablePrimes,The following statement contains a magic number: for (i = 0' primes = 2; i < table.Length; i++) {                  w = table[i];                  for (bits = 0; w != 0; w >>= 8)                      bits += (uint)bitCounts[w & 0xff];                  primes += (32 - bits);              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,AvailablePrimes,The following statement contains a magic number: for (i = 0' primes = 2; i < table.Length; i++) {                  w = table[i];                  for (bits = 0; w != 0; w >>= 8)                      bits += (uint)bitCounts[w & 0xff];                  primes += (32 - bits);              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,AvailablePrimes,The following statement contains a magic number: for (i = 0' primes = 2; i < table.Length; i++) {                  w = table[i];                  for (bits = 0; w != 0; w >>= 8)                      bits += (uint)bitCounts[w & 0xff];                  primes += (32 - bits);              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,PrimeSieve,C:\repos\poderosaproject_poderosa\Granados\PrimeSieve.cs,getNextPrime,The following statement contains a magic number: switch (x) {                  /* Trivial cases. */                  case 0:                      return 2;                  case 1:                      return 2;                  case 2:                      return 3;                  /* Cases above 2 are handled with the table. */                  default:                      uint p = ((x - 3) / 2) + 1;                      while (true) {                          if ((p / 32) >= table.Length)                              return 0;                            if ((table[p / 32] & (1u << (int)(p & (32 - 1)))) == 0)                              return p * 2 + 3;                          p++;                      }              }
Magic Number,Granados.PKI,RSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,SignWithSHA1,The following statement contains a magic number: int padLen = (_publickey._n.BitCount() + 7) / 8;
Magic Number,Granados.PKI,RSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,SignWithSHA1,The following statement contains a magic number: int padLen = (_publickey._n.BitCount() + 7) / 8;
Magic Number,Granados.PKI,RSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,GenerateNew,The following statement contains a magic number: while (!finished) {                  p = BigInteger.GeneratePseudoPrime(bits / 2);                  q = BigInteger.GeneratePseudoPrime(bits - (bits / 2));                    if (p == 0) {                      continue;                  }                  else if (q < p) {                      t = q;                      q = p;                      p = t;                  }                    t = p.GCD(q);                  if (t != one) {                      continue;                  }                    p_1 = p - one;                  q_1 = q - one;                  phi = p_1 * q_1;                  G = p_1.GCD(q_1);                  F = phi / G;                    e = one << 5;                  e = e - one;                  do {                      e = e + (one + one);                      t = e.GCD(phi);                  } while (t != one);                    // !!! d = e.modInverse(F);                  d = e.ModInverse(phi);                  n = p * q;                  u = p.ModInverse(q);                    finished = true;              }
Magic Number,Granados.PKI,RSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,GenerateNew,The following statement contains a magic number: while (!finished) {                  p = BigInteger.GeneratePseudoPrime(bits / 2);                  q = BigInteger.GeneratePseudoPrime(bits - (bits / 2));                    if (p == 0) {                      continue;                  }                  else if (q < p) {                      t = q;                      q = p;                      p = t;                  }                    t = p.GCD(q);                  if (t != one) {                      continue;                  }                    p_1 = p - one;                  q_1 = q - one;                  phi = p_1 * q_1;                  G = p_1.GCD(q_1);                  F = phi / G;                    e = one << 5;                  e = e - one;                  do {                      e = e + (one + one);                      t = e.GCD(phi);                  } while (t != one);                    // !!! d = e.modInverse(F);                  d = e.ModInverse(phi);                  n = p * q;                  u = p.ModInverse(q);                    finished = true;              }
Magic Number,Granados.PKI,RSAKeyPair,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,GenerateNew,The following statement contains a magic number: while (!finished) {                  p = BigInteger.GeneratePseudoPrime(bits / 2);                  q = BigInteger.GeneratePseudoPrime(bits - (bits / 2));                    if (p == 0) {                      continue;                  }                  else if (q < p) {                      t = q;                      q = p;                      p = t;                  }                    t = p.GCD(q);                  if (t != one) {                      continue;                  }                    p_1 = p - one;                  q_1 = q - one;                  phi = p_1 * q_1;                  G = p_1.GCD(q_1);                  F = phi / G;                    e = one << 5;                  e = e - one;                  do {                      e = e + (one + one);                      t = e.GCD(phi);                  } while (t != one);                    // !!! d = e.modInverse(F);                  d = e.ModInverse(phi);                  n = p * q;                  u = p.ModInverse(q);                    finished = true;              }
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType2,The following statement contains a magic number: int padLen = len - input.Length - 3;
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType2,The following statement contains a magic number: if (padLen < 8) {                  throw new ArgumentException("message too long");              }
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType2,The following statement contains a magic number: for (int i = 0; i < pad.Length; i++) {                  if (pad[i] == 0) {                      pad[i] = (byte)(1 + rng.GetInt(255));                  }              }
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType2,The following statement contains a magic number: buf[1] = 2;
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType2,The following statement contains a magic number: Buffer.BlockCopy(pad' 0' buf' 2' pad.Length);
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType2,The following statement contains a magic number: Buffer.BlockCopy(input' 0' buf' padLen + 3' input.Length);
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType1,The following statement contains a magic number: int padLen = len - input.Length - 3;
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType1,The following statement contains a magic number: if (padLen < 8) {                  throw new ArgumentException("message too long");              }
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType1,The following statement contains a magic number: for (int i = 0; i < padLen; i++) {                  buf[i + 2] = 0xff;              }
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,PKCS1PadType1,The following statement contains a magic number: Buffer.BlockCopy(input' 0' buf' padLen + 3' input.Length);
Magic Number,Granados.PKI,RSAUtil,C:\repos\poderosaproject_poderosa\Granados\RSA.cs,StripPKCS1Pad,The following statement contains a magic number: if (padLen < 8) {                  throw new ArgumentException("Invalid PKCS1 padding");              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt16,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 8);                  workbuf[1] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt16,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 8);                  workbuf[1] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt16,The following statement contains a magic number: _buffer.Append(workbuf' 0' 2);
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: if (_bigEndian) {                  workbuf[0] = (byte)(v >> 24);                  workbuf[1] = (byte)(v >> 16);                  workbuf[2] = (byte)(v >> 8);                  workbuf[3] = (byte)v;              }              else {                  workbuf[0] = (byte)v;                  workbuf[1] = (byte)(v >> 8);                  workbuf[2] = (byte)(v >> 16);                  workbuf[3] = (byte)(v >> 24);              }
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendUInt32,The following statement contains a magic number: _buffer.Append(workbuf' 0' 4);
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendPaddingBytesOf,The following statement contains a magic number: int pad = (4 - (s.Length % 4)) % 4;
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendPaddingBytesOf,The following statement contains a magic number: int pad = (4 - (s.Length % 4)) % 4;
Magic Number,Granados.X11,XProtocolMessage,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,AppendPaddingBytesOf,The following statement contains a magic number: int pad = (4 - (s.Length % 4)) % 4;
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt16,The following statement contains a magic number: if (_bigEndian) {                  return (ushort)((v1 << 8) | v2);              }              else {                  return (ushort)((v2 << 8) | v1);              }
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt16,The following statement contains a magic number: if (_bigEndian) {                  return (ushort)((v1 << 8) | v2);              }              else {                  return (ushort)((v2 << 8) | v1);              }
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt32,The following statement contains a magic number: byte v3 = buff[offset + 2];
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt32,The following statement contains a magic number: byte v4 = buff[offset + 3];
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian) {                  return ((uint)v1 << 24)                       | ((uint)v2 << 16)                       | ((uint)v3 << 8)                       | ((uint)v4);              }              else {                  return ((uint)v1)                       | ((uint)v2 << 8)                       | ((uint)v3 << 16)                       | ((uint)v4 << 24);              }
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian) {                  return ((uint)v1 << 24)                       | ((uint)v2 << 16)                       | ((uint)v3 << 8)                       | ((uint)v4);              }              else {                  return ((uint)v1)                       | ((uint)v2 << 8)                       | ((uint)v3 << 16)                       | ((uint)v4 << 24);              }
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian) {                  return ((uint)v1 << 24)                       | ((uint)v2 << 16)                       | ((uint)v3 << 8)                       | ((uint)v4);              }              else {                  return ((uint)v1)                       | ((uint)v2 << 8)                       | ((uint)v3 << 16)                       | ((uint)v4 << 24);              }
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian) {                  return ((uint)v1 << 24)                       | ((uint)v2 << 16)                       | ((uint)v3 << 8)                       | ((uint)v4);              }              else {                  return ((uint)v1)                       | ((uint)v2 << 8)                       | ((uint)v3 << 16)                       | ((uint)v4 << 24);              }
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian) {                  return ((uint)v1 << 24)                       | ((uint)v2 << 16)                       | ((uint)v3 << 8)                       | ((uint)v4);              }              else {                  return ((uint)v1)                       | ((uint)v2 << 8)                       | ((uint)v3 << 16)                       | ((uint)v4 << 24);              }
Magic Number,Granados.X11,XDataReader,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt32,The following statement contains a magic number: if (_bigEndian) {                  return ((uint)v1 << 24)                       | ((uint)v2 << 16)                       | ((uint)v3 << 8)                       | ((uint)v4);              }              else {                  return ((uint)v1)                       | ((uint)v2 << 8)                       | ((uint)v3 << 16)                       | ((uint)v4 << 24);              }
Magic Number,Granados.X11,XauthorityParser,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,FindBest,The following statement contains a magic number: const ushort FamilyWild = 65535;
Magic Number,Granados.X11,XauthorityParser,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadEntries,The following statement contains a magic number: try {                  var entries = new List<XauthorityEntry>();                    using (var fs = new FileStream(xauthFile' FileMode.Open' FileAccess.Read)) {                      while (true) {                          ushort family;                          if (!ReadUInt16BE(fs' out family)) {                              break;                          }                            string address;                          if (!ReadString(fs' 256' out address)) {                              break;                          }                            int number;                          if (!ReadNumber(fs' 5' out number)) {                              break;                          }                            string name;                          if (!ReadString(fs' 40' out name)) {                              break;                          }                            byte[] data;                          if (!ReadBytes(fs' 1024' out data)) {                              break;                          }                            entries.Add(new XauthorityEntry(family' address' number' name' data));                      }                  }                    return entries.ToArray();              }              catch (X11UtilException) {                  throw;              }              catch (Exception e) {                  throw new X11UtilException(Strings.GetString("ReadingXauthorityFileFailed")' e);              }
Magic Number,Granados.X11,XauthorityParser,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadEntries,The following statement contains a magic number: try {                  var entries = new List<XauthorityEntry>();                    using (var fs = new FileStream(xauthFile' FileMode.Open' FileAccess.Read)) {                      while (true) {                          ushort family;                          if (!ReadUInt16BE(fs' out family)) {                              break;                          }                            string address;                          if (!ReadString(fs' 256' out address)) {                              break;                          }                            int number;                          if (!ReadNumber(fs' 5' out number)) {                              break;                          }                            string name;                          if (!ReadString(fs' 40' out name)) {                              break;                          }                            byte[] data;                          if (!ReadBytes(fs' 1024' out data)) {                              break;                          }                            entries.Add(new XauthorityEntry(family' address' number' name' data));                      }                  }                    return entries.ToArray();              }              catch (X11UtilException) {                  throw;              }              catch (Exception e) {                  throw new X11UtilException(Strings.GetString("ReadingXauthorityFileFailed")' e);              }
Magic Number,Granados.X11,XauthorityParser,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadEntries,The following statement contains a magic number: try {                  var entries = new List<XauthorityEntry>();                    using (var fs = new FileStream(xauthFile' FileMode.Open' FileAccess.Read)) {                      while (true) {                          ushort family;                          if (!ReadUInt16BE(fs' out family)) {                              break;                          }                            string address;                          if (!ReadString(fs' 256' out address)) {                              break;                          }                            int number;                          if (!ReadNumber(fs' 5' out number)) {                              break;                          }                            string name;                          if (!ReadString(fs' 40' out name)) {                              break;                          }                            byte[] data;                          if (!ReadBytes(fs' 1024' out data)) {                              break;                          }                            entries.Add(new XauthorityEntry(family' address' number' name' data));                      }                  }                    return entries.ToArray();              }              catch (X11UtilException) {                  throw;              }              catch (Exception e) {                  throw new X11UtilException(Strings.GetString("ReadingXauthorityFileFailed")' e);              }
Magic Number,Granados.X11,XauthorityParser,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadEntries,The following statement contains a magic number: try {                  var entries = new List<XauthorityEntry>();                    using (var fs = new FileStream(xauthFile' FileMode.Open' FileAccess.Read)) {                      while (true) {                          ushort family;                          if (!ReadUInt16BE(fs' out family)) {                              break;                          }                            string address;                          if (!ReadString(fs' 256' out address)) {                              break;                          }                            int number;                          if (!ReadNumber(fs' 5' out number)) {                              break;                          }                            string name;                          if (!ReadString(fs' 40' out name)) {                              break;                          }                            byte[] data;                          if (!ReadBytes(fs' 1024' out data)) {                              break;                          }                            entries.Add(new XauthorityEntry(family' address' number' name' data));                      }                  }                    return entries.ToArray();              }              catch (X11UtilException) {                  throw;              }              catch (Exception e) {                  throw new X11UtilException(Strings.GetString("ReadingXauthorityFileFailed")' e);              }
Magic Number,Granados.X11,XauthorityParser,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt16BE,The following statement contains a magic number: int len = fs.Read(_workbuf' 0' 2);
Magic Number,Granados.X11,XauthorityParser,C:\repos\poderosaproject_poderosa\Granados\X11Utils.cs,ReadUInt16BE,The following statement contains a magic number: if (len != 2) {                  val = 0;                  return false;              }
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,ParseDomainSocketFile,The following statement contains a magic number: try {                  int port = Int32.Parse(match.Groups[1].Value' NumberFormatInfo.InvariantInfo);                  uint[] guid = {                      UInt32.Parse(match.Groups[2].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[3].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[4].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[5].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)                  };                    return Tuple.Create(port' guid);              }              catch (Exception e) {                  throw new X11SocketException(Strings.GetString("FailedToReadDomainSocketFile")' e);              }
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,ParseDomainSocketFile,The following statement contains a magic number: try {                  int port = Int32.Parse(match.Groups[1].Value' NumberFormatInfo.InvariantInfo);                  uint[] guid = {                      UInt32.Parse(match.Groups[2].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[3].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[4].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[5].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)                  };                    return Tuple.Create(port' guid);              }              catch (Exception e) {                  throw new X11SocketException(Strings.GetString("FailedToReadDomainSocketFile")' e);              }
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,ParseDomainSocketFile,The following statement contains a magic number: try {                  int port = Int32.Parse(match.Groups[1].Value' NumberFormatInfo.InvariantInfo);                  uint[] guid = {                      UInt32.Parse(match.Groups[2].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[3].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[4].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[5].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)                  };                    return Tuple.Create(port' guid);              }              catch (Exception e) {                  throw new X11SocketException(Strings.GetString("FailedToReadDomainSocketFile")' e);              }
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,ParseDomainSocketFile,The following statement contains a magic number: try {                  int port = Int32.Parse(match.Groups[1].Value' NumberFormatInfo.InvariantInfo);                  uint[] guid = {                      UInt32.Parse(match.Groups[2].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[3].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[4].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)'                      UInt32.Parse(match.Groups[5].Value' NumberStyles.AllowHexSpecifier' NumberFormatInfo.InvariantInfo)                  };                    return Tuple.Create(port' guid);              }              catch (Exception e) {                  throw new X11SocketException(Strings.GetString("FailedToReadDomainSocketFile")' e);              }
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: byte[] secret = new byte[16];
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: putUInt32LE(secret' 4' guid[1]);
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: putUInt32LE(secret' 8' guid[2]);
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: putUInt32LE(secret' 8' guid[2]);
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: putUInt32LE(secret' 12' guid[3]);
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: putUInt32LE(secret' 12' guid[3]);
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: byte[] secretRsp = new byte[16];
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: byte[] credentials = new byte[12];
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: putUInt32LE(credentials' 4' uid);
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: putUInt32LE(credentials' 8' gid);
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,Negotiate,The following statement contains a magic number: byte[] credentialsRsp = new byte[12];
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,putUInt32LE,The following statement contains a magic number: value >>= 8;
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,putUInt32LE,The following statement contains a magic number: value >>= 8;
Magic Number,Granados.X11,X11CygwinDomainSocket,C:\repos\poderosaproject_poderosa\Granados\X11Socket.cs,putUInt32LE,The following statement contains a magic number: value >>= 8;
Magic Number,Granados.X11,X11ConnectionManager,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,GetUntrustedAccessCookie,The following statement contains a magic number: using (IX11Socket socket = socketFactory()) {                  socket.Connect(display);                    const bool BIGENDIAN = true;                    byte[] recv = new byte[100];                  var xmsg = new XProtocolMessage(BIGENDIAN);                  var reader = new XDataReader(BIGENDIAN);                    // Note: if USE_UNTRUSTED_ACCESS was disabled' this method only checks the connectability to the X server.                    // initiation                  {                      byte[] authName = Encoding.ASCII.GetBytes(entry.Name);                      xmsg.Clear()                          .AppendByte(0x42)   // MSB first                          .AppendByte(0)  // unused                          .AppendUInt16(11)   // protocol-major-version                          .AppendUInt16(0)    // protocol-minor-version                          .AppendUInt16((ushort)authName.Length) // length of authorization-protocol-name                          .AppendUInt16((ushort)entry.Data.Length)    // length of authorization-protocol-data                          .AppendUInt16(0)    // unused                          .AppendBytes(authName)  // authorization-protocol-name                          .AppendPaddingBytesOf(authName)                          .AppendBytes(entry.Data)    // authorization-protocol-data                          .AppendPaddingBytesOf(entry.Data);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 8' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Success*/) {                          throw new X11UtilException(Strings.GetString("X11AuthorizationFailed"));                      }                      int extraDataLen = reader.ReadUInt16(recv' 6) * 4;                      byte[] extraData = new byte[extraDataLen];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLen' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }    #if USE_UNTRUSTED_ACCESS                    // QueryExtension                  {                      byte[] extName = Encoding.ASCII.GetBytes("SECURITY");                      xmsg.Clear()                          .AppendByte(98)   // opcode                          .AppendByte(0)  // unused                          .AppendUInt16((ushort)(2 + (extName.Length + 3) / 4))   // request-length                          .AppendUInt16((ushort)extName.Length)    // length of name                          .AppendUInt16(0)    // unused                          .AppendBytes(extName)  // name                          .AppendPaddingBytesOf(extName);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                      if (recv[0] != 1 /*Reply*/ || recv[8] != 1 /*present*/) {                          // no SECURITY extension                          _protocolEventManager.Trace("[X11] X server doesn't have the SECURITY extension.");                          return null;                      }                  }                  byte secOpcode = recv[9];   // major-opcode of the SECURITY extension                    // SecurityQueryVersion                  {                      xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(0)  // minor-opcode                          .AppendUInt16(2)   // request-length                          .AppendUInt16(1)    // client-major-version                          .AppendUInt16(0);   // client-minor-version                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }                    // SecurityGenerateAuthorization                  {                      byte[] authName = Encoding.ASCII.GetBytes(DEFAULT_AUTH_NAME);                      byte[] authData = new byte[0];                        uint[] valueList = new uint[] {                          // timeout                          0'  // no timeout                          // trust-level                          1'  // SecurityClientUntrusted                      };                        xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(1)  // minor-opcode                          .AppendUInt16((ushort)(3 + (authName.Length + 3) / 4 + (authData.Length + 3) / 4 + valueList.Length))                          .AppendUInt16((ushort)authName.Length)                          .AppendUInt16((ushort)authData.Length)                          .AppendUInt32(3)    // value-mask : timeout + trust-level                          .AppendBytes(authName)                          .AppendPaddingBytesOf(authName)                          .AppendBytes(authData)                          .AppendPaddingBytesOf(authData)                          .AppendUInt32(valueList[0])                          .AppendUInt32(valueList[1]);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Reply*/) {                          return null;                      }                        uint authId = reader.ReadUInt32(recv' 8);                        int extraDataLength = (int)reader.ReadUInt32(recv' 4) * 4;                      if (extraDataLength < 0 || extraDataLength > 1024) {                          // something wrong...                          return null;                      }                      int datLength = (int)reader.ReadUInt16(recv' 12);                      if (datLength < 0 || datLength > extraDataLength) {                          // something wrong...                          return null;                      }                      byte[] extraData = new byte[extraDataLength];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLength' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        byte[] generatedAuthData = reader.ReadBytes(extraData' 0' datLength);                        return Tuple.Create(authId' generatedAuthData);                  }    #else   // USE_UNTRUSTED_ACCESS                    // no untrusted access                  return null;    #endif  // USE_UNTRUSTED_ACCESS              }
Magic Number,Granados.X11,X11ConnectionManager,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,GetUntrustedAccessCookie,The following statement contains a magic number: using (IX11Socket socket = socketFactory()) {                  socket.Connect(display);                    const bool BIGENDIAN = true;                    byte[] recv = new byte[100];                  var xmsg = new XProtocolMessage(BIGENDIAN);                  var reader = new XDataReader(BIGENDIAN);                    // Note: if USE_UNTRUSTED_ACCESS was disabled' this method only checks the connectability to the X server.                    // initiation                  {                      byte[] authName = Encoding.ASCII.GetBytes(entry.Name);                      xmsg.Clear()                          .AppendByte(0x42)   // MSB first                          .AppendByte(0)  // unused                          .AppendUInt16(11)   // protocol-major-version                          .AppendUInt16(0)    // protocol-minor-version                          .AppendUInt16((ushort)authName.Length) // length of authorization-protocol-name                          .AppendUInt16((ushort)entry.Data.Length)    // length of authorization-protocol-data                          .AppendUInt16(0)    // unused                          .AppendBytes(authName)  // authorization-protocol-name                          .AppendPaddingBytesOf(authName)                          .AppendBytes(entry.Data)    // authorization-protocol-data                          .AppendPaddingBytesOf(entry.Data);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 8' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Success*/) {                          throw new X11UtilException(Strings.GetString("X11AuthorizationFailed"));                      }                      int extraDataLen = reader.ReadUInt16(recv' 6) * 4;                      byte[] extraData = new byte[extraDataLen];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLen' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }    #if USE_UNTRUSTED_ACCESS                    // QueryExtension                  {                      byte[] extName = Encoding.ASCII.GetBytes("SECURITY");                      xmsg.Clear()                          .AppendByte(98)   // opcode                          .AppendByte(0)  // unused                          .AppendUInt16((ushort)(2 + (extName.Length + 3) / 4))   // request-length                          .AppendUInt16((ushort)extName.Length)    // length of name                          .AppendUInt16(0)    // unused                          .AppendBytes(extName)  // name                          .AppendPaddingBytesOf(extName);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                      if (recv[0] != 1 /*Reply*/ || recv[8] != 1 /*present*/) {                          // no SECURITY extension                          _protocolEventManager.Trace("[X11] X server doesn't have the SECURITY extension.");                          return null;                      }                  }                  byte secOpcode = recv[9];   // major-opcode of the SECURITY extension                    // SecurityQueryVersion                  {                      xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(0)  // minor-opcode                          .AppendUInt16(2)   // request-length                          .AppendUInt16(1)    // client-major-version                          .AppendUInt16(0);   // client-minor-version                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }                    // SecurityGenerateAuthorization                  {                      byte[] authName = Encoding.ASCII.GetBytes(DEFAULT_AUTH_NAME);                      byte[] authData = new byte[0];                        uint[] valueList = new uint[] {                          // timeout                          0'  // no timeout                          // trust-level                          1'  // SecurityClientUntrusted                      };                        xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(1)  // minor-opcode                          .AppendUInt16((ushort)(3 + (authName.Length + 3) / 4 + (authData.Length + 3) / 4 + valueList.Length))                          .AppendUInt16((ushort)authName.Length)                          .AppendUInt16((ushort)authData.Length)                          .AppendUInt32(3)    // value-mask : timeout + trust-level                          .AppendBytes(authName)                          .AppendPaddingBytesOf(authName)                          .AppendBytes(authData)                          .AppendPaddingBytesOf(authData)                          .AppendUInt32(valueList[0])                          .AppendUInt32(valueList[1]);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Reply*/) {                          return null;                      }                        uint authId = reader.ReadUInt32(recv' 8);                        int extraDataLength = (int)reader.ReadUInt32(recv' 4) * 4;                      if (extraDataLength < 0 || extraDataLength > 1024) {                          // something wrong...                          return null;                      }                      int datLength = (int)reader.ReadUInt16(recv' 12);                      if (datLength < 0 || datLength > extraDataLength) {                          // something wrong...                          return null;                      }                      byte[] extraData = new byte[extraDataLength];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLength' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        byte[] generatedAuthData = reader.ReadBytes(extraData' 0' datLength);                        return Tuple.Create(authId' generatedAuthData);                  }    #else   // USE_UNTRUSTED_ACCESS                    // no untrusted access                  return null;    #endif  // USE_UNTRUSTED_ACCESS              }
Magic Number,Granados.X11,X11ConnectionManager,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,GetUntrustedAccessCookie,The following statement contains a magic number: using (IX11Socket socket = socketFactory()) {                  socket.Connect(display);                    const bool BIGENDIAN = true;                    byte[] recv = new byte[100];                  var xmsg = new XProtocolMessage(BIGENDIAN);                  var reader = new XDataReader(BIGENDIAN);                    // Note: if USE_UNTRUSTED_ACCESS was disabled' this method only checks the connectability to the X server.                    // initiation                  {                      byte[] authName = Encoding.ASCII.GetBytes(entry.Name);                      xmsg.Clear()                          .AppendByte(0x42)   // MSB first                          .AppendByte(0)  // unused                          .AppendUInt16(11)   // protocol-major-version                          .AppendUInt16(0)    // protocol-minor-version                          .AppendUInt16((ushort)authName.Length) // length of authorization-protocol-name                          .AppendUInt16((ushort)entry.Data.Length)    // length of authorization-protocol-data                          .AppendUInt16(0)    // unused                          .AppendBytes(authName)  // authorization-protocol-name                          .AppendPaddingBytesOf(authName)                          .AppendBytes(entry.Data)    // authorization-protocol-data                          .AppendPaddingBytesOf(entry.Data);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 8' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Success*/) {                          throw new X11UtilException(Strings.GetString("X11AuthorizationFailed"));                      }                      int extraDataLen = reader.ReadUInt16(recv' 6) * 4;                      byte[] extraData = new byte[extraDataLen];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLen' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }    #if USE_UNTRUSTED_ACCESS                    // QueryExtension                  {                      byte[] extName = Encoding.ASCII.GetBytes("SECURITY");                      xmsg.Clear()                          .AppendByte(98)   // opcode                          .AppendByte(0)  // unused                          .AppendUInt16((ushort)(2 + (extName.Length + 3) / 4))   // request-length                          .AppendUInt16((ushort)extName.Length)    // length of name                          .AppendUInt16(0)    // unused                          .AppendBytes(extName)  // name                          .AppendPaddingBytesOf(extName);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                      if (recv[0] != 1 /*Reply*/ || recv[8] != 1 /*present*/) {                          // no SECURITY extension                          _protocolEventManager.Trace("[X11] X server doesn't have the SECURITY extension.");                          return null;                      }                  }                  byte secOpcode = recv[9];   // major-opcode of the SECURITY extension                    // SecurityQueryVersion                  {                      xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(0)  // minor-opcode                          .AppendUInt16(2)   // request-length                          .AppendUInt16(1)    // client-major-version                          .AppendUInt16(0);   // client-minor-version                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }                    // SecurityGenerateAuthorization                  {                      byte[] authName = Encoding.ASCII.GetBytes(DEFAULT_AUTH_NAME);                      byte[] authData = new byte[0];                        uint[] valueList = new uint[] {                          // timeout                          0'  // no timeout                          // trust-level                          1'  // SecurityClientUntrusted                      };                        xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(1)  // minor-opcode                          .AppendUInt16((ushort)(3 + (authName.Length + 3) / 4 + (authData.Length + 3) / 4 + valueList.Length))                          .AppendUInt16((ushort)authName.Length)                          .AppendUInt16((ushort)authData.Length)                          .AppendUInt32(3)    // value-mask : timeout + trust-level                          .AppendBytes(authName)                          .AppendPaddingBytesOf(authName)                          .AppendBytes(authData)                          .AppendPaddingBytesOf(authData)                          .AppendUInt32(valueList[0])                          .AppendUInt32(valueList[1]);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Reply*/) {                          return null;                      }                        uint authId = reader.ReadUInt32(recv' 8);                        int extraDataLength = (int)reader.ReadUInt32(recv' 4) * 4;                      if (extraDataLength < 0 || extraDataLength > 1024) {                          // something wrong...                          return null;                      }                      int datLength = (int)reader.ReadUInt16(recv' 12);                      if (datLength < 0 || datLength > extraDataLength) {                          // something wrong...                          return null;                      }                      byte[] extraData = new byte[extraDataLength];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLength' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        byte[] generatedAuthData = reader.ReadBytes(extraData' 0' datLength);                        return Tuple.Create(authId' generatedAuthData);                  }    #else   // USE_UNTRUSTED_ACCESS                    // no untrusted access                  return null;    #endif  // USE_UNTRUSTED_ACCESS              }
Magic Number,Granados.X11,X11ConnectionManager,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,GetUntrustedAccessCookie,The following statement contains a magic number: using (IX11Socket socket = socketFactory()) {                  socket.Connect(display);                    const bool BIGENDIAN = true;                    byte[] recv = new byte[100];                  var xmsg = new XProtocolMessage(BIGENDIAN);                  var reader = new XDataReader(BIGENDIAN);                    // Note: if USE_UNTRUSTED_ACCESS was disabled' this method only checks the connectability to the X server.                    // initiation                  {                      byte[] authName = Encoding.ASCII.GetBytes(entry.Name);                      xmsg.Clear()                          .AppendByte(0x42)   // MSB first                          .AppendByte(0)  // unused                          .AppendUInt16(11)   // protocol-major-version                          .AppendUInt16(0)    // protocol-minor-version                          .AppendUInt16((ushort)authName.Length) // length of authorization-protocol-name                          .AppendUInt16((ushort)entry.Data.Length)    // length of authorization-protocol-data                          .AppendUInt16(0)    // unused                          .AppendBytes(authName)  // authorization-protocol-name                          .AppendPaddingBytesOf(authName)                          .AppendBytes(entry.Data)    // authorization-protocol-data                          .AppendPaddingBytesOf(entry.Data);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 8' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Success*/) {                          throw new X11UtilException(Strings.GetString("X11AuthorizationFailed"));                      }                      int extraDataLen = reader.ReadUInt16(recv' 6) * 4;                      byte[] extraData = new byte[extraDataLen];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLen' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }    #if USE_UNTRUSTED_ACCESS                    // QueryExtension                  {                      byte[] extName = Encoding.ASCII.GetBytes("SECURITY");                      xmsg.Clear()                          .AppendByte(98)   // opcode                          .AppendByte(0)  // unused                          .AppendUInt16((ushort)(2 + (extName.Length + 3) / 4))   // request-length                          .AppendUInt16((ushort)extName.Length)    // length of name                          .AppendUInt16(0)    // unused                          .AppendBytes(extName)  // name                          .AppendPaddingBytesOf(extName);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                      if (recv[0] != 1 /*Reply*/ || recv[8] != 1 /*present*/) {                          // no SECURITY extension                          _protocolEventManager.Trace("[X11] X server doesn't have the SECURITY extension.");                          return null;                      }                  }                  byte secOpcode = recv[9];   // major-opcode of the SECURITY extension                    // SecurityQueryVersion                  {                      xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(0)  // minor-opcode                          .AppendUInt16(2)   // request-length                          .AppendUInt16(1)    // client-major-version                          .AppendUInt16(0);   // client-minor-version                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }                    // SecurityGenerateAuthorization                  {                      byte[] authName = Encoding.ASCII.GetBytes(DEFAULT_AUTH_NAME);                      byte[] authData = new byte[0];                        uint[] valueList = new uint[] {                          // timeout                          0'  // no timeout                          // trust-level                          1'  // SecurityClientUntrusted                      };                        xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(1)  // minor-opcode                          .AppendUInt16((ushort)(3 + (authName.Length + 3) / 4 + (authData.Length + 3) / 4 + valueList.Length))                          .AppendUInt16((ushort)authName.Length)                          .AppendUInt16((ushort)authData.Length)                          .AppendUInt32(3)    // value-mask : timeout + trust-level                          .AppendBytes(authName)                          .AppendPaddingBytesOf(authName)                          .AppendBytes(authData)                          .AppendPaddingBytesOf(authData)                          .AppendUInt32(valueList[0])                          .AppendUInt32(valueList[1]);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Reply*/) {                          return null;                      }                        uint authId = reader.ReadUInt32(recv' 8);                        int extraDataLength = (int)reader.ReadUInt32(recv' 4) * 4;                      if (extraDataLength < 0 || extraDataLength > 1024) {                          // something wrong...                          return null;                      }                      int datLength = (int)reader.ReadUInt16(recv' 12);                      if (datLength < 0 || datLength > extraDataLength) {                          // something wrong...                          return null;                      }                      byte[] extraData = new byte[extraDataLength];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLength' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        byte[] generatedAuthData = reader.ReadBytes(extraData' 0' datLength);                        return Tuple.Create(authId' generatedAuthData);                  }    #else   // USE_UNTRUSTED_ACCESS                    // no untrusted access                  return null;    #endif  // USE_UNTRUSTED_ACCESS              }
Magic Number,Granados.X11,X11ConnectionManager,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,GetUntrustedAccessCookie,The following statement contains a magic number: using (IX11Socket socket = socketFactory()) {                  socket.Connect(display);                    const bool BIGENDIAN = true;                    byte[] recv = new byte[100];                  var xmsg = new XProtocolMessage(BIGENDIAN);                  var reader = new XDataReader(BIGENDIAN);                    // Note: if USE_UNTRUSTED_ACCESS was disabled' this method only checks the connectability to the X server.                    // initiation                  {                      byte[] authName = Encoding.ASCII.GetBytes(entry.Name);                      xmsg.Clear()                          .AppendByte(0x42)   // MSB first                          .AppendByte(0)  // unused                          .AppendUInt16(11)   // protocol-major-version                          .AppendUInt16(0)    // protocol-minor-version                          .AppendUInt16((ushort)authName.Length) // length of authorization-protocol-name                          .AppendUInt16((ushort)entry.Data.Length)    // length of authorization-protocol-data                          .AppendUInt16(0)    // unused                          .AppendBytes(authName)  // authorization-protocol-name                          .AppendPaddingBytesOf(authName)                          .AppendBytes(entry.Data)    // authorization-protocol-data                          .AppendPaddingBytesOf(entry.Data);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 8' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Success*/) {                          throw new X11UtilException(Strings.GetString("X11AuthorizationFailed"));                      }                      int extraDataLen = reader.ReadUInt16(recv' 6) * 4;                      byte[] extraData = new byte[extraDataLen];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLen' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }    #if USE_UNTRUSTED_ACCESS                    // QueryExtension                  {                      byte[] extName = Encoding.ASCII.GetBytes("SECURITY");                      xmsg.Clear()                          .AppendByte(98)   // opcode                          .AppendByte(0)  // unused                          .AppendUInt16((ushort)(2 + (extName.Length + 3) / 4))   // request-length                          .AppendUInt16((ushort)extName.Length)    // length of name                          .AppendUInt16(0)    // unused                          .AppendBytes(extName)  // name                          .AppendPaddingBytesOf(extName);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                      if (recv[0] != 1 /*Reply*/ || recv[8] != 1 /*present*/) {                          // no SECURITY extension                          _protocolEventManager.Trace("[X11] X server doesn't have the SECURITY extension.");                          return null;                      }                  }                  byte secOpcode = recv[9];   // major-opcode of the SECURITY extension                    // SecurityQueryVersion                  {                      xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(0)  // minor-opcode                          .AppendUInt16(2)   // request-length                          .AppendUInt16(1)    // client-major-version                          .AppendUInt16(0);   // client-minor-version                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                  }                    // SecurityGenerateAuthorization                  {                      byte[] authName = Encoding.ASCII.GetBytes(DEFAULT_AUTH_NAME);                      byte[] authData = new byte[0];                        uint[] valueList = new uint[] {                          // timeout                          0'  // no timeout                          // trust-level                          1'  // SecurityClientUntrusted                      };                        xmsg.Clear()                          .AppendByte(secOpcode)   // major-opcode                          .AppendByte(1)  // minor-opcode                          .AppendUInt16((ushort)(3 + (authName.Length + 3) / 4 + (authData.Length + 3) / 4 + valueList.Length))                          .AppendUInt16((ushort)authName.Length)                          .AppendUInt16((ushort)authData.Length)                          .AppendUInt32(3)    // value-mask : timeout + trust-level                          .AppendBytes(authName)                          .AppendPaddingBytesOf(authName)                          .AppendBytes(authData)                          .AppendPaddingBytesOf(authData)                          .AppendUInt32(valueList[0])                          .AppendUInt32(valueList[1]);                      if (!socket.Send(xmsg.AsDataFragment()' SEND_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("FailedToSendMessageToXServer"));                      }                        if (!socket.ReceiveBytes(recv' 0' 32' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        if (recv[0] != 1 /*Reply*/) {                          return null;                      }                        uint authId = reader.ReadUInt32(recv' 8);                        int extraDataLength = (int)reader.ReadUInt32(recv' 4) * 4;                      if (extraDataLength < 0 || extraDataLength > 1024) {                          // something wrong...                          return null;                      }                      int datLength = (int)reader.ReadUInt16(recv' 12);                      if (datLength < 0 || datLength > extraDataLength) {                          // something wrong...                          return null;                      }                      byte[] extraData = new byte[extraDataLength];                      if (!socket.ReceiveBytes(extraData' 0' extraDataLength' RESPONSE_TIMEOUT)) {                          throw new X11UtilException(Strings.GetString("XServerDoesntRespond"));                      }                        byte[] generatedAuthData = reader.ReadBytes(extraData' 0' datLength);                        return Tuple.Create(authId' generatedAuthData);                  }    #else   // USE_UNTRUSTED_ACCESS                    // no untrusted access                  return null;    #endif  // USE_UNTRUSTED_ACCESS              }
Magic Number,Granados.X11,X11ConnectionManager,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,GenerateCookie,The following statement contains a magic number: byte[] cookie = new byte[16];
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: if (_messageBuffer.Length < 12) {                  return;              }
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: ushort majorVersion = reader.ReadUInt16(_messageBuffer.RawBuffer' _messageBuffer.RawBufferOffset + 2);
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: ushort minorVersion = reader.ReadUInt16(_messageBuffer.RawBuffer' _messageBuffer.RawBufferOffset + 4);
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: int nameLen = reader.ReadUInt16(_messageBuffer.RawBuffer' _messageBuffer.RawBufferOffset + 6);
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: int namePadLen = (4 - (nameLen % 4)) % 4;
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: int namePadLen = (4 - (nameLen % 4)) % 4;
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: int namePadLen = (4 - (nameLen % 4)) % 4;
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: int dataLen = reader.ReadUInt16(_messageBuffer.RawBuffer' _messageBuffer.RawBufferOffset + 8);
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: int dataPadLen = (4 - (dataLen % 4)) % 4;
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: int dataPadLen = (4 - (dataLen % 4)) % 4;
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: int dataPadLen = (4 - (dataLen % 4)) % 4;
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: int messageLen = 12 + nameLen + namePadLen + dataLen + dataPadLen;
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: if (nameLen != _spoofedAuthProtocolName.Length                  || !CompareBytes(_messageBuffer' 12' _spoofedAuthProtocolName)) {                  // authorization protocol name doesn't match                  _state = Status.HasError;                  return;              }
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,ProcessSetupMessage,The following statement contains a magic number: if (dataLen != _spoofedAuthCookie.Length                  || !CompareBytes(_messageBuffer' 12 + nameLen + namePadLen' _spoofedAuthCookie)) {                  // authorization protocol data doesn't match                  _state = Status.HasError;                  return;              }
Magic Number,Granados.X11,X11ChannelHandler,C:\repos\poderosaproject_poderosa\Granados\X11ConnectionManager.cs,OnDataFromXServer,The following statement contains a magic number: if (_state != Status.Established) {                  if (_state == Status.WaitSetupMessage) {                      SpinWait.SpinUntil(() => _state == Status.Established' 2000);                  }                  Thread.MemoryBarrier();                  if (_state != Status.Established) {                      return;                  }              }
Magic Number,Granados.SSH1,CRC,C:\repos\poderosaproject_poderosa\Granados\CRC.cs,Calc,The following statement contains a magic number: for (int i = 0; i < len; i++)                  val = table[(int)((val ^ buf[off + i]) & 0xff)] ^ (val >> 8);
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,DoKeyExchange,The following statement contains a magic number: try {                  ReceiveServerKey();                    if (_param.VerifySSHHostKey != null) {                      bool accepted = _param.VerifySSHHostKey(_cInfo.GetSSHHostKeyInformationProvider());                      if (!accepted) {                          throw new SSHException(Strings.GetString("HostKeyDenied"));                      }                  }                    byte[] sessionId = ComputeSessionId();                  byte[] sessionKey = new byte[32];                  RngManager.GetSecureRng().GetBytes(sessionKey);                    SendSessionKey(sessionId' sessionKey);              }              catch (Exception) {                  lock (_sequenceLock) {                      _sequenceStatus = SequenceStatus.Failed;                      Monitor.PulseAll(_sequenceLock);                  }                  throw;              }              finally {                  _receivedPacket.Clear();              }
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,ReceiveServerKey,The following statement contains a magic number: _cInfo.AntiSpoofingCookie = reader.Read(8);
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The following statement contains a magic number: if (serverKey.Modulus < hostKey.Modulus) {                  firstEncryption = serverKey;                  secondEncryption = hostKey;                  firstKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;              }              else {                  firstEncryption = hostKey;                  secondEncryption = serverKey;                  firstKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;              }
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The following statement contains a magic number: if (serverKey.Modulus < hostKey.Modulus) {                  firstEncryption = serverKey;                  secondEncryption = hostKey;                  firstKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;              }              else {                  firstEncryption = hostKey;                  secondEncryption = serverKey;                  firstKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;              }
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The following statement contains a magic number: if (serverKey.Modulus < hostKey.Modulus) {                  firstEncryption = serverKey;                  secondEncryption = hostKey;                  firstKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;              }              else {                  firstEncryption = hostKey;                  secondEncryption = serverKey;                  firstKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;              }
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The following statement contains a magic number: if (serverKey.Modulus < hostKey.Modulus) {                  firstEncryption = serverKey;                  secondEncryption = hostKey;                  firstKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;              }              else {                  firstEncryption = hostKey;                  secondEncryption = serverKey;                  firstKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;              }
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The following statement contains a magic number: if (serverKey.Modulus < hostKey.Modulus) {                  firstEncryption = serverKey;                  secondEncryption = hostKey;                  firstKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;              }              else {                  firstEncryption = hostKey;                  secondEncryption = serverKey;                  firstKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;              }
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The following statement contains a magic number: if (serverKey.Modulus < hostKey.Modulus) {                  firstEncryption = serverKey;                  secondEncryption = hostKey;                  firstKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;              }              else {                  firstEncryption = hostKey;                  secondEncryption = serverKey;                  firstKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;              }
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The following statement contains a magic number: if (serverKey.Modulus < hostKey.Modulus) {                  firstEncryption = serverKey;                  secondEncryption = hostKey;                  firstKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;              }              else {                  firstEncryption = hostKey;                  secondEncryption = serverKey;                  firstKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;              }
Magic Number,Granados.SSH1,SSH1KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BuildSessionKeyPacket,The following statement contains a magic number: if (serverKey.Modulus < hostKey.Modulus) {                  firstEncryption = serverKey;                  secondEncryption = hostKey;                  firstKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;              }              else {                  firstEncryption = hostKey;                  secondEncryption = serverKey;                  firstKeyByteLen = (_cInfo.HostKeyBits + 7) / 8;                  secondKeyByteLen = (_cInfo.ServerKeyBits + 7) / 8;              }
Magic Number,Granados.SSH1,SSH1UserAuthentication,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,PublickeyAuthentication,The following statement contains a magic number: byte[] rawchallenge = RSAUtil.StripPKCS1Pad(challenge' 2).GetBytes();
Magic Number,Granados.SSH1,SSH1X11Forwarding,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,CheckX11OpenRequestPacket,The following statement contains a magic number: if (_connectionInfo.ServerProtocolFlags.HasFlag(SSH1ProtocolFlags.SSH_PROTOFLAG_HOST_IN_FWD_OPEN)                  && _connectionInfo.ClientProtocolFlags.HasFlag(SSH1ProtocolFlags.SSH_PROTOFLAG_HOST_IN_FWD_OPEN)                  && reader.RemainingDataLength >= 4) {                    originator = reader.ReadString();              }              else {                  originator = "";              }
Magic Number,Granados.SSH1,SSH1Packet,C:\repos\poderosaproject_poderosa\Granados\SSH1Packet.cs,BuildImage,The following statement contains a magic number: int packetLength = _payload.Length + 5;
Magic Number,Granados.SSH1,SSH1Packet,C:\repos\poderosaproject_poderosa\Granados\SSH1Packet.cs,BuildImage,The following statement contains a magic number: int paddingLength = 8 - (packetLength % 8);
Magic Number,Granados.SSH1,SSH1Packet,C:\repos\poderosaproject_poderosa\Granados\SSH1Packet.cs,BuildImage,The following statement contains a magic number: int paddingLength = 8 - (packetLength % 8);
Magic Number,Granados.SSH1,SSH1PacketBuilderMixin,C:\repos\poderosaproject_poderosa\Granados\SSH1Packet.cs,WriteBigInteger,The following statement contains a magic number: int bits = image.Length * 8;
Magic Number,Granados.SSH1,SSH1Packetizer,C:\repos\poderosaproject_poderosa\Granados\SSH1Packet.cs,ConstructPacket,The following statement contains a magic number: const int PACKET_LENGTH_FIELD_LEN = 4;
Magic Number,Granados.SSH1,SSH1Packetizer,C:\repos\poderosaproject_poderosa\Granados\SSH1Packet.cs,ConstructPacket,The following statement contains a magic number: const int CHECK_BYTES_FIELD_LEN = 4;
Magic Number,Granados.SSH1,SSH1Packetizer,C:\repos\poderosaproject_poderosa\Granados\SSH1Packet.cs,ConstructPacket,The following statement contains a magic number: int paddingLength = 8 - (_packetLength % 8);
Magic Number,Granados.SSH1,SSH1Packetizer,C:\repos\poderosaproject_poderosa\Granados\SSH1Packet.cs,ConstructPacket,The following statement contains a magic number: int paddingLength = 8 - (_packetLength % 8);
Magic Number,Granados.SSH2,SSH2ChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,ProcessPacket,The following statement contains a magic number: lock (_stateSync) {                  switch (_state) {                      case State.InitiatedByServer:                          break;                      case State.InitiatedByClient:                          if (packetType == SSH2PacketType.SSH_MSG_CHANNEL_OPEN_CONFIRMATION) {                              SSH2DataReader reader = new SSH2DataReader(packetFragment);                              RemoteChannel = reader.ReadUInt32();                              _serverWindowSizeLeft = reader.ReadUInt32();                              _serverMaxPacketSize = reader.ReadUInt32();                                _state = State.Established;                              Monitor.PulseAll(_stateSync);   // notifies state change                              dataFragmentArg = reader.GetRemainingDataView();                              goto OnEstablished; // do it out of the lock block                          }                          if (packetType == SSH2PacketType.SSH_MSG_CHANNEL_OPEN_FAILURE) {                              SSH2DataReader reader = new SSH2DataReader(packetFragment);                              uint reasonCode = reader.ReadUInt32();                              string description = reader.ReadUTF8String();                              string lang = reader.ReadString();                              goto RequestFailed; // do it out of the lock block                          }                          break;                      case State.Closing:                          if (packetType == SSH2PacketType.SSH_MSG_CHANNEL_CLOSE) {                              goto SetStateClosedByClient;    // do it out of the lock block                          }                          break;                      case State.Established:                      case State.Ready:                          if (ProcessPacketSub(packetType' packetFragment) == SubPacketProcessResult.Consumed) {                              return;                          }                          switch (packetType) {                              case SSH2PacketType.SSH_MSG_CHANNEL_DATA: {                                      SSH2DataReader reader = new SSH2DataReader(packetFragment);                                      int len = reader.ReadInt32();                                      dataFragmentArg = reader.GetRemainingDataView(len);                                      AdjustWindowSize(len);                                  }                                  goto OnData;    // do it out of the lock block                              case SSH2PacketType.SSH_MSG_CHANNEL_EXTENDED_DATA: {                                      SSH2DataReader reader = new SSH2DataReader(packetFragment);                                      dataTypeCodeArg = reader.ReadUInt32();                                      int len = reader.ReadInt32();                                      dataFragmentArg = reader.GetRemainingDataView(len);                                      AdjustWindowSize(len);                                  }                                  goto OnExtendedData;    // do it out of the lock block                              case SSH2PacketType.SSH_MSG_CHANNEL_REQUEST: {                                      SSH2DataReader reader = new SSH2DataReader(packetFragment);                                      string request = reader.ReadString();                                      bool wantReply = reader.ReadBool();                                      if (wantReply) { //we reject unknown requests including keep-alive check                                          Transmit(                                              0'                                              new SSH2Packet(SSH2PacketType.SSH_MSG_CHANNEL_FAILURE)                                                  .WriteUInt32(RemoteChannel)                                          );                                      }                                  }                                  break;                              case SSH2PacketType.SSH_MSG_CHANNEL_EOF:                                  goto OnEOF; // do it out of the lock block                              case SSH2PacketType.SSH_MSG_CHANNEL_CLOSE:                                  Transmit(                                      0'                                      new SSH2Packet(SSH2PacketType.SSH_MSG_CHANNEL_CLOSE)                                          .WriteUInt32(RemoteChannel)                                  );                                  goto SetStateClosedByServer;    // do it out of the lock block                              case SSH2PacketType.SSH_MSG_CHANNEL_WINDOW_ADJUST: {                                      SSH2DataReader reader = new SSH2DataReader(packetFragment);                                      uint bytesToAdd = reader.ReadUInt32();                                      // some servers may not send SSH_MSG_CHANNEL_WINDOW_ADJUST.                                      // it is dangerous to wait this message in send procedure                                      _serverWindowSizeLeft += bytesToAdd;                                  }                                  goto OnWindowAdjust;                              case SSH2PacketType.SSH_MSG_CHANNEL_SUCCESS:                              case SSH2PacketType.SSH_MSG_CHANNEL_FAILURE: {                                      _channelRequestResult.TrySet(packetType == SSH2PacketType.SSH_MSG_CHANNEL_SUCCESS' 1000);                                  }                                  break;                              default:                                  goto OnUnhandledPacket;                          }                          break;  // case State.Ready                  }              }
Magic Number,Granados.SSH2,SSH2ChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH2Channel.cs,AdjustWindowSize,The following statement contains a magic number: if (_localWindowSizeLeft < _localWindowSize / 2) {                  Transmit(                      0'                      new SSH2Packet(SSH2PacketType.SSH_MSG_CHANNEL_WINDOW_ADJUST)                          .WriteUInt32(RemoteChannel)                          .WriteInt32(_localWindowSize - _localWindowSizeLeft)                  );                    _protocolEventManager.Trace(                      "CH[{0}] adjusted local window size : {1} --> {2}"'                      LocalChannel' _localWindowSizeLeft' _localWindowSize);                    _localWindowSizeLeft = _localWindowSize;              }
Magic Number,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,BuildKEXINITPacket,The following statement contains a magic number: SSH2Packet packet =                  new SSH2Packet(SSH2PacketType.SSH_MSG_KEXINIT)                      .WriteSecureRandomBytes(16) // cookie                      .WriteString(kexAlgorithms) // kex_algorithms                      .WriteString(hostKeyAlgorithmDescription) // server_host_key_algorithms                      .WriteString(cipherAlgorithmDescription) // encryption_algorithms_client_to_server                      .WriteString(cipherAlgorithmDescription) // encryption_algorithms_server_to_client                      .WriteString(macAlgorithmDescription) // mac_algorithms_client_to_server                      .WriteString(macAlgorithmDescription) // mac_algorithms_server_to_client                      .WriteString("none") // compression_algorithms_client_to_server                      .WriteString("none") // compression_algorithms_server_to_client                      .WriteString("") // languages_client_to_server                      .WriteString("") // languages_server_to_client                      .WriteBool(false) // indicates whether a guessed key exchange packet follows                      .WriteInt32(0);
Magic Number,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,ProcessKEXINIT,The following statement contains a magic number: reader.Read(17);
Magic Number,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,BuildKEXDHINITPacket,The following statement contains a magic number: int xBytes = (state.p.BitCount() - 2) / 8;
Magic Number,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,BuildKEXDHINITPacket,The following statement contains a magic number: int xBytes = (state.p.BitCount() - 2) / 8;
Magic Number,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,BuildKEXDHINITPacket,The following statement contains a magic number: state.e = new BigInteger(2).ModPow(x' state.p);
Magic Number,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,DeriveKey,The following statement contains a magic number: ByteBuffer hashBuff = new ByteBuffer(length * 2' -1);
Magic Number,Granados.SSH2,SSH2Packet,C:\repos\poderosaproject_poderosa\Granados\SSH2Packet.cs,BuildImage,The following statement contains a magic number: int blockSize = (cipher != null) ? cipher.BlockSize : 8;
Magic Number,Granados.SSH2,SSH2Packet,C:\repos\poderosaproject_poderosa\Granados\SSH2Packet.cs,BuildImage,The following statement contains a magic number: if (paddingLength < 4) {                  paddingLength += blockSize;              }
Magic Number,Granados.SSH2,SSH2Packetizer,C:\repos\poderosaproject_poderosa\Granados\SSH2Packet.cs,ConstructPacket,The following statement contains a magic number: const int SEQUENCE_NUMBER_FIELD_LEN = 4;
Magic Number,Granados.SSH2,SSH2Packetizer,C:\repos\poderosaproject_poderosa\Granados\SSH2Packet.cs,ConstructPacket,The following statement contains a magic number: const int PACKET_LENGTH_FIELD_LEN = 4;
Magic Number,Granados.SSH2,SSH2Packetizer,C:\repos\poderosaproject_poderosa\Granados\SSH2Packet.cs,ConstructPacket,The following statement contains a magic number: lock (_cipherSync) {                  if (_packetLength < 0) {                      int headLen = (_cipher != null) ? _cipher.BlockSize : 4;                        if (_inputBuffer.Length < headLen) {                          return false;                      }                        _packetImage.Clear();                      _packetImage.WriteUInt32(_sequence);                      _packetImage.Append(_inputBuffer' 0' headLen);                      _inputBuffer.RemoveHead(headLen);                        int headOffset = _packetImage.RawBufferOffset + SEQUENCE_NUMBER_FIELD_LEN;                        if (_cipher != null) {                          // decrypt first block                          _cipher.Decrypt(                              _packetImage.RawBuffer' headOffset' headLen'                              _packetImage.RawBuffer' headOffset);                      }                        uint packetLength = SSHUtil.ReadUInt32(_packetImage.RawBuffer' headOffset);                        if (packetLength < MIN_PACKET_LENGTH || packetLength >= MAX_PACKET_LENGTH) {                          throw new SSHException(String.Format("invalid packet length : {0}"' packetLength));                      }                        _packetLength = (int)packetLength;                  }                    int packetHeadLen = _packetImage.Length;    // size already read in                  int requiredLength = SEQUENCE_NUMBER_FIELD_LEN + PACKET_LENGTH_FIELD_LEN + _packetLength + _macLength - packetHeadLen;                    if (_inputBuffer.Length < requiredLength) {                      return false;                  }                    _packetImage.Append(_inputBuffer' 0' requiredLength);                  _inputBuffer.RemoveHead(requiredLength);                    if (_cipher != null) {                      // decrypt excluding MAC                      int headOffset = _packetImage.RawBufferOffset + packetHeadLen;                      _cipher.Decrypt(                          _packetImage.RawBuffer' headOffset' requiredLength - _macLength'                          _packetImage.RawBuffer' headOffset);                  }                    int paddingLength = _packetImage[SEQUENCE_NUMBER_FIELD_LEN + PACKET_LENGTH_FIELD_LEN];                  if (paddingLength < 4) {                      throw new SSHException(String.Format("invalid padding length : {0}"' paddingLength));                  }                    int payloadLength = _packetLength - PADDING_LENGTH_FIELD_LEN - paddingLength;                    if (_mac != null) {                      int contentLen = SEQUENCE_NUMBER_FIELD_LEN + PACKET_LENGTH_FIELD_LEN + _packetLength;                      byte[] result = _mac.ComputeHash(_packetImage.RawBuffer' _packetImage.RawBufferOffset' contentLen);                        if (result.Length != _macLength ||                          !SSHUtil.ByteArrayEqual(result' 0' _packetImage.RawBuffer' _packetImage.RawBufferOffset + contentLen' _macLength)) {                          throw new SSHException("MAC mismatch");                      }                  }                    // retain only payload                  _packetImage.RemoveHead(SEQUENCE_NUMBER_FIELD_LEN + PACKET_LENGTH_FIELD_LEN + PADDING_LENGTH_FIELD_LEN);                  _packetImage.RemoveTail(_macLength + paddingLength);                    // sanity check                  if (_packetImage.Length != payloadLength) {                      throw new InvalidOperationException();                  }                    // prepare for the next packet                  ++_sequence;                  _packetLength = -1;                    return true;              }
Magic Number,Granados.SSH2,SSH2Packetizer,C:\repos\poderosaproject_poderosa\Granados\SSH2Packet.cs,ConstructPacket,The following statement contains a magic number: lock (_cipherSync) {                  if (_packetLength < 0) {                      int headLen = (_cipher != null) ? _cipher.BlockSize : 4;                        if (_inputBuffer.Length < headLen) {                          return false;                      }                        _packetImage.Clear();                      _packetImage.WriteUInt32(_sequence);                      _packetImage.Append(_inputBuffer' 0' headLen);                      _inputBuffer.RemoveHead(headLen);                        int headOffset = _packetImage.RawBufferOffset + SEQUENCE_NUMBER_FIELD_LEN;                        if (_cipher != null) {                          // decrypt first block                          _cipher.Decrypt(                              _packetImage.RawBuffer' headOffset' headLen'                              _packetImage.RawBuffer' headOffset);                      }                        uint packetLength = SSHUtil.ReadUInt32(_packetImage.RawBuffer' headOffset);                        if (packetLength < MIN_PACKET_LENGTH || packetLength >= MAX_PACKET_LENGTH) {                          throw new SSHException(String.Format("invalid packet length : {0}"' packetLength));                      }                        _packetLength = (int)packetLength;                  }                    int packetHeadLen = _packetImage.Length;    // size already read in                  int requiredLength = SEQUENCE_NUMBER_FIELD_LEN + PACKET_LENGTH_FIELD_LEN + _packetLength + _macLength - packetHeadLen;                    if (_inputBuffer.Length < requiredLength) {                      return false;                  }                    _packetImage.Append(_inputBuffer' 0' requiredLength);                  _inputBuffer.RemoveHead(requiredLength);                    if (_cipher != null) {                      // decrypt excluding MAC                      int headOffset = _packetImage.RawBufferOffset + packetHeadLen;                      _cipher.Decrypt(                          _packetImage.RawBuffer' headOffset' requiredLength - _macLength'                          _packetImage.RawBuffer' headOffset);                  }                    int paddingLength = _packetImage[SEQUENCE_NUMBER_FIELD_LEN + PACKET_LENGTH_FIELD_LEN];                  if (paddingLength < 4) {                      throw new SSHException(String.Format("invalid padding length : {0}"' paddingLength));                  }                    int payloadLength = _packetLength - PADDING_LENGTH_FIELD_LEN - paddingLength;                    if (_mac != null) {                      int contentLen = SEQUENCE_NUMBER_FIELD_LEN + PACKET_LENGTH_FIELD_LEN + _packetLength;                      byte[] result = _mac.ComputeHash(_packetImage.RawBuffer' _packetImage.RawBufferOffset' contentLen);                        if (result.Length != _macLength ||                          !SSHUtil.ByteArrayEqual(result' 0' _packetImage.RawBuffer' _packetImage.RawBufferOffset + contentLen' _macLength)) {                          throw new SSHException("MAC mismatch");                      }                  }                    // retain only payload                  _packetImage.RemoveHead(SEQUENCE_NUMBER_FIELD_LEN + PACKET_LENGTH_FIELD_LEN + PADDING_LENGTH_FIELD_LEN);                  _packetImage.RemoveTail(_macLength + paddingLength);                    // sanity check                  if (_packetImage.Length != payloadLength) {                      throw new InvalidOperationException();                  }                    // prepare for the next packet                  ++_sequence;                  _packetLength = -1;                    return true;              }
Magic Number,Granados.SSH2,SSH2UserAuthKey,C:\repos\poderosaproject_poderosa\Granados\SSH2UserAuthKey.cs,PassphraseToKey,The following statement contains a magic number: int hashlen = md5.HashSize / 8;
Magic Number,Granados.SSH2,SSH2UserAuthKey,C:\repos\poderosaproject_poderosa\Granados\SSH2UserAuthKey.cs,WritePrivatePartInSECSHStyleFile,The following statement contains a magic number: if (passphrase != null) {                  padding_len = 8 - (int)wr.Length % 8;                  wr.Write(new byte[padding_len]);              }
Magic Number,Granados.SSH2,SSH2UserAuthKey,C:\repos\poderosaproject_poderosa\Granados\SSH2UserAuthKey.cs,WritePrivatePartInSECSHStyleFile,The following statement contains a magic number: if (passphrase != null) {                  padding_len = 8 - (int)wr.Length % 8;                  wr.Write(new byte[padding_len]);              }
Magic Number,Granados.SSH2,SSH2UserAuthKey,C:\repos\poderosaproject_poderosa\Granados\SSH2UserAuthKey.cs,WritePrivatePartInSECSHStyleFile,The following statement contains a magic number: SSHUtil.WriteIntToByteArray(encrypted_body' 0' encrypted_body.Length - padding_len - 4);
Magic Number,Granados.SSH2,SSH2UserAuthKey,C:\repos\poderosaproject_poderosa\Granados\SSH2UserAuthKey.cs,WritePrivatePartInSECSHStyleFile,The following statement contains a magic number: if (passphrase != null) {                  Cipher c = CipherFactory.CreateCipher(SSHProtocol.SSH2' CipherAlgorithm.TripleDES' PassphraseToKey(passphrase' 24));                  Debug.Assert(encrypted_body.Length % 8 == 0);                  byte[] tmp = new Byte[encrypted_body.Length];                  c.Encrypt(encrypted_body' 0' encrypted_body.Length' tmp' 0);                  encrypted_body = tmp;              }
Magic Number,Granados.SSH2,SSH2UserAuthKey,C:\repos\poderosaproject_poderosa\Granados\SSH2UserAuthKey.cs,WritePrivatePartInSECSHStyleFile,The following statement contains a magic number: if (passphrase != null) {                  Cipher c = CipherFactory.CreateCipher(SSHProtocol.SSH2' CipherAlgorithm.TripleDES' PassphraseToKey(passphrase' 24));                  Debug.Assert(encrypted_body.Length % 8 == 0);                  byte[] tmp = new Byte[encrypted_body.Length];                  c.Encrypt(encrypted_body' 0' encrypted_body.Length' tmp' 0);                  encrypted_body = tmp;              }
Magic Number,Granados.SSH2,SSH2UserAuthKey,C:\repos\poderosaproject_poderosa\Granados\SSH2UserAuthKey.cs,WritePrivatePartInSECSHStyleFile,The following statement contains a magic number: SSHUtil.WriteIntToByteArray(rawdata' 4' rawdata.Length);
Magic Number,Granados.SSH2,SSH2UserAuthKey,C:\repos\poderosaproject_poderosa\Granados\SSH2UserAuthKey.cs,WriteKeyFileBlock,The following statement contains a magic number: const int maxlen = 70;
Magic Number,Granados,SSHTimeouts,C:\repos\poderosaproject_poderosa\Granados\ConnectionParameter.cs,SSHTimeouts,The following statement contains a magic number: ResponseTimeout = 10000;
Magic Number,Granados,SecureRng,C:\repos\poderosaproject_poderosa\Granados\Rng.cs,GetInt,The following statement contains a magic number: byte[] rbits = new byte[4];
Magic Number,Granados,SecureRng,C:\repos\poderosaproject_poderosa\Granados\Rng.cs,GetInt,The following statement contains a magic number: return (int)((((long)r) * maxValue) >> 32);
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret <<= 8;
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret <<= 8;
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret |= data[offset + 2];
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret <<= 8;
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,ReadUInt32,The following statement contains a magic number: ret |= data[offset + 3];
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos] = (byte)(data >> 24);
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos + 1] = (byte)(data >> 16);
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos + 2] = (byte)(data >> 8);
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos + 2] = (byte)(data >> 8);
Magic Number,Granados,SSHUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,WriteUIntToByteArray,The following statement contains a magic number: dst[pos + 3] = (byte)(data);
Magic Number,Granados,DebugUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,DumpByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  bld.Append(data[offset + i].ToString("X2"));                  if ((i % 4) == 3)                      bld.Append(' ');              }
Magic Number,Granados,DebugUtil,C:\repos\poderosaproject_poderosa\Granados\SSHUtil.cs,DumpByteArray,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  bld.Append(data[offset + i].ToString("X2"));                  if ((i % 4) == 3)                      bld.Append(' ');              }
Magic Number,Granados,SSHConnection,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,Connect,The following statement contains a magic number: try {                  // receive protocol version string                  SSHProtocolVersionReceiver protoVerReceiver = new SSHProtocolVersionReceiver();                  protoVerReceiver.Receive(psocket' 5000);                  // verify the version string                  protoVerReceiver.Verify(param.Protocol);                    ISSHConnection sshConnection;                    if (param.Protocol == SSHProtocol.SSH1) {                      // create a connection object                      var con = new SSH1Connection(                                  psocket'                                  param'                                  protoVerReceiver.ServerVersion'                                  clientVersion'                                  connectionEventHandlerCreator'                                  protocolEventLoggerCreator);                      // start receiving loop                      psocket.RepeatAsyncRead();                      // send client version                      con.SendMyVersion();                      // establish a SSH connection                      con.Connect();                      sshConnection = con;                  }                  else {                      // create a connection object                      var con = new SSH2Connection(                                  psocket'                                  param'                                  protoVerReceiver.ServerVersion'                                  clientVersion'                                  connectionEventHandlerCreator'                                  protocolEventLoggerCreator);                      // start receiving loop                      psocket.RepeatAsyncRead();                      // send client version                      con.SendMyVersion();                      // establish a SSH connection                      con.Connect();                      sshConnection = con;                  }                    return sshConnection;              }              catch (Exception) {                  psocket.Close();                  throw;              }
Magic Number,Granados,SSHProtocolVersionReceiver,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,Receive,The following statement contains a magic number: using (MemoryStream mem = new MemoryStream()) {                  while (DateTime.UtcNow < tm && sock.SocketStatus == SocketStatus.Ready) {                      int n = sock.ReadIfAvailable(buf);                      if (n != 1) {                          Thread.Sleep(10);                          continue;                      }                      byte b = buf[0];                      mem.WriteByte(b);                      if (b == 0xa) { // LF                          byte[] bytestr = mem.ToArray();                          mem.SetLength(0);                          string line = Encoding.UTF8.GetString(bytestr).TrimEnd('\xd'' '\xa');                          _lines.Add(line);                          if (line.StartsWith("SSH-")) {                              _serverVersion = line;                              return true;                          }                      }                  }              }
Magic Number,Granados,SSHProtocolVersionReceiver,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,Verify,The following statement contains a magic number: if (sv.Length >= 3 && sv[0] == "SSH") {                  string protocolVersion = sv[1];                  string[] pv = protocolVersion.Split('.');                  if (pv.Length >= 2) {                      if (protocol == SSHProtocol.SSH1) {                          if (pv[0] == "1") {                              return; // OK                          }                      }                      else if (protocol == SSHProtocol.SSH2) {                          if (pv[0] == "2" || (pv[0] == "1" && pv[1] == "99")) {                              return; // OK                          }                      }                      throw new SSHException(                          String.Format(Strings.GetString("IncompatibleProtocolVersion")' _serverVersion' protocol.ToString()));                  }              }
Magic Number,Granados,SSHProtocolVersionReceiver,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,Verify,The following statement contains a magic number: if (sv.Length >= 3 && sv[0] == "SSH") {                  string protocolVersion = sv[1];                  string[] pv = protocolVersion.Split('.');                  if (pv.Length >= 2) {                      if (protocol == SSHProtocol.SSH1) {                          if (pv[0] == "1") {                              return; // OK                          }                      }                      else if (protocol == SSHProtocol.SSH2) {                          if (pv[0] == "2" || (pv[0] == "1" && pv[1] == "99")) {                              return; // OK                          }                      }                      throw new SSHException(                          String.Format(Strings.GetString("IncompatibleProtocolVersion")' _serverVersion' protocol.ToString()));                  }              }
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: length = (uint)inData.Length >> 2;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i])  					);  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i])  					);  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i])  					);  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i])  					);  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i])  					);  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i])  					);  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i])  					);  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i])  					);  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i])  					);  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint [2] { (uint)ul' (uint)(ul >> 32)};
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint [2] { (uint)ul' (uint)(ul >> 32)};
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following statement contains a magic number: length = 2;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,Parse,The following statement contains a magic number: for (; i < len; i++) {  				c = number [i];  				if (c == '\0') {  					i = len;  					continue;  				}  				if (c >= '0' && c <= '9') {  					val = val * 10 + (c - '0');  					digits_seen = true;  				}   				else {  					if (Char.IsWhiteSpace (c)) {  						for (i++; i < len; i++) {  							if (!Char.IsWhiteSpace (number [i]))  								throw new FormatException ();  						}  						break;  					}   					else  						throw new FormatException ();  				}  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,GenerateRandom,The following statement contains a magic number: int dwords = bits >> 5;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,GenerateRandom,The following statement contains a magic number: byte [] random = new byte [dwords << 2];
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,GenerateRandom,The following statement contains a magic number: Buffer.BlockCopy (random' 0' ret.data' 0' (int)dwords << 2);
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,GenerateRandom,The following statement contains a magic number: if (remBits != 0) {  				uint mask = (uint)(0x01 << (remBits-1));  				ret.data [dwords-1] |= mask;    				mask = (uint)(0xFFFFFFFF >> (32 - remBits));  				ret.data [dwords-1] &= mask;  			}  			else  				ret.data [dwords-1] |= 0x80000000;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,Randomize,The following statement contains a magic number: int dwords = bits >> 5;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,Randomize,The following statement contains a magic number: byte [] random = new byte [dwords << 2];
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,Randomize,The following statement contains a magic number: Buffer.BlockCopy (random' 0' data' 0' (int)dwords << 2);
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,Randomize,The following statement contains a magic number: if (remBits != 0) {  				uint mask = (uint)(0x01 << (remBits-1));  				data [dwords-1] |= mask;    				mask = (uint)(0xFFFFFFFF >> (32 - remBits));  				data [dwords-1] &= mask;  			}    			else  				data [dwords-1] |= 0x80000000;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BitCount,The following statement contains a magic number: uint bits = 32;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BitCount,The following statement contains a magic number: bits += ((length - 1) << 5);
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,TestBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,TestBit,The following statement contains a magic number: uint bytePos = (uint)bitNum >> 5;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,SetBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,GetBytes,The following statement contains a magic number: int numBytes = numBits >> 3;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,GetBytes,The following statement contains a magic number: if (numBytesInWord == 0) numBytesInWord = 4;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--) {  				uint val = data [i];  				for (int j = numBytesInWord - 1; j >= 0; j--) {  					result [pos+j] = (byte)(val & 0xFF);  					val >>= 8;  				}  				pos += numBytesInWord;  				numBytesInWord = 4;  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--) {  				uint val = data [i];  				for (int j = numBytesInWord - 1; j >= 0; j--) {  					result [pos+j] = (byte)(val & 0xFF);  					val >>= 8;  				}  				pos += numBytesInWord;  				numBytesInWord = 4;  			}
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10);
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,Incr2,The following statement contains a magic number: data [0] += 2;
Magic Number,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,Incr2,The following statement contains a magic number: if (data [0] < 2) {    				// Account for the first carry  				data [++i]++;    				// Keep adding until no carry  				while (data [i++] == 0x0)  					data [i]++;    				// See if we increased the data length  				if (length == (uint)i)  					length++;  			}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,AddSameSign,The following statement contains a magic number: do {  					sum = ((ulong)x [i]) + ((ulong)y [i]) + sum;  					r [i] = (uint)sum;  					sum >>= 32;  				} while (++i < yMax);
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,PlusEq,The following statement contains a magic number: do {  					sum += ((ulong)x [i]) + ((ulong)y [i]);  					r [i] = (uint)sum;  					sum >>= 32;  				} while (++i < yMax);
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,SingleByteDivideInPlace,The following statement contains a magic number: while (i-- > 0) {  					r <<= 32;  					r |= n.data [i];  					n.data [i] = (uint)(r / d);  					r %= d;  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,DwordMod,The following statement contains a magic number: while (i-- > 0) {  					r <<= 32;  					r |= n.data [i];  					r %= d;  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,DwordDiv,The following statement contains a magic number: while (i-- > 0) {  					r <<= 32;  					r |= n.data [i];  					ret.data [i] = (uint)(r / d);  					r %= d;  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,DwordDivMod,The following statement contains a magic number: while (i-- > 0) {  					r <<= 32;  					r |= n.data [i];  					ret.data [i] = (uint)(r / d);  					r %= d;  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: if (Kernel.Compare (bi1' bi2) == Sign.Negative)  					return new BigInteger [2] { 0' new BigInteger (bi1) };
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: ulong secondDivisorByte = bi2.data [bi2.length-2];
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,multiByteDivide,The following statement contains a magic number: BigInteger [] ret = new BigInteger [2] { quot' rem };
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,LeftShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,LeftShift,The following statement contains a magic number: n &= ((1 << 5) - 1);
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,LeftShift,The following statement contains a magic number: if (n != 0) {  					uint x' carry = 0;  					while (i < l) {  						x = bi.data [i];  						ret.data [i + w] = (x << n) | carry;  						carry = x >> (32 - n);  						i++;  					}  					ret.data [i + w] = carry;  				} else {  					while (i < l) {  						ret.data [i + w] = bi.data [i];  						i++;  					}  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,RightShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,RightShift,The following statement contains a magic number: int s = n & ((1 << 5) - 1);
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,RightShift,The following statement contains a magic number: if (s != 0) {    					uint x' carry = 0;    					while (l-- > 0) {  						x = bi.data [l + w];  						ret.data [l] = (x >> n) | carry;  						carry = x << (32 - n);  					}  				} else {  					while (l-- > 0)  						ret.data [l] = bi.data [l + w];    				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,MultiplyByDword,The following statement contains a magic number: do {  					c += (ulong)n.data [i] * (ulong)f;  					ret.data [i] = (uint)c;  					c >>= 32;  				} while (++i < n.length);
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,Multiply,The following statement contains a magic number: fixed (uint* xx = x' yy = y' dd = d) {  					uint* xP = xx + xOffset'  						xE = xP + xLen'  						yB = yy + yOffset'  						yE = yB + yLen'  						dB = dd + dOffset;    					for (; xP < xE; xP++' dB++) {    						if (*xP == 0) continue;    						ulong mcarry = 0;    						uint* dP = dB;  						for (uint* yP = yB; yP < yE; yP++' dP++) {  							mcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;    							*dP = (uint)mcarry;  							mcarry >>= 32;  						}    						if (mcarry != 0)  							*dP = (uint)mcarry;  					}  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,MultiplyMod2p32pmod,The following statement contains a magic number: fixed (uint* xx = x' yy = y' dd = d) {  					uint* xP = xx + xOffset'  						xE = xP + xLen'  						yB = yy + yOffest'  						yE = yB + yLen'  						dB = dd + dOffset'  						dE = dB + mod;    					for (; xP < xE; xP++' dB++) {    						if (*xP == 0) continue;    						ulong mcarry = 0;  						uint* dP = dB;  						for (uint* yP = yB; yP < yE && dP < dE; yP++' dP++) {  							mcarry += ((ulong)*xP * (ulong)*yP) + (ulong)*dP;    							*dP = (uint)mcarry;  							mcarry >>= 32;  						}    						if (mcarry != 0 && dP < dE)  							*dP = (uint)mcarry;  					}  				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,SquarePositive,The following statement contains a magic number: fixed (uint* dd = d' tt = t) {    					uint* ttE = tt + t.Length;  					// Clear the dest  					for (uint* ttt = tt; ttt < ttE; ttt++)  						*ttt = 0;    					uint* dP = dd' tP = tt;    					for (uint i = 0; i < dl; i++' dP++) {  						if (*dP == 0)  							continue;    						ulong mcarry = 0;  						uint bi1val = *dP;    						uint* dP2 = dP + 1' tP2 = tP + 2*i + 1;    						for (uint j = i + 1; j < dl; j++' tP2++' dP2++) {  							// k = i + j  							mcarry += ((ulong)bi1val * (ulong)*dP2) + *tP2;    							*tP2 = (uint)mcarry;  							mcarry >>= 32;  						}    						if (mcarry != 0)  							*tP2 = (uint)mcarry;  					}    					// Double t. Inlined for speed.    					tP = tt;    					uint x' carry = 0;  					while (tP < ttE) {  						x = *tP;  						*tP = (x << 1) | carry;  						carry = x >> (32 - 1);  						tP++;  					}  					if (carry != 0) *tP = carry;    					// Add in the diagnals    					dP = dd;  					tP = tt;  					for (uint* dE = dP + dl; (dP < dE); dP++' tP++) {  						ulong val = (ulong)*dP * (ulong)*dP + *tP;  						*tP = (uint)val;  						val >>= 32;  						*(++tP) += (uint)val;  						if (*tP < (uint)val) {  							uint* tP3 = tP;  							// Account for the first carry  							(*++tP3)++;    							// Keep adding until no carry  							while ((*tP3++) == 0)  								(*tP3)++;  						}    					}    					bi.length <<= 1;    					// Normalize length  					while (tt [bi.length-1] == 0 && bi.length > 1) bi.length--;    				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,SquarePositive,The following statement contains a magic number: fixed (uint* dd = d' tt = t) {    					uint* ttE = tt + t.Length;  					// Clear the dest  					for (uint* ttt = tt; ttt < ttE; ttt++)  						*ttt = 0;    					uint* dP = dd' tP = tt;    					for (uint i = 0; i < dl; i++' dP++) {  						if (*dP == 0)  							continue;    						ulong mcarry = 0;  						uint bi1val = *dP;    						uint* dP2 = dP + 1' tP2 = tP + 2*i + 1;    						for (uint j = i + 1; j < dl; j++' tP2++' dP2++) {  							// k = i + j  							mcarry += ((ulong)bi1val * (ulong)*dP2) + *tP2;    							*tP2 = (uint)mcarry;  							mcarry >>= 32;  						}    						if (mcarry != 0)  							*tP2 = (uint)mcarry;  					}    					// Double t. Inlined for speed.    					tP = tt;    					uint x' carry = 0;  					while (tP < ttE) {  						x = *tP;  						*tP = (x << 1) | carry;  						carry = x >> (32 - 1);  						tP++;  					}  					if (carry != 0) *tP = carry;    					// Add in the diagnals    					dP = dd;  					tP = tt;  					for (uint* dE = dP + dl; (dP < dE); dP++' tP++) {  						ulong val = (ulong)*dP * (ulong)*dP + *tP;  						*tP = (uint)val;  						val >>= 32;  						*(++tP) += (uint)val;  						if (*tP < (uint)val) {  							uint* tP3 = tP;  							// Account for the first carry  							(*++tP3)++;    							// Keep adding until no carry  							while ((*tP3++) == 0)  								(*tP3)++;  						}    					}    					bi.length <<= 1;    					// Normalize length  					while (tt [bi.length-1] == 0 && bi.length > 1) bi.length--;    				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,SquarePositive,The following statement contains a magic number: fixed (uint* dd = d' tt = t) {    					uint* ttE = tt + t.Length;  					// Clear the dest  					for (uint* ttt = tt; ttt < ttE; ttt++)  						*ttt = 0;    					uint* dP = dd' tP = tt;    					for (uint i = 0; i < dl; i++' dP++) {  						if (*dP == 0)  							continue;    						ulong mcarry = 0;  						uint bi1val = *dP;    						uint* dP2 = dP + 1' tP2 = tP + 2*i + 1;    						for (uint j = i + 1; j < dl; j++' tP2++' dP2++) {  							// k = i + j  							mcarry += ((ulong)bi1val * (ulong)*dP2) + *tP2;    							*tP2 = (uint)mcarry;  							mcarry >>= 32;  						}    						if (mcarry != 0)  							*tP2 = (uint)mcarry;  					}    					// Double t. Inlined for speed.    					tP = tt;    					uint x' carry = 0;  					while (tP < ttE) {  						x = *tP;  						*tP = (x << 1) | carry;  						carry = x >> (32 - 1);  						tP++;  					}  					if (carry != 0) *tP = carry;    					// Add in the diagnals    					dP = dd;  					tP = tt;  					for (uint* dE = dP + dl; (dP < dE); dP++' tP++) {  						ulong val = (ulong)*dP * (ulong)*dP + *tP;  						*tP = (uint)val;  						val >>= 32;  						*(++tP) += (uint)val;  						if (*tP < (uint)val) {  							uint* tP3 = tP;  							// Account for the first carry  							(*++tP3)++;    							// Keep adding until no carry  							while ((*tP3++) == 0)  								(*tP3)++;  						}    					}    					bi.length <<= 1;    					// Normalize length  					while (tt [bi.length-1] == 0 && bi.length > 1) bi.length--;    				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,SquarePositive,The following statement contains a magic number: fixed (uint* dd = d' tt = t) {    					uint* ttE = tt + t.Length;  					// Clear the dest  					for (uint* ttt = tt; ttt < ttE; ttt++)  						*ttt = 0;    					uint* dP = dd' tP = tt;    					for (uint i = 0; i < dl; i++' dP++) {  						if (*dP == 0)  							continue;    						ulong mcarry = 0;  						uint bi1val = *dP;    						uint* dP2 = dP + 1' tP2 = tP + 2*i + 1;    						for (uint j = i + 1; j < dl; j++' tP2++' dP2++) {  							// k = i + j  							mcarry += ((ulong)bi1val * (ulong)*dP2) + *tP2;    							*tP2 = (uint)mcarry;  							mcarry >>= 32;  						}    						if (mcarry != 0)  							*tP2 = (uint)mcarry;  					}    					// Double t. Inlined for speed.    					tP = tt;    					uint x' carry = 0;  					while (tP < ttE) {  						x = *tP;  						*tP = (x << 1) | carry;  						carry = x >> (32 - 1);  						tP++;  					}  					if (carry != 0) *tP = carry;    					// Add in the diagnals    					dP = dd;  					tP = tt;  					for (uint* dE = dP + dl; (dP < dE); dP++' tP++) {  						ulong val = (ulong)*dP * (ulong)*dP + *tP;  						*tP = (uint)val;  						val >>= 32;  						*(++tP) += (uint)val;  						if (*tP < (uint)val) {  							uint* tP3 = tP;  							// Account for the first carry  							(*++tP3)++;    							// Keep adding until no carry  							while ((*tP3++) == 0)  								(*tP3)++;  						}    					}    					bi.length <<= 1;    					// Normalize length  					while (tt [bi.length-1] == 0 && bi.length > 1) bi.length--;    				}
Magic Number,Granados.Mono.Math,Kernel,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,modInverse,The following statement contains a magic number: BigInteger [] q = new BigInteger [2];
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: switch (confidence) {  				case ConfidenceFactor.ExtraLow:  					Rounds >>= 2;  					return Rounds != 0 ? Rounds : 1;  				case ConfidenceFactor.Low:  					Rounds >>= 1;  					return Rounds != 0 ? Rounds : 1;  				case ConfidenceFactor.Medium:  					return Rounds;  				case ConfidenceFactor.High:  					return Rounds << 1;  				case ConfidenceFactor.ExtraHigh:  					return Rounds << 2;  				case ConfidenceFactor.Provable:  					throw new Exception ("The Rabin-Miller test can not be executed in a way such that its results are provable");  				default:  					throw new ArgumentOutOfRangeException ("confidence");  			}
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: switch (confidence) {  				case ConfidenceFactor.ExtraLow:  					Rounds >>= 2;  					return Rounds != 0 ? Rounds : 1;  				case ConfidenceFactor.Low:  					Rounds >>= 1;  					return Rounds != 0 ? Rounds : 1;  				case ConfidenceFactor.Medium:  					return Rounds;  				case ConfidenceFactor.High:  					return Rounds << 1;  				case ConfidenceFactor.ExtraHigh:  					return Rounds << 2;  				case ConfidenceFactor.Provable:  					throw new Exception ("The Rabin-Miller test can not be executed in a way such that its results are provable");  				default:  					throw new ArgumentOutOfRangeException ("confidence");  			}
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,Test,The following statement contains a magic number: if (n.BitCount () < 33)  				return SmallPrimeSppTest (n' confidence);  			else  				return RabinMillerTest (n' confidence);
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: if (n.BitCount () > 100)  				y = mr.Pow (2' r);
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: if (n.BitCount () > 100)  				y = mr.Pow (2' r);
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: for (int round = 0; round < t; round++) {    				if ((round > 0) || (y == null)) {  					BigInteger a = null;    					// check for 2 <= a <= n - 2  					// ...but we already did a == 2 previously as an optimization  					do {  						a = BigInteger.GenerateRandom (bits);  					} while ((a <= 2) && (a >= n_minus_1));    					y = mr.Pow (a' r);  				}    				if (y == 1)  					continue;    				for (int j = 0; ((j < s) && (y != n_minus_1)); j++) {    					y = mr.Pow (y' 2);  					if (y == 1)  						return false;  				}    				if (y != n_minus_1)  					return false;  			}
Magic Number,Granados.Mono.Math.Prime,PrimalityTests,C:\repos\poderosaproject_poderosa\Granados\Mono\PrimalityTests.cs,RabinMillerTest,The following statement contains a magic number: for (int round = 0; round < t; round++) {    				if ((round > 0) || (y == null)) {  					BigInteger a = null;    					// check for 2 <= a <= n - 2  					// ...but we already did a == 2 previously as an optimization  					do {  						a = BigInteger.GenerateRandom (bits);  					} while ((a <= 2) && (a >= n_minus_1));    					y = mr.Pow (a' r);  				}    				if (y == 1)  					continue;    				for (int j = 0; ((j < s) && (y != n_minus_1)); j++) {    					y = mr.Pow (y' 2);  					if (y == 1)  						return false;  				}    				if (y != n_minus_1)  					return false;  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\poderosaproject_poderosa\Granados\Mono\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 10; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' context))  					goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence))  					return curVal;    				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1)  					pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadObjectIdentifier,The following statement contains a magic number: if (ReadBinary(TagClass.Universal' false' TAG_OBJECTIDENTIFIER' out data)) {                  var s = new StringBuilder();                  s.Append((data[0] / 40).ToString(NumberFormatInfo.InvariantInfo));                  s.Append('.').Append((data[0] % 40).ToString(NumberFormatInfo.InvariantInfo));                    uint val = 0;                  for (int i = 1; i < data.Length; ++i) {                      val = (val << 7) | (data[i] & 0x7fu);                      if ((data[i] & 0x80) == 0) {                          s.Append('.').Append(val.ToString(NumberFormatInfo.InvariantInfo));                          val = 0;                      }                  }                    oid = s.ToString();                  return true;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadObjectIdentifier,The following statement contains a magic number: if (ReadBinary(TagClass.Universal' false' TAG_OBJECTIDENTIFIER' out data)) {                  var s = new StringBuilder();                  s.Append((data[0] / 40).ToString(NumberFormatInfo.InvariantInfo));                  s.Append('.').Append((data[0] % 40).ToString(NumberFormatInfo.InvariantInfo));                    uint val = 0;                  for (int i = 1; i < data.Length; ++i) {                      val = (val << 7) | (data[i] & 0x7fu);                      if ((data[i] & 0x80) == 0) {                          s.Append('.').Append(val.ToString(NumberFormatInfo.InvariantInfo));                          val = 0;                      }                  }                    oid = s.ToString();                  return true;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadObjectIdentifier,The following statement contains a magic number: if (ReadBinary(TagClass.Universal' false' TAG_OBJECTIDENTIFIER' out data)) {                  var s = new StringBuilder();                  s.Append((data[0] / 40).ToString(NumberFormatInfo.InvariantInfo));                  s.Append('.').Append((data[0] % 40).ToString(NumberFormatInfo.InvariantInfo));                    uint val = 0;                  for (int i = 1; i < data.Length; ++i) {                      val = (val << 7) | (data[i] & 0x7fu);                      if ((data[i] & 0x80) == 0) {                          s.Append('.').Append(val.ToString(NumberFormatInfo.InvariantInfo));                          val = 0;                      }                  }                    oid = s.ToString();                  return true;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadBitString,The following statement contains a magic number: if (ReadBinary(TagClass.Universal' false' TAG_BITSTRING' out data)) {                  int unusedBits = data[0];                  int offsetBytes = unusedBits / 8;                  int offsetBits = unusedBits % 8;                  int bitDataLength = data.Length - 1 - offsetBytes;                  byte[] bitData = new byte[bitDataLength];                  ushort w = 0;                  for (int i = 0; i < bitDataLength; ++i) {                      w = (ushort)((w << 8) | data[i + 1]);                      bitData[i] = (byte)(w >> offsetBits);                  }                  bits = bitData;                  return true;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadBitString,The following statement contains a magic number: if (ReadBinary(TagClass.Universal' false' TAG_BITSTRING' out data)) {                  int unusedBits = data[0];                  int offsetBytes = unusedBits / 8;                  int offsetBits = unusedBits % 8;                  int bitDataLength = data.Length - 1 - offsetBytes;                  byte[] bitData = new byte[bitDataLength];                  ushort w = 0;                  for (int i = 0; i < bitDataLength; ++i) {                      w = (ushort)((w << 8) | data[i + 1]);                      bitData[i] = (byte)(w >> offsetBits);                  }                  bits = bitData;                  return true;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadBitString,The following statement contains a magic number: if (ReadBinary(TagClass.Universal' false' TAG_BITSTRING' out data)) {                  int unusedBits = data[0];                  int offsetBytes = unusedBits / 8;                  int offsetBits = unusedBits % 8;                  int bitDataLength = data.Length - 1 - offsetBytes;                  byte[] bitData = new byte[bitDataLength];                  ushort w = 0;                  for (int i = 0; i < bitDataLength; ++i) {                      w = (ushort)((w << 8) | data[i + 1]);                      bitData[i] = (byte)(w >> offsetBits);                  }                  bits = bitData;                  return true;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadTag,The following statement contains a magic number: cls = (n >> 6) & 0x3;
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadTag,The following statement contains a magic number: while (true) {                  n = strm.ReadByte();                  if (n == -1)                      return false;                  num = (num << 7) | (n & 0x7f);                  if (bits == 0) {                      bits = 7;                      for (int mask = 0x40; bits != 0; mask >>= 1' bits--) {                          if ((n & mask) != 0)                              break;                      }                  }                  else {                      bits += 7;                      if (bits > 31)                          return false;                  }                  if ((n & 0x80) == 0)                      break;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadTag,The following statement contains a magic number: while (true) {                  n = strm.ReadByte();                  if (n == -1)                      return false;                  num = (num << 7) | (n & 0x7f);                  if (bits == 0) {                      bits = 7;                      for (int mask = 0x40; bits != 0; mask >>= 1' bits--) {                          if ((n & mask) != 0)                              break;                      }                  }                  else {                      bits += 7;                      if (bits > 31)                          return false;                  }                  if ((n & 0x80) == 0)                      break;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadTag,The following statement contains a magic number: while (true) {                  n = strm.ReadByte();                  if (n == -1)                      return false;                  num = (num << 7) | (n & 0x7f);                  if (bits == 0) {                      bits = 7;                      for (int mask = 0x40; bits != 0; mask >>= 1' bits--) {                          if ((n & mask) != 0)                              break;                      }                  }                  else {                      bits += 7;                      if (bits > 31)                          return false;                  }                  if ((n & 0x80) == 0)                      break;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadTag,The following statement contains a magic number: while (true) {                  n = strm.ReadByte();                  if (n == -1)                      return false;                  num = (num << 7) | (n & 0x7f);                  if (bits == 0) {                      bits = 7;                      for (int mask = 0x40; bits != 0; mask >>= 1' bits--) {                          if ((n & mask) != 0)                              break;                      }                  }                  else {                      bits += 7;                      if (bits > 31)                          return false;                  }                  if ((n & 0x80) == 0)                      break;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadLength,The following statement contains a magic number: for (int i = 0; i < octets; i++) {                  n = strm.ReadByte();                  if (n == -1)                      return false;                  num = (num << 8) | (n & 0xff);                  bits += 8;                  if (bits > 31)                      return false;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadLength,The following statement contains a magic number: for (int i = 0; i < octets; i++) {                  n = strm.ReadByte();                  if (n == -1)                      return false;                  num = (num << 8) | (n & 0xff);                  bits += 8;                  if (bits > 31)                      return false;              }
Magic Number,Granados.Poderosa.KeyFormat,BERReader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\BERReader.cs,ReadLength,The following statement contains a magic number: for (int i = 0; i < octets; i++) {                  n = strm.ReadByte();                  if (n == -1)                      return false;                  num = (num << 8) | (n & 0xff);                  bits += 8;                  if (bits > 31)                      return false;              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (StreamReader sreader = GetStreamReader()) {                  string line = sreader.ReadLine();                  if (line == null)                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                    if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_RSA)                      keyType = PEMKeyType.RSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_DSA)                      keyType = PEMKeyType.DSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_ECDSA)                      keyType = PEMKeyType.ECDSA;                  else                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected key type)");                    string footer = line.Replace("BEGIN"' "END");                    StringBuilder buf = new StringBuilder();                  comment = String.Empty;                  while (true) {                      line = sreader.ReadLine();                      if (line == null)                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                      if (line == footer)                          break;                      if (line.IndexOf(':') >= 0) {                          if (line.StartsWith("Proc-Type:")) {                              string[] w = line.Substring("Proc-Type:".Length).Trim().Split(''');                              if (w.Length < 1)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid Proc-Type)");                              if (w[0] != "4")                                  throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedProcType") + ")");                              if (w.Length >= 2 && w[1] == "ENCRYPTED")                                  encrypted = true;                          }                          else if (line.StartsWith("DEK-Info:")) {                              string[] w = line.Substring("DEK-Info:".Length).Trim().Split(''');                              if (w.Length < 2)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid DEK-Info)");                              switch (w[0]) {                                  case "DES-EDE3-CBC":                                      encryption = CipherAlgorithm.TripleDES;                                      ivSize = 8;                                      keySize = 24;                                      break;                                  case "AES-128-CBC":                                      encryption = CipherAlgorithm.AES128;                                      ivSize = 16;                                      keySize = 16;                                      break;                                  default:                                      throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedEncryptionType") + ")");                              }                              iv = HexToByteArray(w[1]);                              if (iv == null || iv.Length != ivSize)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid IV)");                          }                      }                      else                          buf.Append(line);                  }                  base64Text = buf.ToString();              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (StreamReader sreader = GetStreamReader()) {                  string line = sreader.ReadLine();                  if (line == null)                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                    if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_RSA)                      keyType = PEMKeyType.RSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_DSA)                      keyType = PEMKeyType.DSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_ECDSA)                      keyType = PEMKeyType.ECDSA;                  else                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected key type)");                    string footer = line.Replace("BEGIN"' "END");                    StringBuilder buf = new StringBuilder();                  comment = String.Empty;                  while (true) {                      line = sreader.ReadLine();                      if (line == null)                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                      if (line == footer)                          break;                      if (line.IndexOf(':') >= 0) {                          if (line.StartsWith("Proc-Type:")) {                              string[] w = line.Substring("Proc-Type:".Length).Trim().Split(''');                              if (w.Length < 1)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid Proc-Type)");                              if (w[0] != "4")                                  throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedProcType") + ")");                              if (w.Length >= 2 && w[1] == "ENCRYPTED")                                  encrypted = true;                          }                          else if (line.StartsWith("DEK-Info:")) {                              string[] w = line.Substring("DEK-Info:".Length).Trim().Split(''');                              if (w.Length < 2)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid DEK-Info)");                              switch (w[0]) {                                  case "DES-EDE3-CBC":                                      encryption = CipherAlgorithm.TripleDES;                                      ivSize = 8;                                      keySize = 24;                                      break;                                  case "AES-128-CBC":                                      encryption = CipherAlgorithm.AES128;                                      ivSize = 16;                                      keySize = 16;                                      break;                                  default:                                      throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedEncryptionType") + ")");                              }                              iv = HexToByteArray(w[1]);                              if (iv == null || iv.Length != ivSize)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid IV)");                          }                      }                      else                          buf.Append(line);                  }                  base64Text = buf.ToString();              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (StreamReader sreader = GetStreamReader()) {                  string line = sreader.ReadLine();                  if (line == null)                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                    if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_RSA)                      keyType = PEMKeyType.RSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_DSA)                      keyType = PEMKeyType.DSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_ECDSA)                      keyType = PEMKeyType.ECDSA;                  else                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected key type)");                    string footer = line.Replace("BEGIN"' "END");                    StringBuilder buf = new StringBuilder();                  comment = String.Empty;                  while (true) {                      line = sreader.ReadLine();                      if (line == null)                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                      if (line == footer)                          break;                      if (line.IndexOf(':') >= 0) {                          if (line.StartsWith("Proc-Type:")) {                              string[] w = line.Substring("Proc-Type:".Length).Trim().Split(''');                              if (w.Length < 1)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid Proc-Type)");                              if (w[0] != "4")                                  throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedProcType") + ")");                              if (w.Length >= 2 && w[1] == "ENCRYPTED")                                  encrypted = true;                          }                          else if (line.StartsWith("DEK-Info:")) {                              string[] w = line.Substring("DEK-Info:".Length).Trim().Split(''');                              if (w.Length < 2)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid DEK-Info)");                              switch (w[0]) {                                  case "DES-EDE3-CBC":                                      encryption = CipherAlgorithm.TripleDES;                                      ivSize = 8;                                      keySize = 24;                                      break;                                  case "AES-128-CBC":                                      encryption = CipherAlgorithm.AES128;                                      ivSize = 16;                                      keySize = 16;                                      break;                                  default:                                      throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedEncryptionType") + ")");                              }                              iv = HexToByteArray(w[1]);                              if (iv == null || iv.Length != ivSize)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid IV)");                          }                      }                      else                          buf.Append(line);                  }                  base64Text = buf.ToString();              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (StreamReader sreader = GetStreamReader()) {                  string line = sreader.ReadLine();                  if (line == null)                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                    if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_RSA)                      keyType = PEMKeyType.RSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_DSA)                      keyType = PEMKeyType.DSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_ECDSA)                      keyType = PEMKeyType.ECDSA;                  else                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected key type)");                    string footer = line.Replace("BEGIN"' "END");                    StringBuilder buf = new StringBuilder();                  comment = String.Empty;                  while (true) {                      line = sreader.ReadLine();                      if (line == null)                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                      if (line == footer)                          break;                      if (line.IndexOf(':') >= 0) {                          if (line.StartsWith("Proc-Type:")) {                              string[] w = line.Substring("Proc-Type:".Length).Trim().Split(''');                              if (w.Length < 1)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid Proc-Type)");                              if (w[0] != "4")                                  throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedProcType") + ")");                              if (w.Length >= 2 && w[1] == "ENCRYPTED")                                  encrypted = true;                          }                          else if (line.StartsWith("DEK-Info:")) {                              string[] w = line.Substring("DEK-Info:".Length).Trim().Split(''');                              if (w.Length < 2)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid DEK-Info)");                              switch (w[0]) {                                  case "DES-EDE3-CBC":                                      encryption = CipherAlgorithm.TripleDES;                                      ivSize = 8;                                      keySize = 24;                                      break;                                  case "AES-128-CBC":                                      encryption = CipherAlgorithm.AES128;                                      ivSize = 16;                                      keySize = 16;                                      break;                                  default:                                      throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedEncryptionType") + ")");                              }                              iv = HexToByteArray(w[1]);                              if (iv == null || iv.Length != ivSize)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid IV)");                          }                      }                      else                          buf.Append(line);                  }                  base64Text = buf.ToString();              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (StreamReader sreader = GetStreamReader()) {                  string line = sreader.ReadLine();                  if (line == null)                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                    if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_RSA)                      keyType = PEMKeyType.RSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_DSA)                      keyType = PEMKeyType.DSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_ECDSA)                      keyType = PEMKeyType.ECDSA;                  else                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected key type)");                    string footer = line.Replace("BEGIN"' "END");                    StringBuilder buf = new StringBuilder();                  comment = String.Empty;                  while (true) {                      line = sreader.ReadLine();                      if (line == null)                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                      if (line == footer)                          break;                      if (line.IndexOf(':') >= 0) {                          if (line.StartsWith("Proc-Type:")) {                              string[] w = line.Substring("Proc-Type:".Length).Trim().Split(''');                              if (w.Length < 1)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid Proc-Type)");                              if (w[0] != "4")                                  throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedProcType") + ")");                              if (w.Length >= 2 && w[1] == "ENCRYPTED")                                  encrypted = true;                          }                          else if (line.StartsWith("DEK-Info:")) {                              string[] w = line.Substring("DEK-Info:".Length).Trim().Split(''');                              if (w.Length < 2)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid DEK-Info)");                              switch (w[0]) {                                  case "DES-EDE3-CBC":                                      encryption = CipherAlgorithm.TripleDES;                                      ivSize = 8;                                      keySize = 24;                                      break;                                  case "AES-128-CBC":                                      encryption = CipherAlgorithm.AES128;                                      ivSize = 16;                                      keySize = 16;                                      break;                                  default:                                      throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedEncryptionType") + ")");                              }                              iv = HexToByteArray(w[1]);                              if (iv == null || iv.Length != ivSize)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid IV)");                          }                      }                      else                          buf.Append(line);                  }                  base64Text = buf.ToString();              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (StreamReader sreader = GetStreamReader()) {                  string line = sreader.ReadLine();                  if (line == null)                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                    if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_RSA)                      keyType = PEMKeyType.RSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_DSA)                      keyType = PEMKeyType.DSA;                  else if (line == PrivateKeyFileHeader.SSH2_OPENSSH_HEADER_ECDSA)                      keyType = PEMKeyType.ECDSA;                  else                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected key type)");                    string footer = line.Replace("BEGIN"' "END");                    StringBuilder buf = new StringBuilder();                  comment = String.Empty;                  while (true) {                      line = sreader.ReadLine();                      if (line == null)                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected eof)");                      if (line == footer)                          break;                      if (line.IndexOf(':') >= 0) {                          if (line.StartsWith("Proc-Type:")) {                              string[] w = line.Substring("Proc-Type:".Length).Trim().Split(''');                              if (w.Length < 1)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid Proc-Type)");                              if (w[0] != "4")                                  throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedProcType") + ")");                              if (w.Length >= 2 && w[1] == "ENCRYPTED")                                  encrypted = true;                          }                          else if (line.StartsWith("DEK-Info:")) {                              string[] w = line.Substring("DEK-Info:".Length).Trim().Split(''');                              if (w.Length < 2)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid DEK-Info)");                              switch (w[0]) {                                  case "DES-EDE3-CBC":                                      encryption = CipherAlgorithm.TripleDES;                                      ivSize = 8;                                      keySize = 24;                                      break;                                  case "AES-128-CBC":                                      encryption = CipherAlgorithm.AES128;                                      ivSize = 16;                                      keySize = 16;                                      break;                                  default:                                      throw new SSHException(Strings.GetString("UnsupportedPrivateKeyFormat")                                              + " (" + Strings.GetString("Reason_UnsupportedEncryptionType") + ")");                              }                              iv = HexToByteArray(w[1]);                              if (iv == null || iv.Length != ivSize)                                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid IV)");                          }                      }                      else                          buf.Append(line);                  }                  base64Text = buf.ToString();              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,HexToByteArray,The following statement contains a magic number: if (text.Length % 2 != 0) {                  return null;              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,PassphraseToKey,The following statement contains a magic number: const int HASH_SIZE = 16;
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHPKCSFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,PassphraseToKey,The following statement contains a magic number: const int SALT_SIZE = 8;
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (var blobStream = new MemoryStream(blob' false)) {                  if (!CheckMagic(blobStream)) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported format)");                  }                    string cipherName = ReadString(blobStream);                  CipherAlgorithm? cipherAlgorithm;                  int cipherKeySize;                  int cipherIVSize;                  switch (cipherName) {                      case "none":                          cipherAlgorithm = null;                          cipherKeySize = 0;                          cipherIVSize = 0;                          break;                      case "aes128-cbc":                          cipherAlgorithm = CipherAlgorithm.AES128;                          cipherKeySize = 16;                          cipherIVSize = 16;  // use block size                          break;                      case "aes192-cbc":                          cipherAlgorithm = CipherAlgorithm.AES192;                          cipherKeySize = 24;                          cipherIVSize = 16;  // use block size                          break;                      case "aes256-cbc":                          cipherAlgorithm = CipherAlgorithm.AES256;                          cipherKeySize = 32;                          cipherIVSize = 16;  // use block size                          break;                      default:                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported cipher)");                  }                    string kdfName = ReadString(blobStream);                  if (kdfName != "bcrypt" && kdfName != "none") {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported kdf)");                  }                    if ((cipherName == "none") != (kdfName == "none")) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid cipher)");                  }                    byte[] kdfOptions = ReadBytes(blobStream);                  if (kdfOptions == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing kdf options)");                  }                  byte[] kdfSalt;                  uint kdfRounds;                  byte[] key;                  byte[] iv;                  if (kdfName == "none") {                      kdfSalt = null;                      kdfRounds = 0;                      key = null;                      iv = null;                  }                  else {                      if (!ReadKdfOptions(kdfOptions' out kdfSalt' out kdfRounds)) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                        if (passphrase == null || passphrase.Length == 0) {                          throw new SSHException(Strings.GetString("WrongPassphrase"));                      }                        // prepare decryption                      Bcrypt bcrypt = new Bcrypt();                      byte[] tmpkey = bcrypt.BcryptPbkdf(passphrase' kdfSalt' kdfRounds' cipherKeySize + cipherIVSize);                      if (tmpkey == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                      key = new byte[cipherKeySize];                      Buffer.BlockCopy(tmpkey' 0' key' 0' cipherKeySize);                      iv = new byte[cipherIVSize];                      Buffer.BlockCopy(tmpkey' cipherKeySize' iv' 0' cipherIVSize);                  }                    if (!ReadInt32(blobStream' out numKeys) || numKeys < 0) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing keys)");                  }                    publicKeyBlobs = new byte[numKeys][];                  for (int i = 0; i < numKeys; ++i) {                      byte[] data = ReadBytes(blobStream);                      if (data == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing public keys)");                      }                      publicKeyBlobs[i] = data;                  }                    privateKeyData = ReadBytes(blobStream);                  if (privateKeyData == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing private keys)");                  }                    if (cipherAlgorithm.HasValue && key != null && iv != null) {                      // decrypt private keys                      Cipher cipher = CipherFactory.CreateCipher(SSHProtocol.SSH2' cipherAlgorithm.Value' key' iv);                      cipher.Decrypt(privateKeyData' 0' privateKeyData.Length' privateKeyData' 0);                      decrypted = true;                  }                  else {                      decrypted = false;                  }              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (var blobStream = new MemoryStream(blob' false)) {                  if (!CheckMagic(blobStream)) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported format)");                  }                    string cipherName = ReadString(blobStream);                  CipherAlgorithm? cipherAlgorithm;                  int cipherKeySize;                  int cipherIVSize;                  switch (cipherName) {                      case "none":                          cipherAlgorithm = null;                          cipherKeySize = 0;                          cipherIVSize = 0;                          break;                      case "aes128-cbc":                          cipherAlgorithm = CipherAlgorithm.AES128;                          cipherKeySize = 16;                          cipherIVSize = 16;  // use block size                          break;                      case "aes192-cbc":                          cipherAlgorithm = CipherAlgorithm.AES192;                          cipherKeySize = 24;                          cipherIVSize = 16;  // use block size                          break;                      case "aes256-cbc":                          cipherAlgorithm = CipherAlgorithm.AES256;                          cipherKeySize = 32;                          cipherIVSize = 16;  // use block size                          break;                      default:                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported cipher)");                  }                    string kdfName = ReadString(blobStream);                  if (kdfName != "bcrypt" && kdfName != "none") {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported kdf)");                  }                    if ((cipherName == "none") != (kdfName == "none")) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid cipher)");                  }                    byte[] kdfOptions = ReadBytes(blobStream);                  if (kdfOptions == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing kdf options)");                  }                  byte[] kdfSalt;                  uint kdfRounds;                  byte[] key;                  byte[] iv;                  if (kdfName == "none") {                      kdfSalt = null;                      kdfRounds = 0;                      key = null;                      iv = null;                  }                  else {                      if (!ReadKdfOptions(kdfOptions' out kdfSalt' out kdfRounds)) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                        if (passphrase == null || passphrase.Length == 0) {                          throw new SSHException(Strings.GetString("WrongPassphrase"));                      }                        // prepare decryption                      Bcrypt bcrypt = new Bcrypt();                      byte[] tmpkey = bcrypt.BcryptPbkdf(passphrase' kdfSalt' kdfRounds' cipherKeySize + cipherIVSize);                      if (tmpkey == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                      key = new byte[cipherKeySize];                      Buffer.BlockCopy(tmpkey' 0' key' 0' cipherKeySize);                      iv = new byte[cipherIVSize];                      Buffer.BlockCopy(tmpkey' cipherKeySize' iv' 0' cipherIVSize);                  }                    if (!ReadInt32(blobStream' out numKeys) || numKeys < 0) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing keys)");                  }                    publicKeyBlobs = new byte[numKeys][];                  for (int i = 0; i < numKeys; ++i) {                      byte[] data = ReadBytes(blobStream);                      if (data == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing public keys)");                      }                      publicKeyBlobs[i] = data;                  }                    privateKeyData = ReadBytes(blobStream);                  if (privateKeyData == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing private keys)");                  }                    if (cipherAlgorithm.HasValue && key != null && iv != null) {                      // decrypt private keys                      Cipher cipher = CipherFactory.CreateCipher(SSHProtocol.SSH2' cipherAlgorithm.Value' key' iv);                      cipher.Decrypt(privateKeyData' 0' privateKeyData.Length' privateKeyData' 0);                      decrypted = true;                  }                  else {                      decrypted = false;                  }              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (var blobStream = new MemoryStream(blob' false)) {                  if (!CheckMagic(blobStream)) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported format)");                  }                    string cipherName = ReadString(blobStream);                  CipherAlgorithm? cipherAlgorithm;                  int cipherKeySize;                  int cipherIVSize;                  switch (cipherName) {                      case "none":                          cipherAlgorithm = null;                          cipherKeySize = 0;                          cipherIVSize = 0;                          break;                      case "aes128-cbc":                          cipherAlgorithm = CipherAlgorithm.AES128;                          cipherKeySize = 16;                          cipherIVSize = 16;  // use block size                          break;                      case "aes192-cbc":                          cipherAlgorithm = CipherAlgorithm.AES192;                          cipherKeySize = 24;                          cipherIVSize = 16;  // use block size                          break;                      case "aes256-cbc":                          cipherAlgorithm = CipherAlgorithm.AES256;                          cipherKeySize = 32;                          cipherIVSize = 16;  // use block size                          break;                      default:                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported cipher)");                  }                    string kdfName = ReadString(blobStream);                  if (kdfName != "bcrypt" && kdfName != "none") {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported kdf)");                  }                    if ((cipherName == "none") != (kdfName == "none")) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid cipher)");                  }                    byte[] kdfOptions = ReadBytes(blobStream);                  if (kdfOptions == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing kdf options)");                  }                  byte[] kdfSalt;                  uint kdfRounds;                  byte[] key;                  byte[] iv;                  if (kdfName == "none") {                      kdfSalt = null;                      kdfRounds = 0;                      key = null;                      iv = null;                  }                  else {                      if (!ReadKdfOptions(kdfOptions' out kdfSalt' out kdfRounds)) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                        if (passphrase == null || passphrase.Length == 0) {                          throw new SSHException(Strings.GetString("WrongPassphrase"));                      }                        // prepare decryption                      Bcrypt bcrypt = new Bcrypt();                      byte[] tmpkey = bcrypt.BcryptPbkdf(passphrase' kdfSalt' kdfRounds' cipherKeySize + cipherIVSize);                      if (tmpkey == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                      key = new byte[cipherKeySize];                      Buffer.BlockCopy(tmpkey' 0' key' 0' cipherKeySize);                      iv = new byte[cipherIVSize];                      Buffer.BlockCopy(tmpkey' cipherKeySize' iv' 0' cipherIVSize);                  }                    if (!ReadInt32(blobStream' out numKeys) || numKeys < 0) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing keys)");                  }                    publicKeyBlobs = new byte[numKeys][];                  for (int i = 0; i < numKeys; ++i) {                      byte[] data = ReadBytes(blobStream);                      if (data == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing public keys)");                      }                      publicKeyBlobs[i] = data;                  }                    privateKeyData = ReadBytes(blobStream);                  if (privateKeyData == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing private keys)");                  }                    if (cipherAlgorithm.HasValue && key != null && iv != null) {                      // decrypt private keys                      Cipher cipher = CipherFactory.CreateCipher(SSHProtocol.SSH2' cipherAlgorithm.Value' key' iv);                      cipher.Decrypt(privateKeyData' 0' privateKeyData.Length' privateKeyData' 0);                      decrypted = true;                  }                  else {                      decrypted = false;                  }              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (var blobStream = new MemoryStream(blob' false)) {                  if (!CheckMagic(blobStream)) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported format)");                  }                    string cipherName = ReadString(blobStream);                  CipherAlgorithm? cipherAlgorithm;                  int cipherKeySize;                  int cipherIVSize;                  switch (cipherName) {                      case "none":                          cipherAlgorithm = null;                          cipherKeySize = 0;                          cipherIVSize = 0;                          break;                      case "aes128-cbc":                          cipherAlgorithm = CipherAlgorithm.AES128;                          cipherKeySize = 16;                          cipherIVSize = 16;  // use block size                          break;                      case "aes192-cbc":                          cipherAlgorithm = CipherAlgorithm.AES192;                          cipherKeySize = 24;                          cipherIVSize = 16;  // use block size                          break;                      case "aes256-cbc":                          cipherAlgorithm = CipherAlgorithm.AES256;                          cipherKeySize = 32;                          cipherIVSize = 16;  // use block size                          break;                      default:                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported cipher)");                  }                    string kdfName = ReadString(blobStream);                  if (kdfName != "bcrypt" && kdfName != "none") {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported kdf)");                  }                    if ((cipherName == "none") != (kdfName == "none")) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid cipher)");                  }                    byte[] kdfOptions = ReadBytes(blobStream);                  if (kdfOptions == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing kdf options)");                  }                  byte[] kdfSalt;                  uint kdfRounds;                  byte[] key;                  byte[] iv;                  if (kdfName == "none") {                      kdfSalt = null;                      kdfRounds = 0;                      key = null;                      iv = null;                  }                  else {                      if (!ReadKdfOptions(kdfOptions' out kdfSalt' out kdfRounds)) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                        if (passphrase == null || passphrase.Length == 0) {                          throw new SSHException(Strings.GetString("WrongPassphrase"));                      }                        // prepare decryption                      Bcrypt bcrypt = new Bcrypt();                      byte[] tmpkey = bcrypt.BcryptPbkdf(passphrase' kdfSalt' kdfRounds' cipherKeySize + cipherIVSize);                      if (tmpkey == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                      key = new byte[cipherKeySize];                      Buffer.BlockCopy(tmpkey' 0' key' 0' cipherKeySize);                      iv = new byte[cipherIVSize];                      Buffer.BlockCopy(tmpkey' cipherKeySize' iv' 0' cipherIVSize);                  }                    if (!ReadInt32(blobStream' out numKeys) || numKeys < 0) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing keys)");                  }                    publicKeyBlobs = new byte[numKeys][];                  for (int i = 0; i < numKeys; ++i) {                      byte[] data = ReadBytes(blobStream);                      if (data == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing public keys)");                      }                      publicKeyBlobs[i] = data;                  }                    privateKeyData = ReadBytes(blobStream);                  if (privateKeyData == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing private keys)");                  }                    if (cipherAlgorithm.HasValue && key != null && iv != null) {                      // decrypt private keys                      Cipher cipher = CipherFactory.CreateCipher(SSHProtocol.SSH2' cipherAlgorithm.Value' key' iv);                      cipher.Decrypt(privateKeyData' 0' privateKeyData.Length' privateKeyData' 0);                      decrypted = true;                  }                  else {                      decrypted = false;                  }              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (var blobStream = new MemoryStream(blob' false)) {                  if (!CheckMagic(blobStream)) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported format)");                  }                    string cipherName = ReadString(blobStream);                  CipherAlgorithm? cipherAlgorithm;                  int cipherKeySize;                  int cipherIVSize;                  switch (cipherName) {                      case "none":                          cipherAlgorithm = null;                          cipherKeySize = 0;                          cipherIVSize = 0;                          break;                      case "aes128-cbc":                          cipherAlgorithm = CipherAlgorithm.AES128;                          cipherKeySize = 16;                          cipherIVSize = 16;  // use block size                          break;                      case "aes192-cbc":                          cipherAlgorithm = CipherAlgorithm.AES192;                          cipherKeySize = 24;                          cipherIVSize = 16;  // use block size                          break;                      case "aes256-cbc":                          cipherAlgorithm = CipherAlgorithm.AES256;                          cipherKeySize = 32;                          cipherIVSize = 16;  // use block size                          break;                      default:                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported cipher)");                  }                    string kdfName = ReadString(blobStream);                  if (kdfName != "bcrypt" && kdfName != "none") {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported kdf)");                  }                    if ((cipherName == "none") != (kdfName == "none")) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid cipher)");                  }                    byte[] kdfOptions = ReadBytes(blobStream);                  if (kdfOptions == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing kdf options)");                  }                  byte[] kdfSalt;                  uint kdfRounds;                  byte[] key;                  byte[] iv;                  if (kdfName == "none") {                      kdfSalt = null;                      kdfRounds = 0;                      key = null;                      iv = null;                  }                  else {                      if (!ReadKdfOptions(kdfOptions' out kdfSalt' out kdfRounds)) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                        if (passphrase == null || passphrase.Length == 0) {                          throw new SSHException(Strings.GetString("WrongPassphrase"));                      }                        // prepare decryption                      Bcrypt bcrypt = new Bcrypt();                      byte[] tmpkey = bcrypt.BcryptPbkdf(passphrase' kdfSalt' kdfRounds' cipherKeySize + cipherIVSize);                      if (tmpkey == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                      key = new byte[cipherKeySize];                      Buffer.BlockCopy(tmpkey' 0' key' 0' cipherKeySize);                      iv = new byte[cipherIVSize];                      Buffer.BlockCopy(tmpkey' cipherKeySize' iv' 0' cipherIVSize);                  }                    if (!ReadInt32(blobStream' out numKeys) || numKeys < 0) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing keys)");                  }                    publicKeyBlobs = new byte[numKeys][];                  for (int i = 0; i < numKeys; ++i) {                      byte[] data = ReadBytes(blobStream);                      if (data == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing public keys)");                      }                      publicKeyBlobs[i] = data;                  }                    privateKeyData = ReadBytes(blobStream);                  if (privateKeyData == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing private keys)");                  }                    if (cipherAlgorithm.HasValue && key != null && iv != null) {                      // decrypt private keys                      Cipher cipher = CipherFactory.CreateCipher(SSHProtocol.SSH2' cipherAlgorithm.Value' key' iv);                      cipher.Decrypt(privateKeyData' 0' privateKeyData.Length' privateKeyData' 0);                      decrypted = true;                  }                  else {                      decrypted = false;                  }              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (var blobStream = new MemoryStream(blob' false)) {                  if (!CheckMagic(blobStream)) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported format)");                  }                    string cipherName = ReadString(blobStream);                  CipherAlgorithm? cipherAlgorithm;                  int cipherKeySize;                  int cipherIVSize;                  switch (cipherName) {                      case "none":                          cipherAlgorithm = null;                          cipherKeySize = 0;                          cipherIVSize = 0;                          break;                      case "aes128-cbc":                          cipherAlgorithm = CipherAlgorithm.AES128;                          cipherKeySize = 16;                          cipherIVSize = 16;  // use block size                          break;                      case "aes192-cbc":                          cipherAlgorithm = CipherAlgorithm.AES192;                          cipherKeySize = 24;                          cipherIVSize = 16;  // use block size                          break;                      case "aes256-cbc":                          cipherAlgorithm = CipherAlgorithm.AES256;                          cipherKeySize = 32;                          cipherIVSize = 16;  // use block size                          break;                      default:                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported cipher)");                  }                    string kdfName = ReadString(blobStream);                  if (kdfName != "bcrypt" && kdfName != "none") {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unsupported kdf)");                  }                    if ((cipherName == "none") != (kdfName == "none")) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid cipher)");                  }                    byte[] kdfOptions = ReadBytes(blobStream);                  if (kdfOptions == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing kdf options)");                  }                  byte[] kdfSalt;                  uint kdfRounds;                  byte[] key;                  byte[] iv;                  if (kdfName == "none") {                      kdfSalt = null;                      kdfRounds = 0;                      key = null;                      iv = null;                  }                  else {                      if (!ReadKdfOptions(kdfOptions' out kdfSalt' out kdfRounds)) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                        if (passphrase == null || passphrase.Length == 0) {                          throw new SSHException(Strings.GetString("WrongPassphrase"));                      }                        // prepare decryption                      Bcrypt bcrypt = new Bcrypt();                      byte[] tmpkey = bcrypt.BcryptPbkdf(passphrase' kdfSalt' kdfRounds' cipherKeySize + cipherIVSize);                      if (tmpkey == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid kdf options)");                      }                      key = new byte[cipherKeySize];                      Buffer.BlockCopy(tmpkey' 0' key' 0' cipherKeySize);                      iv = new byte[cipherIVSize];                      Buffer.BlockCopy(tmpkey' cipherKeySize' iv' 0' cipherIVSize);                  }                    if (!ReadInt32(blobStream' out numKeys) || numKeys < 0) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing keys)");                  }                    publicKeyBlobs = new byte[numKeys][];                  for (int i = 0; i < numKeys; ++i) {                      byte[] data = ReadBytes(blobStream);                      if (data == null) {                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing public keys)");                      }                      publicKeyBlobs[i] = data;                  }                    privateKeyData = ReadBytes(blobStream);                  if (privateKeyData == null) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (missing private keys)");                  }                    if (cipherAlgorithm.HasValue && key != null && iv != null) {                      // decrypt private keys                      Cipher cipher = CipherFactory.CreateCipher(SSHProtocol.SSH2' cipherAlgorithm.Value' key' iv);                      cipher.Decrypt(privateKeyData' 0' privateKeyData.Length' privateKeyData' 0);                      decrypted = true;                  }                  else {                      decrypted = false;                  }              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,Load,The following statement contains a magic number: using (var privateKeysStream = new MemoryStream(privateKeyData' false)) {                  uint check1' check2;                  if (!ReadUInt32(privateKeysStream' out check1) ||                      !ReadUInt32(privateKeysStream' out check2)) {                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid private keys)");                  }                  if (check1 != check2) {                      throw new SSHException(decrypted ?                          Strings.GetString("WrongPassphrase") : Strings.GetString("NotValidPrivateKeyFile"));                  }                    for (int i = 0; i < numKeys; ++i) {                      string privateKeyType = ReadString(privateKeysStream);                        using (var publicKeyBlobStream = new MemoryStream(publicKeyBlobs[i]' false)) {                          string publicKeyType = ReadString(publicKeyBlobStream);                          if (publicKeyType != privateKeyType) {                              throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (key type unmatched)");                          }                            switch (privateKeyType) {                              case "ssh-ed25519": {                                      byte[] pk = ReadBytes(privateKeysStream);                                      if (pk == null) {                                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile"));                                      }                                      byte[] sk = ReadBytes(privateKeysStream);                                      if (sk == null) {                                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile"));                                      }                                      string cmnt = ReadString(privateKeysStream);   // comment                                      if (cmnt == null) {                                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile"));                                      }                                        byte[] publicKey = ReadBytes(publicKeyBlobStream);                                      if (publicKey == null) {                                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile"));                                      }                                        // sanity check                                      if (!AreEqual(publicKey' pk)) {                                          throw new SSHException(Strings.GetString("WrongPassphrase"));                                      }                                        // first 32 bytes of secret key is used as a private key for ed25519                                      byte[] privateKey = new byte[32];                                      if (sk.Length < privateKey.Length) {                                          throw new SSHException(Strings.GetString("NotValidPrivateKeyFile"));                                      }                                      Buffer.BlockCopy(sk' 0' privateKey' 0' privateKey.Length);                                        var curve = EdwardsCurve.FindByAlgorithm(PublicKeyAlgorithm.ED25519);                                      if (curve != null) {                                          var kp = new EDDSAKeyPair(curve' new EDDSAPublicKey(curve' publicKey)' privateKey);                                          if (!kp.CheckKeyConsistency()) {                                              throw new SSHException(Strings.GetString("NotValidPrivateKeyFile"));                                          }                                          keyPair = kp;                                          comment = cmnt;                                          return;                                      }                                  }                                  break;                              default:                                  // unsupported key type; check the next key.                                  break;                          }                      }                  }              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,ReadUInt32,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {                  int n = s.ReadByte();                  if (n < 0) {                      val = 0;                      return false;                  }                  v = (v << 8) | (uint)(n & 0xff);              }
Magic Number,Granados.Poderosa.KeyFormat,OpenSSHFileLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\OpenSSHPrivateKeyLoader.cs,ReadUInt32,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {                  int n = s.ReadByte();                  if (n < 0) {                      val = 0;                      return false;                  }                  v = (v << 8) | (uint)(n & 0xff);              }
Magic Number,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,Load,The following statement contains a magic number: if (encryption.HasValue) {                  byte[] key = PuTTYPassphraseToKey(passphrase);                  byte[] iv = new byte[16];                  Cipher cipher = CipherFactory.CreateCipher(SSHProtocol.SSH2' encryption.Value' key' iv);                  if (privateBlob.Length % cipher.BlockSize != 0)                      throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (invalid key data size)");                  cipher.Decrypt(privateBlob' 0' privateBlob.Length' privateBlob' 0);              }
Magic Number,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,ReadHeaderLine,The following statement contains a magic number: if (line.StartsWith(PrivateKeyFileHeader.SSH2_PUTTY_HEADER_1))                  version = 1;              else if (line.StartsWith(PrivateKeyFileHeader.SSH2_PUTTY_HEADER_2))                  version = 2;              else                  throw new SSHException(Strings.GetString("NotValidPrivateKeyFile") + " (unexpected format type)");
Magic Number,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,PuTTYPassphraseToKey,The following statement contains a magic number: const int HASH_SIZE = 20;
Magic Number,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,PuTTYPassphraseToKey,The following statement contains a magic number: byte[] buf = new byte[HASH_SIZE * 2];
Magic Number,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,PuTTYPassphraseToKey,The following statement contains a magic number: sha1.TransformBlock(new byte[] { 0' 0' 0' 0 }' 0' 4' null' 0);
Magic Number,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,PuTTYPassphraseToKey,The following statement contains a magic number: sha1.TransformBlock(new byte[] { 0' 0' 0' 1 }' 0' 4' null' 0);
Magic Number,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,PuTTYPassphraseToKey,The following statement contains a magic number: byte[] key = new byte[32];
Magic Number,Granados.Poderosa.KeyFormat,PuTTYPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\PuTTYPrivateKeyLoader.cs,GetValueOf,The following statement contains a magic number: return line.Substring(p + 2);
Magic Number,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,Load,The following statement contains a magic number: byte[] cipher = reader.Read(2);
Magic Number,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,Load,The following statement contains a magic number: reader.Read(8);
Magic Number,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,Load,The following statement contains a magic number: byte[] mark = prvtreader.Read(4);
Magic Number,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,Load,The following statement contains a magic number: if (mark[0] != mark[2] || mark[1] != mark[3])                  throw new SSHException(Strings.GetString("WrongPassphrase"));
Magic Number,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,Load,The following statement contains a magic number: if (mark[0] != mark[2] || mark[1] != mark[3])                  throw new SSHException(Strings.GetString("WrongPassphrase"));
Magic Number,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,SSH1PassphraseToKey,The following statement contains a magic number: byte[] result = new byte[24];
Magic Number,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,SSH1PassphraseToKey,The following statement contains a magic number: Buffer.BlockCopy(md5' 0' result' 0' 16);
Magic Number,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,SSH1PassphraseToKey,The following statement contains a magic number: Buffer.BlockCopy(md5' 0' result' 16' 8);
Magic Number,Granados.Poderosa.KeyFormat,SSH1PrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSH1PrivateKeyLoader.cs,SSH1PassphraseToKey,The following statement contains a magic number: Buffer.BlockCopy(md5' 0' result' 16' 8);
Magic Number,Granados.Poderosa.KeyFormat,SSHComPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSHComPrivateKeyLoader.cs,ReadBigIntWithBits,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.Poderosa.KeyFormat,SSHComPrivateKeyLoader,C:\repos\poderosaproject_poderosa\Granados\Poderosa\KeyFormat\SSHComPrivateKeyLoader.cs,ReadBigIntWithBits,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,SendModTime,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0);
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,Download,The following statement contains a magic number: using (SCPChannelStream stream = new SCPChannelStream()) {                  stream.Open(_connection' command' _protocolTimeout);                  stream.Write(ZERO);                    while (true) {                      byte[] lineBytes = stream.ReadUntil(LF' _protocolTimeout);                      if (lineBytes[0] == 1 || lineBytes[0] == 2) {                          // Warning or Error                          string message = _encoding.GetString(lineBytes' 1' lineBytes.Length - 2);                          throw new SCPClientException(message);                      }                        if (lineBytes[0] == 0x43 /*'C'*/ || lineBytes[0] == 0x44 /*'D'*/) {                          SCPEntry entry;                          try {                              entry = ParseEntry(lineBytes);                          }                          catch (Exception e) {                              SendError(stream' e.Message);                              throw;                          }                            if (entry.IsDirectory) {                              string directoryPath = DeterminePathToCreate(localBasePath' absLocalPath' entry);                              bool continued = CreateDirectory(stream' directoryPath' modTime' cancellation' progressDelegate);                              if (!continued)                                  break;                              modTime = null;                              localBasePathStack.Push(localBasePath);                              localBasePath = directoryPath;                          }                          else {                              string filePath = DeterminePathToCreate(localBasePath' absLocalPath' entry);                              bool continued = CreateFile(stream' filePath' entry' modTime' cancellation' progressDelegate);                              if (!continued)                                  break;                              modTime = null;                              if (!recursive)                                  break;                          }                      }                      else if (lineBytes[0] == 0x54 /*'T'*/) {                          if (preserveTime) {                              try {                                  modTime = ParseModTime(lineBytes);                              }                              catch (Exception e) {                                  SendError(stream' e.Message);                                  throw;                              }                          }                          stream.Write(ZERO);                      }                      else if (lineBytes[0] == 0x45 /*'E'*/) {                          if (localBasePathStack.Count > 0) {                              localBasePath = localBasePathStack.Pop();                              if (localBasePath == null)                                  break;                          }                          stream.Write(ZERO);                      }                      else {                          SendError(stream' "Invalid control");                          throw new SCPClientException("Invalid control");                      }                  }                }
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,Download,The following statement contains a magic number: using (SCPChannelStream stream = new SCPChannelStream()) {                  stream.Open(_connection' command' _protocolTimeout);                  stream.Write(ZERO);                    while (true) {                      byte[] lineBytes = stream.ReadUntil(LF' _protocolTimeout);                      if (lineBytes[0] == 1 || lineBytes[0] == 2) {                          // Warning or Error                          string message = _encoding.GetString(lineBytes' 1' lineBytes.Length - 2);                          throw new SCPClientException(message);                      }                        if (lineBytes[0] == 0x43 /*'C'*/ || lineBytes[0] == 0x44 /*'D'*/) {                          SCPEntry entry;                          try {                              entry = ParseEntry(lineBytes);                          }                          catch (Exception e) {                              SendError(stream' e.Message);                              throw;                          }                            if (entry.IsDirectory) {                              string directoryPath = DeterminePathToCreate(localBasePath' absLocalPath' entry);                              bool continued = CreateDirectory(stream' directoryPath' modTime' cancellation' progressDelegate);                              if (!continued)                                  break;                              modTime = null;                              localBasePathStack.Push(localBasePath);                              localBasePath = directoryPath;                          }                          else {                              string filePath = DeterminePathToCreate(localBasePath' absLocalPath' entry);                              bool continued = CreateFile(stream' filePath' entry' modTime' cancellation' progressDelegate);                              if (!continued)                                  break;                              modTime = null;                              if (!recursive)                                  break;                          }                      }                      else if (lineBytes[0] == 0x54 /*'T'*/) {                          if (preserveTime) {                              try {                                  modTime = ParseModTime(lineBytes);                              }                              catch (Exception e) {                                  SendError(stream' e.Message);                                  throw;                              }                          }                          stream.Write(ZERO);                      }                      else if (lineBytes[0] == 0x45 /*'E'*/) {                          if (localBasePathStack.Count > 0) {                              localBasePath = localBasePathStack.Pop();                              if (localBasePath == null)                                  break;                          }                          stream.Write(ZERO);                      }                      else {                          SendError(stream' "Invalid control");                          throw new SCPClientException("Invalid control");                      }                  }                }
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,ParseEntry,The following statement contains a magic number: foreach (char c in m.Groups[2].Value.ToCharArray()) {                  permissions = (permissions << 3) | ((int)c - (int)'0');              }
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,ParseEntry,The following statement contains a magic number: foreach (char c in m.Groups[2].Value.ToCharArray()) {                  permissions = (permissions << 3) | ((int)c - (int)'0');              }
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,ParseEntry,The following statement contains a magic number: long fileSize = Int64.Parse(m.Groups[3].Value);
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,ParseEntry,The following statement contains a magic number: string name = m.Groups[4].Value;
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,ParseModTime,The following statement contains a magic number: long mtimeUSec = Int64.Parse(m.Groups[2].Value);
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,ParseModTime,The following statement contains a magic number: long atimeSec = Int64.Parse(m.Groups[3].Value);
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,ParseModTime,The following statement contains a magic number: long atimeUSec = Int64.Parse(m.Groups[4].Value);
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,ParseModTime,The following statement contains a magic number: DateTime mtime = new DateTime(EPOCH.Ticks + mtimeSec * 10000000L + mtimeUSec * 10);
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,ParseModTime,The following statement contains a magic number: DateTime atime = new DateTime(EPOCH.Ticks + atimeSec * 10000000L + atimeUSec * 10);
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,SendError,The following statement contains a magic number: byte[] data = new byte[messageBytes.Length + 2];
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,CheckResponse,The following statement contains a magic number: if (response == 1 || response == 2) {                  // Warning or Error                  // followed by a message which is terminated by LF                  byte[] messageData = stream.ReadUntil(LF' _protocolTimeout);                  string message = _encoding.GetString(messageData' 0' messageData.Length - 1);                  throw new SCPClientException(message);              }
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,GetPermissionsText,The following statement contains a magic number: return new StringBuilder()                  .Append("01234567"[(perm >> 9) & 0x7])                  .Append("01234567"[(perm >> 6) & 0x7])                  .Append("01234567"[(perm >> 3) & 0x7])                  .Append("01234567"[perm & 0x7])                  .ToString();
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,GetPermissionsText,The following statement contains a magic number: return new StringBuilder()                  .Append("01234567"[(perm >> 9) & 0x7])                  .Append("01234567"[(perm >> 6) & 0x7])                  .Append("01234567"[(perm >> 3) & 0x7])                  .Append("01234567"[perm & 0x7])                  .ToString();
Magic Number,Granados.Poderosa.SCP,SCPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPClient.cs,GetPermissionsText,The following statement contains a magic number: return new StringBuilder()                  .Append("01234567"[(perm >> 9) & 0x7])                  .Append("01234567"[(perm >> 6) & 0x7])                  .Append("01234567"[(perm >> 3) & 0x7])                  .Append("01234567"[perm & 0x7])                  .ToString();
Magic Number,Granados.Poderosa.SCP,SCPChannelStream,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPChannelStream.cs,GetPreferredDatagramSize,The following statement contains a magic number: return (_channel != null) ? Math.Max(1024' _channel.MaxChannelDatagramSize) : 1024;
Magic Number,Granados.Poderosa.SCP,SCPChannelStream,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SCP\SCPChannelStream.cs,GetPreferredDatagramSize,The following statement contains a magic number: return (_channel != null) ? Math.Max(1024' _channel.MaxChannelDatagramSize) : 1024;
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,Init,The following statement contains a magic number: _eventHandler.WaitResponse(                  (packetType' dataReader) => {                      if (packetType == SFTPPacketType.SSH_FXP_VERSION) {                          int version = dataReader.ReadInt32();                          Debug.WriteLine("SFTP: SSH_FXP_VERSION => " + version);                            result = true;   // OK' received SSH_FXP_VERSION                            while (dataReader.RemainingDataLength > 4) {                              string extensionText = dataReader.ReadUTF8String();                              Debug.WriteLine("SFTP: SSH_FXP_VERSION => " + extensionText);                          }                            return true;    // processed                      }                        return false;   // ignored                  }'                  _protocolTimeout              );
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,DownloadFile,The following statement contains a magic number: try {                  using (FileStream fileStream = new FileStream(localPath' FileMode.Create' FileAccess.Write' FileShare.Read)) {                        var dataToSave = new AtomicBox<DataFragment>();                      var cancelTask = new CancellationTokenSource();                      var cancelToken = cancelTask.Token;                        Task writeFileTask = Task.Run(() => {                          while (true) {                              DataFragment df = null;                              while (true) {                                  if (dataToSave.TryGet(ref df' 500)) {                                      break;                                  }                                  if (cancelToken.IsCancellationRequested) {                                      return;                                  }                              }                                if (df == null) {                                  dataFinished = true;                                  return; // end of file                              }                                fileStream.Write(df.Data' df.Offset' df.Length);                          }                      }' cancelToken);                        try {                          // fixed buffer size is used.                          // it is very difficult to decide optimal buffer size                          // because the server may change the packet size                          // depending on the available window size.                          const int buffSize = 0x10000;                          // use multiple buffers cyclically.                          // at least 3 buffers are required.                          DataFragment[] dataFrags =                              {                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                              };                          int buffIndex = 0;                            while (true) {                              if (cancellation != null && cancellation.IsRequested) {                                  break;                              }                                DataFragment df = dataFrags[buffIndex];                              buffIndex = (buffIndex + 1) % 3;                                int length = ReadFile(requestId' handle' transmitted' buffSize' df.Data);                              if (length == 0) {                                  df = null;  // end of file                              } else {                                  df.SetLength(0' length);                              }                                // pass to the writing task                              if (!dataToSave.TrySet(df' 1000)) {                                  throw new Exception("write error");                              }                                transmitted += (ulong)length;                                if (progressDelegate != null) {                                  progressDelegate(SFTPFileTransferStatus.Transmitting' transmitted);                              }                                if (length == 0) {                                  writeFileTask.Wait(1000);                                  break; // EOF                              }                          }                      }                      finally {                          if (!writeFileTask.IsCompleted) {                              cancelTask.Cancel();                          }                          writeFileTask.Wait();                      }                  }              }              catch (Exception e) {                  if (e is AggregateException) {                      pendingException = ((AggregateException)e).InnerExceptions[0];                  }                  else {                      pendingException = e;                  }                    hasError = true;              }
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,DownloadFile,The following statement contains a magic number: try {                  using (FileStream fileStream = new FileStream(localPath' FileMode.Create' FileAccess.Write' FileShare.Read)) {                        var dataToSave = new AtomicBox<DataFragment>();                      var cancelTask = new CancellationTokenSource();                      var cancelToken = cancelTask.Token;                        Task writeFileTask = Task.Run(() => {                          while (true) {                              DataFragment df = null;                              while (true) {                                  if (dataToSave.TryGet(ref df' 500)) {                                      break;                                  }                                  if (cancelToken.IsCancellationRequested) {                                      return;                                  }                              }                                if (df == null) {                                  dataFinished = true;                                  return; // end of file                              }                                fileStream.Write(df.Data' df.Offset' df.Length);                          }                      }' cancelToken);                        try {                          // fixed buffer size is used.                          // it is very difficult to decide optimal buffer size                          // because the server may change the packet size                          // depending on the available window size.                          const int buffSize = 0x10000;                          // use multiple buffers cyclically.                          // at least 3 buffers are required.                          DataFragment[] dataFrags =                              {                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                              };                          int buffIndex = 0;                            while (true) {                              if (cancellation != null && cancellation.IsRequested) {                                  break;                              }                                DataFragment df = dataFrags[buffIndex];                              buffIndex = (buffIndex + 1) % 3;                                int length = ReadFile(requestId' handle' transmitted' buffSize' df.Data);                              if (length == 0) {                                  df = null;  // end of file                              } else {                                  df.SetLength(0' length);                              }                                // pass to the writing task                              if (!dataToSave.TrySet(df' 1000)) {                                  throw new Exception("write error");                              }                                transmitted += (ulong)length;                                if (progressDelegate != null) {                                  progressDelegate(SFTPFileTransferStatus.Transmitting' transmitted);                              }                                if (length == 0) {                                  writeFileTask.Wait(1000);                                  break; // EOF                              }                          }                      }                      finally {                          if (!writeFileTask.IsCompleted) {                              cancelTask.Cancel();                          }                          writeFileTask.Wait();                      }                  }              }              catch (Exception e) {                  if (e is AggregateException) {                      pendingException = ((AggregateException)e).InnerExceptions[0];                  }                  else {                      pendingException = e;                  }                    hasError = true;              }
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,DownloadFile,The following statement contains a magic number: try {                  using (FileStream fileStream = new FileStream(localPath' FileMode.Create' FileAccess.Write' FileShare.Read)) {                        var dataToSave = new AtomicBox<DataFragment>();                      var cancelTask = new CancellationTokenSource();                      var cancelToken = cancelTask.Token;                        Task writeFileTask = Task.Run(() => {                          while (true) {                              DataFragment df = null;                              while (true) {                                  if (dataToSave.TryGet(ref df' 500)) {                                      break;                                  }                                  if (cancelToken.IsCancellationRequested) {                                      return;                                  }                              }                                if (df == null) {                                  dataFinished = true;                                  return; // end of file                              }                                fileStream.Write(df.Data' df.Offset' df.Length);                          }                      }' cancelToken);                        try {                          // fixed buffer size is used.                          // it is very difficult to decide optimal buffer size                          // because the server may change the packet size                          // depending on the available window size.                          const int buffSize = 0x10000;                          // use multiple buffers cyclically.                          // at least 3 buffers are required.                          DataFragment[] dataFrags =                              {                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                              };                          int buffIndex = 0;                            while (true) {                              if (cancellation != null && cancellation.IsRequested) {                                  break;                              }                                DataFragment df = dataFrags[buffIndex];                              buffIndex = (buffIndex + 1) % 3;                                int length = ReadFile(requestId' handle' transmitted' buffSize' df.Data);                              if (length == 0) {                                  df = null;  // end of file                              } else {                                  df.SetLength(0' length);                              }                                // pass to the writing task                              if (!dataToSave.TrySet(df' 1000)) {                                  throw new Exception("write error");                              }                                transmitted += (ulong)length;                                if (progressDelegate != null) {                                  progressDelegate(SFTPFileTransferStatus.Transmitting' transmitted);                              }                                if (length == 0) {                                  writeFileTask.Wait(1000);                                  break; // EOF                              }                          }                      }                      finally {                          if (!writeFileTask.IsCompleted) {                              cancelTask.Cancel();                          }                          writeFileTask.Wait();                      }                  }              }              catch (Exception e) {                  if (e is AggregateException) {                      pendingException = ((AggregateException)e).InnerExceptions[0];                  }                  else {                      pendingException = e;                  }                    hasError = true;              }
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,DownloadFile,The following statement contains a magic number: try {                  using (FileStream fileStream = new FileStream(localPath' FileMode.Create' FileAccess.Write' FileShare.Read)) {                        var dataToSave = new AtomicBox<DataFragment>();                      var cancelTask = new CancellationTokenSource();                      var cancelToken = cancelTask.Token;                        Task writeFileTask = Task.Run(() => {                          while (true) {                              DataFragment df = null;                              while (true) {                                  if (dataToSave.TryGet(ref df' 500)) {                                      break;                                  }                                  if (cancelToken.IsCancellationRequested) {                                      return;                                  }                              }                                if (df == null) {                                  dataFinished = true;                                  return; // end of file                              }                                fileStream.Write(df.Data' df.Offset' df.Length);                          }                      }' cancelToken);                        try {                          // fixed buffer size is used.                          // it is very difficult to decide optimal buffer size                          // because the server may change the packet size                          // depending on the available window size.                          const int buffSize = 0x10000;                          // use multiple buffers cyclically.                          // at least 3 buffers are required.                          DataFragment[] dataFrags =                              {                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                              };                          int buffIndex = 0;                            while (true) {                              if (cancellation != null && cancellation.IsRequested) {                                  break;                              }                                DataFragment df = dataFrags[buffIndex];                              buffIndex = (buffIndex + 1) % 3;                                int length = ReadFile(requestId' handle' transmitted' buffSize' df.Data);                              if (length == 0) {                                  df = null;  // end of file                              } else {                                  df.SetLength(0' length);                              }                                // pass to the writing task                              if (!dataToSave.TrySet(df' 1000)) {                                  throw new Exception("write error");                              }                                transmitted += (ulong)length;                                if (progressDelegate != null) {                                  progressDelegate(SFTPFileTransferStatus.Transmitting' transmitted);                              }                                if (length == 0) {                                  writeFileTask.Wait(1000);                                  break; // EOF                              }                          }                      }                      finally {                          if (!writeFileTask.IsCompleted) {                              cancelTask.Cancel();                          }                          writeFileTask.Wait();                      }                  }              }              catch (Exception e) {                  if (e is AggregateException) {                      pendingException = ((AggregateException)e).InnerExceptions[0];                  }                  else {                      pendingException = e;                  }                    hasError = true;              }
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,UploadFile,The following statement contains a magic number: try {                  using (FileStream fileStream = new FileStream(localPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {                        if (progressDelegate != null) {                          progressDelegate(SFTPFileTransferStatus.Open' transmitted);                      }                        handle = OpenFile(requestId' remotePath' SSH_FXF_WRITE | SSH_FXF_CREAT | SSH_FXF_TRUNC);                        var dataToSend = new AtomicBox<DataFragment>();                      var cancelTask = new CancellationTokenSource();                      var cancelToken = cancelTask.Token;                        Task readFileTask = Task.Run(() => {                          // SSH_FXP_WRITE header part                          //   4 bytes : packet length                          //   1 byte  : message type (SSH_FXP_WRITE)                          //   4 bytes : request id                          //   4 bytes : handle length                          //   n bytes : handle                          //   8 bytes : offset                          //   4 bytes : length of the datagram                          int buffSize = _channel.MaxChannelDatagramSize - 25 - handle.Length;                          // use multiple buffers cyclically.                          // at least 3 buffers are required.                          DataFragment[] dataFrags =                              {                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                              };                          int buffIndex = 0;                            while (true) {                              if (cancelToken.IsCancellationRequested) {                                  return;                              }                                DataFragment df = dataFrags[buffIndex];                              buffIndex = (buffIndex + 1) % 3;                                int length = fileStream.Read(df.Data' 0' df.Data.Length);                              if (length == 0) {                                  df = null;  // end of file                              }                              else {                                  df.SetLength(0' length);                              }                                // pass to the sending loop                              while (true) {                                  if (dataToSend.TrySet(df' 500)) {                                      break;                                  }                                  if (cancelToken.IsCancellationRequested) {                                      return;                                  }                              }                                if (length == 0) {                                  return; // end of file                              }                          }                      }' cancelToken);                        try {                          while (true) {                              if (cancellation != null && cancellation.IsRequested) {                                  break;                              }                                DataFragment dataFrag = null;                              if (!dataToSend.TryGet(ref dataFrag' 1000)) {                                  throw new Exception("read error");                              }                                if (dataFrag == null) {                                  dataFinished = true;                                  break;                              }                                WriteFile(requestId' handle' transmitted' dataFrag.Data' dataFrag.Length);                                transmitted += (ulong)dataFrag.Length;                                if (progressDelegate != null) {                                  progressDelegate(SFTPFileTransferStatus.Transmitting' transmitted);                              }                          }                      }                      finally {                          if (!readFileTask.IsCompleted) {                              cancelTask.Cancel();                          }                          readFileTask.Wait();                      }                  }   // using              }              catch (Exception e) {                  if (e is AggregateException) {                      pendingException = ((AggregateException)e).InnerExceptions[0];                  }                  else {                      pendingException = e;                  }                    hasError = true;              }
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,UploadFile,The following statement contains a magic number: try {                  using (FileStream fileStream = new FileStream(localPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {                        if (progressDelegate != null) {                          progressDelegate(SFTPFileTransferStatus.Open' transmitted);                      }                        handle = OpenFile(requestId' remotePath' SSH_FXF_WRITE | SSH_FXF_CREAT | SSH_FXF_TRUNC);                        var dataToSend = new AtomicBox<DataFragment>();                      var cancelTask = new CancellationTokenSource();                      var cancelToken = cancelTask.Token;                        Task readFileTask = Task.Run(() => {                          // SSH_FXP_WRITE header part                          //   4 bytes : packet length                          //   1 byte  : message type (SSH_FXP_WRITE)                          //   4 bytes : request id                          //   4 bytes : handle length                          //   n bytes : handle                          //   8 bytes : offset                          //   4 bytes : length of the datagram                          int buffSize = _channel.MaxChannelDatagramSize - 25 - handle.Length;                          // use multiple buffers cyclically.                          // at least 3 buffers are required.                          DataFragment[] dataFrags =                              {                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                              };                          int buffIndex = 0;                            while (true) {                              if (cancelToken.IsCancellationRequested) {                                  return;                              }                                DataFragment df = dataFrags[buffIndex];                              buffIndex = (buffIndex + 1) % 3;                                int length = fileStream.Read(df.Data' 0' df.Data.Length);                              if (length == 0) {                                  df = null;  // end of file                              }                              else {                                  df.SetLength(0' length);                              }                                // pass to the sending loop                              while (true) {                                  if (dataToSend.TrySet(df' 500)) {                                      break;                                  }                                  if (cancelToken.IsCancellationRequested) {                                      return;                                  }                              }                                if (length == 0) {                                  return; // end of file                              }                          }                      }' cancelToken);                        try {                          while (true) {                              if (cancellation != null && cancellation.IsRequested) {                                  break;                              }                                DataFragment dataFrag = null;                              if (!dataToSend.TryGet(ref dataFrag' 1000)) {                                  throw new Exception("read error");                              }                                if (dataFrag == null) {                                  dataFinished = true;                                  break;                              }                                WriteFile(requestId' handle' transmitted' dataFrag.Data' dataFrag.Length);                                transmitted += (ulong)dataFrag.Length;                                if (progressDelegate != null) {                                  progressDelegate(SFTPFileTransferStatus.Transmitting' transmitted);                              }                          }                      }                      finally {                          if (!readFileTask.IsCompleted) {                              cancelTask.Cancel();                          }                          readFileTask.Wait();                      }                  }   // using              }              catch (Exception e) {                  if (e is AggregateException) {                      pendingException = ((AggregateException)e).InnerExceptions[0];                  }                  else {                      pendingException = e;                  }                    hasError = true;              }
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,UploadFile,The following statement contains a magic number: try {                  using (FileStream fileStream = new FileStream(localPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {                        if (progressDelegate != null) {                          progressDelegate(SFTPFileTransferStatus.Open' transmitted);                      }                        handle = OpenFile(requestId' remotePath' SSH_FXF_WRITE | SSH_FXF_CREAT | SSH_FXF_TRUNC);                        var dataToSend = new AtomicBox<DataFragment>();                      var cancelTask = new CancellationTokenSource();                      var cancelToken = cancelTask.Token;                        Task readFileTask = Task.Run(() => {                          // SSH_FXP_WRITE header part                          //   4 bytes : packet length                          //   1 byte  : message type (SSH_FXP_WRITE)                          //   4 bytes : request id                          //   4 bytes : handle length                          //   n bytes : handle                          //   8 bytes : offset                          //   4 bytes : length of the datagram                          int buffSize = _channel.MaxChannelDatagramSize - 25 - handle.Length;                          // use multiple buffers cyclically.                          // at least 3 buffers are required.                          DataFragment[] dataFrags =                              {                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                              };                          int buffIndex = 0;                            while (true) {                              if (cancelToken.IsCancellationRequested) {                                  return;                              }                                DataFragment df = dataFrags[buffIndex];                              buffIndex = (buffIndex + 1) % 3;                                int length = fileStream.Read(df.Data' 0' df.Data.Length);                              if (length == 0) {                                  df = null;  // end of file                              }                              else {                                  df.SetLength(0' length);                              }                                // pass to the sending loop                              while (true) {                                  if (dataToSend.TrySet(df' 500)) {                                      break;                                  }                                  if (cancelToken.IsCancellationRequested) {                                      return;                                  }                              }                                if (length == 0) {                                  return; // end of file                              }                          }                      }' cancelToken);                        try {                          while (true) {                              if (cancellation != null && cancellation.IsRequested) {                                  break;                              }                                DataFragment dataFrag = null;                              if (!dataToSend.TryGet(ref dataFrag' 1000)) {                                  throw new Exception("read error");                              }                                if (dataFrag == null) {                                  dataFinished = true;                                  break;                              }                                WriteFile(requestId' handle' transmitted' dataFrag.Data' dataFrag.Length);                                transmitted += (ulong)dataFrag.Length;                                if (progressDelegate != null) {                                  progressDelegate(SFTPFileTransferStatus.Transmitting' transmitted);                              }                          }                      }                      finally {                          if (!readFileTask.IsCompleted) {                              cancelTask.Cancel();                          }                          readFileTask.Wait();                      }                  }   // using              }              catch (Exception e) {                  if (e is AggregateException) {                      pendingException = ((AggregateException)e).InnerExceptions[0];                  }                  else {                      pendingException = e;                  }                    hasError = true;              }
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,UploadFile,The following statement contains a magic number: try {                  using (FileStream fileStream = new FileStream(localPath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {                        if (progressDelegate != null) {                          progressDelegate(SFTPFileTransferStatus.Open' transmitted);                      }                        handle = OpenFile(requestId' remotePath' SSH_FXF_WRITE | SSH_FXF_CREAT | SSH_FXF_TRUNC);                        var dataToSend = new AtomicBox<DataFragment>();                      var cancelTask = new CancellationTokenSource();                      var cancelToken = cancelTask.Token;                        Task readFileTask = Task.Run(() => {                          // SSH_FXP_WRITE header part                          //   4 bytes : packet length                          //   1 byte  : message type (SSH_FXP_WRITE)                          //   4 bytes : request id                          //   4 bytes : handle length                          //   n bytes : handle                          //   8 bytes : offset                          //   4 bytes : length of the datagram                          int buffSize = _channel.MaxChannelDatagramSize - 25 - handle.Length;                          // use multiple buffers cyclically.                          // at least 3 buffers are required.                          DataFragment[] dataFrags =                              {                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                                  new DataFragment(new byte[buffSize]' 0' buffSize)'                              };                          int buffIndex = 0;                            while (true) {                              if (cancelToken.IsCancellationRequested) {                                  return;                              }                                DataFragment df = dataFrags[buffIndex];                              buffIndex = (buffIndex + 1) % 3;                                int length = fileStream.Read(df.Data' 0' df.Data.Length);                              if (length == 0) {                                  df = null;  // end of file                              }                              else {                                  df.SetLength(0' length);                              }                                // pass to the sending loop                              while (true) {                                  if (dataToSend.TrySet(df' 500)) {                                      break;                                  }                                  if (cancelToken.IsCancellationRequested) {                                      return;                                  }                              }                                if (length == 0) {                                  return; // end of file                              }                          }                      }' cancelToken);                        try {                          while (true) {                              if (cancellation != null && cancellation.IsRequested) {                                  break;                              }                                DataFragment dataFrag = null;                              if (!dataToSend.TryGet(ref dataFrag' 1000)) {                                  throw new Exception("read error");                              }                                if (dataFrag == null) {                                  dataFinished = true;                                  break;                              }                                WriteFile(requestId' handle' transmitted' dataFrag.Data' dataFrag.Length);                                transmitted += (ulong)dataFrag.Length;                                if (progressDelegate != null) {                                  progressDelegate(SFTPFileTransferStatus.Transmitting' transmitted);                              }                          }                      }                      finally {                          if (!readFileTask.IsCompleted) {                              cancelTask.Cancel();                          }                          readFileTask.Wait();                      }                  }   // using              }              catch (Exception e) {                  if (e is AggregateException) {                      pendingException = ((AggregateException)e).InnerExceptions[0];                  }                  else {                      pendingException = e;                  }                    hasError = true;              }
Magic Number,Granados.Poderosa.SFTP,SFTPClient,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,ReadFileAttributes,The following statement contains a magic number: uint permissions = 0666;
Magic Number,Granados.Poderosa.SFTP,SFTPClientChannelEventHandler,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,WaitResponse,The following statement contains a magic number: lock (_dataBufferSync) {                  bool processed = false;                  while (!processed) {                      while (_dataBuffer.Length < 4) {                          if (!Monitor.Wait(_dataBufferSync' millisecondsTimeout)) {                              throw new SFTPClientTimeoutException();                          }                      }                        int totalSize = SSHUtil.ReadInt32(_dataBuffer.RawBuffer' _dataBuffer.RawBufferOffset);                        while (_dataBuffer.Length < 4 + totalSize) {                          if (!Monitor.Wait(_dataBufferSync' millisecondsTimeout)) {                              throw new SFTPClientTimeoutException();                          }                      }                        _dataBuffer.RemoveHead(4);      // length field                        if (totalSize >= 1) {                          SSH2DataReader reader = new SSH2DataReader(                                      new DataFragment(_dataBuffer.RawBuffer' _dataBuffer.RawBufferOffset' totalSize));                          SFTPPacketType packetType = (SFTPPacketType)reader.ReadByte();                          if (responseHandler != null) {                              processed = responseHandler(packetType' reader);                          }                          else {                              processed = true;                          }                      }                        _dataBuffer.RemoveHead(totalSize);                  }              }
Magic Number,Granados.Poderosa.SFTP,SFTPClientChannelEventHandler,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,WaitResponse,The following statement contains a magic number: lock (_dataBufferSync) {                  bool processed = false;                  while (!processed) {                      while (_dataBuffer.Length < 4) {                          if (!Monitor.Wait(_dataBufferSync' millisecondsTimeout)) {                              throw new SFTPClientTimeoutException();                          }                      }                        int totalSize = SSHUtil.ReadInt32(_dataBuffer.RawBuffer' _dataBuffer.RawBufferOffset);                        while (_dataBuffer.Length < 4 + totalSize) {                          if (!Monitor.Wait(_dataBufferSync' millisecondsTimeout)) {                              throw new SFTPClientTimeoutException();                          }                      }                        _dataBuffer.RemoveHead(4);      // length field                        if (totalSize >= 1) {                          SSH2DataReader reader = new SSH2DataReader(                                      new DataFragment(_dataBuffer.RawBuffer' _dataBuffer.RawBufferOffset' totalSize));                          SFTPPacketType packetType = (SFTPPacketType)reader.ReadByte();                          if (responseHandler != null) {                              processed = responseHandler(packetType' reader);                          }                          else {                              processed = true;                          }                      }                        _dataBuffer.RemoveHead(totalSize);                  }              }
Magic Number,Granados.Poderosa.SFTP,SFTPClientChannelEventHandler,C:\repos\poderosaproject_poderosa\Granados\Poderosa\SFTP\SFTPClient.cs,WaitResponse,The following statement contains a magic number: lock (_dataBufferSync) {                  bool processed = false;                  while (!processed) {                      while (_dataBuffer.Length < 4) {                          if (!Monitor.Wait(_dataBufferSync' millisecondsTimeout)) {                              throw new SFTPClientTimeoutException();                          }                      }                        int totalSize = SSHUtil.ReadInt32(_dataBuffer.RawBuffer' _dataBuffer.RawBufferOffset);                        while (_dataBuffer.Length < 4 + totalSize) {                          if (!Monitor.Wait(_dataBufferSync' millisecondsTimeout)) {                              throw new SFTPClientTimeoutException();                          }                      }                        _dataBuffer.RemoveHead(4);      // length field                        if (totalSize >= 1) {                          SSH2DataReader reader = new SSH2DataReader(                                      new DataFragment(_dataBuffer.RawBuffer' _dataBuffer.RawBufferOffset' totalSize));                          SFTPPacketType packetType = (SFTPPacketType)reader.ReadByte();                          if (responseHandler != null) {                              processed = responseHandler(packetType' reader);                          }                          else {                              processed = true;                          }                      }                        _dataBuffer.RemoveHead(totalSize);                  }              }
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt16,The following statement contains a magic number: const int LENGTH = 2;
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt16,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 8)                  | ((uint)_data[_currentIndex + 1]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: const int LENGTH = 4;
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: const int LENGTH = 8;
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH1,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: ulong ret = ((ulong)i1 << 32) | i2;
Magic Number,Granados.IO.SSH1,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt32,The following statement contains a magic number: _strm.WriteByte((byte)(data >> 24));
Magic Number,Granados.IO.SSH1,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt32,The following statement contains a magic number: _strm.WriteByte((byte)(data >> 16));
Magic Number,Granados.IO.SSH1,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt32,The following statement contains a magic number: _strm.WriteByte((byte)(data >> 8));
Magic Number,Granados.IO.SSH1,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt64,The following statement contains a magic number: WriteUInt32((uint)(data >> 32));
Magic Number,Granados.IO.SSH1,SSH1DataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadMPInt,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.IO.SSH1,SSH1DataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadMPInt,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt16,The following statement contains a magic number: const int LENGTH = 2;
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt16,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 8)                  | ((uint)_data[_currentIndex + 1]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: const int LENGTH = 4;
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt32,The following statement contains a magic number: uint ret =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: const int LENGTH = 8;
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i1 =                    ((uint)_data[_currentIndex] << 24)                  | ((uint)_data[_currentIndex + 1] << 16)                  | ((uint)_data[_currentIndex + 2] << 8)                  | ((uint)_data[_currentIndex + 3]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: uint i2 =                    ((uint)_data[_currentIndex + 4] << 24)                  | ((uint)_data[_currentIndex + 5] << 16)                  | ((uint)_data[_currentIndex + 6] << 8)                  | ((uint)_data[_currentIndex + 7]);
Magic Number,Granados.IO.SSH2,SSHDataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadUInt64,The following statement contains a magic number: ulong ret = ((ulong)i1 << 32) | i2;
Magic Number,Granados.IO.SSH2,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt32,The following statement contains a magic number: _strm.WriteByte((byte)(data >> 24));
Magic Number,Granados.IO.SSH2,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt32,The following statement contains a magic number: _strm.WriteByte((byte)(data >> 16));
Magic Number,Granados.IO.SSH2,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt32,The following statement contains a magic number: _strm.WriteByte((byte)(data >> 8));
Magic Number,Granados.IO.SSH2,SSHDataWriter,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,WriteUInt64,The following statement contains a magic number: WriteUInt32((uint)(data >> 32));
Magic Number,Granados.IO.SSH2,SSH1DataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadMPInt,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.IO.SSH2,SSH1DataReader,C:\repos\poderosaproject_poderosa\Granados\ReaderWriter.cs,ReadMPInt,The following statement contains a magic number: int bytes = (bits + 7) / 8;
Magic Number,Granados.SSH,SSHConnection,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,Connect,The following statement contains a magic number: try {                  // receive protocol version string                  SSHProtocolVersionReceiver protoVerReceiver = new SSHProtocolVersionReceiver();                  protoVerReceiver.Receive(psocket' 5000);                  // verify the version string                  protoVerReceiver.Verify(param.Protocol);                    ISSHConnection sshConnection;                    if (param.Protocol == SSHProtocol.SSH1) {                      // create a connection object                      var con = new SSH1Connection(                                  psocket'                                  param'                                  protoVerReceiver.ServerVersion'                                  clientVersion'                                  connectionEventHandlerCreator'                                  protocolEventLoggerCreator);                      // start receiving loop                      psocket.RepeatAsyncRead();                      // send client version                      con.SendMyVersion();                      // establish a SSH connection                      con.Connect();                      sshConnection = con;                  }                  else {                      // create a connection object                      var con = new SSH2Connection(                                  psocket'                                  param'                                  protoVerReceiver.ServerVersion'                                  clientVersion'                                  connectionEventHandlerCreator'                                  protocolEventLoggerCreator);                      // start receiving loop                      psocket.RepeatAsyncRead();                      // send client version                      con.SendMyVersion();                      // establish a SSH connection                      con.Connect();                      sshConnection = con;                  }                    return sshConnection;              }              catch (Exception) {                  psocket.Close();                  throw;              }
Magic Number,Granados.SSH,SSHProtocolVersionReceiver,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,Receive,The following statement contains a magic number: using (MemoryStream mem = new MemoryStream()) {                  while (DateTime.UtcNow < tm && sock.SocketStatus == SocketStatus.Ready) {                      int n = sock.ReadIfAvailable(buf);                      if (n != 1) {                          Thread.Sleep(10);                          continue;                      }                      byte b = buf[0];                      mem.WriteByte(b);                      if (b == 0xa) { // LF                          byte[] bytestr = mem.ToArray();                          mem.SetLength(0);                          string line = Encoding.UTF8.GetString(bytestr).TrimEnd('\xd'' '\xa');                          _lines.Add(line);                          if (line.StartsWith("SSH-")) {                              _serverVersion = line;                              return true;                          }                      }                  }              }
Magic Number,Granados.SSH,SSHProtocolVersionReceiver,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,Verify,The following statement contains a magic number: if (sv.Length >= 3 && sv[0] == "SSH") {                  string protocolVersion = sv[1];                  string[] pv = protocolVersion.Split('.');                  if (pv.Length >= 2) {                      if (protocol == SSHProtocol.SSH1) {                          if (pv[0] == "1") {                              return; // OK                          }                      }                      else if (protocol == SSHProtocol.SSH2) {                          if (pv[0] == "2" || (pv[0] == "1" && pv[1] == "99")) {                              return; // OK                          }                      }                      throw new SSHException(                          String.Format(Strings.GetString("IncompatibleProtocolVersion")' _serverVersion' protocol.ToString()));                  }              }
Magic Number,Granados.SSH,SSHProtocolVersionReceiver,C:\repos\poderosaproject_poderosa\Granados\SSHConnection.cs,Verify,The following statement contains a magic number: if (sv.Length >= 3 && sv[0] == "SSH") {                  string protocolVersion = sv[1];                  string[] pv = protocolVersion.Split('.');                  if (pv.Length >= 2) {                      if (protocol == SSHProtocol.SSH1) {                          if (pv[0] == "1") {                              return; // OK                          }                      }                      else if (protocol == SSHProtocol.SSH2) {                          if (pv[0] == "2" || (pv[0] == "1" && pv[1] == "99")) {                              return; // OK                          }                      }                      throw new SSHException(                          String.Format(Strings.GetString("IncompatibleProtocolVersion")' _serverVersion' protocol.ToString()));                  }              }
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,Main,The following statement contains a magic number: int tutorial = 5;
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,Main,The following statement contains a magic number: if (tutorial == 0)                  GenerateRSAKey();              else if (tutorial == 1)                  GenerateDSAKey();              else if (tutorial == 2)                  ConnectAndOpenShell();              else if (tutorial == 3)                  ConnectSSH2AndPortforwarding();              else if (tutorial == 5)                  AgentForward();
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,Main,The following statement contains a magic number: if (tutorial == 0)                  GenerateRSAKey();              else if (tutorial == 1)                  GenerateDSAKey();              else if (tutorial == 2)                  ConnectAndOpenShell();              else if (tutorial == 3)                  ConnectSSH2AndPortforwarding();              else if (tutorial == 5)                  AgentForward();
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,Main,The following statement contains a magic number: if (tutorial == 0)                  GenerateRSAKey();              else if (tutorial == 1)                  GenerateDSAKey();              else if (tutorial == 2)                  ConnectAndOpenShell();              else if (tutorial == 3)                  ConnectSSH2AndPortforwarding();              else if (tutorial == 5)                  AgentForward();
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,GenerateRSAKey,The following statement contains a magic number: RSAKeyPair kp = RSAKeyPair.GenerateNew(2048' RngManager.GetSecureRng());
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,GenerateDSAKey,The following statement contains a magic number: DSAKeyPair kp = DSAKeyPair.GenerateNew(2048' RngManager.GetSecureRng());
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,ConnectAndOpenShell,The following statement contains a magic number: SSHConnectionParameter f = new SSHConnectionParameter("172.22.1.15"' 22' SSHProtocol.SSH2' AuthenticationType.PublicKey' "okajima"' "aaa");
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,ConnectSSH2AndPortforwarding,The following statement contains a magic number: SSHConnectionParameter f = new SSHConnectionParameter("10.10.9.8"' 22' SSHProtocol.SSH2' AuthenticationType.Password' "root"' "");
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,ConnectSSH2AndPortforwarding,The following statement contains a magic number: while (!reader._ready)                  System.Threading.Thread.Sleep(100);
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,AgentForward,The following statement contains a magic number: SSHConnectionParameter f = new SSHConnectionParameter("172.22.1.15"' 22' SSHProtocol.SSH2' AuthenticationType.Password' "root"' "");
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,AgentForward,The following statement contains a magic number: while (!reader._ready)                  Thread.Sleep(100);
Magic Number,Granados.Tutorial,Tutorial,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,AgentForward,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,Granados.Tutorial,SampleKeyboardInteractiveAuthenticationHandler,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,GetResult,The following statement contains a magic number: _box.TryGet(ref result' 10000);
Magic Number,Granados.Tutorial,SampleKeyboardInteractiveAuthenticationHandler,C:\repos\poderosaproject_poderosa\Granados\Tutorial.cs,OnKeyboardInteractiveAuthenticationCompleted,The following statement contains a magic number: _box.TrySet(success' 10000);
Duplicate Code,Granados.SSH2,SSH2KeyExchanger,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,GetDiffieHellmanPrime,The method contains a code clone-set at the following line numbers (starting from the method definition): ((41' 60)' (71' 90))
Missing Default,Granados.SSH1,SSH1InteractiveSession,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,ProcessPacket,The following switch statement is missing a default case: switch (_state) {                      case State.Initial:                          break;                      case State.WaitStartPTYResponse:                          if (packetType == SSH1PacketType.SSH_SMSG_SUCCESS) {                              _state = State.StartPTYSuccess;                              Monitor.PulseAll(_stateSync);   // notifies state change                              _receivedPacket.TrySet(packetFragment' PASSING_TIMEOUT);                          }                          else if (packetType == SSH1PacketType.SSH_SMSG_FAILURE) {                              _state = State.StartPTYFailure;                              Monitor.PulseAll(_stateSync);   // notifies state change                              _receivedPacket.TrySet(packetFragment' PASSING_TIMEOUT);                          }                          break;                      case State.Established:                          break;                      case State.Ready:                          switch (packetType) {                              case SSH1PacketType.SSH_SMSG_STDOUT_DATA: {                                      SSH1DataReader reader = new SSH1DataReader(packetFragment);                                      int len = reader.ReadInt32();                                      dataFragmentArg = reader.GetRemainingDataView(len);                                  }                                  goto OnData;    // do it out of the lock block                              case SSH1PacketType.SSH_SMSG_STDERR_DATA: {                                      SSH1DataReader reader = new SSH1DataReader(packetFragment);                                      int len = reader.ReadInt32();                                      dataFragmentArg = reader.GetRemainingDataView(len);                                  }                                  goto OnData;    // do it out of the lock block                              case SSH1PacketType.SSH_SMSG_EXITSTATUS:                                  Transmit(                                      new SSH1Packet(SSH1PacketType.SSH_CMSG_EXIT_CONFIRMATION)                                  );                                  goto SetStateClosedByServer;    // do it out of the lock block                          }                          goto OnUnhandledPacket; // do it out of the lock block                  }
Missing Default,Granados.SSH1,SSH1InteractiveSession,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,ProcessPacket,The following switch statement is missing a default case: switch (packetType) {                              case SSH1PacketType.SSH_SMSG_STDOUT_DATA: {                                      SSH1DataReader reader = new SSH1DataReader(packetFragment);                                      int len = reader.ReadInt32();                                      dataFragmentArg = reader.GetRemainingDataView(len);                                  }                                  goto OnData;    // do it out of the lock block                              case SSH1PacketType.SSH_SMSG_STDERR_DATA: {                                      SSH1DataReader reader = new SSH1DataReader(packetFragment);                                      int len = reader.ReadInt32();                                      dataFragmentArg = reader.GetRemainingDataView(len);                                  }                                  goto OnData;    // do it out of the lock block                              case SSH1PacketType.SSH_SMSG_EXITSTATUS:                                  Transmit(                                      new SSH1Packet(SSH1PacketType.SSH_CMSG_EXIT_CONFIRMATION)                                  );                                  goto SetStateClosedByServer;    // do it out of the lock block                          }
Missing Default,Granados.SSH1,SSH1SubChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,ProcessPacket,The following switch statement is missing a default case: switch (_state) {                      case State.InitiatedByServer:                          break;                      case State.InitiatedByClient:                          if (packetType == SSH1PacketType.SSH_MSG_CHANNEL_OPEN_CONFIRMATION) {                              SSH1DataReader reader = new SSH1DataReader(packetFragment);                              SetRemoteChannel(reader.ReadUInt32());                              _state = State.Established;                              Monitor.PulseAll(_stateSync);   // notifies state change                              dataFragmentArg = new DataFragment(0);                              goto OnEstablished; // do it out of the lock block                          }                          if (packetType == SSH1PacketType.SSH_MSG_CHANNEL_OPEN_FAILURE) {                              goto RequestFailed; // do it out of the lock block                          }                          break;                      case State.Closing:                          if (packetType == SSH1PacketType.SSH_MSG_CHANNEL_CLOSE_CONFIRMATION) {                              goto SetStateClosedByClient;    // do it out of the lock block                          }                          break;                      case State.Established:                      case State.Ready:                          if (ProcessPacketSub(packetType' packetFragment) == SubPacketProcessResult.Consumed) {                              return;                          }                          switch (packetType) {                              case SSH1PacketType.SSH_MSG_CHANNEL_DATA: {                                      SSH1DataReader reader = new SSH1DataReader(packetFragment);                                      int len = reader.ReadInt32();                                      dataFragmentArg = reader.GetRemainingDataView(len);                                  }                                  goto OnData;    // do it out of the lock block                              case SSH1PacketType.SSH_MSG_CHANNEL_CLOSE:                                  Transmit(                                      new SSH1Packet(SSH1PacketType.SSH_MSG_CHANNEL_CLOSE_CONFIRMATION)                                          .WriteUInt32(RemoteChannel)                                  );                                  goto SetStateClosedByServer;    // do it out of the lock block                          }                          goto OnUnhandledPacket; // do it out of the lock block                  }
Missing Default,Granados.SSH1,SSH1SubChannelBase,C:\repos\poderosaproject_poderosa\Granados\SSH1Channel.cs,ProcessPacket,The following switch statement is missing a default case: switch (packetType) {                              case SSH1PacketType.SSH_MSG_CHANNEL_DATA: {                                      SSH1DataReader reader = new SSH1DataReader(packetFragment);                                      int len = reader.ReadInt32();                                      dataFragmentArg = reader.GetRemainingDataView(len);                                  }                                  goto OnData;    // do it out of the lock block                              case SSH1PacketType.SSH_MSG_CHANNEL_CLOSE:                                  Transmit(                                      new SSH1Packet(SSH1PacketType.SSH_MSG_CHANNEL_CLOSE_CONFIRMATION)                                          .WriteUInt32(RemoteChannel)                                  );                                  goto SetStateClosedByServer;    // do it out of the lock block                          }
Missing Default,Granados.SSH1,SSH1SynchronousPacketHandler,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,BeforeSend,The following switch statement is missing a default case: switch (packetType) {                  case SSH1PacketType.SSH_CMSG_STDIN_DATA:                  case SSH1PacketType.SSH_SMSG_STDOUT_DATA:                  case SSH1PacketType.SSH_SMSG_STDERR_DATA:                  case SSH1PacketType.SSH_MSG_CHANNEL_DATA:                  case SSH1PacketType.SSH_MSG_IGNORE:                  case SSH1PacketType.SSH_MSG_DEBUG:                      return;              }
Missing Default,Granados.SSH1,SSH1SynchronousPacketHandler,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,AfterReceived,The following switch statement is missing a default case: switch (packetType) {                  case SSH1PacketType.SSH_CMSG_STDIN_DATA:                  case SSH1PacketType.SSH_SMSG_STDOUT_DATA:                  case SSH1PacketType.SSH_SMSG_STDERR_DATA:                  case SSH1PacketType.SSH_MSG_CHANNEL_DATA:                  case SSH1PacketType.SSH_MSG_IGNORE:                  case SSH1PacketType.SSH_MSG_DEBUG:                      return;              }
Missing Default,Granados.SSH1,SSH1RemotePortForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,InterceptPacket,The following switch statement is missing a default case: switch (_sequenceStatus) {                      case SequenceStatus.WaitPortForwardResponse:                          if (packetType == SSH1PacketType.SSH_SMSG_SUCCESS) {                              _sequenceStatus = SequenceStatus.PortForwardSuccess;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          if (packetType == SSH1PacketType.SSH_SMSG_FAILURE) {                              _sequenceStatus = SequenceStatus.PortForwardFailure;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          break;                  }
Missing Default,Granados.SSH1,SSH1AgentForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,InterceptPacket,The following switch statement is missing a default case: switch (_sequenceStatus) {                      case SequenceStatus.WaitAgentForwardingResponse:                          if (packetType == SSH1PacketType.SSH_SMSG_SUCCESS) {                              _sequenceStatus = SequenceStatus.AgentForwardingSuccess;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          if (packetType == SSH1PacketType.SSH_SMSG_FAILURE) {                              _sequenceStatus = SequenceStatus.AgentForwardingFailure;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          break;                  }
Missing Default,Granados.SSH1,SSH1X11Forwarding,C:\repos\poderosaproject_poderosa\Granados\SSH1Connection.cs,InterceptPacket,The following switch statement is missing a default case: switch (_sequenceStatus) {                      case SequenceStatus.WaitX11ForwardResponse:                          if (packetType == SSH1PacketType.SSH_SMSG_SUCCESS) {                              _sequenceStatus = SequenceStatus.X11ForwardSuccess;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          if (packetType == SSH1PacketType.SSH_SMSG_FAILURE) {                              _sequenceStatus = SequenceStatus.X11ForwardFailure;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          break;                  }
Missing Default,Granados.SSH2,SSH2Connection,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,DoProcessPacket,The following switch statement is missing a default case: switch (packetType) {                  case SSH2PacketType.SSH_MSG_DISCONNECT: {                          int errorcode = reader.ReadInt32();                          _eventHandler.OnConnectionClosed();                      }                      return;                  case SSH2PacketType.SSH_MSG_IGNORE: {                          _eventHandler.OnIgnoreMessage(reader.ReadByteString());                      }                      return;                  case SSH2PacketType.SSH_MSG_DEBUG: {                          bool alwaysDisplay = reader.ReadBool();                          string message = reader.ReadUTF8String();                          string languageTag = reader.ReadString();                          _eventHandler.OnDebugMessage(alwaysDisplay' message);                      }                      return;                  case SSH2PacketType.SSH_MSG_GLOBAL_REQUEST: {                          string requestName = reader.ReadString();                          bool wantReply = reader.ReadBool();                          _protocolEventManager.Trace("Unhandled request: name={0} wantReply={1}"' requestName' wantReply);                          if (wantReply) {                              Transmit(                                  new SSH2Packet(SSH2PacketType.SSH_MSG_REQUEST_FAILURE)                              );                          }                      }                      return;                  case SSH2PacketType.SSH_MSG_CHANNEL_OPEN: { // unhandled channel-open request                          string channelType = reader.ReadString();                          uint remoteChannel = reader.ReadUInt32();                          _protocolEventManager.Trace("Unhandled channel open: channelType={0} remoteChannel={1}"' channelType' remoteChannel);                          _syncHandler.Send(                              new SSH2ChannelOpenFailurePacket(                                  remoteChannel'                                  "Unknown channel type"'                                  SSH2ChannelOpenFailureCode.SSH_OPEN_UNKNOWN_CHANNEL_TYPE                              )                          );                      }                      return;              }
Missing Default,Granados.SSH2,SSH2SynchronousPacketHandler,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,BeforeSend,The following switch statement is missing a default case: switch (packetType) {                  case SSH2PacketType.SSH_MSG_CHANNEL_DATA:                  case SSH2PacketType.SSH_MSG_CHANNEL_EXTENDED_DATA:                  case SSH2PacketType.SSH_MSG_IGNORE:                  case SSH2PacketType.SSH_MSG_DEBUG:                      return;              }
Missing Default,Granados.SSH2,SSH2SynchronousPacketHandler,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,AfterReceived,The following switch statement is missing a default case: switch (packetType) {                  case SSH2PacketType.SSH_MSG_CHANNEL_DATA:                  case SSH2PacketType.SSH_MSG_CHANNEL_EXTENDED_DATA:                  case SSH2PacketType.SSH_MSG_IGNORE:                  case SSH2PacketType.SSH_MSG_DEBUG:                      return;              }
Missing Default,Granados.SSH2,SSH2RemotePortForwarding,C:\repos\poderosaproject_poderosa\Granados\SSH2Connection.cs,InterceptPacket,The following switch statement is missing a default case: switch (_sequenceStatus) {                      case SequenceStatus.WaitTcpIpForwardResponse:                          if (packetType == SSH2PacketType.SSH_MSG_REQUEST_SUCCESS) {                              _sequenceStatus = SequenceStatus.TcpIpForwardSuccess;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          if (packetType == SSH2PacketType.SSH_MSG_REQUEST_FAILURE) {                              _sequenceStatus = SequenceStatus.TcpIpForwardFailure;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          break;                        case SequenceStatus.WaitCancelTcpIpForwardResponse:                          if (packetType == SSH2PacketType.SSH_MSG_REQUEST_SUCCESS) {                              _sequenceStatus = SequenceStatus.CancelTcpIpForwardSuccess;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          if (packetType == SSH2PacketType.SSH_MSG_REQUEST_FAILURE) {                              _sequenceStatus = SequenceStatus.CancelTcpIpForwardFailure;                              _receivedPacket.TrySet(packet' PASSING_TIMEOUT);                              return SSHPacketInterceptorResult.Consumed;                          }                          break;                  }
Missing Default,Granados.Mono.Math,BigInteger,C:\repos\poderosaproject_poderosa\Granados\Mono\BigInteger.cs,BigInteger,The following switch statement is missing a default case: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
