Implementation smell,Namespace,Class,File,Method,Description
Complex Method,HellBrick.Collections,AsyncCollection<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncCollection.cs,TakeFromAnyAsync,Cyclomatic complexity of the method is 9
Long Identifier,HellBrick.Collections.Internal,ExclusiveCompletionSourceGroup<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\Internal\ExclusiveCompletionSourceGroup.cs,,The length of the parameter _cancellationRegistrationHolder is 31.
Long Statement,HellBrick.Collections,Batch,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncBatchQueue.cs,TryAdd,The length of the statement  "				//	The following is true if someone has beaten us to the last slot and we have to wait until the next batch comes along. " is 120.
Long Statement,HellBrick.Collections,Batch,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncBatchQueue.cs,TryAdd,The length of the statement  "				//	The following is true if we've taken the last slot' which means we're obligated to flush the current batch and create a new one. " is 131.
Long Statement,HellBrick.Collections,Batch,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncBatchQueue.cs,TryFlush,The length of the statement  "				int previousReservation = Interlocked.CompareExchange( ref _lastReservationIndex' _queue.BatchSize' expectedPreviousReservation ); " is 130.
Long Statement,HellBrick.Collections,AsyncBoundedPriorityQueue<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncBoundedPriorityQueue.cs,Add,The length of the statement  "				throw new ArgumentOutOfRangeException( nameof( priority )' priority' $"Priority can't be less than 0 or bigger than {PriorityLevels - 1}." ); " is 141.
Long Statement,HellBrick.Collections,AsyncBoundedPriorityQueue<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncBoundedPriorityQueue.cs,TakeAsync,The length of the statement  "			return prioritizedItemTask.IsCompletedSuccessfully ? new ValueTask<T>( prioritizedItemTask.Result.Item ) : new ValueTask<T>( UnwrapAsync( prioritizedItemTask ) ); " is 162.
Long Statement,HellBrick.Collections,AsyncCollection<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncCollection.cs,TakeFromAnyAsync,The length of the statement  "				throw new ArgumentException( String.Format( "The collection array can't contain less than 1 or more than {0} collections."' TakeFromAnyMaxCollections )' "collections" ); " is 169.
Long Statement,HellBrick.Collections,AsyncQueue<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,GetEnumerator,The length of the statement  "				if ( oldBalance >= 0 && Interlocked.CompareExchange( ref _enumerationPoolingBalance' oldBalance + 1' oldBalance ) == oldBalance ) " is 129.
Long Statement,HellBrick.Collections,Enumerator,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,MoveNext,The length of the statement  "						/// Items in slots 0 .. <see cref="_awaiterIndex"/> are taken by awaiters' so they are no longer considered stored in the queue. " is 128.
Long Statement,HellBrick.Collections,Enumerator,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,MoveNext,The length of the statement  "						/// <see cref="_itemIndex"/> is the last slot an item actually exists at at the moment' so we shouldn't enumerate through the default values that are stored further. " is 165.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,TryAddWithoutValidation,The length of the statement  "				bool wonSlot = Interlocked.CompareExchange( ref _slotStates[ slot ]' SlotState.HasItem' SlotState.None ) == SlotState.None; " is 123.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,TryAddWithoutValidation,The length of the statement  "				///    Awaiter could have been canceled by now' and if it has' we should return false to insert item again into another slot. " is 125.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,TryAddWithoutValidation,The length of the statement  "				///    We also can't blindly read awaiter from the slot' because <see cref="TryTakeAsync(CancellationToken)"/> captures slot *before* filling in the awaiter. " is 157.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,TryTakeWithoutValidationAsync,The length of the statement  "				/// This means <see cref="TryAdd(T)"/> can see the default awaiter value' but it is easily solved by spinning until the awaiter is assigned. " is 140.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,TryTakeWithoutValidationAsync,The length of the statement  "				bool wonSlot = Interlocked.CompareExchange( ref _slotStates[ slot ]' SlotState.HasAwaiter' SlotState.None ) == SlotState.None; " is 126.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,TryPoolSegment,The length of the statement  "				/// 2. By this time <see cref="_head"/> is already rewritten so future enumerators can't possibly reference the current segment. " is 128.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,TryDecreaseBalance,The length of the statement  "					// We can't spin until the balance is restored either' because we have no guarantee that enumerators will be disposed soon (or will be disposed at all). " is 152.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,TryDecreaseBalance,The length of the statement  "					if ( Interlocked.CompareExchange( ref _queue._enumerationPoolingBalance' enumeratorPoolBalance - 1' enumeratorPoolBalance ) == enumeratorPoolBalance ) " is 150.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,ResetAfterTakingFromPool,The length of the statement  "				/// Otherwise appenders could successfully increment a pointer and mess with the slots before they are ready to be messed with. " is 127.
Long Statement,HellBrick.Collections,Segment,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AsyncQueue.cs,ResetAfterTakingFromPool,The length of the statement  "					/// We can't simply overwrite the state' because it's possible that the slot loser has not finished <see cref="ClearSlot(int)"/> yet. " is 133.
Long Statement,HellBrick.Collections.Internal,ExclusiveCompletionSourceGroup<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\Internal\ExclusiveCompletionSourceGroup.cs,UnlockCompetition,The length of the statement  "						/// #1: The token is canceled before <see cref="UnlockCompetition(CancellationToken)"/> is called' but after the token is validated higher up the stack. " is 152.
Long Statement,HellBrick.Collections.Internal,ExclusiveCompletionSourceGroup<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\Internal\ExclusiveCompletionSourceGroup.cs,UnlockCompetition,The length of the statement  "						/// Is this is the case' the cancellation callbak will be called synchronously while <see cref="_completedSource"/> is still set to <see cref="State.Locked"/>. " is 159.
Long Statement,HellBrick.Collections.Internal,ExclusiveCompletionSourceGroup<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\Internal\ExclusiveCompletionSourceGroup.cs,UnlockCompetition,The length of the statement  "						/// If this is the case' we have a simple race against the awaiters to progress from <see cref="State.Unlocked"/> to <see cref="State.Canceled"/>. " is 146.
Long Statement,HellBrick.Collections.Internal,ExclusiveCompletionSourceGroup<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\Internal\ExclusiveCompletionSourceGroup.cs,UnlockCompetition,The length of the statement  "						if ( group.TryTransitionToCanceledIfStateIs( State.Locked ) || group.TryTransitionToCanceledIfStateIs( State.Unlocked ) ) " is 121.
Long Statement,HellBrick.Collections.Internal,ExclusiveCompletionSourceGroup<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\Internal\ExclusiveCompletionSourceGroup.cs,UnlockCompetition,The length of the statement  "			// We can't do volatile reads/writes on a custom value type field' so we have to wrap the registration into a holder instance. " is 126.
Long Statement,HellBrick.Collections.Internal,ExclusiveCompletionSourceGroup<T>,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\Internal\ExclusiveCompletionSourceGroup.cs,UnlockCompetition,The length of the statement  "			// If the cancellation was processed synchronously' the state will already be set to Canceled and we must *NOT* unlock the competition. " is 135.
Magic Number,HellBrick.Collections,AnyResult,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AnyResult.cs,GetHashCode,The following statement contains a magic number: const int prime = -1521134295;
Magic Number,HellBrick.Collections,AnyResult,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\AnyResult.cs,GetHashCode,The following statement contains a magic number: int hash = 12345701;
Magic Number,HellBrick.Collections,PrioritizedItem,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\PrioritizedItem.cs,GetHashCode,The following statement contains a magic number: const int prime = -1521134295;
Magic Number,HellBrick.Collections,PrioritizedItem,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\PrioritizedItem.cs,GetHashCode,The following statement contains a magic number: int hash = 12345701;
Magic Number,HellBrick.Collections.Internal,Factory,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\Internal\ExclusiveCompletionSourceGroup.cs,GetHashCode,The following statement contains a magic number: const int prime = -1521134295;
Magic Number,HellBrick.Collections.Internal,Factory,D:\research\architectureSmells\repos\HellBrick_AsyncCollections\AsyncCollections\Internal\ExclusiveCompletionSourceGroup.cs,GetHashCode,The following statement contains a magic number: int hash = 12345701;
