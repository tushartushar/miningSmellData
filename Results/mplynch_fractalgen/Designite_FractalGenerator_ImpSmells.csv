Implementation smell,Namespace,Class,File,Method,Description
Complex Method,FractalGenerator,GenerationMetricChartForm,C:\repos\mplynch_fractalgen\FractalGenerator\GenerationMetricChartForm.cs,LoadMetrics,Cyclomatic complexity of the method is 11
Long Parameter List,FractalGenerator,GenerationMetric,C:\repos\mplynch_fractalgen\FractalGenerator\GenerationMetric.cs,GenerationMetric,The method has 5 parameters.
Long Statement,FractalGenerator,MainForm,C:\repos\mplynch_fractalgen\FractalGenerator\MainForm.cs,Draw,The length of the statement  "	this.metrics.Add (new GenerationMetric (this.currentGenerator.FractalType' this.concurrencyMode' this.pictureBox1.Width' this.pictureBox1.Height' milliseconds)); " is 161.
Long Statement,FractalGenerator,MainForm,C:\repos\mplynch_fractalgen\FractalGenerator\MainForm.cs,saveToolStripMenuItem_Click,The length of the statement  "		MessageBox.Show ("An error occurred while attempting to save " + "the report.  Details can be found below." + Environment.NewLine + Environment.NewLine + ex.Message' "Error"); " is 175.
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<float> (2' realLeft);  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<float> (3' imaginaryBottom);  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<float> (4' imaginaryTop);  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<uint> (5' maxIterations);  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<int> (6' width);  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: kernel.SetMemoryArgument (7' kernelOutput);  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: commands.Read (kernelOutput' false' 0' width * height * 4' kernelResultHandle.AddrOfPinnedObject ()' events);  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: unsafe {  	fixed (byte* pKernelResult = kernelResult) {  		IntPtr intPtr = new IntPtr ((void*)pKernelResult);  		image = new Bitmap (width' height' width * 4' PixelFormat.Format32bppArgb' intPtr);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: fixed (byte* pKernelResult = kernelResult) {  	IntPtr intPtr = new IntPtr ((void*)pKernelResult);  	image = new Bitmap (width' height' width * 4' PixelFormat.Format32bppArgb' intPtr);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateGPU,The following statement contains a magic number: image = new Bitmap (width' height' width * 4' PixelFormat.Format32bppArgb' intPtr);  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: realLeft = -1.5;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: realRight = 1.5;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: imaginaryBottom = -1.2;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			//double c_re = realLeft + x * realFactor;  			double c_re = -0.4;  			double Z_re = realLeft + x * realFactor;  			double Z_im = imaginaryTop - y * imaginaryFactor;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re;  				double Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		//double c_re = realLeft + x * realFactor;  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re;  			double Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	//double c_re = realLeft + x * realFactor;  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re;  		double Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (n = 0; n < maxIterations; ++n) {  	double Z_re2 = Z_re * Z_re;  	double Z_im2 = Z_im * Z_im;  	if (Z_re2 + Z_im2 > 4) {  		isInside = false;  		break;  	}  	Z_im = 2 * Z_re * Z_im + c_im;  	Z_re = Z_re2 - Z_im2 + c_re;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: for (n = 0; n < maxIterations; ++n) {  	double Z_re2 = Z_re * Z_re;  	double Z_im2 = Z_im * Z_im;  	if (Z_re2 + Z_im2 > 4) {  		isInside = false;  		break;  	}  	Z_im = 2 * Z_re * Z_im + c_im;  	Z_re = Z_re2 - Z_im2 + c_re;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: if (Z_re2 + Z_im2 > 4) {  	isInside = false;  	break;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: Z_im = 2 * Z_re * Z_im + c_im;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: if (n < (maxIterations / 2) - 1) {  	color = Color.FromArgb (0' 0' (int)colorValue);  }  else {  	color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: if (n < (maxIterations / 2) - 1) {  	color = Color.FromArgb (0' 0' (int)colorValue);  }  else {  	color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: buffer [y * data.Stride + (x * 3)] = color.B;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: buffer [y * data.Stride + (x * 3) + 1] = color.G;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: buffer [y * data.Stride + (x * 3) + 2] = color.R;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateParallel,The following statement contains a magic number: buffer [y * data.Stride + (x * 3) + 2] = color.R;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: realLeft = -1.5;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: realRight = 1.5;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: imaginaryBottom = -1.2;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	//double c_im = imaginaryTop - y * imaginaryFactor;  	double c_im = 0.6;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = -0.4;  		double Z_re = realLeft + x * realFactor;  		double Z_im = imaginaryTop - y * imaginaryFactor;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = -0.4;  	double Z_re = realLeft + x * realFactor;  	double Z_im = imaginaryTop - y * imaginaryFactor;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (n = 0; n < maxIterations; ++n) {  	double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  	if (Z_re2 + Z_im2 > 4) {  		isInside = false;  		break;  	}  	Z_im = 2 * Z_re * Z_im + c_im;  	Z_re = Z_re2 - Z_im2 + c_re;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: for (n = 0; n < maxIterations; ++n) {  	double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  	if (Z_re2 + Z_im2 > 4) {  		isInside = false;  		break;  	}  	Z_im = 2 * Z_re * Z_im + c_im;  	Z_re = Z_re2 - Z_im2 + c_re;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: if (Z_re2 + Z_im2 > 4) {  	isInside = false;  	break;  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: Z_im = 2 * Z_re * Z_im + c_im;  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: if (n < (maxIterations / 2) - 1) {  	color = Color.FromArgb (0' 0' (int)colorValue);  }  else {  	color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: if (n < (maxIterations / 2) - 1) {  	color = Color.FromArgb (0' 0' (int)colorValue);  }  else {  	color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  }  
Magic Number,FractalGenerator,Julia,C:\repos\mplynch_fractalgen\FractalGenerator\Julia.cs,CreateSequential,The following statement contains a magic number: color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  
Magic Number,FractalGenerator,MainForm,C:\repos\mplynch_fractalgen\FractalGenerator\MainForm.cs,res320x240ToolStripMenuItem_Click,The following statement contains a magic number: this.SetResolution (320' 240);  
Magic Number,FractalGenerator,MainForm,C:\repos\mplynch_fractalgen\FractalGenerator\MainForm.cs,res320x240ToolStripMenuItem_Click,The following statement contains a magic number: this.SetResolution (320' 240);  
Magic Number,FractalGenerator,MainForm,C:\repos\mplynch_fractalgen\FractalGenerator\MainForm.cs,res640x480ToolStripMenuItem_Click,The following statement contains a magic number: this.SetResolution (640' 480);  
Magic Number,FractalGenerator,MainForm,C:\repos\mplynch_fractalgen\FractalGenerator\MainForm.cs,res640x480ToolStripMenuItem_Click,The following statement contains a magic number: this.SetResolution (640' 480);  
Magic Number,FractalGenerator,MainForm,C:\repos\mplynch_fractalgen\FractalGenerator\MainForm.cs,res1024x768ToolStripMenuItem_Click,The following statement contains a magic number: this.SetResolution (1024' 768);  
Magic Number,FractalGenerator,MainForm,C:\repos\mplynch_fractalgen\FractalGenerator\MainForm.cs,res1024x768ToolStripMenuItem_Click,The following statement contains a magic number: this.SetResolution (1024' 768);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<float> (2' realLeft);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<float> (3' imaginaryBottom);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<float> (4' imaginaryTop);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<uint> (5' maxIterations);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: kernel.SetValueArgument<int> (6' width);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: kernel.SetMemoryArgument (7' kernelOutput);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: commands.Read (kernelOutput' false' 0' width * height * 4' kernelResultHandle.AddrOfPinnedObject ()' events);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: unsafe {  	fixed (byte* pKernelResult = kernelResult) {  		IntPtr intPtr = new IntPtr ((void*)pKernelResult);  		image = new Bitmap (width' height' width * 4' PixelFormat.Format32bppArgb' intPtr);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: fixed (byte* pKernelResult = kernelResult) {  	IntPtr intPtr = new IntPtr ((void*)pKernelResult);  	image = new Bitmap (width' height' width * 4' PixelFormat.Format32bppArgb' intPtr);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateGPU,The following statement contains a magic number: image = new Bitmap (width' height' width * 4' PixelFormat.Format32bppArgb' intPtr);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: realLeft = -2.0;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: imaginaryBottom = -1.2;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			double c_re = realLeft + x * realFactor;  			double Z_re = c_re' Z_im = c_im;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			double c_re = realLeft + x * realFactor;  			double Z_re = c_re' Z_im = c_im;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			double c_re = realLeft + x * realFactor;  			double Z_re = c_re' Z_im = c_im;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			double c_re = realLeft + x * realFactor;  			double Z_re = c_re' Z_im = c_im;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			double c_re = realLeft + x * realFactor;  			double Z_re = c_re' Z_im = c_im;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			double c_re = realLeft + x * realFactor;  			double Z_re = c_re' Z_im = c_im;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			double c_re = realLeft + x * realFactor;  			double Z_re = c_re' Z_im = c_im;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			double c_re = realLeft + x * realFactor;  			double Z_re = c_re' Z_im = c_im;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Parallel.For (0' height' delegate (int y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	lock (buffer) {  		// Loop over the columns.  		for (int x = 0; x < width; x++) {  			double c_re = realLeft + x * realFactor;  			double Z_re = c_re' Z_im = c_im;  			uint n;  			bool isInside = true;  			/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  				double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  				if (Z_re2 + Z_im2 > 4) {  					isInside = false;  					break;  				}  				Z_im = 2 * Z_re * Z_im + c_im;  				Z_re = Z_re2 - Z_im2 + c_re;  			}  			if (isInside) {  				color = Color.Black;  			}  			else {  				double colorValue = (double)n / (double)maxIterations * 256.0;  				if (n < (maxIterations / 2) - 1) {  					color = Color.FromArgb (0' 0' (int)colorValue);  				}  				else {  					color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  				}  			}  			buffer [y * data.Stride + (x * 3)] = color.B;  			buffer [y * data.Stride + (x * 3) + 1] = color.G;  			buffer [y * data.Stride + (x * 3) + 2] = color.R;  		}  	}  });  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: lock (buffer) {  	// Loop over the columns.  	for (int x = 0; x < width; x++) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		buffer [y * data.Stride + (x * 3)] = color.B;  		buffer [y * data.Stride + (x * 3) + 1] = color.G;  		buffer [y * data.Stride + (x * 3) + 2] = color.R;  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                          * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	buffer [y * data.Stride + (x * 3)] = color.B;  	buffer [y * data.Stride + (x * 3) + 1] = color.G;  	buffer [y * data.Stride + (x * 3) + 2] = color.R;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (n = 0; n < maxIterations; ++n) {  	double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  	if (Z_re2 + Z_im2 > 4) {  		isInside = false;  		break;  	}  	Z_im = 2 * Z_re * Z_im + c_im;  	Z_re = Z_re2 - Z_im2 + c_re;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: for (n = 0; n < maxIterations; ++n) {  	double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  	if (Z_re2 + Z_im2 > 4) {  		isInside = false;  		break;  	}  	Z_im = 2 * Z_re * Z_im + c_im;  	Z_re = Z_re2 - Z_im2 + c_re;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: if (Z_re2 + Z_im2 > 4) {  	isInside = false;  	break;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: Z_im = 2 * Z_re * Z_im + c_im;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: if (n < (maxIterations / 2) - 1) {  	color = Color.FromArgb (0' 0' (int)colorValue);  }  else {  	color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: if (n < (maxIterations / 2) - 1) {  	color = Color.FromArgb (0' 0' (int)colorValue);  }  else {  	color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: buffer [y * data.Stride + (x * 3)] = color.B;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: buffer [y * data.Stride + (x * 3) + 1] = color.G;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: buffer [y * data.Stride + (x * 3) + 2] = color.R;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateParallel,The following statement contains a magic number: buffer [y * data.Stride + (x * 3) + 2] = color.R;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: realLeft = -2.0;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: imaginaryBottom = -1.2;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int y = 0; y < height; ++y) {  	double c_im = imaginaryTop - y * imaginaryFactor;  	// Loop over the columns.  	for (int x = 0; x < width; ++x) {  		double c_re = realLeft + x * realFactor;  		double Z_re = c_re' Z_im = c_im;  		uint n;  		bool isInside = true;  		/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  			double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  			if (Z_re2 + Z_im2 > 4) {  				isInside = false;  				break;  			}  			Z_im = 2 * Z_re * Z_im + c_im;  			Z_re = Z_re2 - Z_im2 + c_re;  		}  		if (isInside) {  			color = Color.Black;  		}  		else {  			double colorValue = (double)n / (double)maxIterations * 256.0;  			if (n < (maxIterations / 2) - 1) {  				color = Color.FromArgb (0' 0' (int)colorValue);  			}  			else {  				color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  			}  		}  		image.SetPixel (x' y' color);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (int x = 0; x < width; ++x) {  	double c_re = realLeft + x * realFactor;  	double Z_re = c_re' Z_im = c_im;  	uint n;  	bool isInside = true;  	/* Loop until a value is proved to be out of the set or                      * until maxIterations is reached. */for (n = 0; n < maxIterations; ++n) {  		double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  		if (Z_re2 + Z_im2 > 4) {  			isInside = false;  			break;  		}  		Z_im = 2 * Z_re * Z_im + c_im;  		Z_re = Z_re2 - Z_im2 + c_re;  	}  	if (isInside) {  		color = Color.Black;  	}  	else {  		double colorValue = (double)n / (double)maxIterations * 256.0;  		if (n < (maxIterations / 2) - 1) {  			color = Color.FromArgb (0' 0' (int)colorValue);  		}  		else {  			color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  		}  	}  	image.SetPixel (x' y' color);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (n = 0; n < maxIterations; ++n) {  	double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  	if (Z_re2 + Z_im2 > 4) {  		isInside = false;  		break;  	}  	Z_im = 2 * Z_re * Z_im + c_im;  	Z_re = Z_re2 - Z_im2 + c_re;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: for (n = 0; n < maxIterations; ++n) {  	double Z_re2 = Z_re * Z_re' Z_im2 = Z_im * Z_im;  	if (Z_re2 + Z_im2 > 4) {  		isInside = false;  		break;  	}  	Z_im = 2 * Z_re * Z_im + c_im;  	Z_re = Z_re2 - Z_im2 + c_re;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: if (Z_re2 + Z_im2 > 4) {  	isInside = false;  	break;  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: Z_im = 2 * Z_re * Z_im + c_im;  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: if (isInside) {  	color = Color.Black;  }  else {  	double colorValue = (double)n / (double)maxIterations * 256.0;  	if (n < (maxIterations / 2) - 1) {  		color = Color.FromArgb (0' 0' (int)colorValue);  	}  	else {  		color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  	}  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: if (n < (maxIterations / 2) - 1) {  	color = Color.FromArgb (0' 0' (int)colorValue);  }  else {  	color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: if (n < (maxIterations / 2) - 1) {  	color = Color.FromArgb (0' 0' (int)colorValue);  }  else {  	color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  }  
Magic Number,FractalGenerator,Mandelbrot,C:\repos\mplynch_fractalgen\FractalGenerator\Mandelbrot.cs,CreateSequential,The following statement contains a magic number: color = Color.FromArgb ((int)colorValue' (int)colorValue' 255);  
