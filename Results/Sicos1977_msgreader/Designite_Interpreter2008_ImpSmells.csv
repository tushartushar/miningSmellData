Implementation smell,Namespace,Class,File,Method,Description
Long Method,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitTag,The method has 231 lines of code.
Long Method,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitGroup,The method has 136 lines of code.
Complex Method,Itenso.Rtf.Model,RtfDocument,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfDocument.cs,RtfDocument,Cyclomatic complexity of the method is 9
Complex Method,Itenso.Rtf.Model,RtfVisualImage,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfVisualImage.cs,RtfVisualImage,Cyclomatic complexity of the method is 8
Long Parameter List,Itenso.Rtf.Converter.Image,RtfImageConverter,C:\repos\Sicos1977_msgreader\Interpreter\Converter\Image\RtfImageConverter.cs,DoInsertImage,The method has 9 parameters. Parameters: context' format' width' height' desiredWidth' desiredHeight' scaleWidthPercent' scaleHeightPercent' imageDataHex
Long Parameter List,Itenso.Rtf,IRtfInterpreterListener,C:\repos\Sicos1977_msgreader\Interpreter\IRtfInterpreterListener.cs,InsertImage,The method has 9 parameters. Parameters: context' format' width' height' desiredWidth' desiredHeight' scaleWidthPercent' scaleHeightPercent' imageDataHex
Long Parameter List,Itenso.Rtf.Interpreter,RtfInterpreterListenerFileLogger,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreterListenerFileLogger.cs,DoInsertImage,The method has 9 parameters. Parameters: context' format' width' height' desiredWidth' desiredHeight' scaleWidthPercent' scaleHeightPercent' imageDataHex
Long Parameter List,Itenso.Rtf.Interpreter,RtfInterpreterBase,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreterBase.cs,NotifyInsertImage,The method has 8 parameters. Parameters: format' width' height' desiredWidth' desiredHeight' scaleWidthPercent' scaleHeightPercent' imageDataHex
Long Parameter List,Itenso.Rtf.Interpreter,RtfInterpreterListenerBase,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreterListenerBase.cs,InsertImage,The method has 9 parameters. Parameters: context' format' width' height' desiredWidth' desiredHeight' scaleWidthPercent' scaleHeightPercent' imageDataHex
Long Parameter List,Itenso.Rtf.Interpreter,RtfInterpreterListenerBase,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreterListenerBase.cs,DoInsertImage,The method has 9 parameters. Parameters: context' format' width' height' desiredWidth' desiredHeight' scaleWidthPercent' scaleHeightPercent' imageDataHex
Long Parameter List,Itenso.Rtf.Interpreter,RtfInterpreterListenerDocumentBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreterListenerDocumentBuilder.cs,DoInsertImage,The method has 9 parameters. Parameters: context' format' width' height' desiredWidth' desiredHeight' scaleWidthPercent' scaleHeightPercent' imageDataHex
Long Parameter List,Itenso.Rtf.Converter.Text,RtfTextConverter,C:\repos\Sicos1977_msgreader\Interpreter\Converter\Text\RtfTextConverter.cs,DoInsertImage,The method has 9 parameters. Parameters: context' format' width' height' desiredWidth' desiredHeight' scaleWidthPercent' scaleHeightPercent' imageDataHex
Long Parameter List,Itenso.Rtf.Model,RtfDocument,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfDocument.cs,RtfDocument,The method has 9 parameters. Parameters: rtfVersion' defaultFont' fontTable' colorTable' generator' uniqueTextFormats' documentInfo' userProperties' visualContent
Long Parameter List,Itenso.Rtf.Model,RtfFont,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfFont.cs,RtfFont,The method has 6 parameters. Parameters: id' kind' pitch' charSet' codePage' name
Long Parameter List,Itenso.Rtf.Model,RtfVisualImage,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfVisualImage.cs,RtfVisualImage,The method has 9 parameters. Parameters: format' alignment' width' height' desiredWidth' desiredHeight' scaleWidthPercent' scaleHeightPercent' imageDataHex
Magic Number,Itenso.Rtf.Interpreter,RtfInterpreterListenerFileLogger,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreterListenerFileLogger.cs,DoInsertImage,The following statement contains a magic number: if ( settings.Enabled && !string.IsNullOrEmpty( settings.ImageFormatText ) )  			{  				WriteLine( string.Format(  					CultureInfo.InvariantCulture'  					settings.ImageFormatText'  					format'  					width'  					height'  					desiredWidth'  					desiredHeight'  					scaleWidthPercent'  					scaleHeightPercent'  					imageDataHex'  					(imageDataHex.Length / 2) ) );  			}
Magic Number,Itenso.Rtf.Interpreter,RtfFontBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfFontBuilder.cs,DoVisitTag,The following statement contains a magic number: switch ( tag.Name )  			{  				case RtfSpec.TagThemeFontLoMajor:  				case RtfSpec.TagThemeFontHiMajor:  				case RtfSpec.TagThemeFontDbMajor:  				case RtfSpec.TagThemeFontBiMajor:  				case RtfSpec.TagThemeFontLoMinor:  				case RtfSpec.TagThemeFontHiMinor:  				case RtfSpec.TagThemeFontDbMinor:  				case RtfSpec.TagThemeFontBiMinor:  					// skip and ignore for the moment  					break;  				case RtfSpec.TagFont:  					fontId = tag.FullName;  					fontIndex = tag.ValueAsNumber;  					break;  				case RtfSpec.TagFontKindNil:  					fontKind = RtfFontKind.Nil;  					break;  				case RtfSpec.TagFontKindRoman:  					fontKind = RtfFontKind.Roman;  					break;  				case RtfSpec.TagFontKindSwiss:  					fontKind = RtfFontKind.Swiss;  					break;  				case RtfSpec.TagFontKindModern:  					fontKind = RtfFontKind.Modern;  					break;  				case RtfSpec.TagFontKindScript:  					fontKind = RtfFontKind.Script;  					break;  				case RtfSpec.TagFontKindDecor:  					fontKind = RtfFontKind.Decor;  					break;  				case RtfSpec.TagFontKindTech:  					fontKind = RtfFontKind.Tech;  					break;  				case RtfSpec.TagFontKindBidi:  					fontKind = RtfFontKind.Bidi;  					break;  				case RtfSpec.TagFontCharset:  					fontCharset = tag.ValueAsNumber;  					break;  				case RtfSpec.TagCodePage:  					fontCodePage = tag.ValueAsNumber;  					break;  				case RtfSpec.TagFontPitch:  					switch ( tag.ValueAsNumber )  					{  						case 0:  							fontPitch = RtfFontPitch.Default;  							break;  						case 1:  							fontPitch = RtfFontPitch.Fixed;  							break;  						case 2:  							fontPitch = RtfFontPitch.Variable;  							break;  					}  					break;  			}
Magic Number,Itenso.Rtf.Interpreter,RtfImageBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfImageBuilder.cs,Reset,The following statement contains a magic number: scaleWidthPercent = 100;
Magic Number,Itenso.Rtf.Interpreter,RtfImageBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfImageBuilder.cs,Reset,The following statement contains a magic number: scaleHeightPercent = 100;
Magic Number,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitTag,The following statement contains a magic number: switch ( Context.State )  			{  				case RtfInterpreterState.Init:  					if ( RtfSpec.TagRtf.Equals( tag.Name ) )  					{  						Context.State = RtfInterpreterState.InHeader;  						Context.RtfVersion = tag.ValueAsNumber;  					}  					else  					{  						throw new RtfStructureException( Strings.InvalidInitTagState( tag.ToString() ) );  					}  					break;  				case RtfInterpreterState.InHeader:  					switch ( tag.Name )  					{  						case RtfSpec.TagDefaultFont:  							Context.DefaultFontId = RtfSpec.TagFont + tag.ValueAsNumber;  							break;  					}  					break;  				case RtfInterpreterState.InDocument:  					switch ( tag.Name )  					{  						case RtfSpec.TagPlain:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveNormal();  							break;  						case RtfSpec.TagParagraphDefaults:  						case RtfSpec.TagSectionDefaults:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Left );  							break;  						case RtfSpec.TagBold:  							bool bold = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithBold( bold );  							break;  						case RtfSpec.TagItalic:  							bool italic = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithItalic( italic );  							break;  						case RtfSpec.TagUnderLine:  							bool underline = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithUnderline( underline );  							break;  						case RtfSpec.TagUnderLineNone:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithUnderline( false );  							break;  						case RtfSpec.TagStrikeThrough:  							bool strikeThrough = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithStrikeThrough( strikeThrough );  							break;  						case RtfSpec.TagHidden:  							bool hidden = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithHidden( hidden );  							break;  						case RtfSpec.TagFont:  							string fontId = tag.FullName;  							if ( Context.FontTable.ContainsFontWithId( fontId ) )  							{  								Context.WritableCurrentTextFormat =  									Context.WritableCurrentTextFormat.DeriveWithFont(  										Context.FontTable[ fontId ] );  							}  							else  							{  								if ( Settings.IgnoreUnknownFonts && Context.FontTable.Count > 0 )  								{  									Context.WritableCurrentTextFormat =  										Context.WritableCurrentTextFormat.DeriveWithFont( Context.FontTable[ 0 ] );  								}  								else  								{  									throw new RtfUndefinedFontException( Strings.UndefinedFont( fontId ) );  								}  							}  							break;  						case RtfSpec.TagFontSize:  							int fontSize = tag.ValueAsNumber;  							if ( fontSize >= 0 )  							{  								Context.WritableCurrentTextFormat =  									Context.WritableCurrentTextFormat.DeriveWithFontSize( fontSize );  							}  							else  							{  								throw new RtfInvalidDataException( Strings.InvalidFontSize( fontSize ) );  							}  							break;  						case RtfSpec.TagFontSubscript:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( false );  							break;  						case RtfSpec.TagFontSuperscript:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( true );  							break;  						case RtfSpec.TagFontNoSuperSub:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( 0 );  							break;  						case RtfSpec.TagFontDown:  							int moveDown = tag.ValueAsNumber;  							if ( moveDown == 0 )  							{  								moveDown = 6; // the default value according to rtf spec  							}  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( -moveDown );  							break;  						case RtfSpec.TagFontUp:  							int moveUp = tag.ValueAsNumber;  							if ( moveUp == 0 )  							{  								moveUp = 6; // the default value according to rtf spec  							}  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( moveUp );  							break;  						case RtfSpec.TagAlignLeft:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Left );  							break;  						case RtfSpec.TagAlignCenter:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Center );  							break;  						case RtfSpec.TagAlignRight:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Right );  							break;  						case RtfSpec.TagAlignJustify:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Justify );  							break;  						case RtfSpec.TagColorBackground:  						case RtfSpec.TagColorBackgroundWord:  						case RtfSpec.TagColorHighlight:  						case RtfSpec.TagColorForeground:  							int colorIndex = tag.ValueAsNumber;  							if ( colorIndex >= 0 && colorIndex < Context.ColorTable.Count )  							{  								IRtfColor newColor = Context.ColorTable[ colorIndex ];  								bool isForeground = RtfSpec.TagColorForeground.Equals( tag.Name );  								Context.WritableCurrentTextFormat = isForeground ?  									Context.WritableCurrentTextFormat.DeriveWithForegroundColor( newColor ) :  									Context.WritableCurrentTextFormat.DeriveWithBackgroundColor( newColor );  							}  							else  							{  								throw new RtfUndefinedColorException( Strings.UndefinedColor( colorIndex ) );  							}  							break;  						case RtfSpec.TagSection:  							NotifyInsertBreak( RtfVisualBreakKind.Section );  							break;  						case RtfSpec.TagParagraph:  							NotifyInsertBreak( RtfVisualBreakKind.Paragraph );  							break;  						case RtfSpec.TagLine:  							NotifyInsertBreak( RtfVisualBreakKind.Line );  							break;  						case RtfSpec.TagPage:  							NotifyInsertBreak( RtfVisualBreakKind.Page );  							break;  						case RtfSpec.TagTabulator:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.Tabulator );  							break;  						case RtfSpec.TagTilde:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.NonBreakingSpace );  							break;  						case RtfSpec.TagEmDash:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EmDash );  							break;  						case RtfSpec.TagEnDash:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EnDash );  							break;  						case RtfSpec.TagEmSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EmSpace );  							break;  						case RtfSpec.TagEnSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EnSpace );  							break;  						case RtfSpec.TagQmSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.QmSpace );  							break;  						case RtfSpec.TagBulltet:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.Bullet );  							break;  						case RtfSpec.TagLeftSingleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.LeftSingleQuote );  							break;  						case RtfSpec.TagRightSingleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.RightSingleQuote );  							break;  						case RtfSpec.TagLeftDoubleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.LeftDoubleQuote );  							break;  						case RtfSpec.TagRightDoubleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.RightDoubleQuote );  							break;  						case RtfSpec.TagHyphen:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.OptionalHyphen );  							break;  						case RtfSpec.TagUnderscore:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.NonBreakingHyphen );  							break;  					}  					break;  			}
Magic Number,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitTag,The following statement contains a magic number: switch ( Context.State )  			{  				case RtfInterpreterState.Init:  					if ( RtfSpec.TagRtf.Equals( tag.Name ) )  					{  						Context.State = RtfInterpreterState.InHeader;  						Context.RtfVersion = tag.ValueAsNumber;  					}  					else  					{  						throw new RtfStructureException( Strings.InvalidInitTagState( tag.ToString() ) );  					}  					break;  				case RtfInterpreterState.InHeader:  					switch ( tag.Name )  					{  						case RtfSpec.TagDefaultFont:  							Context.DefaultFontId = RtfSpec.TagFont + tag.ValueAsNumber;  							break;  					}  					break;  				case RtfInterpreterState.InDocument:  					switch ( tag.Name )  					{  						case RtfSpec.TagPlain:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveNormal();  							break;  						case RtfSpec.TagParagraphDefaults:  						case RtfSpec.TagSectionDefaults:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Left );  							break;  						case RtfSpec.TagBold:  							bool bold = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithBold( bold );  							break;  						case RtfSpec.TagItalic:  							bool italic = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithItalic( italic );  							break;  						case RtfSpec.TagUnderLine:  							bool underline = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithUnderline( underline );  							break;  						case RtfSpec.TagUnderLineNone:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithUnderline( false );  							break;  						case RtfSpec.TagStrikeThrough:  							bool strikeThrough = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithStrikeThrough( strikeThrough );  							break;  						case RtfSpec.TagHidden:  							bool hidden = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithHidden( hidden );  							break;  						case RtfSpec.TagFont:  							string fontId = tag.FullName;  							if ( Context.FontTable.ContainsFontWithId( fontId ) )  							{  								Context.WritableCurrentTextFormat =  									Context.WritableCurrentTextFormat.DeriveWithFont(  										Context.FontTable[ fontId ] );  							}  							else  							{  								if ( Settings.IgnoreUnknownFonts && Context.FontTable.Count > 0 )  								{  									Context.WritableCurrentTextFormat =  										Context.WritableCurrentTextFormat.DeriveWithFont( Context.FontTable[ 0 ] );  								}  								else  								{  									throw new RtfUndefinedFontException( Strings.UndefinedFont( fontId ) );  								}  							}  							break;  						case RtfSpec.TagFontSize:  							int fontSize = tag.ValueAsNumber;  							if ( fontSize >= 0 )  							{  								Context.WritableCurrentTextFormat =  									Context.WritableCurrentTextFormat.DeriveWithFontSize( fontSize );  							}  							else  							{  								throw new RtfInvalidDataException( Strings.InvalidFontSize( fontSize ) );  							}  							break;  						case RtfSpec.TagFontSubscript:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( false );  							break;  						case RtfSpec.TagFontSuperscript:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( true );  							break;  						case RtfSpec.TagFontNoSuperSub:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( 0 );  							break;  						case RtfSpec.TagFontDown:  							int moveDown = tag.ValueAsNumber;  							if ( moveDown == 0 )  							{  								moveDown = 6; // the default value according to rtf spec  							}  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( -moveDown );  							break;  						case RtfSpec.TagFontUp:  							int moveUp = tag.ValueAsNumber;  							if ( moveUp == 0 )  							{  								moveUp = 6; // the default value according to rtf spec  							}  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( moveUp );  							break;  						case RtfSpec.TagAlignLeft:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Left );  							break;  						case RtfSpec.TagAlignCenter:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Center );  							break;  						case RtfSpec.TagAlignRight:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Right );  							break;  						case RtfSpec.TagAlignJustify:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Justify );  							break;  						case RtfSpec.TagColorBackground:  						case RtfSpec.TagColorBackgroundWord:  						case RtfSpec.TagColorHighlight:  						case RtfSpec.TagColorForeground:  							int colorIndex = tag.ValueAsNumber;  							if ( colorIndex >= 0 && colorIndex < Context.ColorTable.Count )  							{  								IRtfColor newColor = Context.ColorTable[ colorIndex ];  								bool isForeground = RtfSpec.TagColorForeground.Equals( tag.Name );  								Context.WritableCurrentTextFormat = isForeground ?  									Context.WritableCurrentTextFormat.DeriveWithForegroundColor( newColor ) :  									Context.WritableCurrentTextFormat.DeriveWithBackgroundColor( newColor );  							}  							else  							{  								throw new RtfUndefinedColorException( Strings.UndefinedColor( colorIndex ) );  							}  							break;  						case RtfSpec.TagSection:  							NotifyInsertBreak( RtfVisualBreakKind.Section );  							break;  						case RtfSpec.TagParagraph:  							NotifyInsertBreak( RtfVisualBreakKind.Paragraph );  							break;  						case RtfSpec.TagLine:  							NotifyInsertBreak( RtfVisualBreakKind.Line );  							break;  						case RtfSpec.TagPage:  							NotifyInsertBreak( RtfVisualBreakKind.Page );  							break;  						case RtfSpec.TagTabulator:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.Tabulator );  							break;  						case RtfSpec.TagTilde:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.NonBreakingSpace );  							break;  						case RtfSpec.TagEmDash:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EmDash );  							break;  						case RtfSpec.TagEnDash:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EnDash );  							break;  						case RtfSpec.TagEmSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EmSpace );  							break;  						case RtfSpec.TagEnSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EnSpace );  							break;  						case RtfSpec.TagQmSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.QmSpace );  							break;  						case RtfSpec.TagBulltet:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.Bullet );  							break;  						case RtfSpec.TagLeftSingleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.LeftSingleQuote );  							break;  						case RtfSpec.TagRightSingleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.RightSingleQuote );  							break;  						case RtfSpec.TagLeftDoubleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.LeftDoubleQuote );  							break;  						case RtfSpec.TagRightDoubleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.RightDoubleQuote );  							break;  						case RtfSpec.TagHyphen:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.OptionalHyphen );  							break;  						case RtfSpec.TagUnderscore:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.NonBreakingHyphen );  							break;  					}  					break;  			}
Magic Number,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitGroup,The following statement contains a magic number: switch ( Context.State )  			{  				case RtfInterpreterState.Init:  					if ( RtfSpec.TagRtf.Equals( groupDestination ) )  					{  						VisitChildrenOf( group );  					}  					else  					{  						throw new RtfStructureException( Strings.InvalidInitGroupState( groupDestination ) );  					}  					break;  				case RtfInterpreterState.InHeader:  					switch ( groupDestination )  					{  						case RtfSpec.TagFontTable:  							fontTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagColorTable:  							colorTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagGenerator:  							// last group with a destination in header' but no need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							IRtfText generator = group.Contents.Count == 3 ? group.Contents[ 2 ] as IRtfText : null;  							if ( generator != null )  							{  								string generatorName = generator.Text;  								Context.Generator = generatorName.EndsWith( ";" ) ?  									generatorName.Substring( 0' generatorName.Length - 1 ) : generatorName;  							}  							else  							{  								throw new RtfInvalidDataException( Strings.InvalidGeneratorGroup( group.ToString() ) );  							}  							break;  						case RtfSpec.TagPlain:  						case RtfSpec.TagParagraphDefaults:  						case RtfSpec.TagSectionDefaults:  						case RtfSpec.TagUnderLineNone:  						case null:  							// <tags>: special tags commonly used to reset state in a beginning group. necessary to recognize  							//         state transition form header to document in case no other mechanism detects it and the  							//         content starts with a group with such a 'destination' ...  							// 'null': group without destination cannot be part of header' but need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							if ( !group.IsExtensionDestination )  							{  								VisitChildrenOf( group );  							}  							break;  					}  					break;  				case RtfInterpreterState.InDocument:  					switch ( groupDestination )  					{  						case RtfSpec.TagUserProperties:  							userPropertyBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagInfo:  							documentInfoBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagUnicodeAlternativeChoices:  							IRtfGroup alternativeWithUnicodeSupport =  								group.SelectChildGroupWithDestination( RtfSpec.TagUnicodeAlternativeUnicode );  							if ( alternativeWithUnicodeSupport != null )  							{  								// there is an alternative with unicode formatted content -> use this  								VisitChildrenOf( alternativeWithUnicodeSupport );  							}  							else  							{  								// try to locate the alternative without unicode -> only ANSI fallbacks  								IRtfGroup alternativeWithoutUnicode = // must be the third element if present  									group.Contents.Count > 2 ? group.Contents[ 2 ] as IRtfGroup : null;  								if ( alternativeWithoutUnicode != null )  								{  									VisitChildrenOf( alternativeWithoutUnicode );  								}  							}  							break;  						case RtfSpec.TagHeader:  						case RtfSpec.TagHeaderFirst:  						case RtfSpec.TagHeaderLeft:  						case RtfSpec.TagHeaderRight:  						case RtfSpec.TagFooter:  						case RtfSpec.TagFooterFirst:  						case RtfSpec.TagFooterLeft:  						case RtfSpec.TagFooterRight:  						case RtfSpec.TagFootnote:  						case RtfSpec.TagStyleSheet:  							// groups we currently ignore' so their content doesn't intermix with  							// the actual document content  							break;  						case RtfSpec.TagPictureWrapper:  							VisitChildrenOf( group );  							lastGroupWasPictureWrapper = true;  							break;  						case RtfSpec.TagPictureWrapperAlternative:  							if ( !lastGroupWasPictureWrapper )  							{  								VisitChildrenOf( group );  							}  							lastGroupWasPictureWrapper = false;  							break;  						case RtfSpec.TagPicture:  							imageBuilder.VisitGroup( group );  							NotifyInsertImage(  								imageBuilder.Format'  								imageBuilder.Width'  								imageBuilder.Height'  								imageBuilder.DesiredWidth'  								imageBuilder.DesiredHeight'  								imageBuilder.ScaleWidthPercent'  								imageBuilder.ScaleHeightPercent'  								imageBuilder.ImageDataHex );  							break;  						case RtfSpec.TagParagraphNumberText:  						case RtfSpec.TagListNumberText:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.ParagraphNumberBegin );  							VisitChildrenOf( group );  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.ParagraphNumberEnd );  							break;  						default:  							if ( !group.IsExtensionDestination )  							{  								// nested text group  								VisitChildrenOf( group );  							}  							break;  					}  					break;  			}
Magic Number,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitGroup,The following statement contains a magic number: switch ( Context.State )  			{  				case RtfInterpreterState.Init:  					if ( RtfSpec.TagRtf.Equals( groupDestination ) )  					{  						VisitChildrenOf( group );  					}  					else  					{  						throw new RtfStructureException( Strings.InvalidInitGroupState( groupDestination ) );  					}  					break;  				case RtfInterpreterState.InHeader:  					switch ( groupDestination )  					{  						case RtfSpec.TagFontTable:  							fontTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagColorTable:  							colorTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagGenerator:  							// last group with a destination in header' but no need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							IRtfText generator = group.Contents.Count == 3 ? group.Contents[ 2 ] as IRtfText : null;  							if ( generator != null )  							{  								string generatorName = generator.Text;  								Context.Generator = generatorName.EndsWith( ";" ) ?  									generatorName.Substring( 0' generatorName.Length - 1 ) : generatorName;  							}  							else  							{  								throw new RtfInvalidDataException( Strings.InvalidGeneratorGroup( group.ToString() ) );  							}  							break;  						case RtfSpec.TagPlain:  						case RtfSpec.TagParagraphDefaults:  						case RtfSpec.TagSectionDefaults:  						case RtfSpec.TagUnderLineNone:  						case null:  							// <tags>: special tags commonly used to reset state in a beginning group. necessary to recognize  							//         state transition form header to document in case no other mechanism detects it and the  							//         content starts with a group with such a 'destination' ...  							// 'null': group without destination cannot be part of header' but need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							if ( !group.IsExtensionDestination )  							{  								VisitChildrenOf( group );  							}  							break;  					}  					break;  				case RtfInterpreterState.InDocument:  					switch ( groupDestination )  					{  						case RtfSpec.TagUserProperties:  							userPropertyBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagInfo:  							documentInfoBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagUnicodeAlternativeChoices:  							IRtfGroup alternativeWithUnicodeSupport =  								group.SelectChildGroupWithDestination( RtfSpec.TagUnicodeAlternativeUnicode );  							if ( alternativeWithUnicodeSupport != null )  							{  								// there is an alternative with unicode formatted content -> use this  								VisitChildrenOf( alternativeWithUnicodeSupport );  							}  							else  							{  								// try to locate the alternative without unicode -> only ANSI fallbacks  								IRtfGroup alternativeWithoutUnicode = // must be the third element if present  									group.Contents.Count > 2 ? group.Contents[ 2 ] as IRtfGroup : null;  								if ( alternativeWithoutUnicode != null )  								{  									VisitChildrenOf( alternativeWithoutUnicode );  								}  							}  							break;  						case RtfSpec.TagHeader:  						case RtfSpec.TagHeaderFirst:  						case RtfSpec.TagHeaderLeft:  						case RtfSpec.TagHeaderRight:  						case RtfSpec.TagFooter:  						case RtfSpec.TagFooterFirst:  						case RtfSpec.TagFooterLeft:  						case RtfSpec.TagFooterRight:  						case RtfSpec.TagFootnote:  						case RtfSpec.TagStyleSheet:  							// groups we currently ignore' so their content doesn't intermix with  							// the actual document content  							break;  						case RtfSpec.TagPictureWrapper:  							VisitChildrenOf( group );  							lastGroupWasPictureWrapper = true;  							break;  						case RtfSpec.TagPictureWrapperAlternative:  							if ( !lastGroupWasPictureWrapper )  							{  								VisitChildrenOf( group );  							}  							lastGroupWasPictureWrapper = false;  							break;  						case RtfSpec.TagPicture:  							imageBuilder.VisitGroup( group );  							NotifyInsertImage(  								imageBuilder.Format'  								imageBuilder.Width'  								imageBuilder.Height'  								imageBuilder.DesiredWidth'  								imageBuilder.DesiredHeight'  								imageBuilder.ScaleWidthPercent'  								imageBuilder.ScaleHeightPercent'  								imageBuilder.ImageDataHex );  							break;  						case RtfSpec.TagParagraphNumberText:  						case RtfSpec.TagListNumberText:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.ParagraphNumberBegin );  							VisitChildrenOf( group );  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.ParagraphNumberEnd );  							break;  						default:  							if ( !group.IsExtensionDestination )  							{  								// nested text group  								VisitChildrenOf( group );  							}  							break;  					}  					break;  			}
Magic Number,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitGroup,The following statement contains a magic number: switch ( Context.State )  			{  				case RtfInterpreterState.Init:  					if ( RtfSpec.TagRtf.Equals( groupDestination ) )  					{  						VisitChildrenOf( group );  					}  					else  					{  						throw new RtfStructureException( Strings.InvalidInitGroupState( groupDestination ) );  					}  					break;  				case RtfInterpreterState.InHeader:  					switch ( groupDestination )  					{  						case RtfSpec.TagFontTable:  							fontTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagColorTable:  							colorTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagGenerator:  							// last group with a destination in header' but no need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							IRtfText generator = group.Contents.Count == 3 ? group.Contents[ 2 ] as IRtfText : null;  							if ( generator != null )  							{  								string generatorName = generator.Text;  								Context.Generator = generatorName.EndsWith( ";" ) ?  									generatorName.Substring( 0' generatorName.Length - 1 ) : generatorName;  							}  							else  							{  								throw new RtfInvalidDataException( Strings.InvalidGeneratorGroup( group.ToString() ) );  							}  							break;  						case RtfSpec.TagPlain:  						case RtfSpec.TagParagraphDefaults:  						case RtfSpec.TagSectionDefaults:  						case RtfSpec.TagUnderLineNone:  						case null:  							// <tags>: special tags commonly used to reset state in a beginning group. necessary to recognize  							//         state transition form header to document in case no other mechanism detects it and the  							//         content starts with a group with such a 'destination' ...  							// 'null': group without destination cannot be part of header' but need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							if ( !group.IsExtensionDestination )  							{  								VisitChildrenOf( group );  							}  							break;  					}  					break;  				case RtfInterpreterState.InDocument:  					switch ( groupDestination )  					{  						case RtfSpec.TagUserProperties:  							userPropertyBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagInfo:  							documentInfoBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagUnicodeAlternativeChoices:  							IRtfGroup alternativeWithUnicodeSupport =  								group.SelectChildGroupWithDestination( RtfSpec.TagUnicodeAlternativeUnicode );  							if ( alternativeWithUnicodeSupport != null )  							{  								// there is an alternative with unicode formatted content -> use this  								VisitChildrenOf( alternativeWithUnicodeSupport );  							}  							else  							{  								// try to locate the alternative without unicode -> only ANSI fallbacks  								IRtfGroup alternativeWithoutUnicode = // must be the third element if present  									group.Contents.Count > 2 ? group.Contents[ 2 ] as IRtfGroup : null;  								if ( alternativeWithoutUnicode != null )  								{  									VisitChildrenOf( alternativeWithoutUnicode );  								}  							}  							break;  						case RtfSpec.TagHeader:  						case RtfSpec.TagHeaderFirst:  						case RtfSpec.TagHeaderLeft:  						case RtfSpec.TagHeaderRight:  						case RtfSpec.TagFooter:  						case RtfSpec.TagFooterFirst:  						case RtfSpec.TagFooterLeft:  						case RtfSpec.TagFooterRight:  						case RtfSpec.TagFootnote:  						case RtfSpec.TagStyleSheet:  							// groups we currently ignore' so their content doesn't intermix with  							// the actual document content  							break;  						case RtfSpec.TagPictureWrapper:  							VisitChildrenOf( group );  							lastGroupWasPictureWrapper = true;  							break;  						case RtfSpec.TagPictureWrapperAlternative:  							if ( !lastGroupWasPictureWrapper )  							{  								VisitChildrenOf( group );  							}  							lastGroupWasPictureWrapper = false;  							break;  						case RtfSpec.TagPicture:  							imageBuilder.VisitGroup( group );  							NotifyInsertImage(  								imageBuilder.Format'  								imageBuilder.Width'  								imageBuilder.Height'  								imageBuilder.DesiredWidth'  								imageBuilder.DesiredHeight'  								imageBuilder.ScaleWidthPercent'  								imageBuilder.ScaleHeightPercent'  								imageBuilder.ImageDataHex );  							break;  						case RtfSpec.TagParagraphNumberText:  						case RtfSpec.TagListNumberText:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.ParagraphNumberBegin );  							VisitChildrenOf( group );  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.ParagraphNumberEnd );  							break;  						default:  							if ( !group.IsExtensionDestination )  							{  								// nested text group  								VisitChildrenOf( group );  							}  							break;  					}  					break;  			}
Magic Number,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitGroup,The following statement contains a magic number: switch ( Context.State )  			{  				case RtfInterpreterState.Init:  					if ( RtfSpec.TagRtf.Equals( groupDestination ) )  					{  						VisitChildrenOf( group );  					}  					else  					{  						throw new RtfStructureException( Strings.InvalidInitGroupState( groupDestination ) );  					}  					break;  				case RtfInterpreterState.InHeader:  					switch ( groupDestination )  					{  						case RtfSpec.TagFontTable:  							fontTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagColorTable:  							colorTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagGenerator:  							// last group with a destination in header' but no need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							IRtfText generator = group.Contents.Count == 3 ? group.Contents[ 2 ] as IRtfText : null;  							if ( generator != null )  							{  								string generatorName = generator.Text;  								Context.Generator = generatorName.EndsWith( ";" ) ?  									generatorName.Substring( 0' generatorName.Length - 1 ) : generatorName;  							}  							else  							{  								throw new RtfInvalidDataException( Strings.InvalidGeneratorGroup( group.ToString() ) );  							}  							break;  						case RtfSpec.TagPlain:  						case RtfSpec.TagParagraphDefaults:  						case RtfSpec.TagSectionDefaults:  						case RtfSpec.TagUnderLineNone:  						case null:  							// <tags>: special tags commonly used to reset state in a beginning group. necessary to recognize  							//         state transition form header to document in case no other mechanism detects it and the  							//         content starts with a group with such a 'destination' ...  							// 'null': group without destination cannot be part of header' but need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							if ( !group.IsExtensionDestination )  							{  								VisitChildrenOf( group );  							}  							break;  					}  					break;  				case RtfInterpreterState.InDocument:  					switch ( groupDestination )  					{  						case RtfSpec.TagUserProperties:  							userPropertyBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagInfo:  							documentInfoBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagUnicodeAlternativeChoices:  							IRtfGroup alternativeWithUnicodeSupport =  								group.SelectChildGroupWithDestination( RtfSpec.TagUnicodeAlternativeUnicode );  							if ( alternativeWithUnicodeSupport != null )  							{  								// there is an alternative with unicode formatted content -> use this  								VisitChildrenOf( alternativeWithUnicodeSupport );  							}  							else  							{  								// try to locate the alternative without unicode -> only ANSI fallbacks  								IRtfGroup alternativeWithoutUnicode = // must be the third element if present  									group.Contents.Count > 2 ? group.Contents[ 2 ] as IRtfGroup : null;  								if ( alternativeWithoutUnicode != null )  								{  									VisitChildrenOf( alternativeWithoutUnicode );  								}  							}  							break;  						case RtfSpec.TagHeader:  						case RtfSpec.TagHeaderFirst:  						case RtfSpec.TagHeaderLeft:  						case RtfSpec.TagHeaderRight:  						case RtfSpec.TagFooter:  						case RtfSpec.TagFooterFirst:  						case RtfSpec.TagFooterLeft:  						case RtfSpec.TagFooterRight:  						case RtfSpec.TagFootnote:  						case RtfSpec.TagStyleSheet:  							// groups we currently ignore' so their content doesn't intermix with  							// the actual document content  							break;  						case RtfSpec.TagPictureWrapper:  							VisitChildrenOf( group );  							lastGroupWasPictureWrapper = true;  							break;  						case RtfSpec.TagPictureWrapperAlternative:  							if ( !lastGroupWasPictureWrapper )  							{  								VisitChildrenOf( group );  							}  							lastGroupWasPictureWrapper = false;  							break;  						case RtfSpec.TagPicture:  							imageBuilder.VisitGroup( group );  							NotifyInsertImage(  								imageBuilder.Format'  								imageBuilder.Width'  								imageBuilder.Height'  								imageBuilder.DesiredWidth'  								imageBuilder.DesiredHeight'  								imageBuilder.ScaleWidthPercent'  								imageBuilder.ScaleHeightPercent'  								imageBuilder.ImageDataHex );  							break;  						case RtfSpec.TagParagraphNumberText:  						case RtfSpec.TagListNumberText:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.ParagraphNumberBegin );  							VisitChildrenOf( group );  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.ParagraphNumberEnd );  							break;  						default:  							if ( !group.IsExtensionDestination )  							{  								// nested text group  								VisitChildrenOf( group );  							}  							break;  					}  					break;  			}
Magic Number,Itenso.Rtf.Interpreter,RtfTimestampBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfTimestampBuilder.cs,Reset,The following statement contains a magic number: year = 1970;
Magic Number,Itenso.Rtf.Model,RtfColor,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfColor.cs,RtfColor,The following statement contains a magic number: if ( red < 0 || red > 255 )  			{  				throw new RtfColorException( Strings.InvalidColor( red ) );  			}
Magic Number,Itenso.Rtf.Model,RtfColor,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfColor.cs,RtfColor,The following statement contains a magic number: if ( green < 0 || green > 255 )  			{  				throw new RtfColorException( Strings.InvalidColor( green ) );  			}
Magic Number,Itenso.Rtf.Model,RtfColor,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfColor.cs,RtfColor,The following statement contains a magic number: if ( blue < 0 || blue > 255 )  			{  				throw new RtfColorException( Strings.InvalidColor( blue ) );  			}
Magic Number,Itenso.Rtf.Model,RtfTextFormat,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfTextFormat.cs,DeriveWithSuperScript,The following statement contains a magic number: if ( deviation == 0 )  			{  				copy.fontSize = ( fontSize / 2 ) * 3;  			}
Magic Number,Itenso.Rtf.Model,RtfTextFormat,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfTextFormat.cs,DeriveWithSuperScript,The following statement contains a magic number: if ( deviation == 0 )  			{  				copy.fontSize = ( fontSize / 2 ) * 3;  			}
Magic Number,Itenso.Rtf.Model,RtfTextFormat,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfTextFormat.cs,DeriveWithSuperScript,The following statement contains a magic number: copy.fontSize = Math.Max( 1' ( fontSize * 2 ) / 3 );
Magic Number,Itenso.Rtf.Model,RtfTextFormat,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfTextFormat.cs,DeriveWithSuperScript,The following statement contains a magic number: copy.fontSize = Math.Max( 1' ( fontSize * 2 ) / 3 );
Magic Number,Itenso.Rtf.Model,RtfTextFormat,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfTextFormat.cs,DeriveWithSuperScript,The following statement contains a magic number: copy.superScript = ( super ? 1 : -1 ) * Math.Max( 1' fontSize / 2 );
Magic Number,Itenso.Rtf.Model,RtfVisualImage,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfVisualImage.cs,ToBinary,The following statement contains a magic number: int dataSize = hexDigits / 2;
Magic Number,Itenso.Rtf.Model,RtfVisualImage,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfVisualImage.cs,ToBinary,The following statement contains a magic number: StringBuilder hex = new StringBuilder( 2 );
Magic Number,Itenso.Rtf.Model,RtfVisualImage,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfVisualImage.cs,ToBinary,The following statement contains a magic number: for ( int i = 0; i < hexDigits; i++ )  			{  				char c = imageDataHex[ i ];  				if ( char.IsWhiteSpace( c ) )  				{  					continue;  				}  				hex.Append( imageDataHex[ i ] );  				if ( hex.Length == 2 )  				{  					imageDataBinary[ dataPos ] = byte.Parse( hex.ToString()' NumberStyles.HexNumber );  					dataPos++;  					hex.Remove( 0' 2 );  				}  			}
Magic Number,Itenso.Rtf.Model,RtfVisualImage,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfVisualImage.cs,ToBinary,The following statement contains a magic number: for ( int i = 0; i < hexDigits; i++ )  			{  				char c = imageDataHex[ i ];  				if ( char.IsWhiteSpace( c ) )  				{  					continue;  				}  				hex.Append( imageDataHex[ i ] );  				if ( hex.Length == 2 )  				{  					imageDataBinary[ dataPos ] = byte.Parse( hex.ToString()' NumberStyles.HexNumber );  					dataPos++;  					hex.Remove( 0' 2 );  				}  			}
Magic Number,Itenso.Rtf.Model,RtfVisualImage,C:\repos\Sicos1977_msgreader\Interpreter\Model\RtfVisualImage.cs,ToString,The following statement contains a magic number: return "[" + format + ": " + alignment + "' " +  				width + " x " + height + " " +  				"(" + desiredWidth + " x " + desiredHeight + ") " +  				"{" + scaleWidthPercent + "% x " + scaleHeightPercent + "%} " +  				":" + ( imageDataHex.Length / 2 ) + " bytes]";
Missing Default,Itenso.Rtf.Converter.Image,RtfVisualImageAdapter,C:\repos\Sicos1977_msgreader\Interpreter\Converter\Image\RtfVisualImageAdapter.cs,GetImageFormat,The following switch statement is missing a default case: switch ( rtfVisualImageFormat )  			{  				case RtfVisualImageFormat.Emf:  					imageFormat = ImageFormat.Emf;  					break;  				case RtfVisualImageFormat.Png:  					imageFormat = ImageFormat.Png;  					break;  				case RtfVisualImageFormat.Jpg:  					imageFormat = ImageFormat.Jpeg;  					break;  				case RtfVisualImageFormat.Wmf:  					imageFormat = ImageFormat.Wmf;  					break;  				case RtfVisualImageFormat.Bmp:  					imageFormat = ImageFormat.Bmp;  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfColorTableBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfColorTableBuilder.cs,DoVisitTag,The following switch statement is missing a default case: switch ( tag.Name )  			{  				case RtfSpec.TagColorRed:  					curRed = tag.ValueAsNumber;  					break;  				case RtfSpec.TagColorGreen:  					curGreen = tag.ValueAsNumber;  					break;  				case RtfSpec.TagColorBlue:  					curBlue = tag.ValueAsNumber;  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfDocumentInfoBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfDocumentInfoBuilder.cs,DoVisitGroup,The following switch statement is missing a default case: switch ( group.Destination )  			{  				case RtfSpec.TagInfo:  					VisitGroupChildren( group );  					break;  				case RtfSpec.TagInfoTitle:  					info.Title = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoSubject:  					info.Subject = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoAuthor:  					info.Author = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoManager:  					info.Manager = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoCompany:  					info.Company = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoOperator:  					info.Operator = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoCategory:  					info.Category = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoKeywords:  					info.Keywords = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoComment:  					info.Comment = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoDocumentComment:  					info.DocumentComment = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoHyperLinkBase:  					info.HyperLinkbase = ExtractGroupText( group );  					break;  				case RtfSpec.TagInfoCreationTime:  					info.CreationTime = ExtractTimestamp( group );  					break;  				case RtfSpec.TagInfoRevisionTime:  					info.RevisionTime = ExtractTimestamp( group );  					break;  				case RtfSpec.TagInfoPrintTime:  					info.PrintTime = ExtractTimestamp( group );  					break;  				case RtfSpec.TagInfoBackupTime:  					info.BackupTime = ExtractTimestamp( group );  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfDocumentInfoBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfDocumentInfoBuilder.cs,DoVisitTag,The following switch statement is missing a default case: switch ( tag.Name )  			{  				case RtfSpec.TagInfoVersion:  					info.Version = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoRevision:  					info.Revision = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoNumberOfPages:  					info.NumberOfPages = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoNumberOfWords:  					info.NumberOfWords = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoNumberOfChars:  					info.NumberOfCharacters = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoId:  					info.Id = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoEditingTimeMinutes:  					info.EditingTimeInMinutes = tag.ValueAsNumber;  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfFontBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfFontBuilder.cs,DoVisitGroup,The following switch statement is missing a default case: switch ( group.Destination )  			{  				case RtfSpec.TagFont:  				case RtfSpec.TagThemeFontLoMajor:  				case RtfSpec.TagThemeFontHiMajor:  				case RtfSpec.TagThemeFontDbMajor:  				case RtfSpec.TagThemeFontBiMajor:  				case RtfSpec.TagThemeFontLoMinor:  				case RtfSpec.TagThemeFontHiMinor:  				case RtfSpec.TagThemeFontDbMinor:  				case RtfSpec.TagThemeFontBiMinor:  					VisitGroupChildren( group );  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfFontBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfFontBuilder.cs,DoVisitTag,The following switch statement is missing a default case: switch ( tag.Name )  			{  				case RtfSpec.TagThemeFontLoMajor:  				case RtfSpec.TagThemeFontHiMajor:  				case RtfSpec.TagThemeFontDbMajor:  				case RtfSpec.TagThemeFontBiMajor:  				case RtfSpec.TagThemeFontLoMinor:  				case RtfSpec.TagThemeFontHiMinor:  				case RtfSpec.TagThemeFontDbMinor:  				case RtfSpec.TagThemeFontBiMinor:  					// skip and ignore for the moment  					break;  				case RtfSpec.TagFont:  					fontId = tag.FullName;  					fontIndex = tag.ValueAsNumber;  					break;  				case RtfSpec.TagFontKindNil:  					fontKind = RtfFontKind.Nil;  					break;  				case RtfSpec.TagFontKindRoman:  					fontKind = RtfFontKind.Roman;  					break;  				case RtfSpec.TagFontKindSwiss:  					fontKind = RtfFontKind.Swiss;  					break;  				case RtfSpec.TagFontKindModern:  					fontKind = RtfFontKind.Modern;  					break;  				case RtfSpec.TagFontKindScript:  					fontKind = RtfFontKind.Script;  					break;  				case RtfSpec.TagFontKindDecor:  					fontKind = RtfFontKind.Decor;  					break;  				case RtfSpec.TagFontKindTech:  					fontKind = RtfFontKind.Tech;  					break;  				case RtfSpec.TagFontKindBidi:  					fontKind = RtfFontKind.Bidi;  					break;  				case RtfSpec.TagFontCharset:  					fontCharset = tag.ValueAsNumber;  					break;  				case RtfSpec.TagCodePage:  					fontCodePage = tag.ValueAsNumber;  					break;  				case RtfSpec.TagFontPitch:  					switch ( tag.ValueAsNumber )  					{  						case 0:  							fontPitch = RtfFontPitch.Default;  							break;  						case 1:  							fontPitch = RtfFontPitch.Fixed;  							break;  						case 2:  							fontPitch = RtfFontPitch.Variable;  							break;  					}  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfFontBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfFontBuilder.cs,DoVisitTag,The following switch statement is missing a default case: switch ( tag.ValueAsNumber )  					{  						case 0:  							fontPitch = RtfFontPitch.Default;  							break;  						case 1:  							fontPitch = RtfFontPitch.Fixed;  							break;  						case 2:  							fontPitch = RtfFontPitch.Variable;  							break;  					}
Missing Default,Itenso.Rtf.Interpreter,RtfFontTableBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfFontTableBuilder.cs,DoVisitGroup,The following switch statement is missing a default case: switch ( group.Destination )  			{  				case RtfSpec.TagFont:  				case RtfSpec.TagThemeFontLoMajor:  				case RtfSpec.TagThemeFontHiMajor:  				case RtfSpec.TagThemeFontDbMajor:  				case RtfSpec.TagThemeFontBiMajor:  				case RtfSpec.TagThemeFontLoMinor:  				case RtfSpec.TagThemeFontHiMinor:  				case RtfSpec.TagThemeFontDbMinor:  				case RtfSpec.TagThemeFontBiMinor:  					BuildFontFromGroup( group );  					break;  				case RtfSpec.TagFontTable:  					if ( group.Contents.Count > 1 )  					{  						if ( group.Contents[ 1 ].Kind == RtfElementKind.Group )  						{  							// the 'new' style where each font resides in a group of its own  							VisitGroupChildren( group );  						}  						else  						{  							// the 'old' style where individual fonts are 'terminated' by their  							// respective name content text (which ends with ';')  							// -> need to manually iterate from here  							int childCount = group.Contents.Count;  							fontBuilder.Reset();  							for ( int i = 1; i < childCount; i++ ) // skip over the initial \fonttbl tag  							{  								group.Contents[ i ].Visit( fontBuilder );  								if ( fontBuilder.FontName != null )  								{  									// fonts are 'terminated' by their name (as content text)  									AddCurrentFont();  									fontBuilder.Reset();  								}  							}  							//BuildFontFromGroup( group ); // a single font info  						}  					}  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfImageBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfImageBuilder.cs,DoVisitGroup,The following switch statement is missing a default case: switch ( group.Destination )  			{  				case RtfSpec.TagPicture:  					Reset();  					VisitGroupChildren( group );  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfImageBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfImageBuilder.cs,DoVisitTag,The following switch statement is missing a default case: switch ( tag.Name )  			{  				case RtfSpec.TagPictureFormatWinDib:  				case RtfSpec.TagPictureFormatWinBmp:  					format = RtfVisualImageFormat.Bmp;  					break;  				case RtfSpec.TagPictureFormatEmf:  					format = RtfVisualImageFormat.Emf;  					break;  				case RtfSpec.TagPictureFormatJpg:  					format = RtfVisualImageFormat.Jpg;  					break;  				case RtfSpec.TagPictureFormatPng:  					format = RtfVisualImageFormat.Png;  					break;  				case RtfSpec.TagPictureFormatWmf:  					format = RtfVisualImageFormat.Wmf;  					break;  				case RtfSpec.TagPictureWidth:  					width = Math.Abs( tag.ValueAsNumber );  					desiredWidth = width;  					break;  				case RtfSpec.TagPictureHeight:  					height = Math.Abs( tag.ValueAsNumber );  					desiredHeight = height;  					break;  				case RtfSpec.TagPictureWidthGoal:  					desiredWidth = Math.Abs( tag.ValueAsNumber );  					if ( width == 0 )  					{  						// hack to prevent WordPad documents which lack the \picw and \pich tags  						// from resulting in an exception due to undefined width/height  						width = desiredWidth;  					}  					break;  				case RtfSpec.TagPictureHeightGoal:  					desiredHeight = Math.Abs( tag.ValueAsNumber );  					if ( height == 0 )  					{  						// hack to prevent WordPad documents which lack the \picw and \pich tags  						// from resulting in an exception due to undefined width/height  						height = desiredHeight;  					}  					break;  				case RtfSpec.TagPictureWidthScale:  					scaleWidthPercent = Math.Abs( tag.ValueAsNumber );  					break;  				case RtfSpec.TagPictureHeightScale:  					scaleHeightPercent = Math.Abs( tag.ValueAsNumber );  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitTag,The following switch statement is missing a default case: switch ( Context.State )  			{  				case RtfInterpreterState.Init:  					if ( RtfSpec.TagRtf.Equals( tag.Name ) )  					{  						Context.State = RtfInterpreterState.InHeader;  						Context.RtfVersion = tag.ValueAsNumber;  					}  					else  					{  						throw new RtfStructureException( Strings.InvalidInitTagState( tag.ToString() ) );  					}  					break;  				case RtfInterpreterState.InHeader:  					switch ( tag.Name )  					{  						case RtfSpec.TagDefaultFont:  							Context.DefaultFontId = RtfSpec.TagFont + tag.ValueAsNumber;  							break;  					}  					break;  				case RtfInterpreterState.InDocument:  					switch ( tag.Name )  					{  						case RtfSpec.TagPlain:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveNormal();  							break;  						case RtfSpec.TagParagraphDefaults:  						case RtfSpec.TagSectionDefaults:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Left );  							break;  						case RtfSpec.TagBold:  							bool bold = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithBold( bold );  							break;  						case RtfSpec.TagItalic:  							bool italic = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithItalic( italic );  							break;  						case RtfSpec.TagUnderLine:  							bool underline = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithUnderline( underline );  							break;  						case RtfSpec.TagUnderLineNone:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithUnderline( false );  							break;  						case RtfSpec.TagStrikeThrough:  							bool strikeThrough = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithStrikeThrough( strikeThrough );  							break;  						case RtfSpec.TagHidden:  							bool hidden = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithHidden( hidden );  							break;  						case RtfSpec.TagFont:  							string fontId = tag.FullName;  							if ( Context.FontTable.ContainsFontWithId( fontId ) )  							{  								Context.WritableCurrentTextFormat =  									Context.WritableCurrentTextFormat.DeriveWithFont(  										Context.FontTable[ fontId ] );  							}  							else  							{  								if ( Settings.IgnoreUnknownFonts && Context.FontTable.Count > 0 )  								{  									Context.WritableCurrentTextFormat =  										Context.WritableCurrentTextFormat.DeriveWithFont( Context.FontTable[ 0 ] );  								}  								else  								{  									throw new RtfUndefinedFontException( Strings.UndefinedFont( fontId ) );  								}  							}  							break;  						case RtfSpec.TagFontSize:  							int fontSize = tag.ValueAsNumber;  							if ( fontSize >= 0 )  							{  								Context.WritableCurrentTextFormat =  									Context.WritableCurrentTextFormat.DeriveWithFontSize( fontSize );  							}  							else  							{  								throw new RtfInvalidDataException( Strings.InvalidFontSize( fontSize ) );  							}  							break;  						case RtfSpec.TagFontSubscript:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( false );  							break;  						case RtfSpec.TagFontSuperscript:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( true );  							break;  						case RtfSpec.TagFontNoSuperSub:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( 0 );  							break;  						case RtfSpec.TagFontDown:  							int moveDown = tag.ValueAsNumber;  							if ( moveDown == 0 )  							{  								moveDown = 6; // the default value according to rtf spec  							}  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( -moveDown );  							break;  						case RtfSpec.TagFontUp:  							int moveUp = tag.ValueAsNumber;  							if ( moveUp == 0 )  							{  								moveUp = 6; // the default value according to rtf spec  							}  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( moveUp );  							break;  						case RtfSpec.TagAlignLeft:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Left );  							break;  						case RtfSpec.TagAlignCenter:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Center );  							break;  						case RtfSpec.TagAlignRight:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Right );  							break;  						case RtfSpec.TagAlignJustify:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Justify );  							break;  						case RtfSpec.TagColorBackground:  						case RtfSpec.TagColorBackgroundWord:  						case RtfSpec.TagColorHighlight:  						case RtfSpec.TagColorForeground:  							int colorIndex = tag.ValueAsNumber;  							if ( colorIndex >= 0 && colorIndex < Context.ColorTable.Count )  							{  								IRtfColor newColor = Context.ColorTable[ colorIndex ];  								bool isForeground = RtfSpec.TagColorForeground.Equals( tag.Name );  								Context.WritableCurrentTextFormat = isForeground ?  									Context.WritableCurrentTextFormat.DeriveWithForegroundColor( newColor ) :  									Context.WritableCurrentTextFormat.DeriveWithBackgroundColor( newColor );  							}  							else  							{  								throw new RtfUndefinedColorException( Strings.UndefinedColor( colorIndex ) );  							}  							break;  						case RtfSpec.TagSection:  							NotifyInsertBreak( RtfVisualBreakKind.Section );  							break;  						case RtfSpec.TagParagraph:  							NotifyInsertBreak( RtfVisualBreakKind.Paragraph );  							break;  						case RtfSpec.TagLine:  							NotifyInsertBreak( RtfVisualBreakKind.Line );  							break;  						case RtfSpec.TagPage:  							NotifyInsertBreak( RtfVisualBreakKind.Page );  							break;  						case RtfSpec.TagTabulator:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.Tabulator );  							break;  						case RtfSpec.TagTilde:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.NonBreakingSpace );  							break;  						case RtfSpec.TagEmDash:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EmDash );  							break;  						case RtfSpec.TagEnDash:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EnDash );  							break;  						case RtfSpec.TagEmSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EmSpace );  							break;  						case RtfSpec.TagEnSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EnSpace );  							break;  						case RtfSpec.TagQmSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.QmSpace );  							break;  						case RtfSpec.TagBulltet:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.Bullet );  							break;  						case RtfSpec.TagLeftSingleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.LeftSingleQuote );  							break;  						case RtfSpec.TagRightSingleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.RightSingleQuote );  							break;  						case RtfSpec.TagLeftDoubleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.LeftDoubleQuote );  							break;  						case RtfSpec.TagRightDoubleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.RightDoubleQuote );  							break;  						case RtfSpec.TagHyphen:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.OptionalHyphen );  							break;  						case RtfSpec.TagUnderscore:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.NonBreakingHyphen );  							break;  					}  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitTag,The following switch statement is missing a default case: switch ( tag.Name )  					{  						case RtfSpec.TagDefaultFont:  							Context.DefaultFontId = RtfSpec.TagFont + tag.ValueAsNumber;  							break;  					}
Missing Default,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitTag,The following switch statement is missing a default case: switch ( tag.Name )  					{  						case RtfSpec.TagPlain:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveNormal();  							break;  						case RtfSpec.TagParagraphDefaults:  						case RtfSpec.TagSectionDefaults:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Left );  							break;  						case RtfSpec.TagBold:  							bool bold = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithBold( bold );  							break;  						case RtfSpec.TagItalic:  							bool italic = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithItalic( italic );  							break;  						case RtfSpec.TagUnderLine:  							bool underline = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithUnderline( underline );  							break;  						case RtfSpec.TagUnderLineNone:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithUnderline( false );  							break;  						case RtfSpec.TagStrikeThrough:  							bool strikeThrough = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithStrikeThrough( strikeThrough );  							break;  						case RtfSpec.TagHidden:  							bool hidden = !tag.HasValue || tag.ValueAsNumber != 0;  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithHidden( hidden );  							break;  						case RtfSpec.TagFont:  							string fontId = tag.FullName;  							if ( Context.FontTable.ContainsFontWithId( fontId ) )  							{  								Context.WritableCurrentTextFormat =  									Context.WritableCurrentTextFormat.DeriveWithFont(  										Context.FontTable[ fontId ] );  							}  							else  							{  								if ( Settings.IgnoreUnknownFonts && Context.FontTable.Count > 0 )  								{  									Context.WritableCurrentTextFormat =  										Context.WritableCurrentTextFormat.DeriveWithFont( Context.FontTable[ 0 ] );  								}  								else  								{  									throw new RtfUndefinedFontException( Strings.UndefinedFont( fontId ) );  								}  							}  							break;  						case RtfSpec.TagFontSize:  							int fontSize = tag.ValueAsNumber;  							if ( fontSize >= 0 )  							{  								Context.WritableCurrentTextFormat =  									Context.WritableCurrentTextFormat.DeriveWithFontSize( fontSize );  							}  							else  							{  								throw new RtfInvalidDataException( Strings.InvalidFontSize( fontSize ) );  							}  							break;  						case RtfSpec.TagFontSubscript:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( false );  							break;  						case RtfSpec.TagFontSuperscript:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( true );  							break;  						case RtfSpec.TagFontNoSuperSub:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( 0 );  							break;  						case RtfSpec.TagFontDown:  							int moveDown = tag.ValueAsNumber;  							if ( moveDown == 0 )  							{  								moveDown = 6; // the default value according to rtf spec  							}  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( -moveDown );  							break;  						case RtfSpec.TagFontUp:  							int moveUp = tag.ValueAsNumber;  							if ( moveUp == 0 )  							{  								moveUp = 6; // the default value according to rtf spec  							}  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithSuperScript( moveUp );  							break;  						case RtfSpec.TagAlignLeft:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Left );  							break;  						case RtfSpec.TagAlignCenter:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Center );  							break;  						case RtfSpec.TagAlignRight:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Right );  							break;  						case RtfSpec.TagAlignJustify:  							Context.WritableCurrentTextFormat =  								Context.WritableCurrentTextFormat.DeriveWithAlignment( RtfTextAlignment.Justify );  							break;  						case RtfSpec.TagColorBackground:  						case RtfSpec.TagColorBackgroundWord:  						case RtfSpec.TagColorHighlight:  						case RtfSpec.TagColorForeground:  							int colorIndex = tag.ValueAsNumber;  							if ( colorIndex >= 0 && colorIndex < Context.ColorTable.Count )  							{  								IRtfColor newColor = Context.ColorTable[ colorIndex ];  								bool isForeground = RtfSpec.TagColorForeground.Equals( tag.Name );  								Context.WritableCurrentTextFormat = isForeground ?  									Context.WritableCurrentTextFormat.DeriveWithForegroundColor( newColor ) :  									Context.WritableCurrentTextFormat.DeriveWithBackgroundColor( newColor );  							}  							else  							{  								throw new RtfUndefinedColorException( Strings.UndefinedColor( colorIndex ) );  							}  							break;  						case RtfSpec.TagSection:  							NotifyInsertBreak( RtfVisualBreakKind.Section );  							break;  						case RtfSpec.TagParagraph:  							NotifyInsertBreak( RtfVisualBreakKind.Paragraph );  							break;  						case RtfSpec.TagLine:  							NotifyInsertBreak( RtfVisualBreakKind.Line );  							break;  						case RtfSpec.TagPage:  							NotifyInsertBreak( RtfVisualBreakKind.Page );  							break;  						case RtfSpec.TagTabulator:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.Tabulator );  							break;  						case RtfSpec.TagTilde:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.NonBreakingSpace );  							break;  						case RtfSpec.TagEmDash:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EmDash );  							break;  						case RtfSpec.TagEnDash:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EnDash );  							break;  						case RtfSpec.TagEmSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EmSpace );  							break;  						case RtfSpec.TagEnSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.EnSpace );  							break;  						case RtfSpec.TagQmSpace:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.QmSpace );  							break;  						case RtfSpec.TagBulltet:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.Bullet );  							break;  						case RtfSpec.TagLeftSingleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.LeftSingleQuote );  							break;  						case RtfSpec.TagRightSingleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.RightSingleQuote );  							break;  						case RtfSpec.TagLeftDoubleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.LeftDoubleQuote );  							break;  						case RtfSpec.TagRightDoubleQuote:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.RightDoubleQuote );  							break;  						case RtfSpec.TagHyphen:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.OptionalHyphen );  							break;  						case RtfSpec.TagUnderscore:  							NotifyInsertSpecialChar( RtfVisualSpecialCharKind.NonBreakingHyphen );  							break;  					}
Missing Default,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitGroup,The following switch statement is missing a default case: switch ( groupDestination )  					{  						case RtfSpec.TagFontTable:  							fontTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagColorTable:  							colorTableBuilder.VisitGroup( group );  							break;  						case RtfSpec.TagGenerator:  							// last group with a destination in header' but no need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							IRtfText generator = group.Contents.Count == 3 ? group.Contents[ 2 ] as IRtfText : null;  							if ( generator != null )  							{  								string generatorName = generator.Text;  								Context.Generator = generatorName.EndsWith( ";" ) ?  									generatorName.Substring( 0' generatorName.Length - 1 ) : generatorName;  							}  							else  							{  								throw new RtfInvalidDataException( Strings.InvalidGeneratorGroup( group.ToString() ) );  							}  							break;  						case RtfSpec.TagPlain:  						case RtfSpec.TagParagraphDefaults:  						case RtfSpec.TagSectionDefaults:  						case RtfSpec.TagUnderLineNone:  						case null:  							// <tags>: special tags commonly used to reset state in a beginning group. necessary to recognize  							//         state transition form header to document in case no other mechanism detects it and the  							//         content starts with a group with such a 'destination' ...  							// 'null': group without destination cannot be part of header' but need to process its contents  							Context.State = RtfInterpreterState.InDocument;  							if ( !group.IsExtensionDestination )  							{  								VisitChildrenOf( group );  							}  							break;  					}
Missing Default,Itenso.Rtf.Interpreter,RtfInterpreter,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreter.cs,VisitText,The following switch statement is missing a default case: switch ( Context.State )  			{  				case RtfInterpreterState.Init:  					throw new RtfStructureException( Strings.InvalidInitTextState( text.Text ) );  				case RtfInterpreterState.InHeader:  					// allow spaces in between header tables  					if ( !string.IsNullOrEmpty( text.Text.Trim() ) )  					{  						Context.State = RtfInterpreterState.InDocument;  					}  					break;  				case RtfInterpreterState.InDocument:  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfInterpreterListenerDocumentBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreterListenerDocumentBuilder.cs,DoInsertBreak,The following switch statement is missing a default case: switch ( kind )  			{  				case RtfVisualBreakKind.Paragraph:  				case RtfVisualBreakKind.Section:  					EndParagraph( context );  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfInterpreterListenerDocumentBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfInterpreterListenerDocumentBuilder.cs,EndParagraph,The following switch statement is missing a default case: switch ( alignedVisual.Kind )  				{  					case RtfVisualKind.Image:  						RtfVisualImage image = (RtfVisualImage)alignedVisual;  						// ReSharper disable RedundantCheckBeforeAssignment  						if ( image.Alignment != finalParagraphAlignment )  						// ReSharper restore RedundantCheckBeforeAssignment  						{  							image.Alignment = finalParagraphAlignment;  						}  						break;  					case RtfVisualKind.Text:  						RtfVisualText text = (RtfVisualText)alignedVisual;  						if ( text.Format.Alignment != finalParagraphAlignment )  						{  							IRtfTextFormat correctedFormat = ( (RtfTextFormat)text.Format ).DeriveWithAlignment( finalParagraphAlignment );  							IRtfTextFormat correctedUniqueFormat = context.GetUniqueTextFormatInstance( correctedFormat );  							text.Format = correctedUniqueFormat;  						}  						break;  				}
Missing Default,Itenso.Rtf.Interpreter,RtfTimestampBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfTimestampBuilder.cs,DoVisitTag,The following switch statement is missing a default case: switch ( tag.Name )  			{  				case RtfSpec.TagInfoYear:  					year = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoMonth:  					month = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoDay:  					day = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoHour:  					hour = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoMinute:  					minutes = tag.ValueAsNumber;  					break;  				case RtfSpec.TagInfoSecond:  					seconds = tag.ValueAsNumber;  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfUserPropertyBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfUserPropertyBuilder.cs,DoVisitGroup,The following switch statement is missing a default case: switch ( group.Destination )  			{  				case RtfSpec.TagUserProperties:  					VisitGroupChildren( group );  					break;  				case null:  					Reset();  					VisitGroupChildren( group );  					collectedProperties.Add( CreateProperty() );  					break;  				case RtfSpec.TagUserPropertyName:  					textBuilder.Reset();  					textBuilder.VisitGroup( group );  					propertyName = textBuilder.CombinedText;  					break;  				case RtfSpec.TagUserPropertyValue:  					textBuilder.Reset();  					textBuilder.VisitGroup( group );  					staticValue = textBuilder.CombinedText;  					break;  				case RtfSpec.TagUserPropertyLink:  					textBuilder.Reset();  					textBuilder.VisitGroup( group );  					linkValue = textBuilder.CombinedText;  					break;  			}
Missing Default,Itenso.Rtf.Interpreter,RtfUserPropertyBuilder,C:\repos\Sicos1977_msgreader\Interpreter\Interpreter\RtfUserPropertyBuilder.cs,DoVisitTag,The following switch statement is missing a default case: switch ( tag.Name )  			{  				case RtfSpec.TagUserPropertyType:  					propertyTypeCode = tag.ValueAsNumber;  					break;  			}
