Implementation smell,Namespace,Class,File,Method,Description
Long Method,MsgReader.Helpers,MimeType,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\MimeType.cs,GetExtensionFromMimeType,The method has 424 lines of code.
Long Method,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The method has 160 lines of code.
Long Method,MsgReader.Mime.Decode,Rfc2231Decoder,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\Rfc2231Decoder.cs,DecodePairs,The method has 105 lines of code.
Long Method,MsgReader.Mime.Decode,Rfc2822DateTime,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\Rfc2822DateTime.cs,MatchEvaluator,The method has 116 lines of code.
Long Method,MsgReader.Mime.Header,MessageHeader,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Header\MessageHeader.cs,ParseHeader,The method has 130 lines of code.
Long Method,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The method has 138 lines of code.
Long Method,MsgReader.Outlook,Contact,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Contact.cs,Contact,The method has 132 lines of code.
Long Method,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The method has 197 lines of code.
Long Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,ExtractMsgEmailHeader,The method has 123 lines of code.
Long Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteEmlStreamEmail,The method has 111 lines of code.
Long Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgAppointment,The method has 129 lines of code.
Long Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgTask,The method has 131 lines of code.
Long Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgContact,The method has 262 lines of code.
Long Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,PreProcessMsgFile,The method has 129 lines of code.
Long Method,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteStartDocument,The method has 171 lines of code.
Long Method,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteStartString,The method has 101 lines of code.
Long Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,Load,The method has 1096 lines of code.
Long Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,AddContentElement,The method has 113 lines of code.
Long Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,CombineTable,The method has 107 lines of code.
Long Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,UpdateTableCells,The method has 334 lines of code.
Long Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadHtmlContent,The method has 186 lines of code.
Complex Method,MsgReader.Helpers,DateDifference,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\DateDifference.cs,ToString,Cyclomatic complexity of the method is 22
Complex Method,MsgReader.Helpers,DateDifference,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\DateDifference.cs,Difference,Cyclomatic complexity of the method is 17
Complex Method,MsgReader.Mime,Message,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Message.cs,GetEmailAddresses,Cyclomatic complexity of the method is 8
Complex Method,MsgReader.Mime,MessagePart,C:\repos\Sicos1977_msgreader\MsgReader\Mime\MessagePart.cs,FindFileName,Cyclomatic complexity of the method is 8
Complex Method,MsgReader.Outlook,Contact,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Contact.cs,Contact,Cyclomatic complexity of the method is 21
Complex Method,MsgReader.Outlook,MapiTagMapper,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTagMapper.cs,GetMapping,Cyclomatic complexity of the method is 8
Complex Method,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,Cyclomatic complexity of the method is 13
Complex Method,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,SetEmailSenderAndRepresentingSender,Cyclomatic complexity of the method is 13
Complex Method,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,Cyclomatic complexity of the method is 19
Complex Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,ExtractMsgEmailHeader,Cyclomatic complexity of the method is 16
Complex Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteEmlStreamEmail,Cyclomatic complexity of the method is 10
Complex Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteEmlEmail,Cyclomatic complexity of the method is 9
Complex Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgAppointment,Cyclomatic complexity of the method is 12
Complex Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgTask,Cyclomatic complexity of the method is 15
Complex Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgContact,Cyclomatic complexity of the method is 45
Complex Method,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,PreProcessMsgFile,Cyclomatic complexity of the method is 18
Complex Method,MsgReader.Rtf,DocumentFormatInfo,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentFormatInfo.cs,EqualsSettings,Cyclomatic complexity of the method is 33
Complex Method,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteStartString,Cyclomatic complexity of the method is 18
Complex Method,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteEndString,Cyclomatic complexity of the method is 9
Complex Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,Load,Cyclomatic complexity of the method is 20
Complex Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,FixElements,Cyclomatic complexity of the method is 12
Complex Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,AddContentElement,Cyclomatic complexity of the method is 19
Complex Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,CombineTable,Cyclomatic complexity of the method is 12
Complex Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,UpdateTableCells,Cyclomatic complexity of the method is 66
Complex Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadListOverrideTable,Cyclomatic complexity of the method is 9
Complex Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadListTable,Cyclomatic complexity of the method is 10
Complex Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadFontTable,Cyclomatic complexity of the method is 10
Complex Method,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ToDomString,Cyclomatic complexity of the method is 9
Complex Method,MsgReader.Rtf,Lex,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Lex.cs,ParseKeyword,Cyclomatic complexity of the method is 9
Complex Method,MsgReader.Rtf,NodeGroup,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\NodeGroup.cs,MergeText,Cyclomatic complexity of the method is 11
Complex Method,MsgReader.Rtf,TextContainer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\TextContainer.cs,Accept,Cyclomatic complexity of the method is 14
Long Parameter List,MsgReader.Helpers,NativeMethods,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileIcon.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pszPath' dwFileAttributes' psfi' cbSizeFileInfo' uFlags
Long Parameter List,MsgReader.Outlook,NativeMethods,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\NativeMethods.cs,StgOpenStorageOnILockBytes,The method has 6 parameters. Parameters: plkbyt' pstgPriority' grfMode' snbExclude' reserved' ppstgOpen
Long Parameter List,MsgReader.Outlook,NativeMethods,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\NativeMethods.cs,StgOpenStorage,The method has 6 parameters. Parameters: wcsName' pstgPriority' grfMode' snbExclude' reserved' ppstgOpen
Long Parameter List,MsgReader.Outlook,IStorage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\NativeMethods.cs,OpenStorage,The method has 5 parameters. Parameters: pwcsName' pstgPriority' grfMode' snbExclude' reserved
Long Parameter List,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The method has 10 parameters. Parameters: binaryReader' addressType' supportsRtf' displayNameIncluded' emailAddressIncluded' addressTypeIncluded' simpleDisplayNameIncluded' transmittableDisplayNameSameAsDisplayName' transmittableDisplayNameIncluded' stringsInUnicode
Long Parameter List,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteHeaderLine,The method has 5 parameters. Parameters: header' htmlBody' labelPadRightWidth' label' text
Long Parameter List,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteHeaderLineNoEncoding,The method has 5 parameters. Parameters: header' htmlBody' labelPadRightWidth' label' text
Long Parameter List,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,PreProcessMsgFile,The method has 9 parameters. Parameters: message' hyperlinks' outputFolder' fileName' htmlBody' body' contactPhotoFileName' attachments' files
Long Parameter List,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,PreProcessEmlStream,The method has 6 parameters. Parameters: message' hyperlinks' htmlBody' body' attachments' attachStreams
Long Parameter List,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,PreProcessEmlFile,The method has 8 parameters. Parameters: message' hyperlinks' outputFolder' fileName' htmlBody' body' attachments' files
Long Parameter List,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadInnerText,The method has 5 parameters. Parameters: reader' firstToken' deeply' breakMeetControlWord' htmlMode
Long Parameter List,MsgReader.Rtf,AnsiEncoding,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,GetBytes,The method has 5 parameters. Parameters: chars' charIndex' charCount' bytes' byteIndex
Long Parameter List,MsgReader.Rtf,AnsiEncoding,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,MsgReader.Rtf,NativeMethods,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Util.cs,GdipEmfToWmfBits,The method has 5 parameters. Parameters: hEmf' bufferSize' buffer' mappingMode' flags
Long Identifier,MsgReader.Mime,MessagePart,C:\repos\Sicos1977_msgreader\MsgReader\Mime\MessagePart.cs,GetMultiPartParts,The length of the parameter lastMultipartBoundaryEncountered is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ALTERNATE_RECIPIENT_ALLOWED is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID is 39.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_CONVERSION_WITH_LOSS_PROHIBITED is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_IMPLICIT_CONVERSION_PROHIBITED is 33.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINALLY_INTENDED_RECIPIENT_NAME is 37.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED is 39.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_PROOF_OF_SUBMISSION_REQUESTED is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RECIPIENT_REASSIGNMENT_PROHIBITED is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_SENT_REPRESENTING_SEARCH_KEY is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RCVD_REPRESENTING_SEARCH_KEY is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_NAME is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_NAME_W is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_NAME_A is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_ENTRYID is 37.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY is 40.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_SENT_REPRESENTING_ADDRTYPE_W is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_SENT_REPRESENTING_ADDRTYPE_A is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_SENT_REPRESENTING_EMAIL_ADDRESS is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_SENT_REPRESENTING_EMAIL_ADDRESS_W is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_SENT_REPRESENTING_EMAIL_ADDRESS_A is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENDER_EMAIL_ADDRESS is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE is 38.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W is 40.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A is 40.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS is 43.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W is 45.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A is 45.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RECEIVED_BY_EMAIL_ADDRESS_W is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RECEIVED_BY_EMAIL_ADDRESS_A is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RCVD_REPRESENTING_ADDRTYPE_W is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RCVD_REPRESENTING_ADDRTYPE_A is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RCVD_REPRESENTING_EMAIL_ADDRESS is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RCVD_REPRESENTING_EMAIL_ADDRESS_W is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RCVD_REPRESENTING_EMAIL_ADDRESS_A is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_W is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_A is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE is 37.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_W is 39.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_A is 39.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS is 42.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_W is 44.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_A is 44.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_TRANSPORT_MESSAGE_HEADERS_W is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_TRANSPORT_MESSAGE_HEADERS_A is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY is 38.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINALLY_INTENDED_RECIP_ENTRYID is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_NON_RECEIPT_NOTIFICATION_REQUESTED is 37.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED is 43.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT is 43.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY is 40.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_PHYSICAL_DELIVERY_REPORT_REQUEST is 35.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_PHYSICAL_FORWARDING_ADDRESS is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED is 40.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_PHYSICAL_FORWARDING_PROHIBITED is 33.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_PHYSICAL_RENDITION_ATTRIBUTES is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_PROOF_OF_DELIVERY_REQUESTED is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RECIPIENT_NUMBER_FOR_ADVICE is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RECIPIENT_NUMBER_FOR_ADVICE_W is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_RECIPIENT_NUMBER_FOR_ADVICE_A is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ORIGINATING_MTA_CERTIFICATE is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_CALLBACK_TELEPHONE_NUMBER_W is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_CALLBACK_TELEPHONE_NUMBER_A is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_TELEPHONE_NUMBER_W is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_TELEPHONE_NUMBER_A is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS2_TELEPHONE_NUMBER_W is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS2_TELEPHONE_NUMBER_A is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_CELLULAR_TELEPHONE_NUMBER_W is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_CELLULAR_TELEPHONE_NUMBER_A is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_TRANSMITABLE_DISPLAY_NAME_W is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_TRANSMITABLE_DISPLAY_NAME_A is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE is 37.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_W is 39.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_A is 39.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_ADDRESS_POSTAL_CODE is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_ADDRESS_POSTAL_CODE_W is 33.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_ADDRESS_POSTAL_CODE_A is 33.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_ADDRESS_POST_OFFICE_BOX is 35.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_W is 37.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_A is 37.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ASSISTANT_TELEPHONE_NUMBER_W is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_ASSISTANT_TELEPHONE_NUMBER_A is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_CONTACT_DEFAULT_ADDRESS_INDEX is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_COMPANY_MAIN_PHONE_NUMBER_W is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_COMPANY_MAIN_PHONE_NUMBER_A is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_HOME_ADDRESS_STATE_OR_PROVINCE is 33.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_HOME_ADDRESS_STATE_OR_PROVINCE_W is 35.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_HOME_ADDRESS_STATE_OR_PROVINCE_A is 35.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_HOME_ADDRESS_POST_OFFICE_BOX is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_HOME_ADDRESS_POST_OFFICE_BOX_W is 33.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_HOME_ADDRESS_POST_OFFICE_BOX_A is 33.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_OTHER_ADDRESS_POSTAL_CODE_W is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_OTHER_ADDRESS_POSTAL_CODE_A is 30.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_OTHER_ADDRESS_STATE_OR_PROVINCE is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_OTHER_ADDRESS_STATE_OR_PROVINCE_W is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_OTHER_ADDRESS_STATE_OR_PROVINCE_A is 36.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_OTHER_ADDRESS_POST_OFFICE_BOX is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_OTHER_ADDRESS_POST_OFFICE_BOX_W is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_OTHER_ADDRESS_POST_OFFICE_BOX_A is 34.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_X400_DEFERRED_DELIVERY_CANCEL is 32.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PropertiesStreamHeaderAttachOrRecip is 35.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter AppointmentUnsendableRecipients is 31.
Long Identifier,MsgReader.Outlook,MapiTags,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTags.cs,,The length of the parameter PR_SENT_REPRESENTING_SMTP_ADDRESS is 33.
Long Identifier,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The length of the parameter transmittableDisplayNameSameAsDisplayName is 41.
Long Identifier,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The length of the parameter transmittableDisplayNameIncluded is 32.
Long Statement,MsgReader.Helpers,FileManager,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileManager.cs,RemoveInvalidFileNameChars,The length of the statement  "            return Path.GetInvalidFileNameChars().Aggregate(fileName' (current' c) => current.Replace(c.ToString(CultureInfo.InvariantCulture)' string.Empty)); " is 147.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0xD0' 0xCF' 0x11' 0xE0' 0xA1' 0xB1' 0x1A' 0xE1 }' MicroSoftOffice' "Microsoft Office applications (Word' Powerpoint' Excel' Works)")); " is 182.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x50' 0x4B }' ZipOrOffice2007' "Zip or Microsoft Office 2007' 2010 or 2013 document")); " is 135.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0xC5' 0x00' 0x00' 0x00' 0x00' 0x00' 0x0D }' "cold"' "FileNet COLD document")); " is 126.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(Stb("# Microsoft Developer Studio")' "dsp"' "Microsoft Developer Studio project file")); " is 123.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x00' 0x01' 0x00' 0x00' 0x53' 0x74' 0x61' 0x6E' 0x64' 0x61' 0x72' 0x64' 0x20' 0x4A' 0x65' 0x74' 0x20' 0x44' 0x42 }' "mdb"' "Microsoft Access file")); " is 197.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x00' 0x01' 0x00' 0x00' 0x53' 0x74' 0x61' 0x6E' 0x64' 0x61' 0x72' 0x64' 0x20' 0x41' 0x43' 0x45' 0x20' 0x44' 0x42 }' "accdb"' "Microsoft Access 2007 file")); " is 204.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x9C' 0xCB' 0xCB' 0x8D' 0x13' 0x75' 0xD2' 0x11' 0x91' 0x58' 0x00' 0xC0' 0x4F' 0x79' 0x56' 0xA4 }' "wab"' "Outlook address file")); " is 178.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x50' 0x4B' 0x03' 0x04' 0x14' 0x00' 0x01' 0x00 }' "zip"' "ZLock Pro encrypted ZIP")); " is 133.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x37' 0x7A' 0xBC' 0xAF' 0x27' 0x1C }' "7z"' "7-Zip compressed file")); // 7Z zip formaat	 " is 136.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(Stb("PKSFX")' "zip"' "PKSFX self-extracting executable compressed file (see also PKZIP)")); " is 126.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(Stb("<?xml version=\"1.0\" encoding=\"utf-16\"")' "xml"' "XML File (UTF16 encoding)")); " is 122.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(Stb("<?xml version=\"1.0\" encoding=\"utf-8\"")' "xml"' "XML File (UTF8 encoding)")); " is 120.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(Stb("<?xml version=\"1.0\" encoding=\"utf-7\"")' "xml"' "XML File (UTF7 encoding)")); " is 120.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x52' 0x65' 0x74' 0x75' 0x72' 0x6E' 0x2D' 0x50' 0x61' 0x74' 0x68' 0x3A' 0x20 }' "eml"' "A commmon file extension for e-mail files")); " is 181.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x46' 0x72' 0x6F' 0x6D' 0x20' 0x3F' 0x3F' 0x3F }' "eml"' "E-mail markup language file")); " is 137.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x46' 0x72' 0x6F' 0x6D' 0x20' 0x20' 0x20 }' "eml"' "E-mail markup language file")); " is 131.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x46' 0x72' 0x6F' 0x6D' 0x3A' 0x20 }' "eml"' "E-mail markup language file")); " is 125.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x4D' 0x4D' 0x00' 0x2B }' "tif"' "BigTIFF files; Tagged Image File Format files > 4 GB")); " is 138.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x4D' 0x4D' 0x00' 0x2A }' "tif"' "Tagged Image File Format file (big endian' i.e.' LSB last in the byte; Motorola)")); " is 166.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x49' 0x49' 0x2A' 0x00 }' "tif"' "Tagged Image File Format file (little endian' i.e.' LSB first in the byte; Intel)")); " is 167.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x30' 0x32 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R2.5")); " is 136.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x30' 0x33 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R2.6")); " is 136.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x30' 0x34 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R9")); " is 134.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x30' 0x36 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R10")); " is 135.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x30' 0x39 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R11/R12")); " is 139.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x31' 0x30 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R13 (subtype 10)")); " is 148.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x31' 0x31 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R13 (subtype 11)")); " is 148.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x31' 0x32 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R13 (subtype 12)")); " is 148.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x31' 0x33 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R13 (subtype 13)")); " is 148.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x31' 0x34 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R13 (subtype 14)")); " is 148.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x31' 0x35 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R2000")); " is 137.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x31' 0x38 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R2004")); " is 137.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x41' 0x43' 0x31' 0x30' 0x32' 0x31 }' "dwg"' "Generic AutoCAD drawing - AutoCAD R2007")); " is 137.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0xFF' 0xD8' 0xFF' 0xE8 }' "jpg"' "Still Picture Interchange File Format (SPIFF)")); " is 131.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x2E' 0x52' 0x4D' 0x46' 0x00' 0x00' 0x00' 0x12' 0x00 }' "ra"' "RealAudio file")); " is 129.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x2E' 0x72' 0x61' 0xFD' 0x00 }' "ra"' "RealAudio streaming media file")); " is 121.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x00' 0x01' 0x00' 0x08' 0x00' 0x01' 0x00' 0x01' 0x01 }' "img"' "Image Format Bitmap file")); " is 140.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x50' 0x49' 0x43' 0x54' 0x00' 0x08 }' "img"' "ADEX Corp. ChromaGraph Graphics Card Bitmap Graphic file")); " is 154.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x45' 0x6C' 0x66' 0x46' 0x69' 0x6C' 0x65' 0x00 }' "evtx"' "Windows Vista event log file")); " is 139.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x30' 0x00' 0x00' 0x00' 0x4C' 0x66' 0x4C' 0x65 }' "evt"' "Windows Event Viewer file")); " is 135.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x49' 0x54' 0x53' 0x46 }' "chm"' "Microsoft Compiled HTM   L Help File")); " is 122.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x49' 0x53' 0x63' 0x28 }' "cab"' "Install Shield v5.x or 6.x compressed file")); " is 128.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x52' 0x61' 0x72' 0x21' 0x1A' 0x07' 0x00 }' "rar"' "WinRAR compressed archive file")); " is 134.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x1A' 0x45' 0xD5' 0xA3' 0x93' 0x42' 0x82' 0x88' 0x6D' 0x61' 0x74' 0x72' 0x6F' 0x73' 0x6B }' "mkv"' "Matroska open movie format")); " is 178.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x30' 0x26' 0xB2' 0x75' 0x8E' 0x66' 0xCF' 0x11' 0xA6' 0xD9' 0x00' 0xAA' 0x00' 0x62' 0xCE' 0x6C }' "wmv"' "Microsoft Windows Media Audio/Video File (Advanced Streaming Format")); " is 225.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x30' 0x26' 0xB2' 0x75' 0x8E' 0x66' 0xCF' 0x11' 0xA6' 0xD9' 0x00' 0xAA' 0x00' 0x62' 0xCE' 0x6C }' "wma"' "	Microsoft Windows Media Audio/Video File (Advanced Streaming Format)")); " is 227.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(Stb("Windows Registry Editor Version 5.00")' "reg"' "Windows Registry Editor Version 5.00 file")); " is 133.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x00' 0x00' 0x00' 0x18' 0x66' 0x74' 0x79' 0x70' 0x33' 0x67' 0x70' 0x35 }' "mp4"' "MPEG-4 video files")); " is 152.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x49' 0x49' 0x1A' 0x00' 0x00' 0x00' 0x48' 0x45' 0x41' 0x50' 0x43' 0x43' 0x44' 0x52' 0x02' 0x00 }' "crw"' "Canon digital camera RAW file")); " is 187.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x00' 0x00' 0x00' 0x20' 0x66' 0x74' 0x79' 0x70' 0x4D' 0x34' 0x41' 0x20' 0x00' 0x00' 0x00' 0x00 }' "mov"' "Apple QuickTime movie file")); " is 184.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x4C' 0x00' 0x00' 0x00' 0x01' 0x14' 0x02' 0x00 }' "lnk"' "Windows shortcut file")); " is 131.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x52' 0x45' 0x47' 0x45' 0x44' 0x49' 0x54 }' "reg"' "Windows NT Registry and Registry Undo files")); " is 147.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x43' 0x50' 0x54' 0x46' 0x49' 0x4C' 0x45 }' "cpt"' "Corel Photopaint file")); " is 125.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x4A' 0x41' 0x52' 0x43' 0x53' 0x00 }' "jar"' "JARCS compressed archive")); " is 122.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x01' 0x0F' 0x00' 0x00 }' "mdf"' "Microsoft SQL Server 2000 database")); " is 120.
Long Statement,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,GetFileTypes,The length of the statement  "            fileTypes.Add(new FileTypeFileInfo(new byte[] { 0x00' 0x00' 0x01' 0xBA }' "vob"' "DVD Video Movie File (video/dvd' video/mpeg)")); " is 130.
Long Statement,MsgReader.Mime.Decode,Rfc2822DateTime,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\Rfc2822DateTime.cs,ExtractDateTime,The length of the statement  "                    strDate = strDate.Substring(0' strDate.Length - parts[parts.Length - 1].Length).Trim(); //Use the length of the old last part " is 125.
Long Statement,MsgReader.Mime.Header,RfcMailAddress,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Header\RfcMailAddress.cs,ParseMailAddress,The length of the statement  "            //Find the index of the first angle bracket in this series of angle brackets' e.g "a>b" <<blah@email.com>> wouldn't find the angle bracket in the display name " is 158.
Long Statement,MsgReader.Mime.Header,RfcMailAddress,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Header\RfcMailAddress.cs,ParseMailAddress,The length of the statement  "                input[firstOpenAngleBracketIdx - 1] == '<' && //The character before the last open angle bracket is another open angle bracket " is 126.
Long Statement,MsgReader.Mime.Header,RfcMailAddress,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Header\RfcMailAddress.cs,ParseMailAddress,The length of the statement  "                input[firstCloseAngleBracketIdx - 1] == '>') //The character before the last close angle bracket is another close angle bracket " is 127.
Long Statement,MsgReader.Mime.Header,RfcMailAddress,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Header\RfcMailAddress.cs,ParseMailAddress,The length of the statement  "                    input.Substring(lastOpenAngleBracketIdx' firstCloseAngleBracketIdx - lastOpenAngleBracketIdx + 1); //actual email address' including one angle bracket either side " is 162.
Long Statement,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The length of the statement  "                    var subStorage = storage.OpenStorage(storageStatistic.pwcsName' IntPtr.Zero' NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' " is 138.
Long Statement,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,Save,The length of the statement  "                    // If not the top parent then the name id mapping needs to be copied from top parent to this message and the property stream header  " is 131.
Long Statement,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,Save,The length of the statement  "                        // Insert 8 null bytes from index 24 to 32. this is because a top level object property header requires a 32 byte header " is 120.
Long Statement,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,PreProcessMsgFile,The length of the statement  "                            "<table style=\"width: 70px; display: inline; text-align: center; font-family: Times New Roman; font-size: 12pt;\"><tr><td>" + " is 126.
Long Statement,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,PreProcessEmlStream,The length of the statement  "                            attachments.Add(CheckValidAttachment(attachmentFileName) + " (" + FileManager.GetFileSizeString(attachment.Body.Length) + ")"); " is 127.
Long Statement,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,UpdateTableCells,The length of the statement  "					cell.Format.BackColor = cell.HasAttribute(Consts.Clcbpat) ? ColorTable.GetColor(cell.Attributes[Consts.Clcbpat]' Color.Transparent) : Color.Transparent; " is 152.
Long Statement,MsgReader.Rtf,RawDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\RawDocument.cs,ReadDocumentInfo,The length of the statement  "                    InternalInfo.SetInfo(node.Keyword' node.HasParameter ? node.Parameter.ToString(CultureInfo.InvariantCulture) : node.Nodes.Text); " is 128.
Complex Conditional,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,StripByteOrderMarker,The conditional expression  "IndexOf(magicBytes' new byte[] { 0xDD' 0x73' 0x66' 0x73 }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0xFF' 0xFE' 0x00' 0x00 }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0x00' 0x00' 0xFE' 0xFF }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0x84' 0x31' 0x95' 0x33 }' 0) == 0"  is complex.
Complex Conditional,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,StripByteOrderMarker,The conditional expression  "IndexOf(magicBytes' new byte[] { 0xEF' 0xBB' 0xBF }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0x2B' 0x2F' 0x76 }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0x0E' 0xFE' 0xFF }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0xFB' 0xEE' 0x28 }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0xF7' 0x64' 0x4C }' 0) == 0"  is complex.
Complex Conditional,MsgReader.Rtf,ByteBuffer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\ByteBuffer.cs,Add,The conditional expression  "bs != null && startIndex >= 0 && (startIndex + length ) <= bs.Length && length > 0"  is complex.
Complex Conditional,MsgReader.Rtf,DocumentInfo,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentInfo.cs,Write,The conditional expression  "strKey == "edmins"                      || strKey == "vern"                      || strKey == "nofpages"                      || strKey == "nofwords"                      || strKey == "nofchars"                      || strKey == "nofcharsws"                      || strKey == "id""  is complex.
Complex Conditional,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteStartString,The conditional expression  "info.LeftBorder                  || info.TopBorder                  || info.RightBorder                  || info.BottomBorder"  is complex.
Complex Conditional,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,FixForParagraphs,The conditional expression  "element is DomParagraph  					|| element is DomTableRow  					|| element is DomTable  					|| element is DomTableCell"  is complex.
Complex Conditional,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,AddContentElement,The conditional expression  "newElement is DomText  					|| newElement is DomImage  					|| newElement is DomObject  					|| newElement is DomShape  					|| newElement is DomShapeGroup"  is complex.
Complex Conditional,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,AddContentElement,The conditional expression  "newElement is DomText  								|| newElement is DomImage  								|| newElement is DomObject  								|| newElement is DomShape  								|| newElement is DomShapeGroup  								|| newElement is DomField  								|| newElement is DomBookmark  								|| newElement is DomLineBreak"  is complex.
Complex Conditional,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,AddContentElement,The conditional expression  "element2 is DomTableRow  										|| element2 is DomTableCell  										|| element2 is DomField  										|| element2 is DomParagraph"  is complex.
Complex Conditional,MsgReader.Rtf,Lex,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Lex.cs,PeekTokenType,The conditional expression  "c == '\r'                     || c == '\n'                     || c == '\t'                     || c == '\0'"  is complex.
Complex Conditional,MsgReader.Rtf,Lex,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Lex.cs,NextToken,The conditional expression  "c < 0 || c == '\"' || c == '\r' || c == '\n'"  is complex.
Complex Conditional,MsgReader.Rtf,Lex,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Lex.cs,NextToken,The conditional expression  "c == '\r'                     || c == '\n'                     || c == '\t'                     || c == '\0'"  is complex.
Complex Conditional,MsgReader.Rtf,Lex,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Lex.cs,ParseText,The conditional expression  "c != '\\' && c != '}' && c != '{' && c != Eof"  is complex.
Complex Conditional,MsgReader.Rtf,Lex,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Lex.cs,ClearWhiteSpace,The conditional expression  "c == '\r'                     || c == '\n'                     || c == '\t'                     || c == '\0'"  is complex.
Virtual Method Call from Constructor,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Storage,The constructor "Storage" calls a virtual method "LoadStorage".
Virtual Method Call from Constructor,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Storage,The constructor "Storage" calls a virtual method "LoadStorage".
Virtual Method Call from Constructor,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Storage,The constructor "Storage" calls a virtual method "LoadStorage".
Empty Catch Block,MsgReader.Mime.Decode,Rfc2822DateTime,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\Rfc2822DateTime.cs,ExtractDateTime,The method has an empty catch block.
Empty Catch Block,MsgReader.Mime.Decode,Rfc2822DateTime,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\Rfc2822DateTime.cs,ExtractDateTime,The method has an empty catch block.
Empty Catch Block,MsgReader.Mime.Header,RfcMailAddress,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Header\RfcMailAddress.cs,ParseMailAddress,The method has an empty catch block.
Empty Catch Block,MsgReader.Mime,MessagePart,C:\repos\Sicos1977_msgreader\MsgReader\Mime\MessagePart.cs,FindFileName,The method has an empty catch block.
Empty Catch Block,MsgReader.Outlook,Attachment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Attachment.cs,ResolveAttachment,The method has an empty catch block.
Magic Number,MsgReader.Helpers,DateDifference,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\DateDifference.cs,Difference,The following statement contains a magic number: if (dateTime2.Month < dateTime1.Month)                  dateDiff.Months = 12 - dateTime1.Month + dateTime2.Month;
Magic Number,MsgReader.Helpers,DateDifference,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\DateDifference.cs,Difference,The following statement contains a magic number: dateDiff.Weeks = dateDiff.Days/7;
Magic Number,MsgReader.Helpers,DateDifference,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\DateDifference.cs,Difference,The following statement contains a magic number: dateDiff.Days = dateDiff.Days%7;
Magic Number,MsgReader.Helpers,DateDifference,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\DateDifference.cs,Difference,The following statement contains a magic number: if (dateTime2.Hour < dateTime1.Hour)                  dateDiff.Hours = 24 - dateTime1.Hour + dateTime2.Hour;
Magic Number,MsgReader.Helpers,DateDifference,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\DateDifference.cs,Difference,The following statement contains a magic number: if (dateTime2.Minute < dateTime1.Minute)                  dateDiff.Minutes = 60 - dateTime1.Minute + dateTime2.Minute;
Magic Number,MsgReader.Helpers,DateDifference,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\DateDifference.cs,Difference,The following statement contains a magic number: if (dateTime2.Second < dateTime1.Second)                  dateDiff.Seconds = 60 - dateTime1.Second + dateTime2.Second;
Magic Number,MsgReader.Helpers,Strings,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\Strings.cs,ReadNullTerminatedUnicodeString,The following statement contains a magic number: var b = binaryReader.ReadBytes(2);
Magic Number,MsgReader.Helpers,Strings,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\Strings.cs,ReadNullTerminatedUnicodeString,The following statement contains a magic number: while (b[0] != 0 && b[1] != 0)              {                  result.WriteByte(b[0]);                  result.WriteByte(b[2]);                  b = binaryReader.ReadBytes(2);              }
Magic Number,MsgReader.Helpers,Strings,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\Strings.cs,ReadNullTerminatedUnicodeString,The following statement contains a magic number: while (b[0] != 0 && b[1] != 0)              {                  result.WriteByte(b[0]);                  result.WriteByte(b[2]);                  b = binaryReader.ReadBytes(2);              }
Magic Number,MsgReader.Helpers,FileManager,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileManager.cs,FileExistsMakeNew,The following statement contains a magic number: var i = 2;
Magic Number,MsgReader.Helpers,FileManager,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileManager.cs,GetFileSizeString,The following statement contains a magic number: if (bytes >= 1073741824.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1073741824.0) + " GB";              else if (bytes >= 1048576.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1048576.0) + " MB";              else if (bytes >= 1024.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1024.0) + " KB";              else if (bytes > 0 && bytes < 1024.0)                  size = bytes + " Bytes";
Magic Number,MsgReader.Helpers,FileManager,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileManager.cs,GetFileSizeString,The following statement contains a magic number: if (bytes >= 1073741824.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1073741824.0) + " GB";              else if (bytes >= 1048576.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1048576.0) + " MB";              else if (bytes >= 1024.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1024.0) + " KB";              else if (bytes > 0 && bytes < 1024.0)                  size = bytes + " Bytes";
Magic Number,MsgReader.Helpers,FileManager,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileManager.cs,GetFileSizeString,The following statement contains a magic number: if (bytes >= 1073741824.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1073741824.0) + " GB";              else if (bytes >= 1048576.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1048576.0) + " MB";              else if (bytes >= 1024.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1024.0) + " KB";              else if (bytes > 0 && bytes < 1024.0)                  size = bytes + " Bytes";
Magic Number,MsgReader.Helpers,FileManager,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileManager.cs,GetFileSizeString,The following statement contains a magic number: if (bytes >= 1073741824.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1073741824.0) + " GB";              else if (bytes >= 1048576.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1048576.0) + " MB";              else if (bytes >= 1024.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1024.0) + " KB";              else if (bytes > 0 && bytes < 1024.0)                  size = bytes + " Bytes";
Magic Number,MsgReader.Helpers,FileManager,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileManager.cs,GetFileSizeString,The following statement contains a magic number: if (bytes >= 1073741824.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1073741824.0) + " GB";              else if (bytes >= 1048576.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1048576.0) + " MB";              else if (bytes >= 1024.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1024.0) + " KB";              else if (bytes > 0 && bytes < 1024.0)                  size = bytes + " Bytes";
Magic Number,MsgReader.Helpers,FileManager,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileManager.cs,GetFileSizeString,The following statement contains a magic number: if (bytes >= 1073741824.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1073741824.0) + " GB";              else if (bytes >= 1048576.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1048576.0) + " MB";              else if (bytes >= 1024.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1024.0) + " KB";              else if (bytes > 0 && bytes < 1024.0)                  size = bytes + " Bytes";
Magic Number,MsgReader.Helpers,FileManager,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileManager.cs,GetFileSizeString,The following statement contains a magic number: if (bytes >= 1073741824.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1073741824.0) + " GB";              else if (bytes >= 1048576.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1048576.0) + " MB";              else if (bytes >= 1024.0)                  size = String.Format(CultureInfo.InvariantCulture' "{0:##.##}"' bytes / 1024.0) + " KB";              else if (bytes > 0 && bytes < 1024.0)                  size = bytes + " Bytes";
Magic Number,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,StripByteOrderMarker,The following statement contains a magic number: if (IndexOf(magicBytes' new byte[] { 0xDD' 0x73' 0x66' 0x73 }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0xFF' 0xFE' 0x00' 0x00 }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0x00' 0x00' 0xFE' 0xFF }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0x84' 0x31' 0x95' 0x33 }' 0) == 0)                  return magicBytes.Select(m => m).Skip(4).ToArray();
Magic Number,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,StripByteOrderMarker,The following statement contains a magic number: if (IndexOf(magicBytes' new byte[] { 0xEF' 0xBB' 0xBF }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0x2B' 0x2F' 0x76 }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0x0E' 0xFE' 0xFF }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0xFB' 0xEE' 0x28 }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0xF7' 0x64' 0x4C }' 0) == 0)                  return magicBytes.Select(m => m).Skip(3).ToArray();
Magic Number,MsgReader.Helpers,FileTypeSelector,C:\repos\Sicos1977_msgreader\MsgReader\Helpers\FileTypeSelector.cs,StripByteOrderMarker,The following statement contains a magic number: if (IndexOf(magicBytes' new byte[] { 0xFE' 0xFF }' 0) == 0 ||                  IndexOf(magicBytes' new byte[] { 0xFF' 0xFE }' 0) == 0)                  return magicBytes.Select(m => m).Skip(2).ToArray();
Magic Number,MsgReader.Mime.Decode,Base64,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\Base64.cs,Decode,The following statement contains a magic number: try  	        {                  using (var memoryStream = new MemoryStream())                  {                      base64Encoded = base64Encoded.Replace("\r\n"' "");                      base64Encoded = base64Encoded.Replace("\t"' "");                      base64Encoded = base64Encoded.Replace(" "' "");                        var inputBytes = Encoding.ASCII.GetBytes(base64Encoded);                        using (var transform = new FromBase64Transform(FromBase64TransformMode.DoNotIgnoreWhiteSpaces))                      {                          var outputBytes = new byte[transform.OutputBlockSize];                            // Transform the data in chunks the size of InputBlockSize.                          const int inputBlockSize = 4;                          var currentOffset = 0;                          while (inputBytes.Length - currentOffset > inputBlockSize)                          {                              transform.TransformBlock(inputBytes' currentOffset' inputBlockSize' outputBytes' 0);                              currentOffset += inputBlockSize;                              memoryStream.Write(outputBytes' 0' transform.OutputBlockSize);                          }                            // Transform the final block of data.                          outputBytes = transform.TransformFinalBlock(inputBytes' currentOffset'                              inputBytes.Length - currentOffset);                          memoryStream.Write(outputBytes' 0' outputBytes.Length);                      }                        return memoryStream.ToArray();                  }              }  	        catch (Exception)  	        {  	            return new byte[0];  	        }
Magic Number,MsgReader.Mime.Decode,QuotedPrintable,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: using (var byteArrayBuilder = new MemoryStream())  	        {  	            // Remove illegal control characters  	            toDecode = RemoveIllegalControlCharacters(toDecode);    	            // Run through the whole string that needs to be decoded  	            for (var i = 0; i < toDecode.Length; i++)  	            {  	                var currentChar = toDecode[i];  	                if (currentChar == '=')  	                {  	                    // Check that there is at least two characters behind the equal sign  	                    if (toDecode.Length - i < 3)  	                    {  	                        // We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  	                        WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSignNotLongEnough(toDecode.Substring(i)));    	                        // Since it was the last part' we should stop parsing anymore  	                        break;  	                    }    	                    // Decode the Quoted-Printable part  	                    var quotedPrintablePart = toDecode.Substring(i' 3);  	                    WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSign(quotedPrintablePart));    	                    // We now consumed two extra characters. Go forward two extra characters  	                    i += 2;  	                }  	                else  	                {  	                    // This character is not quoted printable hex encoded.    	                    // Could it be the _ character' which represents space  	                    // and are we using the encoded word variant of QuotedPrintable  	                    if (currentChar == '_' && encodedWordVariant)  	                    {  	                        // The RFC specifies that the "_" always represents hexadecimal 20 even if the  	                        // SPACE character occupies a different code position in the character set in use.  	                        byteArrayBuilder.WriteByte(0x20);  	                    }  	                    else  	                    {  	                        // This is not encoded at all. This is a literal which should just be included into the output.  	                        byteArrayBuilder.WriteByte((byte) currentChar);  	                    }  	                }  	            }    	            return byteArrayBuilder.ToArray();  	        }
Magic Number,MsgReader.Mime.Decode,QuotedPrintable,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: using (var byteArrayBuilder = new MemoryStream())  	        {  	            // Remove illegal control characters  	            toDecode = RemoveIllegalControlCharacters(toDecode);    	            // Run through the whole string that needs to be decoded  	            for (var i = 0; i < toDecode.Length; i++)  	            {  	                var currentChar = toDecode[i];  	                if (currentChar == '=')  	                {  	                    // Check that there is at least two characters behind the equal sign  	                    if (toDecode.Length - i < 3)  	                    {  	                        // We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  	                        WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSignNotLongEnough(toDecode.Substring(i)));    	                        // Since it was the last part' we should stop parsing anymore  	                        break;  	                    }    	                    // Decode the Quoted-Printable part  	                    var quotedPrintablePart = toDecode.Substring(i' 3);  	                    WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSign(quotedPrintablePart));    	                    // We now consumed two extra characters. Go forward two extra characters  	                    i += 2;  	                }  	                else  	                {  	                    // This character is not quoted printable hex encoded.    	                    // Could it be the _ character' which represents space  	                    // and are we using the encoded word variant of QuotedPrintable  	                    if (currentChar == '_' && encodedWordVariant)  	                    {  	                        // The RFC specifies that the "_" always represents hexadecimal 20 even if the  	                        // SPACE character occupies a different code position in the character set in use.  	                        byteArrayBuilder.WriteByte(0x20);  	                    }  	                    else  	                    {  	                        // This is not encoded at all. This is a literal which should just be included into the output.  	                        byteArrayBuilder.WriteByte((byte) currentChar);  	                    }  	                }  	            }    	            return byteArrayBuilder.ToArray();  	        }
Magic Number,MsgReader.Mime.Decode,QuotedPrintable,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: using (var byteArrayBuilder = new MemoryStream())  	        {  	            // Remove illegal control characters  	            toDecode = RemoveIllegalControlCharacters(toDecode);    	            // Run through the whole string that needs to be decoded  	            for (var i = 0; i < toDecode.Length; i++)  	            {  	                var currentChar = toDecode[i];  	                if (currentChar == '=')  	                {  	                    // Check that there is at least two characters behind the equal sign  	                    if (toDecode.Length - i < 3)  	                    {  	                        // We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  	                        WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSignNotLongEnough(toDecode.Substring(i)));    	                        // Since it was the last part' we should stop parsing anymore  	                        break;  	                    }    	                    // Decode the Quoted-Printable part  	                    var quotedPrintablePart = toDecode.Substring(i' 3);  	                    WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSign(quotedPrintablePart));    	                    // We now consumed two extra characters. Go forward two extra characters  	                    i += 2;  	                }  	                else  	                {  	                    // This character is not quoted printable hex encoded.    	                    // Could it be the _ character' which represents space  	                    // and are we using the encoded word variant of QuotedPrintable  	                    if (currentChar == '_' && encodedWordVariant)  	                    {  	                        // The RFC specifies that the "_" always represents hexadecimal 20 even if the  	                        // SPACE character occupies a different code position in the character set in use.  	                        byteArrayBuilder.WriteByte(0x20);  	                    }  	                    else  	                    {  	                        // This is not encoded at all. This is a literal which should just be included into the output.  	                        byteArrayBuilder.WriteByte((byte) currentChar);  	                    }  	                }  	            }    	            return byteArrayBuilder.ToArray();  	        }
Magic Number,MsgReader.Mime.Decode,QuotedPrintable,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\QuotedPrintable.cs,DecodeEqualSignNotLongEnough,The following statement contains a magic number: if (decode.Length >= 3)  	            throw new ArgumentException("decode must have length lower than 3"' "decode");
Magic Number,MsgReader.Mime.Decode,QuotedPrintable,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\QuotedPrintable.cs,DecodeEqualSign,The following statement contains a magic number: if (decode.Length != 3)  	            throw new ArgumentException("decode must have length 3"' "decode");
Magic Number,MsgReader.Mime.Decode,QuotedPrintable,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\QuotedPrintable.cs,DecodeEqualSign,The following statement contains a magic number: try  	        {  	            // The number part of the string is the last two digits. Here we simply remove the equal sign  	            var numberString = decode.Substring(1);    	            // Now we create a byte array with the converted number encoded in the string as a hex value (base 16)  	            // This will also handle illegal encodings like =3d where the hex digits are not uppercase'  	            // which is a robustness requirement from RFC 2045.  	            var oneByte = new[] {Convert.ToByte(numberString' 16)};    	            // Simply return our one byte byte array  	            return oneByte;  	        }  	        catch (FormatException)  	        {  	            // RFC 2045 says about robust implementation:  	            // An "=" followed by a character that is neither a  	            // hexadecimal digit (including "abcdef") nor the CR  	            // character of a CRLF pair is illegal.  This case can be  	            // the result of US-ASCII text having been included in a  	            // quoted-printable part of a message without itself  	            // having been subjected to quoted-printable encoding.  A  	            // reasonable approach by a robust implementation might be  	            // to include the "=" character and the following  	            // character in the decoded data without any  	            // transformation and' if possible' indicate to the user  	            // that proper decoding was not possible at this point in  	            // the data.    	            // So we choose to believe this is actually an un-encoded string  	            // Therefore it must be in US-ASCII and we will return the bytes it corrosponds to  	            return Encoding.ASCII.GetBytes(decode);  	        }
Magic Number,MsgReader.Mime.Decode,Rfc2231Decoder,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\Rfc2231Decoder.cs,Decode,The following statement contains a magic number: foreach (var part in splitted)  	        {  	            // Empty strings should not be processed  	            if (part.Trim().Length == 0)  	                continue;    	            var keyValue = part.Trim().Split(new[] {'='}' 2);  	            switch (keyValue.Length)  	            {  	                case 1:  	                    collection.Add(new KeyValuePair<string' string>(""' keyValue[0]));  	                    break;  	                case 2:  	                    collection.Add(new KeyValuePair<string' string>(keyValue[0]' keyValue[1]));  	                    break;  	                default:  	                    throw new ArgumentException("When splitting the part \"" + part + "\" by = there was " +  	                                                keyValue.Length +  	                                                " parts. Only 1 and 2 are supported");  	            }  	        }
Magic Number,MsgReader.Mime.Decode,Rfc2231Decoder,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\Rfc2231Decoder.cs,Decode,The following statement contains a magic number: foreach (var part in splitted)  	        {  	            // Empty strings should not be processed  	            if (part.Trim().Length == 0)  	                continue;    	            var keyValue = part.Trim().Split(new[] {'='}' 2);  	            switch (keyValue.Length)  	            {  	                case 1:  	                    collection.Add(new KeyValuePair<string' string>(""' keyValue[0]));  	                    break;  	                case 2:  	                    collection.Add(new KeyValuePair<string' string>(keyValue[0]' keyValue[1]));  	                    break;  	                default:  	                    throw new ArgumentException("When splitting the part \"" + part + "\" by = there was " +  	                                                keyValue.Length +  	                                                " parts. Only 1 and 2 are supported");  	            }  	        }
Magic Number,MsgReader.Mime.Decode,Utility,C:\repos\Sicos1977_msgreader\MsgReader\Mime\Decode\Utility.cs,RemoveQuotesIfAny,The following statement contains a magic number: if (text.Length > 1 && text[0] == '"' && text[text.Length - 1] == '"')  	        {  	            // Remove quotes at both ends  	            return text.Substring(1' text.Length - 2);  	        }
Magic Number,MsgReader.Outlook,AddressBookEntryId,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\AddressBookEntryId.cs,AddressBookEntryId,The following statement contains a magic number: Flags = binaryReader.ReadBytes(4);
Magic Number,MsgReader.Outlook,Property,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Property.cs,ByteArrayToDecimal,The following statement contains a magic number: var i2 = BitConverter.ToInt32(source' offset + 4);
Magic Number,MsgReader.Outlook,Property,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Property.cs,ByteArrayToDecimal,The following statement contains a magic number: var i3 = BitConverter.ToInt32(source' offset + 8);
Magic Number,MsgReader.Outlook,Property,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Property.cs,ByteArrayToDecimal,The following statement contains a magic number: var i4 = BitConverter.ToInt32(source' offset + 12);
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,LoadStorage,The following statement contains a magic number: try              {                  // Enum all elements of the storage                  storage.EnumElements(0' IntPtr.Zero' 0' out storageElementEnum);                    // Iterate elements                  while (true)                  {                      // Get 1 element out of the COM enumerator                      uint elementStatCount;                      var elementStats = new STATSTG[1];                      storageElementEnum.Next(1' elementStats' out elementStatCount);                        // Break loop if element not retrieved                      if (elementStatCount != 1)                          break;                        var elementStat = elementStats[0];                      switch (elementStat.type)                      {                          case 1:                              // Element is a storage' add its statistics object to the storage dictionary                              _subStorageStatistics.Add(elementStat.pwcsName' elementStat);                              break;                            case 2:                              // Element is a stream' add its statistics object to the stream dictionary                              _streamStatistics.Add(elementStat.pwcsName' elementStat);                              break;                      }                  }              }              finally              {                  // Free memory                  if (storageElementEnum != null)                      Marshal.ReleaseComObject(storageElementEnum);              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromStreamOrStorage,The following statement contains a magic number: foreach (var propKey in propKeys)              {                  if (!propKey.StartsWith(MapiTags.SubStgVersion1 + "_" + propIdentifier)) continue;                  propTag = propKey.Substring(12' 8);                  propType = (PropertyType) ushort.Parse(propKey.Substring(16' 4)' NumberStyles.HexNumber);                  break;              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromStreamOrStorage,The following statement contains a magic number: foreach (var propKey in propKeys)              {                  if (!propKey.StartsWith(MapiTags.SubStgVersion1 + "_" + propIdentifier)) continue;                  propTag = propKey.Substring(12' 8);                  propType = (PropertyType) ushort.Parse(propKey.Substring(16' 4)' NumberStyles.HexNumber);                  break;              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromStreamOrStorage,The following statement contains a magic number: foreach (var propKey in propKeys)              {                  if (!propKey.StartsWith(MapiTags.SubStgVersion1 + "_" + propIdentifier)) continue;                  propTag = propKey.Substring(12' 8);                  propType = (PropertyType) ushort.Parse(propKey.Substring(16' 4)' NumberStyles.HexNumber);                  break;              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromStreamOrStorage,The following statement contains a magic number: foreach (var propKey in propKeys)              {                  if (!propKey.StartsWith(MapiTags.SubStgVersion1 + "_" + propIdentifier)) continue;                  propTag = propKey.Substring(12' 8);                  propType = (PropertyType) ushort.Parse(propKey.Substring(16' 4)' NumberStyles.HexNumber);                  break;              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following statement contains a magic number: for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)              {                  // Get property type located in the 1st and 2nd bytes as a unsigned short value                  var propType = (PropertyType) BitConverter.ToUInt16(propBytes' i);                    // Get property identifer located in 3nd and 4th bytes as a hexdecimal string                  var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                  var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                    // If this is not the property being gotten continue to next property                  if (propIdentString != propIdentifier) continue;                    // Depending on prop type use method to get property value                  switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following statement contains a magic number: for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)              {                  // Get property type located in the 1st and 2nd bytes as a unsigned short value                  var propType = (PropertyType) BitConverter.ToUInt16(propBytes' i);                    // Get property identifer located in 3nd and 4th bytes as a hexdecimal string                  var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                  var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                    // If this is not the property being gotten continue to next property                  if (propIdentString != propIdentifier) continue;                    // Depending on prop type use method to get property value                  switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following statement contains a magic number: for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)              {                  // Get property type located in the 1st and 2nd bytes as a unsigned short value                  var propType = (PropertyType) BitConverter.ToUInt16(propBytes' i);                    // Get property identifer located in 3nd and 4th bytes as a hexdecimal string                  var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                  var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                    // If this is not the property being gotten continue to next property                  if (propIdentString != propIdentifier) continue;                    // Depending on prop type use method to get property value                  switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following statement contains a magic number: for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)              {                  // Get property type located in the 1st and 2nd bytes as a unsigned short value                  var propType = (PropertyType) BitConverter.ToUInt16(propBytes' i);                    // Get property identifer located in 3nd and 4th bytes as a hexdecimal string                  var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                  var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                    // If this is not the property being gotten continue to next property                  if (propIdentString != propIdentifier) continue;                    // Depending on prop type use method to get property value                  switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following statement contains a magic number: for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)              {                  // Get property type located in the 1st and 2nd bytes as a unsigned short value                  var propType = (PropertyType) BitConverter.ToUInt16(propBytes' i);                    // Get property identifer located in 3nd and 4th bytes as a hexdecimal string                  var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                  var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                    // If this is not the property being gotten continue to next property                  if (propIdentString != propIdentifier) continue;                    // Depending on prop type use method to get property value                  switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following statement contains a magic number: for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)              {                  // Get property type located in the 1st and 2nd bytes as a unsigned short value                  var propType = (PropertyType) BitConverter.ToUInt16(propBytes' i);                    // Get property identifer located in 3nd and 4th bytes as a hexdecimal string                  var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                  var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                    // If this is not the property being gotten continue to next property                  if (propIdentString != propIdentifier) continue;                    // Depending on prop type use method to get property value                  switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following statement contains a magic number: for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)              {                  // Get property type located in the 1st and 2nd bytes as a unsigned short value                  var propType = (PropertyType) BitConverter.ToUInt16(propBytes' i);                    // Get property identifer located in 3nd and 4th bytes as a hexdecimal string                  var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                  var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                    // If this is not the property being gotten continue to next property                  if (propIdentString != propIdentifier) continue;                    // Depending on prop type use method to get property value                  switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following statement contains a magic number: for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)              {                  // Get property type located in the 1st and 2nd bytes as a unsigned short value                  var propType = (PropertyType) BitConverter.ToUInt16(propBytes' i);                    // Get property identifer located in 3nd and 4th bytes as a hexdecimal string                  var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                  var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                    // If this is not the property being gotten continue to next property                  if (propIdentString != propIdentifier) continue;                    // Depending on prop type use method to get property value                  switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }              }
Magic Number,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following statement contains a magic number: for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)              {                  // Get property type located in the 1st and 2nd bytes as a unsigned short value                  var propType = (PropertyType) BitConverter.ToUInt16(propBytes' i);                    // Get property identifer located in 3nd and 4th bytes as a hexdecimal string                  var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                  var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                    // If this is not the property being gotten continue to next property                  if (propIdentString != propIdentifier) continue;                    // Depending on prop type use method to get property value                  switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }              }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (recurrenceType == null)                  {                      ReccurrenceType = AppointmentRecurrenceType.None;                      RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeNoneText;                  }                  else                  {                      switch (recurrenceType)                      {                          case 1:                              ReccurrenceType = AppointmentRecurrenceType.Daily;                              break;                            case 2:                              ReccurrenceType = AppointmentRecurrenceType.Weekly;                              break;                            case 3:                          case 4:                              ReccurrenceType = AppointmentRecurrenceType.Montly;                              break;                            case 5:                          case 6:                              ReccurrenceType = AppointmentRecurrenceType.Yearly;                              break;                            default:                              ReccurrenceType = AppointmentRecurrenceType.None;                              break;                      }                                        switch (ReccurrenceType)                      {                          case AppointmentRecurrenceType.Daily:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeDailyText;                              break;                            case AppointmentRecurrenceType.Weekly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeWeeklyText;                              break;                            case AppointmentRecurrenceType.Montly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeMonthlyText;                              break;                            case AppointmentRecurrenceType.Yearly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeYearlyText;                              break;                      }                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (recurrenceType == null)                  {                      ReccurrenceType = AppointmentRecurrenceType.None;                      RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeNoneText;                  }                  else                  {                      switch (recurrenceType)                      {                          case 1:                              ReccurrenceType = AppointmentRecurrenceType.Daily;                              break;                            case 2:                              ReccurrenceType = AppointmentRecurrenceType.Weekly;                              break;                            case 3:                          case 4:                              ReccurrenceType = AppointmentRecurrenceType.Montly;                              break;                            case 5:                          case 6:                              ReccurrenceType = AppointmentRecurrenceType.Yearly;                              break;                            default:                              ReccurrenceType = AppointmentRecurrenceType.None;                              break;                      }                                        switch (ReccurrenceType)                      {                          case AppointmentRecurrenceType.Daily:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeDailyText;                              break;                            case AppointmentRecurrenceType.Weekly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeWeeklyText;                              break;                            case AppointmentRecurrenceType.Montly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeMonthlyText;                              break;                            case AppointmentRecurrenceType.Yearly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeYearlyText;                              break;                      }                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (recurrenceType == null)                  {                      ReccurrenceType = AppointmentRecurrenceType.None;                      RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeNoneText;                  }                  else                  {                      switch (recurrenceType)                      {                          case 1:                              ReccurrenceType = AppointmentRecurrenceType.Daily;                              break;                            case 2:                              ReccurrenceType = AppointmentRecurrenceType.Weekly;                              break;                            case 3:                          case 4:                              ReccurrenceType = AppointmentRecurrenceType.Montly;                              break;                            case 5:                          case 6:                              ReccurrenceType = AppointmentRecurrenceType.Yearly;                              break;                            default:                              ReccurrenceType = AppointmentRecurrenceType.None;                              break;                      }                                        switch (ReccurrenceType)                      {                          case AppointmentRecurrenceType.Daily:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeDailyText;                              break;                            case AppointmentRecurrenceType.Weekly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeWeeklyText;                              break;                            case AppointmentRecurrenceType.Montly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeMonthlyText;                              break;                            case AppointmentRecurrenceType.Yearly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeYearlyText;                              break;                      }                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (recurrenceType == null)                  {                      ReccurrenceType = AppointmentRecurrenceType.None;                      RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeNoneText;                  }                  else                  {                      switch (recurrenceType)                      {                          case 1:                              ReccurrenceType = AppointmentRecurrenceType.Daily;                              break;                            case 2:                              ReccurrenceType = AppointmentRecurrenceType.Weekly;                              break;                            case 3:                          case 4:                              ReccurrenceType = AppointmentRecurrenceType.Montly;                              break;                            case 5:                          case 6:                              ReccurrenceType = AppointmentRecurrenceType.Yearly;                              break;                            default:                              ReccurrenceType = AppointmentRecurrenceType.None;                              break;                      }                                        switch (ReccurrenceType)                      {                          case AppointmentRecurrenceType.Daily:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeDailyText;                              break;                            case AppointmentRecurrenceType.Weekly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeWeeklyText;                              break;                            case AppointmentRecurrenceType.Montly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeMonthlyText;                              break;                            case AppointmentRecurrenceType.Yearly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeYearlyText;                              break;                      }                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (recurrenceType == null)                  {                      ReccurrenceType = AppointmentRecurrenceType.None;                      RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeNoneText;                  }                  else                  {                      switch (recurrenceType)                      {                          case 1:                              ReccurrenceType = AppointmentRecurrenceType.Daily;                              break;                            case 2:                              ReccurrenceType = AppointmentRecurrenceType.Weekly;                              break;                            case 3:                          case 4:                              ReccurrenceType = AppointmentRecurrenceType.Montly;                              break;                            case 5:                          case 6:                              ReccurrenceType = AppointmentRecurrenceType.Yearly;                              break;                            default:                              ReccurrenceType = AppointmentRecurrenceType.None;                              break;                      }                                        switch (ReccurrenceType)                      {                          case AppointmentRecurrenceType.Daily:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeDailyText;                              break;                            case AppointmentRecurrenceType.Weekly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeWeeklyText;                              break;                            case AppointmentRecurrenceType.Montly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeMonthlyText;                              break;                            case AppointmentRecurrenceType.Yearly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeYearlyText;                              break;                      }                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following statement contains a magic number: if (clientIntent == null)                      ClientIntent = null;                  else                  {                      var bitwiseValue = (int)clientIntent;                        if ((bitwiseValue & 1) == 1)                      {                          clientIntentList.Add(AppointmentClientIntent.Manager);                          ClientIntentText = LanguageConsts.AppointmentClientIntentManagerText;                      }                        if ((bitwiseValue & 2) == 2)                      {                          clientIntentList.Add(AppointmentClientIntent.Delegate);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDelegateText;                      }                        if ((bitwiseValue & 4) == 4)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedWithNoResponseText;                      }                        if ((bitwiseValue & 8) == 8)                      {                          clientIntentList.Add(AppointmentClientIntent.DeletedExceptionWithNoResponse);                          ClientIntentText = LanguageConsts.AppointmentClientIntentDeletedExceptionWithNoResponseText;                      }                        if ((bitwiseValue & 16) == 16)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedTentative);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedTentativeText;                      }                        if ((bitwiseValue & 32) == 32)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedAccept);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedAcceptText;                      }                        if ((bitwiseValue & 64) == 64)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedDeclineText;                      }                      if ((bitwiseValue & 128) == 128)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedStartTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedStartTimeText;                      }                        if ((bitwiseValue & 256) == 256)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedEndTime);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedEndTimeText;                      }                        if ((bitwiseValue & 512) == 512)                      {                          clientIntentList.Add(AppointmentClientIntent.ModifiedLocation);                          ClientIntentText = LanguageConsts.AppointmentClientIntentModifiedLocationText;                      }                        if ((bitwiseValue & 1024) == 1024)                      {                          clientIntentList.Add(AppointmentClientIntent.RespondedExceptionDecline);                          ClientIntentText = LanguageConsts.AppointmentClientIntentRespondedExceptionDeclineText;                      }                        if ((bitwiseValue & 2048) == 2048)                      {                          clientIntentList.Add(AppointmentClientIntent.Canceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentCanceledText;                      }                        if ((bitwiseValue & 4096) == 4096)                      {                          clientIntentList.Add(AppointmentClientIntent.ExceptionCanceled);                          ClientIntentText = LanguageConsts.AppointmentClientIntentExceptionCanceledText;                      }                        ClientIntent = clientIntentList.AsReadOnly();                  }
Magic Number,MsgReader.Outlook,Attachment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Attachment.cs,Attachment,The following statement contains a magic number: switch (attachmentMethod)                  {                      case MapiTags.ATTACH_BY_REFERENCE:                      case MapiTags.ATTACH_BY_REF_RESOLVE:                      case MapiTags.ATTACH_BY_REF_ONLY:                          ResolveAttachment();                          break;                        case MapiTags.ATTACH_OLE:                          var storage = GetMapiProperty(MapiTags.PR_ATTACH_DATA_BIN) as NativeMethods.IStorage;                          var attachmentOle = new Attachment(new Storage(storage)' null);                          _data = attachmentOle.GetStreamBytes("CONTENTS");                          if (_data != null)                          {                              var fileTypeInfo = FileTypeSelector.GetFileTypeFileInfo(Data);                                if (string.IsNullOrEmpty(FileName))                                  FileName = fileTypeInfo.Description;                                FileName += "." + fileTypeInfo.Extension.ToLower();                          }                          else                              // http://www.devsuperpage.com/search/Articles.aspx?G=10&ArtID=142729                              _data = attachmentOle.GetStreamBytes("\u0002OlePres000");                            if (_data != null)                          {                              try                              {                                  SaveImageAsPng(40);                              }                              catch (ArgumentException)                              {                                  SaveImageAsPng(0);                              }                          }                          else                              throw new MRUnknownAttachmentFormat("Can not read the attachment");                            OleAttachment = true;                          IsInline = true;                          break;                  }
Magic Number,MsgReader.Outlook,MapiTagMapper,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTagMapper.cs,GetMapping,The following statement contains a magic number: foreach (var propertyIdent in propertyIdents)                  {                      // To read the correct mapped property we need to calculate the offset in the entry stream                      // The offset is calculated bij substracting 32768 (8000 hex) from the named property and                      // multiply the outcome with 8                      var identValue = ushort.Parse(propertyIdent' NumberStyles.HexNumber);                      var entryOffset = (identValue - 32768)*8;                      if (entryOffset > entryStreamBytes.Length) continue;                        string entryIdentString;                        // We need the first 2 bytes for the mapping' but because the nameStreamBytes is in little                       // endian we need to swap the first 2 bytes                      if (entryStreamBytes[entryOffset + 1] == 0)                      {                          var entryIdent = new[] {entryStreamBytes[entryOffset]};                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                      }                      else                      {                          var entryIdent = new[] { entryStreamBytes[entryOffset + 1]' entryStreamBytes[entryOffset] };                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                          }                        // When the type = 05 it means we have to look for a mapping in the string stream                      // 03-E8-00-00-05-00-FE-00                      var type = BitConverter.ToString(entryStreamBytes' entryOffset + 4' 1);                      if (type == "05")                      {                          var stringOffset = ushort.Parse(entryIdentString' NumberStyles.HexNumber);                            if (stringOffset >= stringStreamBytes.Length) continue;                          // Read the first 4 bytes to determine the length of the string to read                          var stringLength = BitConverter.ToInt32(stringStreamBytes' stringOffset);                          var str = string.Empty;                            // Skip 4 bytes and start reading the string                          stringOffset += 4;                          for (var i = stringOffset; i < stringOffset + stringLength; i += 2)                          {                              var chr = BitConverter.ToChar(stringStreamBytes' i);                              str += chr;                          }                            // Remove any null character                          str = str.Replace("\0"' string.Empty);                          result.Add(new MapiTagMapping(propertyIdent' str));                      }                      else                          result.Add(new MapiTagMapping(propertyIdent' entryIdentString));                  }
Magic Number,MsgReader.Outlook,MapiTagMapper,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTagMapper.cs,GetMapping,The following statement contains a magic number: foreach (var propertyIdent in propertyIdents)                  {                      // To read the correct mapped property we need to calculate the offset in the entry stream                      // The offset is calculated bij substracting 32768 (8000 hex) from the named property and                      // multiply the outcome with 8                      var identValue = ushort.Parse(propertyIdent' NumberStyles.HexNumber);                      var entryOffset = (identValue - 32768)*8;                      if (entryOffset > entryStreamBytes.Length) continue;                        string entryIdentString;                        // We need the first 2 bytes for the mapping' but because the nameStreamBytes is in little                       // endian we need to swap the first 2 bytes                      if (entryStreamBytes[entryOffset + 1] == 0)                      {                          var entryIdent = new[] {entryStreamBytes[entryOffset]};                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                      }                      else                      {                          var entryIdent = new[] { entryStreamBytes[entryOffset + 1]' entryStreamBytes[entryOffset] };                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                          }                        // When the type = 05 it means we have to look for a mapping in the string stream                      // 03-E8-00-00-05-00-FE-00                      var type = BitConverter.ToString(entryStreamBytes' entryOffset + 4' 1);                      if (type == "05")                      {                          var stringOffset = ushort.Parse(entryIdentString' NumberStyles.HexNumber);                            if (stringOffset >= stringStreamBytes.Length) continue;                          // Read the first 4 bytes to determine the length of the string to read                          var stringLength = BitConverter.ToInt32(stringStreamBytes' stringOffset);                          var str = string.Empty;                            // Skip 4 bytes and start reading the string                          stringOffset += 4;                          for (var i = stringOffset; i < stringOffset + stringLength; i += 2)                          {                              var chr = BitConverter.ToChar(stringStreamBytes' i);                              str += chr;                          }                            // Remove any null character                          str = str.Replace("\0"' string.Empty);                          result.Add(new MapiTagMapping(propertyIdent' str));                      }                      else                          result.Add(new MapiTagMapping(propertyIdent' entryIdentString));                  }
Magic Number,MsgReader.Outlook,MapiTagMapper,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTagMapper.cs,GetMapping,The following statement contains a magic number: foreach (var propertyIdent in propertyIdents)                  {                      // To read the correct mapped property we need to calculate the offset in the entry stream                      // The offset is calculated bij substracting 32768 (8000 hex) from the named property and                      // multiply the outcome with 8                      var identValue = ushort.Parse(propertyIdent' NumberStyles.HexNumber);                      var entryOffset = (identValue - 32768)*8;                      if (entryOffset > entryStreamBytes.Length) continue;                        string entryIdentString;                        // We need the first 2 bytes for the mapping' but because the nameStreamBytes is in little                       // endian we need to swap the first 2 bytes                      if (entryStreamBytes[entryOffset + 1] == 0)                      {                          var entryIdent = new[] {entryStreamBytes[entryOffset]};                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                      }                      else                      {                          var entryIdent = new[] { entryStreamBytes[entryOffset + 1]' entryStreamBytes[entryOffset] };                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                          }                        // When the type = 05 it means we have to look for a mapping in the string stream                      // 03-E8-00-00-05-00-FE-00                      var type = BitConverter.ToString(entryStreamBytes' entryOffset + 4' 1);                      if (type == "05")                      {                          var stringOffset = ushort.Parse(entryIdentString' NumberStyles.HexNumber);                            if (stringOffset >= stringStreamBytes.Length) continue;                          // Read the first 4 bytes to determine the length of the string to read                          var stringLength = BitConverter.ToInt32(stringStreamBytes' stringOffset);                          var str = string.Empty;                            // Skip 4 bytes and start reading the string                          stringOffset += 4;                          for (var i = stringOffset; i < stringOffset + stringLength; i += 2)                          {                              var chr = BitConverter.ToChar(stringStreamBytes' i);                              str += chr;                          }                            // Remove any null character                          str = str.Replace("\0"' string.Empty);                          result.Add(new MapiTagMapping(propertyIdent' str));                      }                      else                          result.Add(new MapiTagMapping(propertyIdent' entryIdentString));                  }
Magic Number,MsgReader.Outlook,MapiTagMapper,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTagMapper.cs,GetMapping,The following statement contains a magic number: foreach (var propertyIdent in propertyIdents)                  {                      // To read the correct mapped property we need to calculate the offset in the entry stream                      // The offset is calculated bij substracting 32768 (8000 hex) from the named property and                      // multiply the outcome with 8                      var identValue = ushort.Parse(propertyIdent' NumberStyles.HexNumber);                      var entryOffset = (identValue - 32768)*8;                      if (entryOffset > entryStreamBytes.Length) continue;                        string entryIdentString;                        // We need the first 2 bytes for the mapping' but because the nameStreamBytes is in little                       // endian we need to swap the first 2 bytes                      if (entryStreamBytes[entryOffset + 1] == 0)                      {                          var entryIdent = new[] {entryStreamBytes[entryOffset]};                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                      }                      else                      {                          var entryIdent = new[] { entryStreamBytes[entryOffset + 1]' entryStreamBytes[entryOffset] };                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                          }                        // When the type = 05 it means we have to look for a mapping in the string stream                      // 03-E8-00-00-05-00-FE-00                      var type = BitConverter.ToString(entryStreamBytes' entryOffset + 4' 1);                      if (type == "05")                      {                          var stringOffset = ushort.Parse(entryIdentString' NumberStyles.HexNumber);                            if (stringOffset >= stringStreamBytes.Length) continue;                          // Read the first 4 bytes to determine the length of the string to read                          var stringLength = BitConverter.ToInt32(stringStreamBytes' stringOffset);                          var str = string.Empty;                            // Skip 4 bytes and start reading the string                          stringOffset += 4;                          for (var i = stringOffset; i < stringOffset + stringLength; i += 2)                          {                              var chr = BitConverter.ToChar(stringStreamBytes' i);                              str += chr;                          }                            // Remove any null character                          str = str.Replace("\0"' string.Empty);                          result.Add(new MapiTagMapping(propertyIdent' str));                      }                      else                          result.Add(new MapiTagMapping(propertyIdent' entryIdentString));                  }
Magic Number,MsgReader.Outlook,MapiTagMapper,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\MapiTagMapper.cs,GetMapping,The following statement contains a magic number: foreach (var propertyIdent in propertyIdents)                  {                      // To read the correct mapped property we need to calculate the offset in the entry stream                      // The offset is calculated bij substracting 32768 (8000 hex) from the named property and                      // multiply the outcome with 8                      var identValue = ushort.Parse(propertyIdent' NumberStyles.HexNumber);                      var entryOffset = (identValue - 32768)*8;                      if (entryOffset > entryStreamBytes.Length) continue;                        string entryIdentString;                        // We need the first 2 bytes for the mapping' but because the nameStreamBytes is in little                       // endian we need to swap the first 2 bytes                      if (entryStreamBytes[entryOffset + 1] == 0)                      {                          var entryIdent = new[] {entryStreamBytes[entryOffset]};                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                      }                      else                      {                          var entryIdent = new[] { entryStreamBytes[entryOffset + 1]' entryStreamBytes[entryOffset] };                          entryIdentString = BitConverter.ToString(entryIdent).Replace("-"' string.Empty);                          }                        // When the type = 05 it means we have to look for a mapping in the string stream                      // 03-E8-00-00-05-00-FE-00                      var type = BitConverter.ToString(entryStreamBytes' entryOffset + 4' 1);                      if (type == "05")                      {                          var stringOffset = ushort.Parse(entryIdentString' NumberStyles.HexNumber);                            if (stringOffset >= stringStreamBytes.Length) continue;                          // Read the first 4 bytes to determine the length of the string to read                          var stringLength = BitConverter.ToInt32(stringStreamBytes' stringOffset);                          var str = string.Empty;                            // Skip 4 bytes and start reading the string                          stringOffset += 4;                          for (var i = stringOffset; i < stringOffset + stringLength; i += 2)                          {                              var chr = BitConverter.ToChar(stringStreamBytes' i);                              str += chr;                          }                            // Remove any null character                          str = str.Replace("\0"' string.Empty);                          result.Add(new MapiTagMapping(propertyIdent' str));                      }                      else                          result.Add(new MapiTagMapping(propertyIdent' entryIdentString));                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The following statement contains a magic number: if (_subStorageStatistics.ContainsKey(MapiTags.NameIdStorage))                  {                      var mappingValues = new List<string>();                        // Get all the named properties from the _streamStatistics                      foreach (var streamStatistic in _streamStatistics)                      {                          var name = streamStatistic.Value.pwcsName;                            if (name.StartsWith(MapiTags.SubStgVersion1))                          {                              // Get the property value                              var propIdentString = name.Substring(12' 4);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is also a properties stream and if so get all the named MAPI properties from it                      if (_streamStatistics.ContainsKey(MapiTags.PropertiesStream))                      {                          // Get the raw bytes for the property stream                          var propBytes = GetStreamBytes(MapiTags.PropertiesStream);                            for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)                          {                              // Get property identifer located in 3rd and 4th bytes as a hexdecimal string                              var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                              var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is something to map                      if (mappingValues.Count <= 0) return;                      // Get the Named Id Storage' we need this one to perform the mapping                      var storageStat = _subStorageStatistics[MapiTags.NameIdStorage];                      var subStorage = storage.OpenStorage(storageStat.pwcsName' IntPtr.Zero'                          NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0);                        // Load the subStorage into our mapping class that does all the mapping magic                      var mapiToOom = new MapiTagMapper(new Storage(subStorage));                        // Get the mapped properties                      _namedProperties = mapiToOom.GetMapping(mappingValues);                        // Clean up the com object                      Marshal.ReleaseComObject(subStorage);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The following statement contains a magic number: if (_subStorageStatistics.ContainsKey(MapiTags.NameIdStorage))                  {                      var mappingValues = new List<string>();                        // Get all the named properties from the _streamStatistics                      foreach (var streamStatistic in _streamStatistics)                      {                          var name = streamStatistic.Value.pwcsName;                            if (name.StartsWith(MapiTags.SubStgVersion1))                          {                              // Get the property value                              var propIdentString = name.Substring(12' 4);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is also a properties stream and if so get all the named MAPI properties from it                      if (_streamStatistics.ContainsKey(MapiTags.PropertiesStream))                      {                          // Get the raw bytes for the property stream                          var propBytes = GetStreamBytes(MapiTags.PropertiesStream);                            for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)                          {                              // Get property identifer located in 3rd and 4th bytes as a hexdecimal string                              var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                              var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is something to map                      if (mappingValues.Count <= 0) return;                      // Get the Named Id Storage' we need this one to perform the mapping                      var storageStat = _subStorageStatistics[MapiTags.NameIdStorage];                      var subStorage = storage.OpenStorage(storageStat.pwcsName' IntPtr.Zero'                          NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0);                        // Load the subStorage into our mapping class that does all the mapping magic                      var mapiToOom = new MapiTagMapper(new Storage(subStorage));                        // Get the mapped properties                      _namedProperties = mapiToOom.GetMapping(mappingValues);                        // Clean up the com object                      Marshal.ReleaseComObject(subStorage);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The following statement contains a magic number: if (_subStorageStatistics.ContainsKey(MapiTags.NameIdStorage))                  {                      var mappingValues = new List<string>();                        // Get all the named properties from the _streamStatistics                      foreach (var streamStatistic in _streamStatistics)                      {                          var name = streamStatistic.Value.pwcsName;                            if (name.StartsWith(MapiTags.SubStgVersion1))                          {                              // Get the property value                              var propIdentString = name.Substring(12' 4);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is also a properties stream and if so get all the named MAPI properties from it                      if (_streamStatistics.ContainsKey(MapiTags.PropertiesStream))                      {                          // Get the raw bytes for the property stream                          var propBytes = GetStreamBytes(MapiTags.PropertiesStream);                            for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)                          {                              // Get property identifer located in 3rd and 4th bytes as a hexdecimal string                              var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                              var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is something to map                      if (mappingValues.Count <= 0) return;                      // Get the Named Id Storage' we need this one to perform the mapping                      var storageStat = _subStorageStatistics[MapiTags.NameIdStorage];                      var subStorage = storage.OpenStorage(storageStat.pwcsName' IntPtr.Zero'                          NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0);                        // Load the subStorage into our mapping class that does all the mapping magic                      var mapiToOom = new MapiTagMapper(new Storage(subStorage));                        // Get the mapped properties                      _namedProperties = mapiToOom.GetMapping(mappingValues);                        // Clean up the com object                      Marshal.ReleaseComObject(subStorage);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The following statement contains a magic number: if (_subStorageStatistics.ContainsKey(MapiTags.NameIdStorage))                  {                      var mappingValues = new List<string>();                        // Get all the named properties from the _streamStatistics                      foreach (var streamStatistic in _streamStatistics)                      {                          var name = streamStatistic.Value.pwcsName;                            if (name.StartsWith(MapiTags.SubStgVersion1))                          {                              // Get the property value                              var propIdentString = name.Substring(12' 4);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is also a properties stream and if so get all the named MAPI properties from it                      if (_streamStatistics.ContainsKey(MapiTags.PropertiesStream))                      {                          // Get the raw bytes for the property stream                          var propBytes = GetStreamBytes(MapiTags.PropertiesStream);                            for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)                          {                              // Get property identifer located in 3rd and 4th bytes as a hexdecimal string                              var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                              var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is something to map                      if (mappingValues.Count <= 0) return;                      // Get the Named Id Storage' we need this one to perform the mapping                      var storageStat = _subStorageStatistics[MapiTags.NameIdStorage];                      var subStorage = storage.OpenStorage(storageStat.pwcsName' IntPtr.Zero'                          NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0);                        // Load the subStorage into our mapping class that does all the mapping magic                      var mapiToOom = new MapiTagMapper(new Storage(subStorage));                        // Get the mapped properties                      _namedProperties = mapiToOom.GetMapping(mappingValues);                        // Clean up the com object                      Marshal.ReleaseComObject(subStorage);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The following statement contains a magic number: if (_subStorageStatistics.ContainsKey(MapiTags.NameIdStorage))                  {                      var mappingValues = new List<string>();                        // Get all the named properties from the _streamStatistics                      foreach (var streamStatistic in _streamStatistics)                      {                          var name = streamStatistic.Value.pwcsName;                            if (name.StartsWith(MapiTags.SubStgVersion1))                          {                              // Get the property value                              var propIdentString = name.Substring(12' 4);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is also a properties stream and if so get all the named MAPI properties from it                      if (_streamStatistics.ContainsKey(MapiTags.PropertiesStream))                      {                          // Get the raw bytes for the property stream                          var propBytes = GetStreamBytes(MapiTags.PropertiesStream);                            for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)                          {                              // Get property identifer located in 3rd and 4th bytes as a hexdecimal string                              var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                              var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is something to map                      if (mappingValues.Count <= 0) return;                      // Get the Named Id Storage' we need this one to perform the mapping                      var storageStat = _subStorageStatistics[MapiTags.NameIdStorage];                      var subStorage = storage.OpenStorage(storageStat.pwcsName' IntPtr.Zero'                          NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0);                        // Load the subStorage into our mapping class that does all the mapping magic                      var mapiToOom = new MapiTagMapper(new Storage(subStorage));                        // Get the mapped properties                      _namedProperties = mapiToOom.GetMapping(mappingValues);                        // Clean up the com object                      Marshal.ReleaseComObject(subStorage);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The following statement contains a magic number: if (_subStorageStatistics.ContainsKey(MapiTags.NameIdStorage))                  {                      var mappingValues = new List<string>();                        // Get all the named properties from the _streamStatistics                      foreach (var streamStatistic in _streamStatistics)                      {                          var name = streamStatistic.Value.pwcsName;                            if (name.StartsWith(MapiTags.SubStgVersion1))                          {                              // Get the property value                              var propIdentString = name.Substring(12' 4);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is also a properties stream and if so get all the named MAPI properties from it                      if (_streamStatistics.ContainsKey(MapiTags.PropertiesStream))                      {                          // Get the raw bytes for the property stream                          var propBytes = GetStreamBytes(MapiTags.PropertiesStream);                            for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)                          {                              // Get property identifer located in 3rd and 4th bytes as a hexdecimal string                              var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                              var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is something to map                      if (mappingValues.Count <= 0) return;                      // Get the Named Id Storage' we need this one to perform the mapping                      var storageStat = _subStorageStatistics[MapiTags.NameIdStorage];                      var subStorage = storage.OpenStorage(storageStat.pwcsName' IntPtr.Zero'                          NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0);                        // Load the subStorage into our mapping class that does all the mapping magic                      var mapiToOom = new MapiTagMapper(new Storage(subStorage));                        // Get the mapped properties                      _namedProperties = mapiToOom.GetMapping(mappingValues);                        // Clean up the com object                      Marshal.ReleaseComObject(subStorage);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The following statement contains a magic number: if (_subStorageStatistics.ContainsKey(MapiTags.NameIdStorage))                  {                      var mappingValues = new List<string>();                        // Get all the named properties from the _streamStatistics                      foreach (var streamStatistic in _streamStatistics)                      {                          var name = streamStatistic.Value.pwcsName;                            if (name.StartsWith(MapiTags.SubStgVersion1))                          {                              // Get the property value                              var propIdentString = name.Substring(12' 4);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is also a properties stream and if so get all the named MAPI properties from it                      if (_streamStatistics.ContainsKey(MapiTags.PropertiesStream))                      {                          // Get the raw bytes for the property stream                          var propBytes = GetStreamBytes(MapiTags.PropertiesStream);                            for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)                          {                              // Get property identifer located in 3rd and 4th bytes as a hexdecimal string                              var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                              var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is something to map                      if (mappingValues.Count <= 0) return;                      // Get the Named Id Storage' we need this one to perform the mapping                      var storageStat = _subStorageStatistics[MapiTags.NameIdStorage];                      var subStorage = storage.OpenStorage(storageStat.pwcsName' IntPtr.Zero'                          NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0);                        // Load the subStorage into our mapping class that does all the mapping magic                      var mapiToOom = new MapiTagMapper(new Storage(subStorage));                        // Get the mapped properties                      _namedProperties = mapiToOom.GetMapping(mappingValues);                        // Clean up the com object                      Marshal.ReleaseComObject(subStorage);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The following statement contains a magic number: if (_subStorageStatistics.ContainsKey(MapiTags.NameIdStorage))                  {                      var mappingValues = new List<string>();                        // Get all the named properties from the _streamStatistics                      foreach (var streamStatistic in _streamStatistics)                      {                          var name = streamStatistic.Value.pwcsName;                            if (name.StartsWith(MapiTags.SubStgVersion1))                          {                              // Get the property value                              var propIdentString = name.Substring(12' 4);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is also a properties stream and if so get all the named MAPI properties from it                      if (_streamStatistics.ContainsKey(MapiTags.PropertiesStream))                      {                          // Get the raw bytes for the property stream                          var propBytes = GetStreamBytes(MapiTags.PropertiesStream);                            for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)                          {                              // Get property identifer located in 3rd and 4th bytes as a hexdecimal string                              var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                              var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is something to map                      if (mappingValues.Count <= 0) return;                      // Get the Named Id Storage' we need this one to perform the mapping                      var storageStat = _subStorageStatistics[MapiTags.NameIdStorage];                      var subStorage = storage.OpenStorage(storageStat.pwcsName' IntPtr.Zero'                          NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0);                        // Load the subStorage into our mapping class that does all the mapping magic                      var mapiToOom = new MapiTagMapper(new Storage(subStorage));                        // Get the mapped properties                      _namedProperties = mapiToOom.GetMapping(mappingValues);                        // Clean up the com object                      Marshal.ReleaseComObject(subStorage);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,LoadStorage,The following statement contains a magic number: if (_subStorageStatistics.ContainsKey(MapiTags.NameIdStorage))                  {                      var mappingValues = new List<string>();                        // Get all the named properties from the _streamStatistics                      foreach (var streamStatistic in _streamStatistics)                      {                          var name = streamStatistic.Value.pwcsName;                            if (name.StartsWith(MapiTags.SubStgVersion1))                          {                              // Get the property value                              var propIdentString = name.Substring(12' 4);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is also a properties stream and if so get all the named MAPI properties from it                      if (_streamStatistics.ContainsKey(MapiTags.PropertiesStream))                      {                          // Get the raw bytes for the property stream                          var propBytes = GetStreamBytes(MapiTags.PropertiesStream);                            for (var i = _propHeaderSize; i < propBytes.Length; i = i + 16)                          {                              // Get property identifer located in 3rd and 4th bytes as a hexdecimal string                              var propIdent = new[] { propBytes[i + 3]' propBytes[i + 2] };                              var propIdentString = BitConverter.ToString(propIdent).Replace("-"' string.Empty);                                // Convert it to a short                              var value = ushort.Parse(propIdentString' NumberStyles.HexNumber);                                // Check if the value is in the named property range (8000 to FFFE (Hex))                              if (value >= 32768 && value <= 65534)                              {                                  // If so then add it to perform mapping later on                                  if (!mappingValues.Contains(propIdentString))                                      mappingValues.Add(propIdentString);                              }                          }                      }                        // Check if there is something to map                      if (mappingValues.Count <= 0) return;                      // Get the Named Id Storage' we need this one to perform the mapping                      var storageStat = _subStorageStatistics[MapiTags.NameIdStorage];                      var subStorage = storage.OpenStorage(storageStat.pwcsName' IntPtr.Zero'                          NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0);                        // Load the subStorage into our mapping class that does all the mapping magic                      var mapiToOom = new MapiTagMapper(new Storage(subStorage));                        // Get the mapped properties                      _namedProperties = mapiToOom.GetMapping(mappingValues);                        // Clean up the com object                      Marshal.ReleaseComObject(subStorage);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,Save,The following statement contains a magic number: try                  {                      // Create a ILockBytes (unmanaged byte array) and then create a IStorage using the byte array as a backing store                      NativeMethods.CreateILockBytesOnHGlobal(IntPtr.Zero' true' out memoryStorageBytes);                      NativeMethods.StgCreateDocfileOnILockBytes(memoryStorageBytes'                          NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0'                          out memoryStorage);                        // Copy the save storage into the new storage                      saveMsg._storage.CopyTo(0' null' IntPtr.Zero' memoryStorage);                      memoryStorageBytes.Flush();                      memoryStorage.Commit(0);                        // If not the top parent then the name id mapping needs to be copied from top parent to this message and the property stream header                       // needs to be padded by 8 bytes                      if (!IsTopParent)                      {                          // Create a new name id storage and get the source name id storage to copy from                          var nameIdStorage = memoryStorage.CreateStorage(MapiTags.NameIdStorage'                              NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE |                              NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                            nameIdSourceStorage = TopParent._storage.OpenStorage(MapiTags.NameIdStorage' IntPtr.Zero'                              NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE'                              IntPtr.Zero' 0);                            // Copy the name id storage from the parent to the new name id storage                          nameIdSourceStorage.CopyTo(0' null' IntPtr.Zero' nameIdStorage);                            // Get the property bytes for the storage being copied                          var props = saveMsg.GetStreamBytes(MapiTags.PropertiesStream);                            // Create new array to store a copy of the properties that is 8 bytes larger than the old so the header can be padded                          var newProps = new byte[props.Length + 8];                            // Insert 8 null bytes from index 24 to 32. this is because a top level object property header requires a 32 byte header                          Buffer.BlockCopy(props' 0' newProps' 0' 24);                          Buffer.BlockCopy(props' 24' newProps' 32' props.Length - 24);                            // Remove the copied prop bytes so it can be replaced with the padded version                          memoryStorage.DestroyElement(MapiTags.PropertiesStream);                            // Create the property stream again and write in the padded version                          var propStream = memoryStorage.CreateStream(MapiTags.PropertiesStream'                              NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                          propStream.Write(newProps' newProps.Length' IntPtr.Zero);                      }                        // Commit changes to the storage                      memoryStorage.Commit(0);                      memoryStorageBytes.Flush();                        // Get the STATSTG of the ILockBytes to determine how many bytes were written to it                      STATSTG memoryStorageBytesStat;                      memoryStorageBytes.Stat(out memoryStorageBytesStat' 1);                        // Read the bytes into a managed byte array                      var memoryStorageContent = new byte[memoryStorageBytesStat.cbSize];                      memoryStorageBytes.ReadAt(0' memoryStorageContent' memoryStorageContent.Length' null);                        // Write storage bytes to stream                      stream.Write(memoryStorageContent' 0' memoryStorageContent.Length);                  }                  finally                  {                      if (nameIdSourceStorage != null)                          Marshal.ReleaseComObject(nameIdSourceStorage);                        if (memoryStorage != null)                          Marshal.ReleaseComObject(memoryStorage);                        if (memoryStorageBytes != null)                          Marshal.ReleaseComObject(memoryStorageBytes);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,Save,The following statement contains a magic number: try                  {                      // Create a ILockBytes (unmanaged byte array) and then create a IStorage using the byte array as a backing store                      NativeMethods.CreateILockBytesOnHGlobal(IntPtr.Zero' true' out memoryStorageBytes);                      NativeMethods.StgCreateDocfileOnILockBytes(memoryStorageBytes'                          NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0'                          out memoryStorage);                        // Copy the save storage into the new storage                      saveMsg._storage.CopyTo(0' null' IntPtr.Zero' memoryStorage);                      memoryStorageBytes.Flush();                      memoryStorage.Commit(0);                        // If not the top parent then the name id mapping needs to be copied from top parent to this message and the property stream header                       // needs to be padded by 8 bytes                      if (!IsTopParent)                      {                          // Create a new name id storage and get the source name id storage to copy from                          var nameIdStorage = memoryStorage.CreateStorage(MapiTags.NameIdStorage'                              NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE |                              NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                            nameIdSourceStorage = TopParent._storage.OpenStorage(MapiTags.NameIdStorage' IntPtr.Zero'                              NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE'                              IntPtr.Zero' 0);                            // Copy the name id storage from the parent to the new name id storage                          nameIdSourceStorage.CopyTo(0' null' IntPtr.Zero' nameIdStorage);                            // Get the property bytes for the storage being copied                          var props = saveMsg.GetStreamBytes(MapiTags.PropertiesStream);                            // Create new array to store a copy of the properties that is 8 bytes larger than the old so the header can be padded                          var newProps = new byte[props.Length + 8];                            // Insert 8 null bytes from index 24 to 32. this is because a top level object property header requires a 32 byte header                          Buffer.BlockCopy(props' 0' newProps' 0' 24);                          Buffer.BlockCopy(props' 24' newProps' 32' props.Length - 24);                            // Remove the copied prop bytes so it can be replaced with the padded version                          memoryStorage.DestroyElement(MapiTags.PropertiesStream);                            // Create the property stream again and write in the padded version                          var propStream = memoryStorage.CreateStream(MapiTags.PropertiesStream'                              NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                          propStream.Write(newProps' newProps.Length' IntPtr.Zero);                      }                        // Commit changes to the storage                      memoryStorage.Commit(0);                      memoryStorageBytes.Flush();                        // Get the STATSTG of the ILockBytes to determine how many bytes were written to it                      STATSTG memoryStorageBytesStat;                      memoryStorageBytes.Stat(out memoryStorageBytesStat' 1);                        // Read the bytes into a managed byte array                      var memoryStorageContent = new byte[memoryStorageBytesStat.cbSize];                      memoryStorageBytes.ReadAt(0' memoryStorageContent' memoryStorageContent.Length' null);                        // Write storage bytes to stream                      stream.Write(memoryStorageContent' 0' memoryStorageContent.Length);                  }                  finally                  {                      if (nameIdSourceStorage != null)                          Marshal.ReleaseComObject(nameIdSourceStorage);                        if (memoryStorage != null)                          Marshal.ReleaseComObject(memoryStorage);                        if (memoryStorageBytes != null)                          Marshal.ReleaseComObject(memoryStorageBytes);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,Save,The following statement contains a magic number: try                  {                      // Create a ILockBytes (unmanaged byte array) and then create a IStorage using the byte array as a backing store                      NativeMethods.CreateILockBytesOnHGlobal(IntPtr.Zero' true' out memoryStorageBytes);                      NativeMethods.StgCreateDocfileOnILockBytes(memoryStorageBytes'                          NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0'                          out memoryStorage);                        // Copy the save storage into the new storage                      saveMsg._storage.CopyTo(0' null' IntPtr.Zero' memoryStorage);                      memoryStorageBytes.Flush();                      memoryStorage.Commit(0);                        // If not the top parent then the name id mapping needs to be copied from top parent to this message and the property stream header                       // needs to be padded by 8 bytes                      if (!IsTopParent)                      {                          // Create a new name id storage and get the source name id storage to copy from                          var nameIdStorage = memoryStorage.CreateStorage(MapiTags.NameIdStorage'                              NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE |                              NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                            nameIdSourceStorage = TopParent._storage.OpenStorage(MapiTags.NameIdStorage' IntPtr.Zero'                              NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE'                              IntPtr.Zero' 0);                            // Copy the name id storage from the parent to the new name id storage                          nameIdSourceStorage.CopyTo(0' null' IntPtr.Zero' nameIdStorage);                            // Get the property bytes for the storage being copied                          var props = saveMsg.GetStreamBytes(MapiTags.PropertiesStream);                            // Create new array to store a copy of the properties that is 8 bytes larger than the old so the header can be padded                          var newProps = new byte[props.Length + 8];                            // Insert 8 null bytes from index 24 to 32. this is because a top level object property header requires a 32 byte header                          Buffer.BlockCopy(props' 0' newProps' 0' 24);                          Buffer.BlockCopy(props' 24' newProps' 32' props.Length - 24);                            // Remove the copied prop bytes so it can be replaced with the padded version                          memoryStorage.DestroyElement(MapiTags.PropertiesStream);                            // Create the property stream again and write in the padded version                          var propStream = memoryStorage.CreateStream(MapiTags.PropertiesStream'                              NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                          propStream.Write(newProps' newProps.Length' IntPtr.Zero);                      }                        // Commit changes to the storage                      memoryStorage.Commit(0);                      memoryStorageBytes.Flush();                        // Get the STATSTG of the ILockBytes to determine how many bytes were written to it                      STATSTG memoryStorageBytesStat;                      memoryStorageBytes.Stat(out memoryStorageBytesStat' 1);                        // Read the bytes into a managed byte array                      var memoryStorageContent = new byte[memoryStorageBytesStat.cbSize];                      memoryStorageBytes.ReadAt(0' memoryStorageContent' memoryStorageContent.Length' null);                        // Write storage bytes to stream                      stream.Write(memoryStorageContent' 0' memoryStorageContent.Length);                  }                  finally                  {                      if (nameIdSourceStorage != null)                          Marshal.ReleaseComObject(nameIdSourceStorage);                        if (memoryStorage != null)                          Marshal.ReleaseComObject(memoryStorage);                        if (memoryStorageBytes != null)                          Marshal.ReleaseComObject(memoryStorageBytes);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,Save,The following statement contains a magic number: try                  {                      // Create a ILockBytes (unmanaged byte array) and then create a IStorage using the byte array as a backing store                      NativeMethods.CreateILockBytesOnHGlobal(IntPtr.Zero' true' out memoryStorageBytes);                      NativeMethods.StgCreateDocfileOnILockBytes(memoryStorageBytes'                          NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0'                          out memoryStorage);                        // Copy the save storage into the new storage                      saveMsg._storage.CopyTo(0' null' IntPtr.Zero' memoryStorage);                      memoryStorageBytes.Flush();                      memoryStorage.Commit(0);                        // If not the top parent then the name id mapping needs to be copied from top parent to this message and the property stream header                       // needs to be padded by 8 bytes                      if (!IsTopParent)                      {                          // Create a new name id storage and get the source name id storage to copy from                          var nameIdStorage = memoryStorage.CreateStorage(MapiTags.NameIdStorage'                              NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE |                              NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                            nameIdSourceStorage = TopParent._storage.OpenStorage(MapiTags.NameIdStorage' IntPtr.Zero'                              NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE'                              IntPtr.Zero' 0);                            // Copy the name id storage from the parent to the new name id storage                          nameIdSourceStorage.CopyTo(0' null' IntPtr.Zero' nameIdStorage);                            // Get the property bytes for the storage being copied                          var props = saveMsg.GetStreamBytes(MapiTags.PropertiesStream);                            // Create new array to store a copy of the properties that is 8 bytes larger than the old so the header can be padded                          var newProps = new byte[props.Length + 8];                            // Insert 8 null bytes from index 24 to 32. this is because a top level object property header requires a 32 byte header                          Buffer.BlockCopy(props' 0' newProps' 0' 24);                          Buffer.BlockCopy(props' 24' newProps' 32' props.Length - 24);                            // Remove the copied prop bytes so it can be replaced with the padded version                          memoryStorage.DestroyElement(MapiTags.PropertiesStream);                            // Create the property stream again and write in the padded version                          var propStream = memoryStorage.CreateStream(MapiTags.PropertiesStream'                              NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                          propStream.Write(newProps' newProps.Length' IntPtr.Zero);                      }                        // Commit changes to the storage                      memoryStorage.Commit(0);                      memoryStorageBytes.Flush();                        // Get the STATSTG of the ILockBytes to determine how many bytes were written to it                      STATSTG memoryStorageBytesStat;                      memoryStorageBytes.Stat(out memoryStorageBytesStat' 1);                        // Read the bytes into a managed byte array                      var memoryStorageContent = new byte[memoryStorageBytesStat.cbSize];                      memoryStorageBytes.ReadAt(0' memoryStorageContent' memoryStorageContent.Length' null);                        // Write storage bytes to stream                      stream.Write(memoryStorageContent' 0' memoryStorageContent.Length);                  }                  finally                  {                      if (nameIdSourceStorage != null)                          Marshal.ReleaseComObject(nameIdSourceStorage);                        if (memoryStorage != null)                          Marshal.ReleaseComObject(memoryStorage);                        if (memoryStorageBytes != null)                          Marshal.ReleaseComObject(memoryStorageBytes);                  }
Magic Number,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,Save,The following statement contains a magic number: try                  {                      // Create a ILockBytes (unmanaged byte array) and then create a IStorage using the byte array as a backing store                      NativeMethods.CreateILockBytesOnHGlobal(IntPtr.Zero' true' out memoryStorageBytes);                      NativeMethods.StgCreateDocfileOnILockBytes(memoryStorageBytes'                          NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0'                          out memoryStorage);                        // Copy the save storage into the new storage                      saveMsg._storage.CopyTo(0' null' IntPtr.Zero' memoryStorage);                      memoryStorageBytes.Flush();                      memoryStorage.Commit(0);                        // If not the top parent then the name id mapping needs to be copied from top parent to this message and the property stream header                       // needs to be padded by 8 bytes                      if (!IsTopParent)                      {                          // Create a new name id storage and get the source name id storage to copy from                          var nameIdStorage = memoryStorage.CreateStorage(MapiTags.NameIdStorage'                              NativeMethods.STGM.CREATE | NativeMethods.STGM.READWRITE |                              NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                            nameIdSourceStorage = TopParent._storage.OpenStorage(MapiTags.NameIdStorage' IntPtr.Zero'                              NativeMethods.STGM.READ | NativeMethods.STGM.SHARE_EXCLUSIVE'                              IntPtr.Zero' 0);                            // Copy the name id storage from the parent to the new name id storage                          nameIdSourceStorage.CopyTo(0' null' IntPtr.Zero' nameIdStorage);                            // Get the property bytes for the storage being copied                          var props = saveMsg.GetStreamBytes(MapiTags.PropertiesStream);                            // Create new array to store a copy of the properties that is 8 bytes larger than the old so the header can be padded                          var newProps = new byte[props.Length + 8];                            // Insert 8 null bytes from index 24 to 32. this is because a top level object property header requires a 32 byte header                          Buffer.BlockCopy(props' 0' newProps' 0' 24);                          Buffer.BlockCopy(props' 24' newProps' 32' props.Length - 24);                            // Remove the copied prop bytes so it can be replaced with the padded version                          memoryStorage.DestroyElement(MapiTags.PropertiesStream);                            // Create the property stream again and write in the padded version                          var propStream = memoryStorage.CreateStream(MapiTags.PropertiesStream'                              NativeMethods.STGM.READWRITE | NativeMethods.STGM.SHARE_EXCLUSIVE' 0' 0);                          propStream.Write(newProps' newProps.Length' IntPtr.Zero);                      }                        // Commit changes to the storage                      memoryStorage.Commit(0);                      memoryStorageBytes.Flush();                        // Get the STATSTG of the ILockBytes to determine how many bytes were written to it                      STATSTG memoryStorageBytesStat;                      memoryStorageBytes.Stat(out memoryStorageBytesStat' 1);                        // Read the bytes into a managed byte array                      var memoryStorageContent = new byte[memoryStorageBytesStat.cbSize];                      memoryStorageBytes.ReadAt(0' memoryStorageContent' memoryStorageContent.Length' null);                        // Write storage bytes to stream                      stream.Write(memoryStorageContent' 0' memoryStorageContent.Length);                  }                  finally                  {                      if (nameIdSourceStorage != null)                          Marshal.ReleaseComObject(nameIdSourceStorage);                        if (memoryStorage != null)                          Marshal.ReleaseComObject(memoryStorage);                        if (memoryStorageBytes != null)                          Marshal.ReleaseComObject(memoryStorageBytes);                  }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,CalculateCrc32,The following statement contains a magic number: for (var i = off; i < end; i++)                  c = Crc32Table[(c ^ buf[i]) & 0xFF] ^ (c >> 8);
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,GetU32,The following statement contains a magic number: return ((buf[offset] & 0xFF) | ((buf[offset + 1] & 0xFF) << 8) | ((buf[offset + 2] & 0xFF) << 16) |                      ((buf[offset + 3] & 0xFF) << 24)) & 0x00000000FFFFFFFFL;
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,GetU32,The following statement contains a magic number: return ((buf[offset] & 0xFF) | ((buf[offset + 1] & 0xFF) << 8) | ((buf[offset + 2] & 0xFF) << 16) |                      ((buf[offset + 3] & 0xFF) << 24)) & 0x00000000FFFFFFFFL;
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,GetU32,The following statement contains a magic number: return ((buf[offset] & 0xFF) | ((buf[offset + 1] & 0xFF) << 8) | ((buf[offset + 2] & 0xFF) << 16) |                      ((buf[offset + 3] & 0xFF) << 24)) & 0x00000000FFFFFFFFL;
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,GetU32,The following statement contains a magic number: return ((buf[offset] & 0xFF) | ((buf[offset + 1] & 0xFF) << 8) | ((buf[offset + 2] & 0xFF) << 16) |                      ((buf[offset + 3] & 0xFF) << 24)) & 0x00000000FFFFFFFFL;
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,GetU32,The following statement contains a magic number: return ((buf[offset] & 0xFF) | ((buf[offset + 1] & 0xFF) << 8) | ((buf[offset + 2] & 0xFF) << 16) |                      ((buf[offset + 3] & 0xFF) << 24)) & 0x00000000FFFFFFFFL;
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: if (src == null || src.Length < 16)                  throw new Exception("Invalid compressed-RTF header");
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: inPos += 4;
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: inPos += 4;
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: inPos += 4;
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: if (compressedSize != src.Length - 4) // check size excluding the size field itself                  throw new Exception("compressed-RTF data size mismatch");
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,RtfDecompressor,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\RtfDecompressor.cs,DecompressRtf,The following statement contains a magic number: switch (magic)              {                  case 0x414c454d:                      dst = new byte[uncompressedSize];                      Array.Copy(src' inPos' dst' outPos' uncompressedSize- inPos); // just copy it as it is                      break;                    case 0x75465a4c:                      {                          var crc32 = (int)GetU32(src' inPos);                          inPos += 4;                            if (crc32 != CalculateCrc32(src' 16' src.Length - 16))                              throw new Exception("compressed-RTF CRC32 failed");                                                    // magic number that identifies the stream as a compressed stream                          dst = new byte[_compressedRtfPrebuf.Length + uncompressedSize];                          Array.Copy(_compressedRtfPrebuf' 0' dst' 0' _compressedRtfPrebuf.Length);                          outPos = _compressedRtfPrebuf.Length;                          var flagCount = 0;                          var flags = 0;                          while (outPos < dst.Length)                          {                              // each flag byte flags 8 literals/references' 1 per bit                              flags = (flagCount++ % 8 == 0) ? GetU8(src' inPos++) : flags >> 1;                              if ((flags & 1) == 1)                              { // each flag bit is 1 for reference' 0 for literal                                  var offset = GetU8(src' inPos++);                                  var length = GetU8(src' inPos++);                                  //!!!!!!!!!            offset = (offset << 4) | (length >>> 4); // the offset relative to block start                                  offset = (offset << 4) | (length >> 4); // the offset relative to block start                                  length = (length & 0xF) + 2; // the number of bytes to copy                                  // the decompression buffer is supposed to wrap around back                                  // to the beginning when the end is reached. we save the                                  // need for such a buffer by pointing straight into the data                                  // buffer' and simulating this behaviour by modifying the                                  // pointers appropriately.                                  offset = (outPos / 4096) * 4096 + offset;                                  if (offset >= outPos) // take from previous block                                      offset -= 4096;                                  // note: can't use System.arraycopy' because the referenced                                  // bytes can cross through the current out position.                                  var end = offset + length;                                  while (offset < end)                                      dst[outPos++] = dst[offset++];                              }                              else                              { // literal                                  dst[outPos++] = src[inPos++];                              }                          }                          // copy it back without the prebuffered data                          src = dst;                          dst = new byte[uncompressedSize];                          Array.Copy(src' _compressedRtfPrebuf.Length' dst' 0' uncompressedSize);                      }                      break;                    default:                      throw new Exception("Unknown compression type (magic number " + magic + ")");              }
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: var b = new BitArray(binaryReader.ReadBytes(4));
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: TransmittableDisplayNameIncluded = b[2];
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: DisplayNameIncluded = b[3];
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: EmailAddressIncluded = b[4];
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: var bt = new BitArray(3);
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: bt.Set(0' b[5]);
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: bt.Set(1' b[6]);
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: bt.Set(2' b[7]);
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: bt.Set(2' b[7]);
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: AddressTypeIncluded = b[8];
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: SimpleDisplayNameIncluded = b[13];
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: StringsInUnicode = b[14];
Magic Number,MsgReader.Outlook,UnsendableRecipients,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,UnsendableRecipients,The following statement contains a magic number: var supportsRtf = !b[15];
Magic Number,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following statement contains a magic number: binaryReader.ReadBytes(6);
Magic Number,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following statement contains a magic number: for (var column = 0; column < columns; column++)              {                  var type = (PropertyType) binaryReader.ReadUInt16();                  var id = binaryReader.ReadUInt16();                  byte[] data;                    switch (type)                  {                      case PropertyType.PT_NULL:                      {                          data = new byte[0];                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_BOOLEAN:                      {                          data = binaryReader.ReadBytes(1);                          binaryReader.ReadByte();                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_SHORT:                      {                          data = binaryReader.ReadBytes(2);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_LONG:                      case PropertyType.PT_FLOAT:                      case PropertyType.PT_ERROR:                      {                          data = binaryReader.ReadBytes(4);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_DOUBLE:                      case PropertyType.PT_APPTIME:                      case PropertyType.PT_I8:                      case PropertyType.PT_SYSTIME:                      {                          data = binaryReader.ReadBytes(8);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_CLSID:                      {                          data = binaryReader.ReadBytes(16);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_OBJECT:                          throw new NotSupportedException("The PT_OBJECT type is not supported");                        case PropertyType.PT_STRING8:                      case PropertyType.PT_UNICODE:                      case PropertyType.PT_BINARY:                      {                          var length = binaryReader.ReadInt16();                          data = binaryReader.ReadBytes(length);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_MV_SHORT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(2);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_LONG:                      case PropertyType.PT_MV_FLOAT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(4);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_DOUBLE:                      case PropertyType.PT_MV_APPTIME:                      case PropertyType.PT_MV_LONGLONG:                      case PropertyType.PT_MV_SYSTIME:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(8);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_TSTRING:                      case PropertyType.PT_MV_STRING8:                      case PropertyType.PT_MV_BINARY:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              var length = binaryReader.ReadInt16();                              data = binaryReader.ReadBytes(length);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_CLSID:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(16);                              RecipientProperties.Add(new Property(id' type' data));                          }                          break;                      }                        default:                          throw new ArgumentOutOfRangeException();                  }              }
Magic Number,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following statement contains a magic number: for (var column = 0; column < columns; column++)              {                  var type = (PropertyType) binaryReader.ReadUInt16();                  var id = binaryReader.ReadUInt16();                  byte[] data;                    switch (type)                  {                      case PropertyType.PT_NULL:                      {                          data = new byte[0];                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_BOOLEAN:                      {                          data = binaryReader.ReadBytes(1);                          binaryReader.ReadByte();                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_SHORT:                      {                          data = binaryReader.ReadBytes(2);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_LONG:                      case PropertyType.PT_FLOAT:                      case PropertyType.PT_ERROR:                      {                          data = binaryReader.ReadBytes(4);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_DOUBLE:                      case PropertyType.PT_APPTIME:                      case PropertyType.PT_I8:                      case PropertyType.PT_SYSTIME:                      {                          data = binaryReader.ReadBytes(8);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_CLSID:                      {                          data = binaryReader.ReadBytes(16);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_OBJECT:                          throw new NotSupportedException("The PT_OBJECT type is not supported");                        case PropertyType.PT_STRING8:                      case PropertyType.PT_UNICODE:                      case PropertyType.PT_BINARY:                      {                          var length = binaryReader.ReadInt16();                          data = binaryReader.ReadBytes(length);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_MV_SHORT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(2);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_LONG:                      case PropertyType.PT_MV_FLOAT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(4);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_DOUBLE:                      case PropertyType.PT_MV_APPTIME:                      case PropertyType.PT_MV_LONGLONG:                      case PropertyType.PT_MV_SYSTIME:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(8);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_TSTRING:                      case PropertyType.PT_MV_STRING8:                      case PropertyType.PT_MV_BINARY:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              var length = binaryReader.ReadInt16();                              data = binaryReader.ReadBytes(length);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_CLSID:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(16);                              RecipientProperties.Add(new Property(id' type' data));                          }                          break;                      }                        default:                          throw new ArgumentOutOfRangeException();                  }              }
Magic Number,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following statement contains a magic number: for (var column = 0; column < columns; column++)              {                  var type = (PropertyType) binaryReader.ReadUInt16();                  var id = binaryReader.ReadUInt16();                  byte[] data;                    switch (type)                  {                      case PropertyType.PT_NULL:                      {                          data = new byte[0];                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_BOOLEAN:                      {                          data = binaryReader.ReadBytes(1);                          binaryReader.ReadByte();                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_SHORT:                      {                          data = binaryReader.ReadBytes(2);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_LONG:                      case PropertyType.PT_FLOAT:                      case PropertyType.PT_ERROR:                      {                          data = binaryReader.ReadBytes(4);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_DOUBLE:                      case PropertyType.PT_APPTIME:                      case PropertyType.PT_I8:                      case PropertyType.PT_SYSTIME:                      {                          data = binaryReader.ReadBytes(8);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_CLSID:                      {                          data = binaryReader.ReadBytes(16);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_OBJECT:                          throw new NotSupportedException("The PT_OBJECT type is not supported");                        case PropertyType.PT_STRING8:                      case PropertyType.PT_UNICODE:                      case PropertyType.PT_BINARY:                      {                          var length = binaryReader.ReadInt16();                          data = binaryReader.ReadBytes(length);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_MV_SHORT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(2);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_LONG:                      case PropertyType.PT_MV_FLOAT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(4);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_DOUBLE:                      case PropertyType.PT_MV_APPTIME:                      case PropertyType.PT_MV_LONGLONG:                      case PropertyType.PT_MV_SYSTIME:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(8);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_TSTRING:                      case PropertyType.PT_MV_STRING8:                      case PropertyType.PT_MV_BINARY:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              var length = binaryReader.ReadInt16();                              data = binaryReader.ReadBytes(length);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_CLSID:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(16);                              RecipientProperties.Add(new Property(id' type' data));                          }                          break;                      }                        default:                          throw new ArgumentOutOfRangeException();                  }              }
Magic Number,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following statement contains a magic number: for (var column = 0; column < columns; column++)              {                  var type = (PropertyType) binaryReader.ReadUInt16();                  var id = binaryReader.ReadUInt16();                  byte[] data;                    switch (type)                  {                      case PropertyType.PT_NULL:                      {                          data = new byte[0];                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_BOOLEAN:                      {                          data = binaryReader.ReadBytes(1);                          binaryReader.ReadByte();                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_SHORT:                      {                          data = binaryReader.ReadBytes(2);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_LONG:                      case PropertyType.PT_FLOAT:                      case PropertyType.PT_ERROR:                      {                          data = binaryReader.ReadBytes(4);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_DOUBLE:                      case PropertyType.PT_APPTIME:                      case PropertyType.PT_I8:                      case PropertyType.PT_SYSTIME:                      {                          data = binaryReader.ReadBytes(8);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_CLSID:                      {                          data = binaryReader.ReadBytes(16);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_OBJECT:                          throw new NotSupportedException("The PT_OBJECT type is not supported");                        case PropertyType.PT_STRING8:                      case PropertyType.PT_UNICODE:                      case PropertyType.PT_BINARY:                      {                          var length = binaryReader.ReadInt16();                          data = binaryReader.ReadBytes(length);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_MV_SHORT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(2);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_LONG:                      case PropertyType.PT_MV_FLOAT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(4);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_DOUBLE:                      case PropertyType.PT_MV_APPTIME:                      case PropertyType.PT_MV_LONGLONG:                      case PropertyType.PT_MV_SYSTIME:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(8);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_TSTRING:                      case PropertyType.PT_MV_STRING8:                      case PropertyType.PT_MV_BINARY:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              var length = binaryReader.ReadInt16();                              data = binaryReader.ReadBytes(length);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_CLSID:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(16);                              RecipientProperties.Add(new Property(id' type' data));                          }                          break;                      }                        default:                          throw new ArgumentOutOfRangeException();                  }              }
Magic Number,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following statement contains a magic number: for (var column = 0; column < columns; column++)              {                  var type = (PropertyType) binaryReader.ReadUInt16();                  var id = binaryReader.ReadUInt16();                  byte[] data;                    switch (type)                  {                      case PropertyType.PT_NULL:                      {                          data = new byte[0];                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_BOOLEAN:                      {                          data = binaryReader.ReadBytes(1);                          binaryReader.ReadByte();                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_SHORT:                      {                          data = binaryReader.ReadBytes(2);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_LONG:                      case PropertyType.PT_FLOAT:                      case PropertyType.PT_ERROR:                      {                          data = binaryReader.ReadBytes(4);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_DOUBLE:                      case PropertyType.PT_APPTIME:                      case PropertyType.PT_I8:                      case PropertyType.PT_SYSTIME:                      {                          data = binaryReader.ReadBytes(8);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_CLSID:                      {                          data = binaryReader.ReadBytes(16);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_OBJECT:                          throw new NotSupportedException("The PT_OBJECT type is not supported");                        case PropertyType.PT_STRING8:                      case PropertyType.PT_UNICODE:                      case PropertyType.PT_BINARY:                      {                          var length = binaryReader.ReadInt16();                          data = binaryReader.ReadBytes(length);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_MV_SHORT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(2);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_LONG:                      case PropertyType.PT_MV_FLOAT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(4);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_DOUBLE:                      case PropertyType.PT_MV_APPTIME:                      case PropertyType.PT_MV_LONGLONG:                      case PropertyType.PT_MV_SYSTIME:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(8);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_TSTRING:                      case PropertyType.PT_MV_STRING8:                      case PropertyType.PT_MV_BINARY:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              var length = binaryReader.ReadInt16();                              data = binaryReader.ReadBytes(length);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_CLSID:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(16);                              RecipientProperties.Add(new Property(id' type' data));                          }                          break;                      }                        default:                          throw new ArgumentOutOfRangeException();                  }              }
Magic Number,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following statement contains a magic number: for (var column = 0; column < columns; column++)              {                  var type = (PropertyType) binaryReader.ReadUInt16();                  var id = binaryReader.ReadUInt16();                  byte[] data;                    switch (type)                  {                      case PropertyType.PT_NULL:                      {                          data = new byte[0];                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_BOOLEAN:                      {                          data = binaryReader.ReadBytes(1);                          binaryReader.ReadByte();                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_SHORT:                      {                          data = binaryReader.ReadBytes(2);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_LONG:                      case PropertyType.PT_FLOAT:                      case PropertyType.PT_ERROR:                      {                          data = binaryReader.ReadBytes(4);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_DOUBLE:                      case PropertyType.PT_APPTIME:                      case PropertyType.PT_I8:                      case PropertyType.PT_SYSTIME:                      {                          data = binaryReader.ReadBytes(8);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_CLSID:                      {                          data = binaryReader.ReadBytes(16);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_OBJECT:                          throw new NotSupportedException("The PT_OBJECT type is not supported");                        case PropertyType.PT_STRING8:                      case PropertyType.PT_UNICODE:                      case PropertyType.PT_BINARY:                      {                          var length = binaryReader.ReadInt16();                          data = binaryReader.ReadBytes(length);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_MV_SHORT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(2);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_LONG:                      case PropertyType.PT_MV_FLOAT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(4);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_DOUBLE:                      case PropertyType.PT_MV_APPTIME:                      case PropertyType.PT_MV_LONGLONG:                      case PropertyType.PT_MV_SYSTIME:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(8);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_TSTRING:                      case PropertyType.PT_MV_STRING8:                      case PropertyType.PT_MV_BINARY:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              var length = binaryReader.ReadInt16();                              data = binaryReader.ReadBytes(length);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_CLSID:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(16);                              RecipientProperties.Add(new Property(id' type' data));                          }                          break;                      }                        default:                          throw new ArgumentOutOfRangeException();                  }              }
Magic Number,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following statement contains a magic number: for (var column = 0; column < columns; column++)              {                  var type = (PropertyType) binaryReader.ReadUInt16();                  var id = binaryReader.ReadUInt16();                  byte[] data;                    switch (type)                  {                      case PropertyType.PT_NULL:                      {                          data = new byte[0];                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_BOOLEAN:                      {                          data = binaryReader.ReadBytes(1);                          binaryReader.ReadByte();                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_SHORT:                      {                          data = binaryReader.ReadBytes(2);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_LONG:                      case PropertyType.PT_FLOAT:                      case PropertyType.PT_ERROR:                      {                          data = binaryReader.ReadBytes(4);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_DOUBLE:                      case PropertyType.PT_APPTIME:                      case PropertyType.PT_I8:                      case PropertyType.PT_SYSTIME:                      {                          data = binaryReader.ReadBytes(8);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_CLSID:                      {                          data = binaryReader.ReadBytes(16);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_OBJECT:                          throw new NotSupportedException("The PT_OBJECT type is not supported");                        case PropertyType.PT_STRING8:                      case PropertyType.PT_UNICODE:                      case PropertyType.PT_BINARY:                      {                          var length = binaryReader.ReadInt16();                          data = binaryReader.ReadBytes(length);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_MV_SHORT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(2);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_LONG:                      case PropertyType.PT_MV_FLOAT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(4);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_DOUBLE:                      case PropertyType.PT_MV_APPTIME:                      case PropertyType.PT_MV_LONGLONG:                      case PropertyType.PT_MV_SYSTIME:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(8);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_TSTRING:                      case PropertyType.PT_MV_STRING8:                      case PropertyType.PT_MV_BINARY:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              var length = binaryReader.ReadInt16();                              data = binaryReader.ReadBytes(length);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_CLSID:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(16);                              RecipientProperties.Add(new Property(id' type' data));                          }                          break;                      }                        default:                          throw new ArgumentOutOfRangeException();                  }              }
Magic Number,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following statement contains a magic number: for (var column = 0; column < columns; column++)              {                  var type = (PropertyType) binaryReader.ReadUInt16();                  var id = binaryReader.ReadUInt16();                  byte[] data;                    switch (type)                  {                      case PropertyType.PT_NULL:                      {                          data = new byte[0];                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_BOOLEAN:                      {                          data = binaryReader.ReadBytes(1);                          binaryReader.ReadByte();                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_SHORT:                      {                          data = binaryReader.ReadBytes(2);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_LONG:                      case PropertyType.PT_FLOAT:                      case PropertyType.PT_ERROR:                      {                          data = binaryReader.ReadBytes(4);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_DOUBLE:                      case PropertyType.PT_APPTIME:                      case PropertyType.PT_I8:                      case PropertyType.PT_SYSTIME:                      {                          data = binaryReader.ReadBytes(8);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_CLSID:                      {                          data = binaryReader.ReadBytes(16);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_OBJECT:                          throw new NotSupportedException("The PT_OBJECT type is not supported");                        case PropertyType.PT_STRING8:                      case PropertyType.PT_UNICODE:                      case PropertyType.PT_BINARY:                      {                          var length = binaryReader.ReadInt16();                          data = binaryReader.ReadBytes(length);                          RecipientProperties.Add(new Property(id' type' data));                          break;                      }                        case PropertyType.PT_MV_SHORT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(2);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_LONG:                      case PropertyType.PT_MV_FLOAT:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(4);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_DOUBLE:                      case PropertyType.PT_MV_APPTIME:                      case PropertyType.PT_MV_LONGLONG:                      case PropertyType.PT_MV_SYSTIME:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(8);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_TSTRING:                      case PropertyType.PT_MV_STRING8:                      case PropertyType.PT_MV_BINARY:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              var length = binaryReader.ReadInt16();                              data = binaryReader.ReadBytes(length);                              RecipientProperties.Add(new Property(id' type' data' true));                          }                          break;                      }                        case PropertyType.PT_MV_CLSID:                      {                          var count = binaryReader.ReadInt16();                          for (var j = 0; j < count; j++)                          {                              data = binaryReader.ReadBytes(16);                              RecipientProperties.Add(new Property(id' type' data));                          }                          break;                      }                        default:                          throw new ArgumentOutOfRangeException();                  }              }
Magic Number,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,CheckFileNameAndOutputFolder,The following statement contains a magic number: using (var fileStream = File.OpenRead(inputFile))              {                  var header = new byte[2];                  fileStream.Read(header' 0' 2);                    switch (extension)                  {                      case ".MSG":                          // Sometimes the email containts an MSG extension and actualy it's an EML.                          // Most of the times this happens when a user saves the email manually and types                           // the filename. To prevent these kind of errors we do a double check to make sure                           // the file is realy an MSG file                          if (header[0] == 0xD0 && header[1] == 0xCF)                              return ".MSG";                            return ".EML";                        case ".EML":                          // We can't do an extra check overhere because an EML file is text based                           return extension;                        default:                          throw new MRFileTypeNotSupported("Wrong file extension' expected .msg or .eml");                  }              }
Magic Number,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,CheckFileNameAndOutputFolder,The following statement contains a magic number: using (var fileStream = File.OpenRead(inputFile))              {                  var header = new byte[2];                  fileStream.Read(header' 0' 2);                    switch (extension)                  {                      case ".MSG":                          // Sometimes the email containts an MSG extension and actualy it's an EML.                          // Most of the times this happens when a user saves the email manually and types                           // the filename. To prevent these kind of errors we do a double check to make sure                           // the file is realy an MSG file                          if (header[0] == 0xD0 && header[1] == 0xCF)                              return ".MSG";                            return ".EML";                        case ".EML":                          // We can't do an extra check overhere because an EML file is text based                           return extension;                        default:                          throw new MRFileTypeNotSupported("Wrong file extension' expected .msg or .eml");                  }              }
Magic Number,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,ExtractMsgEmailHeader,The following statement contains a magic number: if (!htmlBody)              {                  var languageConsts = new List<string>                  {                      #region LanguageConsts                      LanguageConsts.EmailFromLabel'                      LanguageConsts.EmailSentOnLabel'                      LanguageConsts.EmailToLabel'                      LanguageConsts.EmailCcLabel'                      LanguageConsts.EmailBccLabel'                      LanguageConsts.EmailSubjectLabel'                      LanguageConsts.ImportanceLabel'                      LanguageConsts.EmailAttachmentsLabel'                      LanguageConsts.EmailFollowUpFlag'                      LanguageConsts.EmailFollowUpLabel'                      LanguageConsts.EmailFollowUpStatusLabel'                      LanguageConsts.EmailFollowUpCompletedText'                      LanguageConsts.TaskStartDateLabel'                      LanguageConsts.TaskDueDateLabel'                      LanguageConsts.TaskDateCompleted'                      LanguageConsts.EmailCategoriesLabel                      #endregion                  };                    if (message.Type == Storage.Message.MessageType.EmailEncryptedAndMaybeSigned ||                      message.Type == Storage.Message.MessageType.EmailClearSigned)                      languageConsts.Add(LanguageConsts.EmailSignedBy);                    maxLength = languageConsts.Select(languageConst => languageConst.Length).Concat(new[] {0}).Max() + 2;              }
Magic Number,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteEmlStreamEmail,The following statement contains a magic number: if (!htmlBody)              {                  var languageConsts = new List<string>                  {                      #region LanguageConsts                      LanguageConsts.EmailFromLabel'                      LanguageConsts.EmailSentOnLabel'                      LanguageConsts.EmailToLabel'                      LanguageConsts.EmailCcLabel'                      LanguageConsts.EmailBccLabel'                      LanguageConsts.EmailSubjectLabel'                      LanguageConsts.ImportanceLabel'                      LanguageConsts.EmailAttachmentsLabel'                      #endregion                  };                    maxLength = languageConsts.Select(languageConst => languageConst.Length).Concat(new[] { 0 }).Max() + 2;              }
Magic Number,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteEmlEmail,The following statement contains a magic number: if (!htmlBody)              {                  var languageConsts = new List<string>                  {                      #region LanguageConsts                      LanguageConsts.EmailFromLabel'                      LanguageConsts.EmailSentOnLabel'                      LanguageConsts.EmailToLabel'                      LanguageConsts.EmailCcLabel'                      LanguageConsts.EmailBccLabel'                      LanguageConsts.EmailSubjectLabel'                      LanguageConsts.ImportanceLabel'                      LanguageConsts.EmailAttachmentsLabel'                      #endregion                  };                    maxLength = languageConsts.Select(languageConst => languageConst.Length).Concat(new[] { 0 }).Max() + 2;              }
Magic Number,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgAppointment,The following statement contains a magic number: if (!htmlBody)              {                  var languageConsts = new List<string>                  {                      #region LanguageConsts                      LanguageConsts.AppointmentSubjectLabel'                      LanguageConsts.AppointmentLocationLabel'                      LanguageConsts.AppointmentStartDateLabel'                      LanguageConsts.AppointmentEndDateLabel'                      LanguageConsts.AppointmentRecurrenceTypeLabel'                      LanguageConsts.AppointmentClientIntentLabel'                      LanguageConsts.AppointmentOrganizerLabel'                      LanguageConsts.AppointmentRecurrencePaternLabel'                      LanguageConsts.AppointmentOrganizerLabel'                      LanguageConsts.AppointmentMandatoryParticipantsLabel'                      LanguageConsts.AppointmentOptionalParticipantsLabel'                      LanguageConsts.AppointmentCategoriesLabel'                      LanguageConsts.ImportanceLabel'                      LanguageConsts.TaskDateCompleted'                      LanguageConsts.EmailCategoriesLabel                      #endregion                  };                    maxLength = languageConsts.Select(languageConst => languageConst.Length).Concat(new[] {0}).Max() + 2;              }
Magic Number,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgTask,The following statement contains a magic number: if (!htmlBody)              {                  var languageConsts = new List<string>                  {                      #region LanguageConsts                      LanguageConsts.TaskSubjectLabel'                      LanguageConsts.TaskStartDateLabel'                      LanguageConsts.TaskDueDateLabel'                      LanguageConsts.ImportanceLabel'                      LanguageConsts.TaskStatusLabel'                      LanguageConsts.TaskPercentageCompleteLabel'                      LanguageConsts.TaskEstimatedEffortLabel'                      LanguageConsts.TaskActualEffortLabel'                      LanguageConsts.TaskOwnerLabel'                      LanguageConsts.TaskContactsLabel'                      LanguageConsts.EmailCategoriesLabel'                      LanguageConsts.TaskCompanyLabel'                      LanguageConsts.TaskBillingInformationLabel'                      LanguageConsts.TaskMileageLabel                      #endregion                  };                    maxLength = languageConsts.Select(languageConst => languageConst.Length).Concat(new[] {0}).Max() + 2;              }
Magic Number,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgTask,The following statement contains a magic number: if (message.Task.PercentageComplete != null)                  WriteHeaderLine(taskHeader' htmlBody' maxLength' LanguageConsts.TaskPercentageCompleteLabel'                      (message.Task.PercentageComplete*100) + "%");
Magic Number,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteMsgContact,The following statement contains a magic number: if (!htmlBody)              {                  #region Language consts                  var languageConsts = new List<string>                  {                      LanguageConsts.DisplayNameLabel'                      LanguageConsts.SurNameLabel'                      LanguageConsts.GivenNameLabel'                      LanguageConsts.FunctionLabel'                      LanguageConsts.DepartmentLabel'                      LanguageConsts.CompanyLabel'                      LanguageConsts.WorkAddressLabel'                      LanguageConsts.BusinessTelephoneNumberLabel'                      LanguageConsts.BusinessTelephoneNumber2Label'                      LanguageConsts.BusinessFaxNumberLabel'                      LanguageConsts.HomeAddressLabel'                      LanguageConsts.HomeTelephoneNumberLabel'                      LanguageConsts.HomeTelephoneNumber2Label'                      LanguageConsts.HomeFaxNumberLabel'                      LanguageConsts.OtherAddressLabel'                      LanguageConsts.OtherFaxLabel'                      LanguageConsts.PrimaryTelephoneNumberLabel'                      LanguageConsts.PrimaryFaxNumberLabel'                      LanguageConsts.AssistantTelephoneNumberLabel'                      LanguageConsts.InstantMessagingAddressLabel'                      LanguageConsts.CompanyMainTelephoneNumberLabel'                      LanguageConsts.CellularTelephoneNumberLabel'                      LanguageConsts.CarTelephoneNumberLabel'                      LanguageConsts.RadioTelephoneNumberLabel'                      LanguageConsts.BeeperTelephoneNumberLabel'                      LanguageConsts.CallbackTelephoneNumberLabel'                      LanguageConsts.TextTelephoneLabel'                      LanguageConsts.ISDNNumberLabel'                      LanguageConsts.TelexNumberLabel'                      LanguageConsts.Email1EmailAddressLabel'                      LanguageConsts.Email1DisplayNameLabel'                      LanguageConsts.Email2EmailAddressLabel'                      LanguageConsts.Email2DisplayNameLabel'                      LanguageConsts.Email3EmailAddressLabel'                      LanguageConsts.Email3DisplayNameLabel'                      LanguageConsts.BirthdayLabel'                      LanguageConsts.WeddingAnniversaryLabel'                      LanguageConsts.SpouseNameLabel'                      LanguageConsts.ProfessionLabel'                      LanguageConsts.HtmlLabel                  };                  #endregion                    maxLength = languageConsts.Select(languageConst => languageConst.Length).Concat(new[] {0}).Max() + 2;              }
Magic Number,MsgReader.Rtf,ByteBuffer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\ByteBuffer.cs,Clear,The following statement contains a magic number: BsBuffer = new byte[ 16 ];
Magic Number,MsgReader.Rtf,ByteBuffer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\ByteBuffer.cs,FixBuffer,The following statement contains a magic number: if( newSize < (int)( BsBuffer.Length * 1.5 ))  				newSize = (int)( BsBuffer.Length * 1.5 );
Magic Number,MsgReader.Rtf,ByteBuffer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\ByteBuffer.cs,FixBuffer,The following statement contains a magic number: if( newSize < (int)( BsBuffer.Length * 1.5 ))  				newSize = (int)( BsBuffer.Length * 1.5 );
Magic Number,MsgReader.Rtf,ColorTable,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\ColorTable.cs,Add,The following statement contains a magic number: if (c.A != 255)                  c = Color.FromArgb(255' c);
Magic Number,MsgReader.Rtf,ColorTable,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\ColorTable.cs,Add,The following statement contains a magic number: if (c.A != 255)                  c = Color.FromArgb(255' c);
Magic Number,MsgReader.Rtf,ColorTable,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\ColorTable.cs,IndexOf,The following statement contains a magic number: if (c.A != 255)                  c = Color.FromArgb(255' c);
Magic Number,MsgReader.Rtf,ColorTable,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\ColorTable.cs,IndexOf,The following statement contains a magic number: if (c.A != 255)                  c = Color.FromArgb(255' c);
Magic Number,MsgReader.Rtf,DocumentFormatInfo,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentFormatInfo.cs,DocumentFormatInfo,The following statement contains a magic number: StandTabWidth = 100;
Magic Number,MsgReader.Rtf,DocumentFormatInfo,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentFormatInfo.cs,Reset,The following statement contains a magic number: FontSize = 12;
Magic Number,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteStartParagraph,The following statement contains a magic number: if (CollectionInfo)              {                  //myFontTable.Add("Wingdings");              }              else              {                  if (_firstParagraph)                  {                      _firstParagraph = false;                      Writer.WriteRaw(Environment.NewLine);                      //myWriter.WriteKeyword("par");                  }                  else                  {                      Writer.WriteKeyword("par");                  }                  if (info.ListId >= 0)                  {                      Writer.WriteKeyword("pard");                      Writer.WriteKeyword("ls" + info.ListId);                        if (_lastParagraphInfo != null)                      {                          if (_lastParagraphInfo.ListId >= 0)                          {                              Writer.WriteKeyword("pard");                          }                      }                  }                    switch (info.Align)                  {                      case RtfAlignment.Left:                          Writer.WriteKeyword("ql");                          break;                        case RtfAlignment.Center:                          Writer.WriteKeyword("qc");                          break;                                            case RtfAlignment.Right:                          Writer.WriteKeyword("qr");                          break;                                            case RtfAlignment.Justify:                          Writer.WriteKeyword("qj");                          break;                  }                    if (info.ParagraphFirstLineIndent != 0)                  {                      Writer.WriteKeyword("fi" + Convert.ToInt32(                          info.ParagraphFirstLineIndent*400/info.StandTabWidth));                  }                  else                      Writer.WriteKeyword("fi0");                    if (info.LeftIndent != 0)                  {                      Writer.WriteKeyword("li" + Convert.ToInt32(                          info.LeftIndent*400/info.StandTabWidth));                  }                  else                  {                      Writer.WriteKeyword("li0");                  }                  Writer.WriteKeyword("plain");              }
Magic Number,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteStartParagraph,The following statement contains a magic number: if (CollectionInfo)              {                  //myFontTable.Add("Wingdings");              }              else              {                  if (_firstParagraph)                  {                      _firstParagraph = false;                      Writer.WriteRaw(Environment.NewLine);                      //myWriter.WriteKeyword("par");                  }                  else                  {                      Writer.WriteKeyword("par");                  }                  if (info.ListId >= 0)                  {                      Writer.WriteKeyword("pard");                      Writer.WriteKeyword("ls" + info.ListId);                        if (_lastParagraphInfo != null)                      {                          if (_lastParagraphInfo.ListId >= 0)                          {                              Writer.WriteKeyword("pard");                          }                      }                  }                    switch (info.Align)                  {                      case RtfAlignment.Left:                          Writer.WriteKeyword("ql");                          break;                        case RtfAlignment.Center:                          Writer.WriteKeyword("qc");                          break;                                            case RtfAlignment.Right:                          Writer.WriteKeyword("qr");                          break;                                            case RtfAlignment.Justify:                          Writer.WriteKeyword("qj");                          break;                  }                    if (info.ParagraphFirstLineIndent != 0)                  {                      Writer.WriteKeyword("fi" + Convert.ToInt32(                          info.ParagraphFirstLineIndent*400/info.StandTabWidth));                  }                  else                      Writer.WriteKeyword("fi0");                    if (info.LeftIndent != 0)                  {                      Writer.WriteKeyword("li" + Convert.ToInt32(                          info.LeftIndent*400/info.StandTabWidth));                  }                  else                  {                      Writer.WriteKeyword("li0");                  }                  Writer.WriteKeyword("plain");              }
Magic Number,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteFont,The following statement contains a magic number: if (CollectionInfo)                  FontTable.Add(font.Name);              else              {                  var index = FontTable.IndexOf(font.Name);                                    if (index >= 0)                      Writer.WriteKeyword("f" + index);                                    if (font.Bold)                      Writer.WriteKeyword("b");                                    if (font.Italic)                      Writer.WriteKeyword("i");                                    if (font.Underline)                      Writer.WriteKeyword("ul");                                    if (font.Strikeout)                      Writer.WriteKeyword("strike");                                    Writer.WriteKeyword("fs" + Convert.ToInt32(font.Size*2));              }
Magic Number,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteStartString,The following statement contains a magic number: Writer.WriteKeyword("fs" + Convert.ToInt32(info.FontSize*2));
Magic Number,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteImage,The following statement contains a magic number: Writer.WriteKeyword("picscalex" + Convert.ToInt32(width*100.0/image.Size.Width));
Magic Number,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteImage,The following statement contains a magic number: Writer.WriteKeyword("picscaley" + Convert.ToInt32(height*100.0/image.Size.Height));
Magic Number,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteImage,The following statement contains a magic number: Writer.WriteKeyword("picwgoal" + Convert.ToString(image.Size.Width*15));
Magic Number,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteImage,The following statement contains a magic number: Writer.WriteKeyword("pichgoal" + Convert.ToString(image.Size.Height*15));
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,DomDocument,The following statement contains a magic number: DefaultRowHeight = 400;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,DomDocument,The following statement contains a magic number: FooterDistance = 720;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,DomDocument,The following statement contains a magic number: HeaderDistance = 720;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,DomDocument,The following statement contains a magic number: BottomMargin = 1440;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,DomDocument,The following statement contains a magic number: RightMargin = 1800;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,DomDocument,The following statement contains a magic number: TopMargin = 1440;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,DomDocument,The following statement contains a magic number: LeftMargin = 1800;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,DomDocument,The following statement contains a magic number: PaperHeight = 15840;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,DomDocument,The following statement contains a magic number: PaperWidth = 12240;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,Load,The following statement contains a magic number: while (reader.ReadToken() != null)  			{  				if (reader.TokenCount - _tokenCount > 100)  				{  					_tokenCount = reader.TokenCount;  					OnProgress(reader.ContentLength' reader.ContentPosition' null);  				}  				if (_startContent)  				{  					if (textContainer.Accept(reader.CurrentToken' reader))  					{  						textContainer.Level = reader.Level;  						continue;  					}  					if (textContainer.HasContent)  					{  						if (ApplyText(textContainer' reader' format))  							break;  					}  				}    				if (reader.TokenType == RtfTokenType.GroupEnd)  				{  					var elements = GetLastElements(true);  					for (var count = 0; count < elements.Length; count++)  					{  						var element = elements[count];  						if (element.NativeLevel >= 0 && element.NativeLevel > reader.Level)  						{  							for (var count2 = count; count2 < elements.Length; count2++)  								elements[count2].Locked = true;  							break;  						}  					}    					break;  				}    				if (reader.Level < levelBack)  					break;    				if (reader.TokenType == RtfTokenType.GroupStart)  				{  					Load(reader' format);  					if (reader.Level < levelBack)  						break;  				}    				if (reader.TokenType == RtfTokenType.Control  					|| reader.TokenType == RtfTokenType.Keyword  					|| reader.TokenType == RtfTokenType.ExtKeyword)  				{  					switch (reader.Keyword)  					{  						case Consts.FromHtml:  							// Extract html from rtf  							ReadHtmlContent(reader);  							return;    						#region Read document information  						case Consts.Listtable:  							ReadListTable(reader);  							return;    						case Consts.ListOverride:  							// Unknow keyword  							ReadToEndGround(reader);  							break;    						case Consts.Ansi:  							break;    						case Consts.Ansicpg:  							// Read default encoding  							_defaultEncoding = Encoding.GetEncoding(reader.Parameter);  							break;    						case Consts.Fonttbl:  							// Read font table  							ReadFontTable(reader);  							break;    						case Consts.ListOverrideTable:  							ReadListOverrideTable(reader);  							break;    						case Consts.FileTable:  							// Unsupport file list  							ReadToEndGround(reader);  							break; // Finish current level    						case Consts.Colortbl:  							// Read color table  							ReadColorTable(reader);  							return; // Finish current level    						case Consts.StyleSheet:  							// Unsupport style sheet list  							ReadToEndGround(reader);  							break;    						case Consts.Generator:  							// Read document generator  							Generator = ReadInnerText(reader' true);  							break;    						case Consts.Info:  							// Read document information  							ReadDocumentInfo(reader);  							return;    						case Consts.Headery:  							if (reader.HasParam)  								HeaderDistance = reader.Parameter;  							break;    						case Consts.Footery:  							if (reader.HasParam)  								FooterDistance = reader.Parameter;  							break;    						case Consts.Header:  							// Analyse header  							var header = new DomHeader { Style = RtfHeaderFooterStyle.AllPages };  							AppendChild(header);  							Load(reader' parentFormat);  							header.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Headerl:  							// Analyse header  							var header1 = new DomHeader { Style = RtfHeaderFooterStyle.LeftPages };  							AppendChild(header1);  							Load(reader' parentFormat);  							header1.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Headerr:  							// Analyse header  							var headerr = new DomHeader { Style = RtfHeaderFooterStyle.RightPages };  							AppendChild(headerr);  							Load(reader' parentFormat);  							headerr.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Headerf:  							// Analyse header  							var headerf = new DomHeader { Style = RtfHeaderFooterStyle.FirstPage };  							AppendChild(headerf);  							Load(reader' parentFormat);  							headerf.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Footer:  							// Analyse footer  							var footer = new DomFooter { Style = RtfHeaderFooterStyle.FirstPage };  							AppendChild(footer);  							Load(reader' parentFormat);  							footer.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Footerl:  							// analyse footer  							var footerl = new DomFooter { Style = RtfHeaderFooterStyle.LeftPages };  							AppendChild(footerl);  							Load(reader' parentFormat);  							footerl.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Footerr:  							// Analyse footer  							var footerr = new DomFooter { Style = RtfHeaderFooterStyle.RightPages };  							AppendChild(footerr);  							Load(reader' parentFormat);  							footerr.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Footerf:  							// analyse footer  							var footerf = new DomFooter { Style = RtfHeaderFooterStyle.FirstPage };  							AppendChild(footerf);  							Load(reader' parentFormat);  							footerf.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Xmlns:  							// Unsupport xml namespace  							ReadToEndGround(reader);  							break;    						case Consts.Nonesttables:  							// I support nest table ' then ignore this keyword  							ReadToEndGround(reader);  							break;    						case Consts.Xmlopen:  							// Unsupport xmlopen keyword  							break;    						case Consts.Revtbl:  							//ReadToEndGround(reader);  							break;  						#endregion    						#region Read document information  						case Consts.Paperw:  							// Read paper width  							PaperWidth = reader.Parameter;  							break;    						case Consts.Paperh:  							// Read paper height  							PaperHeight = reader.Parameter;  							break;    						case Consts.Margl:  							// Read left margin  							LeftMargin = reader.Parameter;  							break;    						case Consts.Margr:  							// Read right margin  							RightMargin = reader.Parameter;  							break;    						case Consts.Margb:  							// Read bottom margin  							BottomMargin = reader.Parameter;  							break;    						case Consts.Margt:  							// Read top margin   							TopMargin = reader.Parameter;  							break;    						case Consts.Landscape:  							// Set landscape  							Landscape = true;  							break;    						case Consts.Fchars:  							FollowingChars = ReadInnerText(reader' true);  							break;    						case Consts.Lchars:  							LeadingChars = ReadInnerText(reader' true);  							break;    						case "pnseclvl":  							// Ignore this keyword  							ReadToEndGround(reader);  							break;  						#endregion    						#region Read paragraph format  						case Consts.Pard:  							_startContent = true;  							if (forbitPard)  								continue;    							// Clear paragraph format  							_paragraphFormat.ResetParagraph();  							// Format.ResetParagraph();  							break;    						case Consts.Par:  							_startContent = true;  							// New paragraph  							if (GetLastElement(typeof(DomParagraph)) == null)  							{  								var paragraph = new DomParagraph { Format = _paragraphFormat };  								_paragraphFormat = _paragraphFormat.Clone();  								AddContentElement(paragraph);  								paragraph.Locked = true;  							}  							else  							{  								CompleteParagraph();  								var p = new DomParagraph { Format = _paragraphFormat };  								AddContentElement(p);  							}  							_startContent = true;  							break;    						case Consts.Page:  							_startContent = true;  							CompleteParagraph();  							AddContentElement(new DomPageBreak());  							break;    						case Consts.Pagebb:  							_startContent = true;  							_paragraphFormat.PageBreak = true;  							break;    						case Consts.Ql:  							// Left alignment  							_startContent = true;  							_paragraphFormat.Align = RtfAlignment.Left;  							break;    						case Consts.Qc:  							// Center alignment  							_startContent = true;  							_paragraphFormat.Align = RtfAlignment.Center;  							break;    						case Consts.Qr:  							// Right alignment  							_startContent = true;  							_paragraphFormat.Align = RtfAlignment.Right;  							break;    						case Consts.Qj:  							// Jusitify alignment  							_startContent = true;  							_paragraphFormat.Align = RtfAlignment.Justify;  							break;    						case Consts.Sl:  							// Line spacing  							_startContent = true;  							if (reader.Parameter >= 0)  								_paragraphFormat.LineSpacing = reader.Parameter;  							break;    						case Consts.Slmult:  							_startContent = true;  							_paragraphFormat.MultipleLineSpacing = (reader.Parameter == 1);  							break;    						case Consts.Sb:  							// Spacing before paragraph  							_startContent = true;  							_paragraphFormat.SpacingBefore = reader.Parameter;  							break;    						case Consts.Sa:  							// Spacing after paragraph  							_startContent = true;  							_paragraphFormat.SpacingAfter = reader.Parameter;  							break;    						case Consts.Fi:  							// Indent first line  							_startContent = true;  							_paragraphFormat.ParagraphFirstLineIndent = reader.Parameter;  							break;    						case Consts.Brdrw:  							_startContent = true;  							if (reader.HasParam)  								_paragraphFormat.BorderWidth = reader.Parameter;  							break;    						case Consts.Pn:  							_startContent = true;  							_paragraphFormat.ListId = -1;  							break;    						case Consts.Pntext:  							break;    						case Consts.Pntxtb:  							break;    						case Consts.Pntxta:  							break;    						case Consts.Pnlvlbody:  							_startContent = true;  							break;    						case Consts.Pnlvlblt:  							_startContent = true;  							break;    						case Consts.Listtext:  							_startContent = true;  							var text = ReadInnerText(reader' true);  							if (text != null)  							{  								text = text.Trim();  								_listTextFlag = text.StartsWith("l") ? 1 : 2;  							}  							break;    						case Consts.Ls:  							_startContent = true;  							_paragraphFormat.ListId = reader.Parameter;  							_listTextFlag = 0;  							break;    						case Consts.Li:  							_startContent = true;  							if (reader.HasParam)  								_paragraphFormat.LeftIndent = reader.Parameter;  							break;    						case Consts.Line:  							_startContent = true;  							if (format.ReadText)  							{  								var line = new DomLineBreak();  								line.NativeLevel = reader.Level;  								AddContentElement(line);  							}  							break;  						#endregion    						#region Read text format  						case Consts.Insrsid:  							break;    						case Consts.Plain:  							// Clear text format  							_startContent = true;  							format.ResetText();  							break;    						case Consts.F:  							// Font name  							_startContent = true;  							if (format.ReadText)  							{  								var fontName = FontTable.GetFontName(reader.Parameter);  								if (fontName != null)  									fontName = fontName.Trim();  								if (string.IsNullOrEmpty(fontName))  									fontName = DefaultFontName;    								if (ChangeTimesNewRoman)  								{  									if (fontName == "Times New Roman")  										fontName = DefaultFontName;  								}  								format.FontName = fontName;  							}  							_fontChartset = FontTable[reader.Parameter].Encoding;  							break;    						case Consts.Af:  							_associateFontChartset = FontTable[reader.Parameter].Encoding;  							break;    						case Consts.Fs:  							// Font size  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam)  									format.FontSize = reader.Parameter / 2.0f;  							}  							break;    						case Consts.Cf:  							// Font color  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam)  									format.TextColor = ColorTable.GetColor(reader.Parameter' Color.Black);  							}  							break;    						case Consts.Cb:  						case Consts.Chcbpat:  							// Background color  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam)  								{  									format.BackColor = ColorTable.GetColor(reader.Parameter' Color.Empty);  								}  							}  							break;    						case Consts.B:  							// Bold  							_startContent = true;  							if (format.ReadText)  								format.Bold = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.V:  							// Hidden text  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam && reader.Parameter == 0)  									format.Hidden = false;  								else  									format.Hidden = true;  							}  							break;    						case Consts.Highlight:  							// Highlight content  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam)  									format.BackColor = ColorTable.GetColor(  										reader.Parameter'  										Color.Empty);  							}  							break;    						case Consts.I:  							// Italic  							_startContent = true;  							if (format.ReadText)  								format.Italic = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Ul:  							// Under line  							_startContent = true;  							if (format.ReadText)  								format.Underline = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Strike:  							// Strikeout  							_startContent = true;  							if (format.ReadText)  								format.Strikeout = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Sub:  							// Subscript  							_startContent = true;  							if (format.ReadText)  								format.Subscript = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Super:  							// superscript  							_startContent = true;  							if (format.ReadText)  								format.Superscript = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Nosupersub:  							// nosupersub  							_startContent = true;  							format.Subscript = false;  							format.Superscript = false;  							break;    						case Consts.Brdrb:  							_startContent = true;  							//format.ParagraphBorder.Bottom = true;  							_paragraphFormat.BottomBorder = true;  							break;    						case Consts.Brdrl:  							_startContent = true;  							//format.ParagraphBorder.Left = true ;  							_paragraphFormat.LeftBorder = true;  							break;    						case Consts.Brdrr:  							_startContent = true;  							//format.ParagraphBorder.Right = true ;  							_paragraphFormat.RightBorder = true;  							break;    						case Consts.Brdrt:  							_startContent = true;  							//format.ParagraphBorder.Top = true;  							_paragraphFormat.BottomBorder = true;  							break;    						case Consts.Brdrcf:  							_startContent = true;  							var element = GetLastElement(typeof(DomTableRow)' false);  							if (element is DomTableRow)  							{  								// Reading a table row  								var row = (DomTableRow)element;  								if (row.CellSettings.Count > 0)  								{  									var style = (AttributeList)row.CellSettings[row.CellSettings.Count - 1];  									style.Add(reader.Keyword' reader.Parameter);  								}  							}  							else  							{  								_paragraphFormat.BorderColor = ColorTable.GetColor(reader.Parameter' Color.Black);  								format.BorderColor = format.BorderColor;  							}  							break;    						case Consts.Brdrs:  							_startContent = true;  							_paragraphFormat.BorderThickness = false;  							format.BorderThickness = false;  							break;    						case Consts.Brdrth:  							_startContent = true;  							_paragraphFormat.BorderThickness = true;  							format.BorderThickness = true;  							break;    						case Consts.Brdrdot:  							_startContent = true;  							_paragraphFormat.BorderStyle = DashStyle.Dot;  							format.BorderStyle = DashStyle.Dot;  							break;    						case Consts.Brdrdash:  							_startContent = true;  							_paragraphFormat.BorderStyle = DashStyle.Dash;  							format.BorderStyle = DashStyle.Dash;  							break;    						case Consts.Brdrdashd:  							_startContent = true;  							_paragraphFormat.BorderStyle = DashStyle.DashDot;  							format.BorderStyle = DashStyle.DashDot;  							break;    						case Consts.Brdrdashdd:  							_startContent = true;  							_paragraphFormat.BorderStyle = DashStyle.DashDotDot;  							format.BorderStyle = DashStyle.DashDotDot;  							break;    						case Consts.Brdrnil:  							_startContent = true;  							_paragraphFormat.LeftBorder = false;  							_paragraphFormat.TopBorder = false;  							_paragraphFormat.RightBorder = false;  							_paragraphFormat.BottomBorder = false;    							format.LeftBorder = false;  							format.TopBorder = false;  							format.RightBorder = false;  							format.BottomBorder = false;  							break;    						case Consts.Brsp:  							_startContent = true;  							if (reader.HasParam)  								_paragraphFormat.BorderSpacing = reader.Parameter;  							break;    						case Consts.Chbrdr:  							_startContent = true;  							format.LeftBorder = true;  							format.TopBorder = true;  							format.RightBorder = true;  							format.BottomBorder = true;  							break;    						case Consts.Bkmkstart:  							// Book mark  							_startContent = true;  							if (format.ReadText && _startContent)  							{  								var bk = new DomBookmark();  								bk.Name = ReadInnerText(reader' true);  								bk.Locked = true;  								AddContentElement(bk);  							}  							break;    						case Consts.Bkmkend:  							forbitPard = true;  							format.ReadText = false;  							break;    						case Consts.Field:  							// Field  							_startContent = true;  							ReadDomField(reader' format);  							return; // finish current level  									//break;  						#endregion    						#region Read object  						case Consts.Object:  							{  								// object  								_startContent = true;  								ReadDomObject(reader' format);  								return; // finish current level  							}  						#endregion    						#region Read image  						case Consts.Shppict:  							// Continue the following token  							break;    						case Consts.Nonshppict:  							// unsupport keyword  							ReadToEndGround(reader);  							break;    						case Consts.Pict:  							{  								// Read image data  								//ReadDomImage(reader' format);  								_startContent = true;  								var image = new DomImage();  								image.NativeLevel = reader.Level;  								AddContentElement(image);  								break;  							}    						case Consts.Picscalex:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.ScaleX = reader.Parameter;  								break;  							}    						case Consts.Picscaley:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.ScaleY = reader.Parameter;  								break;  							}    						case Consts.Picwgoal:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.DesiredWidth = reader.Parameter;  								break;  							}    						case Consts.Pichgoal:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.DesiredHeight = reader.Parameter;  								break;  							}    						case Consts.Blipuid:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.Id = ReadInnerText(reader' true);  								break;  							}    						case Consts.Emfblip:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Emfblip;  								break;  							}    						case Consts.Pngblip:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Pngblip;  								break;  							}    						case Consts.Jpegblip:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Jpegblip;  								break;  							}    						case Consts.Macpict:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Macpict;  								break;  							}    						case Consts.Pmmetafile:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Pmmetafile;  								break;  							}    						case Consts.Wmetafile:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Wmetafile;  								break;  							}    						case Consts.Dibitmap:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Dibitmap;  								break;  							}    						case Consts.Wbitmap:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Wbitmap;  								break;  							}  						#endregion    						#region Read shape  						case Consts.Sp:  							{  								// Begin read shape property  								var level = 0;  								string vName = null;  								string vValue = null;  								while (reader.ReadToken() != null)  								{  									if (reader.TokenType == RtfTokenType.GroupStart)  										level++;  									else if (reader.TokenType == RtfTokenType.GroupEnd)  									{  										level--;  										if (level < 0)  										{  											break;  										}  									}  									else switch (reader.Keyword)  										{  											case Consts.Sn:  												vName = ReadInnerText(reader' true);  												break;  											case Consts.Sv:  												vValue = ReadInnerText(reader' true);  												break;  										}  								}    								var shape = (DomShape)GetLastElement(typeof(DomShape));    								if (shape != null)  									shape.ExtAttrbutes[vName] = vValue;  								else  								{  									var g = (DomShapeGroup)GetLastElement(typeof(DomShapeGroup));  									if (g != null)  									{  										g.ExtAttrbutes[vName] = vValue;  									}  								}  								break;  							}    						case Consts.Shptxt:  							// handle following token  							break;    						case Consts.Shprslt:  							// ignore this level  							ReadToEndGround(reader);  							break;    						case Consts.Shp:  							{  								_startContent = true;  								var shape = new DomShape();  								shape.NativeLevel = reader.Level;  								AddContentElement(shape);  								break;  							}  						case Consts.Shpleft:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Left = reader.Parameter;  								break;  							}    						case Consts.Shptop:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Top = reader.Parameter;  								break;  							}    						case Consts.Shpright:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Width = reader.Parameter - shape.Left;  								break;  							}    						case Consts.Shpbottom:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Height = reader.Parameter - shape.Top;  								break;  							}    						case Consts.Shplid:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Id = reader.Parameter;  								break;  							}    						case Consts.Shpz:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.ZIndex = reader.Parameter;  								break;  							}    						case Consts.Shpgrp:  							{  								var group = new DomShapeGroup();  								group.NativeLevel = reader.Level;  								AddContentElement(group);  								break;  							}    						case Consts.Shpinst:  							break;  						#endregion    						#region Read table  						case Consts.Intbl:  						case Consts.Trowd:  						case Consts.Itap:  							{  								// These keyword said than current paragraph is a table row  								_startContent = true;  								var es = GetLastElements(true);  								DomElement lastUnlockElement = null;  								DomElement lastTableElement = null;  								for (var count = es.Length - 1; count >= 0; count--)  								{  									var e = es[count];  									if (e.Locked == false)  									{  										if (lastUnlockElement == null && !(e is DomParagraph))  											lastUnlockElement = e;  										if (e is DomTableRow || e is DomTableCell)  											lastTableElement = e;  										break;  									}  								}    								if (reader.Keyword == Consts.Intbl)  								{  									if (lastTableElement == null)  									{  										// if can not find unlocked row   										// then new row  										var row = new DomTableRow { NativeLevel = reader.Level };  										if (lastUnlockElement != null)  											lastUnlockElement.AppendChild(row);  									}  								}  								else if (reader.Keyword == Consts.Trowd)  								{  									// clear row format  									DomTableRow row;  									if (lastTableElement == null)  									{  										row = new DomTableRow { NativeLevel = reader.Level };  										if (lastUnlockElement != null)  											lastUnlockElement.AppendChild(row);  									}  									else  									{  										row = lastTableElement as DomTableRow ?? (DomTableRow)lastTableElement.Parent;  									}  									row.Attributes.Clear();  									row.CellSettings.Clear();  									_paragraphFormat.ResetParagraph();  								}  								else if (reader.Keyword == Consts.Itap)  								{  									// set nested level    									if (reader.Parameter == 0)  									{  										// is the 0 level ' belong to document ' not to a table  										//foreach (RTFDomElement element in es)  										//{  										//    if (element is RTFDomTableRow || element is RTFDomTableCell)  										//    {  										//        element.Locked = true;  										//    }  										//}  									}  									else  									{  										// in a row  										DomTableRow row;  										if (lastTableElement == null)  										{  											row = new DomTableRow { NativeLevel = reader.Level };  											if (lastUnlockElement != null)  												lastUnlockElement.AppendChild(row);  										}  										else  											row = lastTableElement as DomTableRow ?? (DomTableRow)lastTableElement.Parent;  										if (reader.Parameter == row.Level)  										{  										}  										else if (reader.Parameter > row.Level)  										{  											// nested row  											var newRow = new DomTableRow { Level = reader.Parameter };  											var parentCell = (DomTableCell)GetLastElement(typeof(DomTableCell)' false);  											if (parentCell == null)  												AddContentElement(newRow);  											else  												parentCell.AppendChild(newRow);  										}  										else if (reader.Parameter < row.Level)  										{  											// exit nested row  										}  									}  								}  								break;  							}    						case Consts.Nesttableprops:  							// ignore  							break;    						case Consts.Row:  							{  								// finish read row  								_startContent = true;  								var es = GetLastElements(true);  								for (var count = es.Length - 1; count >= 0; count--)  								{  									es[count].Locked = true;  									if (es[count] is DomTableRow)  										break;  								}  								break;  							}    						case Consts.Nestrow:  							{  								// finish nested row  								_startContent = true;  								var es = GetLastElements(true);  								for (var count = es.Length - 1; count >= 0; count--)  								{  									es[count].Locked = true;  									if (es[count] is DomTableRow)  										break;  								}  								break;  							}    						case Consts.Trrh:  						case Consts.Trautofit:  						case Consts.Irowband:  						case Consts.Trhdr:  						case Consts.Trkeep:  						case Consts.Trkeepfollow:  						case Consts.Trleft:  						case Consts.Trqc:  						case Consts.Trql:  						case Consts.Trqr:  						case Consts.Trcbpat:  						case Consts.Trcfpat:  						case Consts.Trpat:  						case Consts.Trshdng:  						case Consts.TrwWidth:  						case Consts.TrwWidthA:  						case Consts.Irow:  						case Consts.Trpaddb:  						case Consts.Trpaddl:  						case Consts.Trpaddr:  						case Consts.Trpaddt:  						case Consts.Trpaddfb:  						case Consts.Trpaddfl:  						case Consts.Trpaddfr:  						case Consts.Trpaddft:  						case Consts.Lastrow:  							{  								// meet row control word ' not parse at first ' just save it   								_startContent = true;  								var row = (DomTableRow)GetLastElement(typeof(DomTableRow)' false);  								if (row != null)  								{  									row.Attributes.Add(reader.Keyword' reader.Parameter);  								}  								break;  							}    						case Consts.Clvmgf:  						case Consts.Clvmrg:  						case Consts.Cellx:  						case Consts.Clvertalt:  						case Consts.Clvertalc:  						case Consts.Clvertalb:  						case Consts.ClNoWrap:  						case Consts.Clcbpat:  						case Consts.Clcfpat:  						case Consts.Clpadl:  						case Consts.Clpadt:  						case Consts.Clpadr:  						case Consts.Clpadb:  						case Consts.Clbrdrl:  						case Consts.Clbrdrt:  						case Consts.Clbrdrr:  						case Consts.Clbrdrb:  						case Consts.Brdrtbl:  						case Consts.Brdrnone:  							{  								// Meet cell control word ' no parse at first ' just save it  								var row = (DomTableRow)GetLastElement(typeof(DomTableRow)' false);  								if (row == null) break;  								_startContent = true;  								AttributeList style = null;  								if (row.CellSettings.Count > 0)  								{  									style = (AttributeList)row.CellSettings[row.CellSettings.Count - 1];  									if (style.Contains(Consts.Cellx))  									{  										// if find repeat control word ' then can consider this control word  										// belong to the next cell . userly cellx is the last control word of   										// a cell ' when meet cellx ' the current cell defind is finished.  										style = new AttributeList();  										row.CellSettings.Add(style);  									}  								}  								if (style == null)  								{  									style = new AttributeList();  									row.CellSettings.Add(style);  								}  								style.Add(reader.Keyword' reader.Parameter);  								break;  							}    						case Consts.Cell:  							{  								// finish cell content  								_startContent = true;  								AddContentElement(null);  								CompleteParagraph();  								_paragraphFormat.Reset();  								format.Reset();  								var es = GetLastElements(true);  								for (var count = es.Length - 1; count >= 0; count--)  								{  									if (es[count].Locked == false)  									{  										es[count].Locked = true;  										if (es[count] is DomTableCell)  											break;  									}  								}  								break;  							}    						case Consts.Nestcell:  							{  								// finish nested cell content  								_startContent = true;  								AddContentElement(null);  								CompleteParagraph();  								var es = GetLastElements(false);  								for (var count = es.Length - 1; count >= 0; count--)  								{  									es[count].Locked = true;  									if (es[count] is DomTableCell)  									{  										((DomTableCell)es[count]).Format = format;  										break;  									}  								}  								break;  							}  						#endregion    						default:  							// Unsupport keyword  							if (reader.TokenType == RtfTokenType.ExtKeyword && reader.FirstTokenInGroup)  							{  								// if meet unsupport extern keyword ' and this token is the first token in   								// current group ' then ingore whole group.  								ReadToEndGround(reader);  							}  							break;  					}  				}  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,Load,The following statement contains a magic number: while (reader.ReadToken() != null)  			{  				if (reader.TokenCount - _tokenCount > 100)  				{  					_tokenCount = reader.TokenCount;  					OnProgress(reader.ContentLength' reader.ContentPosition' null);  				}  				if (_startContent)  				{  					if (textContainer.Accept(reader.CurrentToken' reader))  					{  						textContainer.Level = reader.Level;  						continue;  					}  					if (textContainer.HasContent)  					{  						if (ApplyText(textContainer' reader' format))  							break;  					}  				}    				if (reader.TokenType == RtfTokenType.GroupEnd)  				{  					var elements = GetLastElements(true);  					for (var count = 0; count < elements.Length; count++)  					{  						var element = elements[count];  						if (element.NativeLevel >= 0 && element.NativeLevel > reader.Level)  						{  							for (var count2 = count; count2 < elements.Length; count2++)  								elements[count2].Locked = true;  							break;  						}  					}    					break;  				}    				if (reader.Level < levelBack)  					break;    				if (reader.TokenType == RtfTokenType.GroupStart)  				{  					Load(reader' format);  					if (reader.Level < levelBack)  						break;  				}    				if (reader.TokenType == RtfTokenType.Control  					|| reader.TokenType == RtfTokenType.Keyword  					|| reader.TokenType == RtfTokenType.ExtKeyword)  				{  					switch (reader.Keyword)  					{  						case Consts.FromHtml:  							// Extract html from rtf  							ReadHtmlContent(reader);  							return;    						#region Read document information  						case Consts.Listtable:  							ReadListTable(reader);  							return;    						case Consts.ListOverride:  							// Unknow keyword  							ReadToEndGround(reader);  							break;    						case Consts.Ansi:  							break;    						case Consts.Ansicpg:  							// Read default encoding  							_defaultEncoding = Encoding.GetEncoding(reader.Parameter);  							break;    						case Consts.Fonttbl:  							// Read font table  							ReadFontTable(reader);  							break;    						case Consts.ListOverrideTable:  							ReadListOverrideTable(reader);  							break;    						case Consts.FileTable:  							// Unsupport file list  							ReadToEndGround(reader);  							break; // Finish current level    						case Consts.Colortbl:  							// Read color table  							ReadColorTable(reader);  							return; // Finish current level    						case Consts.StyleSheet:  							// Unsupport style sheet list  							ReadToEndGround(reader);  							break;    						case Consts.Generator:  							// Read document generator  							Generator = ReadInnerText(reader' true);  							break;    						case Consts.Info:  							// Read document information  							ReadDocumentInfo(reader);  							return;    						case Consts.Headery:  							if (reader.HasParam)  								HeaderDistance = reader.Parameter;  							break;    						case Consts.Footery:  							if (reader.HasParam)  								FooterDistance = reader.Parameter;  							break;    						case Consts.Header:  							// Analyse header  							var header = new DomHeader { Style = RtfHeaderFooterStyle.AllPages };  							AppendChild(header);  							Load(reader' parentFormat);  							header.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Headerl:  							// Analyse header  							var header1 = new DomHeader { Style = RtfHeaderFooterStyle.LeftPages };  							AppendChild(header1);  							Load(reader' parentFormat);  							header1.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Headerr:  							// Analyse header  							var headerr = new DomHeader { Style = RtfHeaderFooterStyle.RightPages };  							AppendChild(headerr);  							Load(reader' parentFormat);  							headerr.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Headerf:  							// Analyse header  							var headerf = new DomHeader { Style = RtfHeaderFooterStyle.FirstPage };  							AppendChild(headerf);  							Load(reader' parentFormat);  							headerf.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Footer:  							// Analyse footer  							var footer = new DomFooter { Style = RtfHeaderFooterStyle.FirstPage };  							AppendChild(footer);  							Load(reader' parentFormat);  							footer.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Footerl:  							// analyse footer  							var footerl = new DomFooter { Style = RtfHeaderFooterStyle.LeftPages };  							AppendChild(footerl);  							Load(reader' parentFormat);  							footerl.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Footerr:  							// Analyse footer  							var footerr = new DomFooter { Style = RtfHeaderFooterStyle.RightPages };  							AppendChild(footerr);  							Load(reader' parentFormat);  							footerr.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Footerf:  							// analyse footer  							var footerf = new DomFooter { Style = RtfHeaderFooterStyle.FirstPage };  							AppendChild(footerf);  							Load(reader' parentFormat);  							footerf.Locked = true;  							_paragraphFormat = new DocumentFormatInfo();  							break;    						case Consts.Xmlns:  							// Unsupport xml namespace  							ReadToEndGround(reader);  							break;    						case Consts.Nonesttables:  							// I support nest table ' then ignore this keyword  							ReadToEndGround(reader);  							break;    						case Consts.Xmlopen:  							// Unsupport xmlopen keyword  							break;    						case Consts.Revtbl:  							//ReadToEndGround(reader);  							break;  						#endregion    						#region Read document information  						case Consts.Paperw:  							// Read paper width  							PaperWidth = reader.Parameter;  							break;    						case Consts.Paperh:  							// Read paper height  							PaperHeight = reader.Parameter;  							break;    						case Consts.Margl:  							// Read left margin  							LeftMargin = reader.Parameter;  							break;    						case Consts.Margr:  							// Read right margin  							RightMargin = reader.Parameter;  							break;    						case Consts.Margb:  							// Read bottom margin  							BottomMargin = reader.Parameter;  							break;    						case Consts.Margt:  							// Read top margin   							TopMargin = reader.Parameter;  							break;    						case Consts.Landscape:  							// Set landscape  							Landscape = true;  							break;    						case Consts.Fchars:  							FollowingChars = ReadInnerText(reader' true);  							break;    						case Consts.Lchars:  							LeadingChars = ReadInnerText(reader' true);  							break;    						case "pnseclvl":  							// Ignore this keyword  							ReadToEndGround(reader);  							break;  						#endregion    						#region Read paragraph format  						case Consts.Pard:  							_startContent = true;  							if (forbitPard)  								continue;    							// Clear paragraph format  							_paragraphFormat.ResetParagraph();  							// Format.ResetParagraph();  							break;    						case Consts.Par:  							_startContent = true;  							// New paragraph  							if (GetLastElement(typeof(DomParagraph)) == null)  							{  								var paragraph = new DomParagraph { Format = _paragraphFormat };  								_paragraphFormat = _paragraphFormat.Clone();  								AddContentElement(paragraph);  								paragraph.Locked = true;  							}  							else  							{  								CompleteParagraph();  								var p = new DomParagraph { Format = _paragraphFormat };  								AddContentElement(p);  							}  							_startContent = true;  							break;    						case Consts.Page:  							_startContent = true;  							CompleteParagraph();  							AddContentElement(new DomPageBreak());  							break;    						case Consts.Pagebb:  							_startContent = true;  							_paragraphFormat.PageBreak = true;  							break;    						case Consts.Ql:  							// Left alignment  							_startContent = true;  							_paragraphFormat.Align = RtfAlignment.Left;  							break;    						case Consts.Qc:  							// Center alignment  							_startContent = true;  							_paragraphFormat.Align = RtfAlignment.Center;  							break;    						case Consts.Qr:  							// Right alignment  							_startContent = true;  							_paragraphFormat.Align = RtfAlignment.Right;  							break;    						case Consts.Qj:  							// Jusitify alignment  							_startContent = true;  							_paragraphFormat.Align = RtfAlignment.Justify;  							break;    						case Consts.Sl:  							// Line spacing  							_startContent = true;  							if (reader.Parameter >= 0)  								_paragraphFormat.LineSpacing = reader.Parameter;  							break;    						case Consts.Slmult:  							_startContent = true;  							_paragraphFormat.MultipleLineSpacing = (reader.Parameter == 1);  							break;    						case Consts.Sb:  							// Spacing before paragraph  							_startContent = true;  							_paragraphFormat.SpacingBefore = reader.Parameter;  							break;    						case Consts.Sa:  							// Spacing after paragraph  							_startContent = true;  							_paragraphFormat.SpacingAfter = reader.Parameter;  							break;    						case Consts.Fi:  							// Indent first line  							_startContent = true;  							_paragraphFormat.ParagraphFirstLineIndent = reader.Parameter;  							break;    						case Consts.Brdrw:  							_startContent = true;  							if (reader.HasParam)  								_paragraphFormat.BorderWidth = reader.Parameter;  							break;    						case Consts.Pn:  							_startContent = true;  							_paragraphFormat.ListId = -1;  							break;    						case Consts.Pntext:  							break;    						case Consts.Pntxtb:  							break;    						case Consts.Pntxta:  							break;    						case Consts.Pnlvlbody:  							_startContent = true;  							break;    						case Consts.Pnlvlblt:  							_startContent = true;  							break;    						case Consts.Listtext:  							_startContent = true;  							var text = ReadInnerText(reader' true);  							if (text != null)  							{  								text = text.Trim();  								_listTextFlag = text.StartsWith("l") ? 1 : 2;  							}  							break;    						case Consts.Ls:  							_startContent = true;  							_paragraphFormat.ListId = reader.Parameter;  							_listTextFlag = 0;  							break;    						case Consts.Li:  							_startContent = true;  							if (reader.HasParam)  								_paragraphFormat.LeftIndent = reader.Parameter;  							break;    						case Consts.Line:  							_startContent = true;  							if (format.ReadText)  							{  								var line = new DomLineBreak();  								line.NativeLevel = reader.Level;  								AddContentElement(line);  							}  							break;  						#endregion    						#region Read text format  						case Consts.Insrsid:  							break;    						case Consts.Plain:  							// Clear text format  							_startContent = true;  							format.ResetText();  							break;    						case Consts.F:  							// Font name  							_startContent = true;  							if (format.ReadText)  							{  								var fontName = FontTable.GetFontName(reader.Parameter);  								if (fontName != null)  									fontName = fontName.Trim();  								if (string.IsNullOrEmpty(fontName))  									fontName = DefaultFontName;    								if (ChangeTimesNewRoman)  								{  									if (fontName == "Times New Roman")  										fontName = DefaultFontName;  								}  								format.FontName = fontName;  							}  							_fontChartset = FontTable[reader.Parameter].Encoding;  							break;    						case Consts.Af:  							_associateFontChartset = FontTable[reader.Parameter].Encoding;  							break;    						case Consts.Fs:  							// Font size  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam)  									format.FontSize = reader.Parameter / 2.0f;  							}  							break;    						case Consts.Cf:  							// Font color  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam)  									format.TextColor = ColorTable.GetColor(reader.Parameter' Color.Black);  							}  							break;    						case Consts.Cb:  						case Consts.Chcbpat:  							// Background color  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam)  								{  									format.BackColor = ColorTable.GetColor(reader.Parameter' Color.Empty);  								}  							}  							break;    						case Consts.B:  							// Bold  							_startContent = true;  							if (format.ReadText)  								format.Bold = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.V:  							// Hidden text  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam && reader.Parameter == 0)  									format.Hidden = false;  								else  									format.Hidden = true;  							}  							break;    						case Consts.Highlight:  							// Highlight content  							_startContent = true;  							if (format.ReadText)  							{  								if (reader.HasParam)  									format.BackColor = ColorTable.GetColor(  										reader.Parameter'  										Color.Empty);  							}  							break;    						case Consts.I:  							// Italic  							_startContent = true;  							if (format.ReadText)  								format.Italic = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Ul:  							// Under line  							_startContent = true;  							if (format.ReadText)  								format.Underline = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Strike:  							// Strikeout  							_startContent = true;  							if (format.ReadText)  								format.Strikeout = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Sub:  							// Subscript  							_startContent = true;  							if (format.ReadText)  								format.Subscript = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Super:  							// superscript  							_startContent = true;  							if (format.ReadText)  								format.Superscript = (reader.HasParam == false || reader.Parameter != 0);  							break;    						case Consts.Nosupersub:  							// nosupersub  							_startContent = true;  							format.Subscript = false;  							format.Superscript = false;  							break;    						case Consts.Brdrb:  							_startContent = true;  							//format.ParagraphBorder.Bottom = true;  							_paragraphFormat.BottomBorder = true;  							break;    						case Consts.Brdrl:  							_startContent = true;  							//format.ParagraphBorder.Left = true ;  							_paragraphFormat.LeftBorder = true;  							break;    						case Consts.Brdrr:  							_startContent = true;  							//format.ParagraphBorder.Right = true ;  							_paragraphFormat.RightBorder = true;  							break;    						case Consts.Brdrt:  							_startContent = true;  							//format.ParagraphBorder.Top = true;  							_paragraphFormat.BottomBorder = true;  							break;    						case Consts.Brdrcf:  							_startContent = true;  							var element = GetLastElement(typeof(DomTableRow)' false);  							if (element is DomTableRow)  							{  								// Reading a table row  								var row = (DomTableRow)element;  								if (row.CellSettings.Count > 0)  								{  									var style = (AttributeList)row.CellSettings[row.CellSettings.Count - 1];  									style.Add(reader.Keyword' reader.Parameter);  								}  							}  							else  							{  								_paragraphFormat.BorderColor = ColorTable.GetColor(reader.Parameter' Color.Black);  								format.BorderColor = format.BorderColor;  							}  							break;    						case Consts.Brdrs:  							_startContent = true;  							_paragraphFormat.BorderThickness = false;  							format.BorderThickness = false;  							break;    						case Consts.Brdrth:  							_startContent = true;  							_paragraphFormat.BorderThickness = true;  							format.BorderThickness = true;  							break;    						case Consts.Brdrdot:  							_startContent = true;  							_paragraphFormat.BorderStyle = DashStyle.Dot;  							format.BorderStyle = DashStyle.Dot;  							break;    						case Consts.Brdrdash:  							_startContent = true;  							_paragraphFormat.BorderStyle = DashStyle.Dash;  							format.BorderStyle = DashStyle.Dash;  							break;    						case Consts.Brdrdashd:  							_startContent = true;  							_paragraphFormat.BorderStyle = DashStyle.DashDot;  							format.BorderStyle = DashStyle.DashDot;  							break;    						case Consts.Brdrdashdd:  							_startContent = true;  							_paragraphFormat.BorderStyle = DashStyle.DashDotDot;  							format.BorderStyle = DashStyle.DashDotDot;  							break;    						case Consts.Brdrnil:  							_startContent = true;  							_paragraphFormat.LeftBorder = false;  							_paragraphFormat.TopBorder = false;  							_paragraphFormat.RightBorder = false;  							_paragraphFormat.BottomBorder = false;    							format.LeftBorder = false;  							format.TopBorder = false;  							format.RightBorder = false;  							format.BottomBorder = false;  							break;    						case Consts.Brsp:  							_startContent = true;  							if (reader.HasParam)  								_paragraphFormat.BorderSpacing = reader.Parameter;  							break;    						case Consts.Chbrdr:  							_startContent = true;  							format.LeftBorder = true;  							format.TopBorder = true;  							format.RightBorder = true;  							format.BottomBorder = true;  							break;    						case Consts.Bkmkstart:  							// Book mark  							_startContent = true;  							if (format.ReadText && _startContent)  							{  								var bk = new DomBookmark();  								bk.Name = ReadInnerText(reader' true);  								bk.Locked = true;  								AddContentElement(bk);  							}  							break;    						case Consts.Bkmkend:  							forbitPard = true;  							format.ReadText = false;  							break;    						case Consts.Field:  							// Field  							_startContent = true;  							ReadDomField(reader' format);  							return; // finish current level  									//break;  						#endregion    						#region Read object  						case Consts.Object:  							{  								// object  								_startContent = true;  								ReadDomObject(reader' format);  								return; // finish current level  							}  						#endregion    						#region Read image  						case Consts.Shppict:  							// Continue the following token  							break;    						case Consts.Nonshppict:  							// unsupport keyword  							ReadToEndGround(reader);  							break;    						case Consts.Pict:  							{  								// Read image data  								//ReadDomImage(reader' format);  								_startContent = true;  								var image = new DomImage();  								image.NativeLevel = reader.Level;  								AddContentElement(image);  								break;  							}    						case Consts.Picscalex:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.ScaleX = reader.Parameter;  								break;  							}    						case Consts.Picscaley:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.ScaleY = reader.Parameter;  								break;  							}    						case Consts.Picwgoal:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.DesiredWidth = reader.Parameter;  								break;  							}    						case Consts.Pichgoal:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.DesiredHeight = reader.Parameter;  								break;  							}    						case Consts.Blipuid:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.Id = ReadInnerText(reader' true);  								break;  							}    						case Consts.Emfblip:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Emfblip;  								break;  							}    						case Consts.Pngblip:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Pngblip;  								break;  							}    						case Consts.Jpegblip:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Jpegblip;  								break;  							}    						case Consts.Macpict:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Macpict;  								break;  							}    						case Consts.Pmmetafile:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Pmmetafile;  								break;  							}    						case Consts.Wmetafile:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Wmetafile;  								break;  							}    						case Consts.Dibitmap:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Dibitmap;  								break;  							}    						case Consts.Wbitmap:  							{  								var image = (DomImage)GetLastElement(typeof(DomImage));  								if (image != null)  									image.PicType = RtfPictureType.Wbitmap;  								break;  							}  						#endregion    						#region Read shape  						case Consts.Sp:  							{  								// Begin read shape property  								var level = 0;  								string vName = null;  								string vValue = null;  								while (reader.ReadToken() != null)  								{  									if (reader.TokenType == RtfTokenType.GroupStart)  										level++;  									else if (reader.TokenType == RtfTokenType.GroupEnd)  									{  										level--;  										if (level < 0)  										{  											break;  										}  									}  									else switch (reader.Keyword)  										{  											case Consts.Sn:  												vName = ReadInnerText(reader' true);  												break;  											case Consts.Sv:  												vValue = ReadInnerText(reader' true);  												break;  										}  								}    								var shape = (DomShape)GetLastElement(typeof(DomShape));    								if (shape != null)  									shape.ExtAttrbutes[vName] = vValue;  								else  								{  									var g = (DomShapeGroup)GetLastElement(typeof(DomShapeGroup));  									if (g != null)  									{  										g.ExtAttrbutes[vName] = vValue;  									}  								}  								break;  							}    						case Consts.Shptxt:  							// handle following token  							break;    						case Consts.Shprslt:  							// ignore this level  							ReadToEndGround(reader);  							break;    						case Consts.Shp:  							{  								_startContent = true;  								var shape = new DomShape();  								shape.NativeLevel = reader.Level;  								AddContentElement(shape);  								break;  							}  						case Consts.Shpleft:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Left = reader.Parameter;  								break;  							}    						case Consts.Shptop:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Top = reader.Parameter;  								break;  							}    						case Consts.Shpright:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Width = reader.Parameter - shape.Left;  								break;  							}    						case Consts.Shpbottom:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Height = reader.Parameter - shape.Top;  								break;  							}    						case Consts.Shplid:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.Id = reader.Parameter;  								break;  							}    						case Consts.Shpz:  							{  								var shape = (DomShape)GetLastElement(typeof(DomShape));  								if (shape != null)  									shape.ZIndex = reader.Parameter;  								break;  							}    						case Consts.Shpgrp:  							{  								var group = new DomShapeGroup();  								group.NativeLevel = reader.Level;  								AddContentElement(group);  								break;  							}    						case Consts.Shpinst:  							break;  						#endregion    						#region Read table  						case Consts.Intbl:  						case Consts.Trowd:  						case Consts.Itap:  							{  								// These keyword said than current paragraph is a table row  								_startContent = true;  								var es = GetLastElements(true);  								DomElement lastUnlockElement = null;  								DomElement lastTableElement = null;  								for (var count = es.Length - 1; count >= 0; count--)  								{  									var e = es[count];  									if (e.Locked == false)  									{  										if (lastUnlockElement == null && !(e is DomParagraph))  											lastUnlockElement = e;  										if (e is DomTableRow || e is DomTableCell)  											lastTableElement = e;  										break;  									}  								}    								if (reader.Keyword == Consts.Intbl)  								{  									if (lastTableElement == null)  									{  										// if can not find unlocked row   										// then new row  										var row = new DomTableRow { NativeLevel = reader.Level };  										if (lastUnlockElement != null)  											lastUnlockElement.AppendChild(row);  									}  								}  								else if (reader.Keyword == Consts.Trowd)  								{  									// clear row format  									DomTableRow row;  									if (lastTableElement == null)  									{  										row = new DomTableRow { NativeLevel = reader.Level };  										if (lastUnlockElement != null)  											lastUnlockElement.AppendChild(row);  									}  									else  									{  										row = lastTableElement as DomTableRow ?? (DomTableRow)lastTableElement.Parent;  									}  									row.Attributes.Clear();  									row.CellSettings.Clear();  									_paragraphFormat.ResetParagraph();  								}  								else if (reader.Keyword == Consts.Itap)  								{  									// set nested level    									if (reader.Parameter == 0)  									{  										// is the 0 level ' belong to document ' not to a table  										//foreach (RTFDomElement element in es)  										//{  										//    if (element is RTFDomTableRow || element is RTFDomTableCell)  										//    {  										//        element.Locked = true;  										//    }  										//}  									}  									else  									{  										// in a row  										DomTableRow row;  										if (lastTableElement == null)  										{  											row = new DomTableRow { NativeLevel = reader.Level };  											if (lastUnlockElement != null)  												lastUnlockElement.AppendChild(row);  										}  										else  											row = lastTableElement as DomTableRow ?? (DomTableRow)lastTableElement.Parent;  										if (reader.Parameter == row.Level)  										{  										}  										else if (reader.Parameter > row.Level)  										{  											// nested row  											var newRow = new DomTableRow { Level = reader.Parameter };  											var parentCell = (DomTableCell)GetLastElement(typeof(DomTableCell)' false);  											if (parentCell == null)  												AddContentElement(newRow);  											else  												parentCell.AppendChild(newRow);  										}  										else if (reader.Parameter < row.Level)  										{  											// exit nested row  										}  									}  								}  								break;  							}    						case Consts.Nesttableprops:  							// ignore  							break;    						case Consts.Row:  							{  								// finish read row  								_startContent = true;  								var es = GetLastElements(true);  								for (var count = es.Length - 1; count >= 0; count--)  								{  									es[count].Locked = true;  									if (es[count] is DomTableRow)  										break;  								}  								break;  							}    						case Consts.Nestrow:  							{  								// finish nested row  								_startContent = true;  								var es = GetLastElements(true);  								for (var count = es.Length - 1; count >= 0; count--)  								{  									es[count].Locked = true;  									if (es[count] is DomTableRow)  										break;  								}  								break;  							}    						case Consts.Trrh:  						case Consts.Trautofit:  						case Consts.Irowband:  						case Consts.Trhdr:  						case Consts.Trkeep:  						case Consts.Trkeepfollow:  						case Consts.Trleft:  						case Consts.Trqc:  						case Consts.Trql:  						case Consts.Trqr:  						case Consts.Trcbpat:  						case Consts.Trcfpat:  						case Consts.Trpat:  						case Consts.Trshdng:  						case Consts.TrwWidth:  						case Consts.TrwWidthA:  						case Consts.Irow:  						case Consts.Trpaddb:  						case Consts.Trpaddl:  						case Consts.Trpaddr:  						case Consts.Trpaddt:  						case Consts.Trpaddfb:  						case Consts.Trpaddfl:  						case Consts.Trpaddfr:  						case Consts.Trpaddft:  						case Consts.Lastrow:  							{  								// meet row control word ' not parse at first ' just save it   								_startContent = true;  								var row = (DomTableRow)GetLastElement(typeof(DomTableRow)' false);  								if (row != null)  								{  									row.Attributes.Add(reader.Keyword' reader.Parameter);  								}  								break;  							}    						case Consts.Clvmgf:  						case Consts.Clvmrg:  						case Consts.Cellx:  						case Consts.Clvertalt:  						case Consts.Clvertalc:  						case Consts.Clvertalb:  						case Consts.ClNoWrap:  						case Consts.Clcbpat:  						case Consts.Clcfpat:  						case Consts.Clpadl:  						case Consts.Clpadt:  						case Consts.Clpadr:  						case Consts.Clpadb:  						case Consts.Clbrdrl:  						case Consts.Clbrdrt:  						case Consts.Clbrdrr:  						case Consts.Clbrdrb:  						case Consts.Brdrtbl:  						case Consts.Brdrnone:  							{  								// Meet cell control word ' no parse at first ' just save it  								var row = (DomTableRow)GetLastElement(typeof(DomTableRow)' false);  								if (row == null) break;  								_startContent = true;  								AttributeList style = null;  								if (row.CellSettings.Count > 0)  								{  									style = (AttributeList)row.CellSettings[row.CellSettings.Count - 1];  									if (style.Contains(Consts.Cellx))  									{  										// if find repeat control word ' then can consider this control word  										// belong to the next cell . userly cellx is the last control word of   										// a cell ' when meet cellx ' the current cell defind is finished.  										style = new AttributeList();  										row.CellSettings.Add(style);  									}  								}  								if (style == null)  								{  									style = new AttributeList();  									row.CellSettings.Add(style);  								}  								style.Add(reader.Keyword' reader.Parameter);  								break;  							}    						case Consts.Cell:  							{  								// finish cell content  								_startContent = true;  								AddContentElement(null);  								CompleteParagraph();  								_paragraphFormat.Reset();  								format.Reset();  								var es = GetLastElements(true);  								for (var count = es.Length - 1; count >= 0; count--)  								{  									if (es[count].Locked == false)  									{  										es[count].Locked = true;  										if (es[count] is DomTableCell)  											break;  									}  								}  								break;  							}    						case Consts.Nestcell:  							{  								// finish nested cell content  								_startContent = true;  								AddContentElement(null);  								CompleteParagraph();  								var es = GetLastElements(false);  								for (var count = es.Length - 1; count >= 0; count--)  								{  									es[count].Locked = true;  									if (es[count] is DomTableCell)  									{  										((DomTableCell)es[count]).Format = format;  										break;  									}  								}  								break;  							}  						#endregion    						default:  							// Unsupport keyword  							if (reader.TokenType == RtfTokenType.ExtKeyword && reader.FirstTokenInGroup)  							{  								// if meet unsupport extern keyword ' and this token is the first token in   								// current group ' then ingore whole group.  								ReadToEndGround(reader);  							}  							break;  					}  				}  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,HexToBytes,The following statement contains a magic number: for (var count = 0; count < hex.Length; count++)  			{  				var c = hex[count];  				c = char.ToLower(c);  				var index = chars.IndexOf(c);  				if (index >= 0)  				{  					charCount++;  					value = value * 16 + index;  					if (charCount > 0 && (charCount % 2) == 0)  					{  						buffer.Add((byte)value);  						value = 0;  					}  				}  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,HexToBytes,The following statement contains a magic number: for (var count = 0; count < hex.Length; count++)  			{  				var c = hex[count];  				c = char.ToLower(c);  				var index = chars.IndexOf(c);  				if (index >= 0)  				{  					charCount++;  					value = value * 16 + index;  					if (charCount > 0 && (charCount % 2) == 0)  					{  						buffer.Add((byte)value);  						value = 0;  					}  				}  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,UpdateTableCells,The following statement contains a magic number: foreach (DomTableRow tableRow in table.Elements)  			{  				var lastCellX = 0;    				columns = Math.Max(columns' tableRow.Elements.Count);  				if (tableRow.HasAttribute(Consts.Irow))  				{  					tableRow.RowIndex = tableRow.Attributes[Consts.Irow];  				}  				tableRow.IsLastRow = tableRow.HasAttribute(Consts.Lastrow);  				tableRow.Header = tableRow.HasAttribute(Consts.Trhdr);  				// Read row height  				if (tableRow.HasAttribute(Consts.Trrh))  				{  					tableRow.Height = tableRow.Attributes[Consts.Trrh];  					if (tableRow.Height == 0)  						tableRow.Height = DefaultRowHeight;  					else if (tableRow.Height < 0)  						tableRow.Height = -tableRow.Height;  				}  				else  					tableRow.Height = DefaultRowHeight;    				// Read default padding of cell  				tableRow.PaddingLeft = tableRow.HasAttribute(Consts.Trpaddl) ? tableRow.Attributes[Consts.Trpaddl] : int.MinValue;  				tableRow.PaddingTop = tableRow.HasAttribute(Consts.Trpaddt) ? tableRow.Attributes[Consts.Trpaddt] : int.MinValue;  				tableRow.PaddingRight = tableRow.HasAttribute(Consts.Trpaddr) ? tableRow.Attributes[Consts.Trpaddr] : int.MinValue;  				tableRow.PaddingBottom = tableRow.HasAttribute(Consts.Trpaddb) ? tableRow.Attributes[Consts.Trpaddb] : int.MinValue;    				if (tableRow.HasAttribute(Consts.Trleft))  					tableLeft = tableRow.Attributes[Consts.Trleft];    				if (tableRow.HasAttribute(Consts.Trcbpat))  					tableRow.Format.BackColor = ColorTable.GetColor(  						tableRow.Attributes[Consts.Trcbpat]'  						Color.Transparent);    				var widthCount = 0;  				foreach (DomTableCell cell in tableRow.Elements)  				{  					// Set cell's dispaly format  					if (cell.HasAttribute(Consts.Clvmgf))  						merge = true;    					if (cell.HasAttribute(Consts.Clvmrg))  						merge = true;    					cell.PaddingLeft = cell.HasAttribute(Consts.Clpadl) ? cell.Attributes[Consts.Clpadl] : int.MinValue;  					cell.PaddingRight = cell.HasAttribute(Consts.Clpadr) ? cell.Attributes[Consts.Clpadr] : int.MinValue;  					cell.PaddingTop = cell.HasAttribute(Consts.Clpadt) ? cell.Attributes[Consts.Clpadt] : int.MinValue;  					cell.PaddingBottom = cell.HasAttribute(Consts.Clpadb) ? cell.Attributes[Consts.Clpadb] : int.MinValue;    					// Whether display border line  					cell.Format.LeftBorder = cell.HasAttribute(Consts.Clbrdrl);  					cell.Format.TopBorder = cell.HasAttribute(Consts.Clbrdrt);  					cell.Format.RightBorder = cell.HasAttribute(Consts.Clbrdrr);  					cell.Format.BottomBorder = cell.HasAttribute(Consts.Clbrdrb);    					if (cell.HasAttribute(Consts.Brdrcf))  					{  						cell.Format.BorderColor = ColorTable.GetColor(  							cell.GetAttributeValue(Consts.Brdrcf' 1)'  							Color.Black);  					}    					for (var count = cell.Attributes.Count - 1; count >= 0; count--)  					{  						var name3 = cell.Attributes.GetItem(count).Name;  						if (name3 == Consts.Brdrtbl  							|| name3 == Consts.Brdrnone  							|| name3 == Consts.Brdrnil)  						{  							for (var count2 = count - 1; count2 >= 0; count2--)  							{  								var name2 = cell.Attributes.GetItem(count2).Name;  								if (name2 == Consts.Clbrdrl)  								{  									cell.Format.LeftBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrt)  								{  									cell.Format.TopBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrr)  								{  									cell.Format.RightBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrb)  								{  									cell.Format.BottomBorder = false;  									break;  								}  							}  						}  					}    					// Vertial alignment  					if (cell.HasAttribute(Consts.Clvertalt))  						cell.VerticalAlignment = RtfVerticalAlignment.Top;  					else if (cell.HasAttribute(Consts.Clvertalc))  						cell.VerticalAlignment = RtfVerticalAlignment.Middle;  					else if (cell.HasAttribute(Consts.Clvertalb))  						cell.VerticalAlignment = RtfVerticalAlignment.Bottom;    					// Background color  					cell.Format.BackColor = cell.HasAttribute(Consts.Clcbpat) ? ColorTable.GetColor(cell.Attributes[Consts.Clcbpat]' Color.Transparent) : Color.Transparent;  					if (cell.HasAttribute(Consts.Clcfpat))  						cell.Format.BorderColor = ColorTable.GetColor(cell.Attributes[Consts.Clcfpat]' Color.Black);    					// Cell's width  					var cellWidth = 2763; // cell's default with is 2763 Twips(570 Document)  					if (cell.HasAttribute(Consts.Cellx))  					{  						cellWidth = cell.Attributes[Consts.Cellx] - lastCellX;  						if (cellWidth < 100)  							cellWidth = 100;  					}    					var right = lastCellX + cellWidth;  					// fix cell's right position ' if this position is very near with another cell's   					// right position( less then 45 twips or 3 pixel)' then consider these two position  					// is the same ' this can decrease number of table columns  					foreach (var t in rights)  					{  						if (Math.Abs(right - (int)t) < 45)  						{  							right = (int)t;  							cellWidth = right - lastCellX;  							break;  						}  					}    					cell.Left = lastCellX;  					cell.Width = cellWidth;    					widthCount += cellWidth;    					if (rights.Contains(right) == false)  					{  						// becase of convert twips to unit of document may cause truncation error.  						// This may cause rights.Contains mistake . so scale cell's with with   						// native twips unit ' after all computing ' convert to unit of document.  						rights.Add(right);  					}  					lastCellX = lastCellX + cellWidth;  				} //foreach  				tableRow.Width = widthCount;  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,UpdateTableCells,The following statement contains a magic number: foreach (DomTableRow tableRow in table.Elements)  			{  				var lastCellX = 0;    				columns = Math.Max(columns' tableRow.Elements.Count);  				if (tableRow.HasAttribute(Consts.Irow))  				{  					tableRow.RowIndex = tableRow.Attributes[Consts.Irow];  				}  				tableRow.IsLastRow = tableRow.HasAttribute(Consts.Lastrow);  				tableRow.Header = tableRow.HasAttribute(Consts.Trhdr);  				// Read row height  				if (tableRow.HasAttribute(Consts.Trrh))  				{  					tableRow.Height = tableRow.Attributes[Consts.Trrh];  					if (tableRow.Height == 0)  						tableRow.Height = DefaultRowHeight;  					else if (tableRow.Height < 0)  						tableRow.Height = -tableRow.Height;  				}  				else  					tableRow.Height = DefaultRowHeight;    				// Read default padding of cell  				tableRow.PaddingLeft = tableRow.HasAttribute(Consts.Trpaddl) ? tableRow.Attributes[Consts.Trpaddl] : int.MinValue;  				tableRow.PaddingTop = tableRow.HasAttribute(Consts.Trpaddt) ? tableRow.Attributes[Consts.Trpaddt] : int.MinValue;  				tableRow.PaddingRight = tableRow.HasAttribute(Consts.Trpaddr) ? tableRow.Attributes[Consts.Trpaddr] : int.MinValue;  				tableRow.PaddingBottom = tableRow.HasAttribute(Consts.Trpaddb) ? tableRow.Attributes[Consts.Trpaddb] : int.MinValue;    				if (tableRow.HasAttribute(Consts.Trleft))  					tableLeft = tableRow.Attributes[Consts.Trleft];    				if (tableRow.HasAttribute(Consts.Trcbpat))  					tableRow.Format.BackColor = ColorTable.GetColor(  						tableRow.Attributes[Consts.Trcbpat]'  						Color.Transparent);    				var widthCount = 0;  				foreach (DomTableCell cell in tableRow.Elements)  				{  					// Set cell's dispaly format  					if (cell.HasAttribute(Consts.Clvmgf))  						merge = true;    					if (cell.HasAttribute(Consts.Clvmrg))  						merge = true;    					cell.PaddingLeft = cell.HasAttribute(Consts.Clpadl) ? cell.Attributes[Consts.Clpadl] : int.MinValue;  					cell.PaddingRight = cell.HasAttribute(Consts.Clpadr) ? cell.Attributes[Consts.Clpadr] : int.MinValue;  					cell.PaddingTop = cell.HasAttribute(Consts.Clpadt) ? cell.Attributes[Consts.Clpadt] : int.MinValue;  					cell.PaddingBottom = cell.HasAttribute(Consts.Clpadb) ? cell.Attributes[Consts.Clpadb] : int.MinValue;    					// Whether display border line  					cell.Format.LeftBorder = cell.HasAttribute(Consts.Clbrdrl);  					cell.Format.TopBorder = cell.HasAttribute(Consts.Clbrdrt);  					cell.Format.RightBorder = cell.HasAttribute(Consts.Clbrdrr);  					cell.Format.BottomBorder = cell.HasAttribute(Consts.Clbrdrb);    					if (cell.HasAttribute(Consts.Brdrcf))  					{  						cell.Format.BorderColor = ColorTable.GetColor(  							cell.GetAttributeValue(Consts.Brdrcf' 1)'  							Color.Black);  					}    					for (var count = cell.Attributes.Count - 1; count >= 0; count--)  					{  						var name3 = cell.Attributes.GetItem(count).Name;  						if (name3 == Consts.Brdrtbl  							|| name3 == Consts.Brdrnone  							|| name3 == Consts.Brdrnil)  						{  							for (var count2 = count - 1; count2 >= 0; count2--)  							{  								var name2 = cell.Attributes.GetItem(count2).Name;  								if (name2 == Consts.Clbrdrl)  								{  									cell.Format.LeftBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrt)  								{  									cell.Format.TopBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrr)  								{  									cell.Format.RightBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrb)  								{  									cell.Format.BottomBorder = false;  									break;  								}  							}  						}  					}    					// Vertial alignment  					if (cell.HasAttribute(Consts.Clvertalt))  						cell.VerticalAlignment = RtfVerticalAlignment.Top;  					else if (cell.HasAttribute(Consts.Clvertalc))  						cell.VerticalAlignment = RtfVerticalAlignment.Middle;  					else if (cell.HasAttribute(Consts.Clvertalb))  						cell.VerticalAlignment = RtfVerticalAlignment.Bottom;    					// Background color  					cell.Format.BackColor = cell.HasAttribute(Consts.Clcbpat) ? ColorTable.GetColor(cell.Attributes[Consts.Clcbpat]' Color.Transparent) : Color.Transparent;  					if (cell.HasAttribute(Consts.Clcfpat))  						cell.Format.BorderColor = ColorTable.GetColor(cell.Attributes[Consts.Clcfpat]' Color.Black);    					// Cell's width  					var cellWidth = 2763; // cell's default with is 2763 Twips(570 Document)  					if (cell.HasAttribute(Consts.Cellx))  					{  						cellWidth = cell.Attributes[Consts.Cellx] - lastCellX;  						if (cellWidth < 100)  							cellWidth = 100;  					}    					var right = lastCellX + cellWidth;  					// fix cell's right position ' if this position is very near with another cell's   					// right position( less then 45 twips or 3 pixel)' then consider these two position  					// is the same ' this can decrease number of table columns  					foreach (var t in rights)  					{  						if (Math.Abs(right - (int)t) < 45)  						{  							right = (int)t;  							cellWidth = right - lastCellX;  							break;  						}  					}    					cell.Left = lastCellX;  					cell.Width = cellWidth;    					widthCount += cellWidth;    					if (rights.Contains(right) == false)  					{  						// becase of convert twips to unit of document may cause truncation error.  						// This may cause rights.Contains mistake . so scale cell's with with   						// native twips unit ' after all computing ' convert to unit of document.  						rights.Add(right);  					}  					lastCellX = lastCellX + cellWidth;  				} //foreach  				tableRow.Width = widthCount;  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,UpdateTableCells,The following statement contains a magic number: foreach (DomTableRow tableRow in table.Elements)  			{  				var lastCellX = 0;    				columns = Math.Max(columns' tableRow.Elements.Count);  				if (tableRow.HasAttribute(Consts.Irow))  				{  					tableRow.RowIndex = tableRow.Attributes[Consts.Irow];  				}  				tableRow.IsLastRow = tableRow.HasAttribute(Consts.Lastrow);  				tableRow.Header = tableRow.HasAttribute(Consts.Trhdr);  				// Read row height  				if (tableRow.HasAttribute(Consts.Trrh))  				{  					tableRow.Height = tableRow.Attributes[Consts.Trrh];  					if (tableRow.Height == 0)  						tableRow.Height = DefaultRowHeight;  					else if (tableRow.Height < 0)  						tableRow.Height = -tableRow.Height;  				}  				else  					tableRow.Height = DefaultRowHeight;    				// Read default padding of cell  				tableRow.PaddingLeft = tableRow.HasAttribute(Consts.Trpaddl) ? tableRow.Attributes[Consts.Trpaddl] : int.MinValue;  				tableRow.PaddingTop = tableRow.HasAttribute(Consts.Trpaddt) ? tableRow.Attributes[Consts.Trpaddt] : int.MinValue;  				tableRow.PaddingRight = tableRow.HasAttribute(Consts.Trpaddr) ? tableRow.Attributes[Consts.Trpaddr] : int.MinValue;  				tableRow.PaddingBottom = tableRow.HasAttribute(Consts.Trpaddb) ? tableRow.Attributes[Consts.Trpaddb] : int.MinValue;    				if (tableRow.HasAttribute(Consts.Trleft))  					tableLeft = tableRow.Attributes[Consts.Trleft];    				if (tableRow.HasAttribute(Consts.Trcbpat))  					tableRow.Format.BackColor = ColorTable.GetColor(  						tableRow.Attributes[Consts.Trcbpat]'  						Color.Transparent);    				var widthCount = 0;  				foreach (DomTableCell cell in tableRow.Elements)  				{  					// Set cell's dispaly format  					if (cell.HasAttribute(Consts.Clvmgf))  						merge = true;    					if (cell.HasAttribute(Consts.Clvmrg))  						merge = true;    					cell.PaddingLeft = cell.HasAttribute(Consts.Clpadl) ? cell.Attributes[Consts.Clpadl] : int.MinValue;  					cell.PaddingRight = cell.HasAttribute(Consts.Clpadr) ? cell.Attributes[Consts.Clpadr] : int.MinValue;  					cell.PaddingTop = cell.HasAttribute(Consts.Clpadt) ? cell.Attributes[Consts.Clpadt] : int.MinValue;  					cell.PaddingBottom = cell.HasAttribute(Consts.Clpadb) ? cell.Attributes[Consts.Clpadb] : int.MinValue;    					// Whether display border line  					cell.Format.LeftBorder = cell.HasAttribute(Consts.Clbrdrl);  					cell.Format.TopBorder = cell.HasAttribute(Consts.Clbrdrt);  					cell.Format.RightBorder = cell.HasAttribute(Consts.Clbrdrr);  					cell.Format.BottomBorder = cell.HasAttribute(Consts.Clbrdrb);    					if (cell.HasAttribute(Consts.Brdrcf))  					{  						cell.Format.BorderColor = ColorTable.GetColor(  							cell.GetAttributeValue(Consts.Brdrcf' 1)'  							Color.Black);  					}    					for (var count = cell.Attributes.Count - 1; count >= 0; count--)  					{  						var name3 = cell.Attributes.GetItem(count).Name;  						if (name3 == Consts.Brdrtbl  							|| name3 == Consts.Brdrnone  							|| name3 == Consts.Brdrnil)  						{  							for (var count2 = count - 1; count2 >= 0; count2--)  							{  								var name2 = cell.Attributes.GetItem(count2).Name;  								if (name2 == Consts.Clbrdrl)  								{  									cell.Format.LeftBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrt)  								{  									cell.Format.TopBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrr)  								{  									cell.Format.RightBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrb)  								{  									cell.Format.BottomBorder = false;  									break;  								}  							}  						}  					}    					// Vertial alignment  					if (cell.HasAttribute(Consts.Clvertalt))  						cell.VerticalAlignment = RtfVerticalAlignment.Top;  					else if (cell.HasAttribute(Consts.Clvertalc))  						cell.VerticalAlignment = RtfVerticalAlignment.Middle;  					else if (cell.HasAttribute(Consts.Clvertalb))  						cell.VerticalAlignment = RtfVerticalAlignment.Bottom;    					// Background color  					cell.Format.BackColor = cell.HasAttribute(Consts.Clcbpat) ? ColorTable.GetColor(cell.Attributes[Consts.Clcbpat]' Color.Transparent) : Color.Transparent;  					if (cell.HasAttribute(Consts.Clcfpat))  						cell.Format.BorderColor = ColorTable.GetColor(cell.Attributes[Consts.Clcfpat]' Color.Black);    					// Cell's width  					var cellWidth = 2763; // cell's default with is 2763 Twips(570 Document)  					if (cell.HasAttribute(Consts.Cellx))  					{  						cellWidth = cell.Attributes[Consts.Cellx] - lastCellX;  						if (cellWidth < 100)  							cellWidth = 100;  					}    					var right = lastCellX + cellWidth;  					// fix cell's right position ' if this position is very near with another cell's   					// right position( less then 45 twips or 3 pixel)' then consider these two position  					// is the same ' this can decrease number of table columns  					foreach (var t in rights)  					{  						if (Math.Abs(right - (int)t) < 45)  						{  							right = (int)t;  							cellWidth = right - lastCellX;  							break;  						}  					}    					cell.Left = lastCellX;  					cell.Width = cellWidth;    					widthCount += cellWidth;    					if (rights.Contains(right) == false)  					{  						// becase of convert twips to unit of document may cause truncation error.  						// This may cause rights.Contains mistake . so scale cell's with with   						// native twips unit ' after all computing ' convert to unit of document.  						rights.Add(right);  					}  					lastCellX = lastCellX + cellWidth;  				} //foreach  				tableRow.Width = widthCount;  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,UpdateTableCells,The following statement contains a magic number: foreach (DomTableRow tableRow in table.Elements)  			{  				var lastCellX = 0;    				columns = Math.Max(columns' tableRow.Elements.Count);  				if (tableRow.HasAttribute(Consts.Irow))  				{  					tableRow.RowIndex = tableRow.Attributes[Consts.Irow];  				}  				tableRow.IsLastRow = tableRow.HasAttribute(Consts.Lastrow);  				tableRow.Header = tableRow.HasAttribute(Consts.Trhdr);  				// Read row height  				if (tableRow.HasAttribute(Consts.Trrh))  				{  					tableRow.Height = tableRow.Attributes[Consts.Trrh];  					if (tableRow.Height == 0)  						tableRow.Height = DefaultRowHeight;  					else if (tableRow.Height < 0)  						tableRow.Height = -tableRow.Height;  				}  				else  					tableRow.Height = DefaultRowHeight;    				// Read default padding of cell  				tableRow.PaddingLeft = tableRow.HasAttribute(Consts.Trpaddl) ? tableRow.Attributes[Consts.Trpaddl] : int.MinValue;  				tableRow.PaddingTop = tableRow.HasAttribute(Consts.Trpaddt) ? tableRow.Attributes[Consts.Trpaddt] : int.MinValue;  				tableRow.PaddingRight = tableRow.HasAttribute(Consts.Trpaddr) ? tableRow.Attributes[Consts.Trpaddr] : int.MinValue;  				tableRow.PaddingBottom = tableRow.HasAttribute(Consts.Trpaddb) ? tableRow.Attributes[Consts.Trpaddb] : int.MinValue;    				if (tableRow.HasAttribute(Consts.Trleft))  					tableLeft = tableRow.Attributes[Consts.Trleft];    				if (tableRow.HasAttribute(Consts.Trcbpat))  					tableRow.Format.BackColor = ColorTable.GetColor(  						tableRow.Attributes[Consts.Trcbpat]'  						Color.Transparent);    				var widthCount = 0;  				foreach (DomTableCell cell in tableRow.Elements)  				{  					// Set cell's dispaly format  					if (cell.HasAttribute(Consts.Clvmgf))  						merge = true;    					if (cell.HasAttribute(Consts.Clvmrg))  						merge = true;    					cell.PaddingLeft = cell.HasAttribute(Consts.Clpadl) ? cell.Attributes[Consts.Clpadl] : int.MinValue;  					cell.PaddingRight = cell.HasAttribute(Consts.Clpadr) ? cell.Attributes[Consts.Clpadr] : int.MinValue;  					cell.PaddingTop = cell.HasAttribute(Consts.Clpadt) ? cell.Attributes[Consts.Clpadt] : int.MinValue;  					cell.PaddingBottom = cell.HasAttribute(Consts.Clpadb) ? cell.Attributes[Consts.Clpadb] : int.MinValue;    					// Whether display border line  					cell.Format.LeftBorder = cell.HasAttribute(Consts.Clbrdrl);  					cell.Format.TopBorder = cell.HasAttribute(Consts.Clbrdrt);  					cell.Format.RightBorder = cell.HasAttribute(Consts.Clbrdrr);  					cell.Format.BottomBorder = cell.HasAttribute(Consts.Clbrdrb);    					if (cell.HasAttribute(Consts.Brdrcf))  					{  						cell.Format.BorderColor = ColorTable.GetColor(  							cell.GetAttributeValue(Consts.Brdrcf' 1)'  							Color.Black);  					}    					for (var count = cell.Attributes.Count - 1; count >= 0; count--)  					{  						var name3 = cell.Attributes.GetItem(count).Name;  						if (name3 == Consts.Brdrtbl  							|| name3 == Consts.Brdrnone  							|| name3 == Consts.Brdrnil)  						{  							for (var count2 = count - 1; count2 >= 0; count2--)  							{  								var name2 = cell.Attributes.GetItem(count2).Name;  								if (name2 == Consts.Clbrdrl)  								{  									cell.Format.LeftBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrt)  								{  									cell.Format.TopBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrr)  								{  									cell.Format.RightBorder = false;  									break;  								}    								if (name2 == Consts.Clbrdrb)  								{  									cell.Format.BottomBorder = false;  									break;  								}  							}  						}  					}    					// Vertial alignment  					if (cell.HasAttribute(Consts.Clvertalt))  						cell.VerticalAlignment = RtfVerticalAlignment.Top;  					else if (cell.HasAttribute(Consts.Clvertalc))  						cell.VerticalAlignment = RtfVerticalAlignment.Middle;  					else if (cell.HasAttribute(Consts.Clvertalb))  						cell.VerticalAlignment = RtfVerticalAlignment.Bottom;    					// Background color  					cell.Format.BackColor = cell.HasAttribute(Consts.Clcbpat) ? ColorTable.GetColor(cell.Attributes[Consts.Clcbpat]' Color.Transparent) : Color.Transparent;  					if (cell.HasAttribute(Consts.Clcfpat))  						cell.Format.BorderColor = ColorTable.GetColor(cell.Attributes[Consts.Clcfpat]' Color.Black);    					// Cell's width  					var cellWidth = 2763; // cell's default with is 2763 Twips(570 Document)  					if (cell.HasAttribute(Consts.Cellx))  					{  						cellWidth = cell.Attributes[Consts.Cellx] - lastCellX;  						if (cellWidth < 100)  							cellWidth = 100;  					}    					var right = lastCellX + cellWidth;  					// fix cell's right position ' if this position is very near with another cell's   					// right position( less then 45 twips or 3 pixel)' then consider these two position  					// is the same ' this can decrease number of table columns  					foreach (var t in rights)  					{  						if (Math.Abs(right - (int)t) < 45)  						{  							right = (int)t;  							cellWidth = right - lastCellX;  							break;  						}  					}    					cell.Left = lastCellX;  					cell.Width = cellWidth;    					widthCount += cellWidth;    					if (rights.Contains(right) == false)  					{  						// becase of convert twips to unit of document may cause truncation error.  						// This may cause rights.Contains mistake . so scale cell's with with   						// native twips unit ' after all computing ' convert to unit of document.  						rights.Add(right);  					}  					lastCellX = lastCellX + cellWidth;  				} //foreach  				tableRow.Width = widthCount;  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ApplyText,The following statement contains a magic number: if (textContainer.HasContent)  			{  				var text = textContainer.Text;  				textContainer.Clear();    				var image = (DomImage)GetLastElement(typeof(DomImage));  				if (image != null && image.Locked == false)  				{  					image.Data = HexToBytes(text);  					image.Format = format.Clone();  					image.Width = image.DesiredWidth * image.ScaleX / 100;  					image.Height = image.DesiredHeight * image.ScaleY / 100;  					image.Locked = true;  					if (reader.TokenType != RtfTokenType.GroupEnd)  					{  						ReadToEndGround(reader);  					}  					return true;  				}  				if (format.ReadText && _startContent)  				{  					var txt = new DomText { NativeLevel = textContainer.Level' Format = format.Clone() };  					if (txt.Format.Align == RtfAlignment.Justify)  						txt.Format.Align = RtfAlignment.Left;  					txt.Text = text;  					AddContentElement(txt);  				}  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ApplyText,The following statement contains a magic number: if (textContainer.HasContent)  			{  				var text = textContainer.Text;  				textContainer.Clear();    				var image = (DomImage)GetLastElement(typeof(DomImage));  				if (image != null && image.Locked == false)  				{  					image.Data = HexToBytes(text);  					image.Format = format.Clone();  					image.Width = image.DesiredWidth * image.ScaleX / 100;  					image.Height = image.DesiredHeight * image.ScaleY / 100;  					image.Locked = true;  					if (reader.TokenType != RtfTokenType.GroupEnd)  					{  						ReadToEndGround(reader);  					}  					return true;  				}  				if (format.ReadText && _startContent)  				{  					var txt = new DomText { NativeLevel = textContainer.Level' Format = format.Clone() };  					if (txt.Format.Align == RtfAlignment.Justify)  						txt.Format.Align = RtfAlignment.Left;  					txt.Text = text;  					AddContentElement(txt);  				}  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadListTable,The following statement contains a magic number: while (reader.ReadToken() != null)  			{  				if (reader.TokenType == RtfTokenType.GroupEnd)  					break;    				if (reader.TokenType == RtfTokenType.GroupStart)  				{  					var firstRead = true;  					RtfList currentList = null;  					var level = reader.Level;  					while (reader.ReadToken() != null)  					{  						if (reader.TokenType == RtfTokenType.GroupEnd)  						{  							if (reader.Level < level)  							{  								break;  							}  						}  						else if (reader.TokenType == RtfTokenType.GroupStart)  						{  							// if meet nested level ' then ignore  							//reader.ReadToken();  							//ReadToEndGround(reader);  							//reader.ReadToken();  						}  						if (firstRead)  						{  							if (reader.CurrentToken.Key != "list")  							{  								// list  								ReadToEndGround(reader);  								reader.ReadToken();  								break;  							}  							currentList = new RtfList();  							ListTable.Add(currentList);  							firstRead = false;  						}    						switch (reader.CurrentToken.Key)  						{  							case "listtemplateid":  								currentList.ListTemplateId = reader.CurrentToken.Param;  								break;    							case "listid":  								currentList.ListId = reader.CurrentToken.Param;  								break;    							case "listhybrid":  								currentList.ListHybrid = true;  								break;    							case "levelfollow":  								currentList.LevelFollow = reader.CurrentToken.Param;  								break;    							case "levelstartat":  								currentList.LevelStartAt = reader.CurrentToken.Param;  								break;    							case "levelnfc":  								if (currentList.LevelNfc == RtfLevelNumberType.None)  									currentList.LevelNfc = (RtfLevelNumberType)reader.CurrentToken.Param;  								break;    							case "levelnfcn":  								if (currentList.LevelNfc == RtfLevelNumberType.None)  									currentList.LevelNfc = (RtfLevelNumberType)reader.CurrentToken.Param;  								break;    							case "leveljc":  								currentList.LevelJc = reader.CurrentToken.Param;  								break;    							case "leveltext":  								if (string.IsNullOrEmpty(currentList.LevelText))  								{  									var text = ReadInnerText(reader' true);  									if (text != null && text.Length > 2)  									{  										int len = text[0];  										len = Math.Min(len' text.Length - 1);  										text = text.Substring(1' len);  									}  									currentList.LevelText = text;  								}  								break;    							case "f":  								currentList.FontName = FontTable.GetFontName(reader.CurrentToken.Param);  								break;  						}  					}  				}  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadColorTable,The following statement contains a magic number: while (reader.ReadToken() != null)  			{  				if (reader.TokenType == RtfTokenType.GroupEnd)  				{  					break;  				}  				switch (reader.Keyword)  				{  					case "red":  						r = reader.Parameter;  						break;  					case "green":  						g = reader.Parameter;  						break;  					case "blue":  						b = reader.Parameter;  						break;  					case ";":  						if (r >= 0 && g >= 0 && b >= 0)  						{  							var c = Color.FromArgb(255' r' g' b);  							ColorTable.Add(c);  							r = -1;  							g = -1;  							b = -1;  						}  						break;  				}  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadColorTable,The following statement contains a magic number: if (r >= 0 && g >= 0 && b >= 0)  			{  				// Read the last color  				var c = Color.FromArgb(255' r' g' b);  				ColorTable.Add(c);  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadDateTime,The following statement contains a magic number: var yr = 1900;
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadDomField,The following statement contains a magic number: while (reader.ReadToken() != null)  			{  				if (reader.Level < levelBack)  					break;    				if (reader.TokenType == RtfTokenType.GroupStart)  				{  				}  				else if (reader.TokenType == RtfTokenType.GroupEnd)  				{  				}  				else  				{  					switch (reader.Keyword)  					{  						case Consts.Flddirty:  							field.Method = RtfDomFieldMethod.Dirty;  							break;    						case Consts.Fldedit:  							field.Method = RtfDomFieldMethod.Edit;  							break;    						case Consts.Fldlock:  							field.Method = RtfDomFieldMethod.Lock;  							break;    						case Consts.Fldpriv:  							field.Method = RtfDomFieldMethod.Priv;  							break;    						case Consts.Fldrslt:  							var result = new ElementContainer { Name = Consts.Fldrslt };  							field.AppendChild(result);  							Load(reader' format);  							result.Locked = true;  							break;    						case Consts.Fldinst:  							var inst = new ElementContainer { Name = Consts.Fldinst };  							field.AppendChild(inst);  							Load(reader' format);  							inst.Locked = true;  							var txt = inst.InnerText;  							if (txt != null)  							{  								var index = txt.IndexOf(Consts.Hyperlink' StringComparison.Ordinal);  								if (index >= 0)  								{  									var index1 = txt.IndexOf('\"'' index);  									if (index1 > 0 && txt.Length > index1 + 2)  									{  										var index2 = txt.IndexOf('\"'' index1 + 2);  										if (index2 > index1)  										{  											var link = txt.Substring(index1 + 1' index2 - index1 - 1);  											if (format.Parent != null)  											{  												if (link.StartsWith("_Toc"))  													link = "#" + link;  												format.Parent.Link = link;  											}  										}  									}  								}  							}    							break;  					}  				}  			}
Magic Number,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadDomField,The following statement contains a magic number: while (reader.ReadToken() != null)  			{  				if (reader.Level < levelBack)  					break;    				if (reader.TokenType == RtfTokenType.GroupStart)  				{  				}  				else if (reader.TokenType == RtfTokenType.GroupEnd)  				{  				}  				else  				{  					switch (reader.Keyword)  					{  						case Consts.Flddirty:  							field.Method = RtfDomFieldMethod.Dirty;  							break;    						case Consts.Fldedit:  							field.Method = RtfDomFieldMethod.Edit;  							break;    						case Consts.Fldlock:  							field.Method = RtfDomFieldMethod.Lock;  							break;    						case Consts.Fldpriv:  							field.Method = RtfDomFieldMethod.Priv;  							break;    						case Consts.Fldrslt:  							var result = new ElementContainer { Name = Consts.Fldrslt };  							field.AppendChild(result);  							Load(reader' format);  							result.Locked = true;  							break;    						case Consts.Fldinst:  							var inst = new ElementContainer { Name = Consts.Fldinst };  							field.AppendChild(inst);  							Load(reader' format);  							inst.Locked = true;  							var txt = inst.InnerText;  							if (txt != null)  							{  								var index = txt.IndexOf(Consts.Hyperlink' StringComparison.Ordinal);  								if (index >= 0)  								{  									var index1 = txt.IndexOf('\"'' index);  									if (index1 > 0 && txt.Length > index1 + 2)  									{  										var index2 = txt.IndexOf('\"'' index1 + 2);  										if (index2 > index1)  										{  											var link = txt.Substring(index1 + 1' index2 - index1 - 1);  											if (format.Parent != null)  											{  												if (link.StartsWith("_Toc"))  													link = "#" + link;  												format.Parent.Link = link;  											}  										}  									}  								}  							}    							break;  					}  				}  			}
Magic Number,MsgReader.Rtf,DomElement,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomElement.cs,ToDomString,The following statement contains a magic number: foreach (DomElement element in elements)              {                  stringBuilder.Append(Environment.NewLine);                  stringBuilder.Append(new string(' '' level*4));                  stringBuilder.Append(element);                  ToDomString(element.Elements' stringBuilder' level + 1);              }
Magic Number,MsgReader.Rtf,DomImage,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomImage.cs,DomImage,The following statement contains a magic number: ScaleY = 100;
Magic Number,MsgReader.Rtf,DomImage,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomImage.cs,DomImage,The following statement contains a magic number: ScaleX = 100;
Magic Number,MsgReader.Rtf,DomImage,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomImage.cs,ToString,The following statement contains a magic number: if (Data != null && Data.Length > 0)                  text = text + " " + Convert.ToDouble( Data.Length / 1024.0).ToString("0.00") + "KB";
Magic Number,MsgReader.Rtf,DomObject,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomObject.cs,DomObject,The following statement contains a magic number: ScaleX = 100;
Magic Number,MsgReader.Rtf,DomObject,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomObject.cs,DomObject,The following statement contains a magic number: ScaleY = 100;
Magic Number,MsgReader.Rtf,DomObject,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomObject.cs,ToString,The following statement contains a magic number: if (Content != null && Content.Length > 0)                  text = text + " " + Convert.ToDouble(Content.Length / 1024.0).ToString("0.00") + "KB";
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Font,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\FontTable.cs,CheckEncodingCharsets,The following statement contains a magic number: if (_encodingCharsets == null)              {                  _encodingCharsets = new Dictionary<int' Encoding>();                  _encodingCharsets[77] = Encoding.GetEncoding(10000); // Mac Roman                  _encodingCharsets[78] = Encoding.GetEncoding(10001); // Mac Shift Jis                  _encodingCharsets[79] = Encoding.GetEncoding(10003); // Mac Hangul                  _encodingCharsets[80] = Encoding.GetEncoding(10008); // Mac GB2312                  _encodingCharsets[81] = Encoding.GetEncoding(10002); // Mac Big5                  _encodingCharsets[83] = Encoding.GetEncoding(10005); // Mac Hebrew                  _encodingCharsets[84] = Encoding.GetEncoding(10004); // Mac Arabic                  _encodingCharsets[85] = Encoding.GetEncoding(10006); // Mac Greek                  _encodingCharsets[86] = Encoding.GetEncoding(10081); // Mac Turkish                  _encodingCharsets[87] = Encoding.GetEncoding(10021); // Mac Thai                  _encodingCharsets[88] = Encoding.GetEncoding(10029); // Mac East Europe                  _encodingCharsets[89] = Encoding.GetEncoding(10007); // Mac Russian                  _encodingCharsets[128] = Encoding.GetEncoding(932); // Shift JIS                  _encodingCharsets[129] = Encoding.GetEncoding(949); // Hangul                  _encodingCharsets[130] = Encoding.GetEncoding(1361); // Johab                  _encodingCharsets[134] = Encoding.GetEncoding(936); // GB2312                  _encodingCharsets[136] = Encoding.GetEncoding(950); // Big5                  _encodingCharsets[161] = Encoding.GetEncoding(1253); // Greek                  _encodingCharsets[162] = Encoding.GetEncoding(1254); // Turkish                  _encodingCharsets[163] = Encoding.GetEncoding(1258); // Vietnamese                  _encodingCharsets[177] = Encoding.GetEncoding(1255); // Hebrew                  _encodingCharsets[178] = Encoding.GetEncoding(1256); // Arabic                   _encodingCharsets[186] = Encoding.GetEncoding(1257); // Baltic                  _encodingCharsets[204] = Encoding.GetEncoding(1251); // Russian                  _encodingCharsets[222] = Encoding.GetEncoding(874); // Thai                  _encodingCharsets[238] = Encoding.GetEncoding(1250); // Eastern European                  _encodingCharsets[254] = Encoding.GetEncoding(437); // PC 437                  _encodingCharsets[255] = Encoding.GetEncoding(850); // OEM              }
Magic Number,MsgReader.Rtf,Lex,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Lex.cs,ParseKeyword,The following statement contains a magic number: if (!char.IsLetter((char) c))              {                  _reader.Read();                  if (c == '*')                  {                      // Expand keyword                      token.Type = RtfTokenType.Keyword;                      _reader.Read();                      ext = true;                  }                  else                  {                      if (c == '\\' || c == '{' || c == '}')                      {                          // Special character                          token.Type = RtfTokenType.Text;                          token.Key = ((char) c).ToString(CultureInfo.InvariantCulture);                      }                      else                      {                          token.Type = RtfTokenType.Control;                          token.Key = ((char) c).ToString(CultureInfo.InvariantCulture);                            if (token.Key == "\'")                          {                              // Read 2 hex characters                              var text = new StringBuilder();                              text.Append((char) _reader.Read());                              text.Append((char) _reader.Read());                              token.HasParam = true;                              token.Hex = text.ToString().ToLower();                                                           token.Param = Convert.ToInt32(text.ToString().ToLower()' 16);                          }                      }                      return;                  }              }
Magic Number,MsgReader.Rtf,RawDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\RawDocument.cs,ReadColorTable,The following statement contains a magic number: foreach (Node node in group.Nodes)              {                  if (node.Keyword == "red")                      r = node.Parameter;                  else if (node.Keyword == "green")                      g = node.Parameter;                  else if (node.Keyword == "blue")                      b = node.Parameter;                                if (node.Keyword == ";")                  {                      if (r >= 0 && g >= 0 && b >= 0)                      {                          var c = Color.FromArgb(255' r' g' b);                          InternalColorTable.Add(c);                          r = -1;                          g = -1;                          b = -1;                      }                  }              }
Magic Number,MsgReader.Rtf,RawDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\RawDocument.cs,ReadColorTable,The following statement contains a magic number: if (r >= 0 && g >= 0 && b >= 0)              {                  // Read the last color                  var c = Color.FromArgb(255' r' g' b);                  InternalColorTable.Add(c);              }
Magic Number,MsgReader.Rtf,RawDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\RawDocument.cs,ReadDateTime,The following statement contains a magic number: var yr = node.Nodes.GetParameter("yr"' 1900);
Magic Number,MsgReader.Rtf,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Reader.cs,LoadRTFText,The following statement contains a magic number: if (text != null && text.Length > 3)              {                  InnerReader = new StringReader(text);                  _lex = new Lex(InnerReader);                  return true;              }
Magic Number,MsgReader.Rtf,Util,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Util.cs,GetRtfImage,The following statement contains a magic number: const int mmAnisotropic = 8;
Magic Number,MsgReader.Rtf,Writer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Writer.cs,WriteUnicodeText,The following statement contains a magic number: if (string.IsNullOrEmpty(text) == false)              {                  WriteKeyword("uc1");                  foreach (var c in text)                  {                      if (c > 127)                      {                          int v = c;                          var v2 = (short) v;                          WriteKeyword("u" + v2);                          WriteRaw(" ?");                      }                      else                      {                          InnerWriteChar(c);                      }                  }              }
Magic Number,MsgReader.Rtf,Writer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Writer.cs,InnerWriteChar,The following statement contains a magic number: if (c > 32 && c < 127)              {                  // Some special characters ' must be converted                  if (c == '\\' || c == '{' || c == '}')                      InnerWrite('\\');                  InnerWrite(c);              }              else              {                  var bytes = Encoding.GetBytes(c.ToString(CultureInfo.InvariantCulture));                  foreach (var b in bytes)                  {                      InnerWrite("\\\'");                      WriteByte(b);                  }              }
Magic Number,MsgReader.Rtf,Writer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Writer.cs,InnerWriteChar,The following statement contains a magic number: if (c > 32 && c < 127)              {                  // Some special characters ' must be converted                  if (c == '\\' || c == '{' || c == '}')                      InnerWrite('\\');                  InnerWrite(c);              }              else              {                  var bytes = Encoding.GetBytes(c.ToString(CultureInfo.InvariantCulture));                  foreach (var b in bytes)                  {                      InnerWrite("\\\'");                      WriteByte(b);                  }              }
Magic Number,MsgReader.Rtf,Writer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Writer.cs,WriteBytes,The following statement contains a magic number: for (var count = 0; count < bytes.Length; count ++)              {                  if ((count%32) == 0)                  {                      WriteRaw(Environment.NewLine);                      WriteIndent();                  }                  else if ((count%8) == 0)                  {                      WriteRaw(" ");                  }                  var b = bytes[count];                  var h = (b & 0xf0) >> 4;                  var l = b & 0xf;                  _textWriter.Write(Hexs[h]);                  _textWriter.Write(Hexs[l]);                  _position += 2;              }
Magic Number,MsgReader.Rtf,Writer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Writer.cs,WriteBytes,The following statement contains a magic number: for (var count = 0; count < bytes.Length; count ++)              {                  if ((count%32) == 0)                  {                      WriteRaw(Environment.NewLine);                      WriteIndent();                  }                  else if ((count%8) == 0)                  {                      WriteRaw(" ");                  }                  var b = bytes[count];                  var h = (b & 0xf0) >> 4;                  var l = b & 0xf;                  _textWriter.Write(Hexs[h]);                  _textWriter.Write(Hexs[l]);                  _position += 2;              }
Magic Number,MsgReader.Rtf,Writer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Writer.cs,WriteBytes,The following statement contains a magic number: for (var count = 0; count < bytes.Length; count ++)              {                  if ((count%32) == 0)                  {                      WriteRaw(Environment.NewLine);                      WriteIndent();                  }                  else if ((count%8) == 0)                  {                      WriteRaw(" ");                  }                  var b = bytes[count];                  var h = (b & 0xf0) >> 4;                  var l = b & 0xf;                  _textWriter.Write(Hexs[h]);                  _textWriter.Write(Hexs[l]);                  _position += 2;              }
Magic Number,MsgReader.Rtf,Writer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Writer.cs,WriteBytes,The following statement contains a magic number: for (var count = 0; count < bytes.Length; count ++)              {                  if ((count%32) == 0)                  {                      WriteRaw(Environment.NewLine);                      WriteIndent();                  }                  else if ((count%8) == 0)                  {                      WriteRaw(" ");                  }                  var b = bytes[count];                  var h = (b & 0xf0) >> 4;                  var l = b & 0xf;                  _textWriter.Write(Hexs[h]);                  _textWriter.Write(Hexs[l]);                  _position += 2;              }
Magic Number,MsgReader.Rtf,Writer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Writer.cs,WriteByte,The following statement contains a magic number: var h = (b & 0xf0) >> 4;
Magic Number,MsgReader.Rtf,Writer,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Writer.cs,WriteByte,The following statement contains a magic number: _position += 2;
Missing Default,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Storage,The following switch statement is missing a default case: switch (fileAccess)              {                  case FileAccess.Read:                      accesMode = NativeMethods.STGM.READ;                      break;                    case FileAccess.Write:                  case FileAccess.ReadWrite:                      accesMode = NativeMethods.STGM.READWRITE;                      break;              }
Missing Default,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Storage,The following switch statement is missing a default case: switch (fileAccess)                  {                      case FileAccess.Read:                          accesMode = NativeMethods.STGM.READ;                          break;                        case FileAccess.Write:                      case FileAccess.ReadWrite:                          accesMode = NativeMethods.STGM.READWRITE;                          break;                  }
Missing Default,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,LoadStorage,The following switch statement is missing a default case: switch (elementStat.type)                      {                          case 1:                              // Element is a storage' add its statistics object to the storage dictionary                              _subStorageStatistics.Add(elementStat.pwcsName' elementStat);                              break;                            case 2:                              // Element is a stream' add its statistics object to the stream dictionary                              _streamStatistics.Add(elementStat.pwcsName' elementStat);                              break;                      }
Missing Default,MsgReader.Outlook,Storage,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,GetMapiPropertyFromPropertyStream,The following switch statement is missing a default case: switch (propType)                  {                      case PropertyType.PT_SHORT:                          return BitConverter.ToInt16(propBytes' i + 8);                        case PropertyType.PT_LONG:                          return BitConverter.ToInt32(propBytes' i + 8);                        case PropertyType.PT_DOUBLE:                          return BitConverter.ToDouble(propBytes' i + 8);                        case PropertyType.PT_SYSTIME:                          var fileTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromFileTime(fileTime);                        case PropertyType.PT_APPTIME:                          var appTime = BitConverter.ToInt64(propBytes' i + 8);                          return DateTime.FromOADate(appTime);                        case PropertyType.PT_BOOLEAN:                          return BitConverter.ToBoolean(propBytes' i + 8);                        //default:                      //throw new ApplicationException("MAPI property has an unsupported type and can not be retrieved.");                  }
Missing Default,MsgReader.Outlook,Appointment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Appointment.cs,Appointment,The following switch statement is missing a default case: switch (ReccurrenceType)                      {                          case AppointmentRecurrenceType.Daily:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeDailyText;                              break;                            case AppointmentRecurrenceType.Weekly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeWeeklyText;                              break;                            case AppointmentRecurrenceType.Montly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeMonthlyText;                              break;                            case AppointmentRecurrenceType.Yearly:                              RecurrenceTypeText = LanguageConsts.AppointmentReccurenceTypeYearlyText;                              break;                      }
Missing Default,MsgReader.Outlook,Attachment,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Attachment.cs,Attachment,The following switch statement is missing a default case: switch (attachmentMethod)                  {                      case MapiTags.ATTACH_BY_REFERENCE:                      case MapiTags.ATTACH_BY_REF_RESOLVE:                      case MapiTags.ATTACH_BY_REF_ONLY:                          ResolveAttachment();                          break;                        case MapiTags.ATTACH_OLE:                          var storage = GetMapiProperty(MapiTags.PR_ATTACH_DATA_BIN) as NativeMethods.IStorage;                          var attachmentOle = new Attachment(new Storage(storage)' null);                          _data = attachmentOle.GetStreamBytes("CONTENTS");                          if (_data != null)                          {                              var fileTypeInfo = FileTypeSelector.GetFileTypeFileInfo(Data);                                if (string.IsNullOrEmpty(FileName))                                  FileName = fileTypeInfo.Description;                                FileName += "." + fileTypeInfo.Extension.ToLower();                          }                          else                              // http://www.devsuperpage.com/search/Articles.aspx?G=10&ArtID=142729                              _data = attachmentOle.GetStreamBytes("\u0002OlePres000");                            if (_data != null)                          {                              try                              {                                  SaveImageAsPng(40);                              }                              catch (ArgumentException)                              {                                  SaveImageAsPng(0);                              }                          }                          else                              throw new MRUnknownAttachmentFormat("Can not read the attachment");                            OleAttachment = true;                          IsInline = true;                          break;                  }
Missing Default,MsgReader.Outlook,Message,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\Message.cs,GetEmailRecipients,The following switch statement is missing a default case: switch (type)                      {                          case Recipient.RecipientType.To:                              if (Headers.To != null)                                  recipients.AddRange(                                      Headers.To.Select(                                          to => new RecipientPlaceHolder(to.Address' to.DisplayName' string.Empty)));                              break;                            case Recipient.RecipientType.Cc:                              if (Headers.Cc != null)                                  recipients.AddRange(                                      Headers.Cc.Select(                                          cc => new RecipientPlaceHolder(cc.Address' cc.DisplayName' string.Empty)));                              break;                            case Recipient.RecipientType.Bcc:                              if (Headers.Bcc != null)                                  recipients.AddRange(                                      Headers.Bcc.Select(                                          bcc => new RecipientPlaceHolder(bcc.Address' bcc.DisplayName' string.Empty)));                              break;                      }
Missing Default,MsgReader.Outlook,RecipientRow,C:\repos\Sicos1977_msgreader\MsgReader\Outlook\UnsendableRecipients.cs,RecipientRow,The following switch statement is missing a default case: switch (AddressType)              {                  case AddressType.X500Dn:                      AddressPrefixUsed = binaryReader.ReadByte();                      DisplayType = (DisplayType) binaryReader.ReadByte();                      X500Dn = Strings.ReadNullTerminatedAsciiString(binaryReader);                      break;                    case AddressType.PersonalDistributionList1:                  case AddressType.PersonalDistributionList2:                      EntryIdSize = binaryReader.ReadUInt16();                      EntryId = new AddressBookEntryId(binaryReader);                      SearchKeySize = binaryReader.ReadUInt16();                      if (SearchKeySize > 0)                          SearchKey = binaryReader.ReadBytes((int) SearchKeySize);                      break;                    case AddressType.NoType:                      if (addressTypeIncluded) AddresType = Strings.ReadNullTerminatedAsciiString(binaryReader);                      break;              }
Missing Default,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,ExtractToFolder,The following switch statement is missing a default case: switch (extension)              {                  case ".EML":                      using (var stream = File.Open(inputFile' FileMode.Open' FileAccess.Read))                      {                          var message = Mime.Message.Load(stream);                          return WriteEmlEmail(message' outputFolder' hyperlinks).ToArray();                      }                    case ".MSG":                      using (var stream = File.Open(inputFile' FileMode.Open' FileAccess.Read))                      using (var message = new Storage.Message(stream))                      {                          switch (message.Type)                          {                              case Storage.Message.MessageType.Email:                              case Storage.Message.MessageType.EmailSms:                              case Storage.Message.MessageType.EmailNonDeliveryReport:                              case Storage.Message.MessageType.EmailDeliveryReport:                              case Storage.Message.MessageType.EmailDelayedDeliveryReport:                              case Storage.Message.MessageType.EmailReadReceipt:                              case Storage.Message.MessageType.EmailNonReadReceipt:                              case Storage.Message.MessageType.EmailEncryptedAndMaybeSigned:                              case Storage.Message.MessageType.EmailEncryptedAndMaybeSignedNonDelivery:                              case Storage.Message.MessageType.EmailEncryptedAndMaybeSignedDelivery:                              case Storage.Message.MessageType.EmailClearSignedReadReceipt:                              case Storage.Message.MessageType.EmailClearSignedNonDelivery:                              case Storage.Message.MessageType.EmailClearSignedDelivery:                              case Storage.Message.MessageType.EmailBmaStub:                              case Storage.Message.MessageType.CiscoUnityVoiceMessage:                              case Storage.Message.MessageType.EmailClearSigned:                              case Storage.Message.MessageType.RightFaxAdv:                              case Storage.Message.MessageType.SkypeForBusinessMissedMessage:                              case Storage.Message.MessageType.SkypeForBusinessConversation:                                  return WriteMsgEmail(message' outputFolder' hyperlinks).ToArray();                                //case Storage.Message.MessageType.EmailClearSigned:                              //    throw new MRFileTypeNotSupported("A clear signed message is not supported");                                case Storage.Message.MessageType.Appointment:                              case Storage.Message.MessageType.AppointmentNotification:                              case Storage.Message.MessageType.AppointmentSchedule:                              case Storage.Message.MessageType.AppointmentRequest:                              case Storage.Message.MessageType.AppointmentRequestNonDelivery:                              case Storage.Message.MessageType.AppointmentResponse:                              case Storage.Message.MessageType.AppointmentResponsePositive:                              case Storage.Message.MessageType.AppointmentResponsePositiveNonDelivery:                              case Storage.Message.MessageType.AppointmentResponseNegative:                              case Storage.Message.MessageType.AppointmentResponseNegativeNonDelivery:                              case Storage.Message.MessageType.AppointmentResponseTentative:                              case Storage.Message.MessageType.AppointmentResponseTentativeNonDelivery:                                  return WriteMsgAppointment(message' outputFolder' hyperlinks).ToArray();                                case Storage.Message.MessageType.Contact:                                  return WriteMsgContact(message' outputFolder' hyperlinks).ToArray();                                case Storage.Message.MessageType.Task:                              case Storage.Message.MessageType.TaskRequestAccept:                              case Storage.Message.MessageType.TaskRequestDecline:                              case Storage.Message.MessageType.TaskRequestUpdate:                                  return WriteMsgTask(message' outputFolder' hyperlinks).ToArray();                                                                case Storage.Message.MessageType.StickyNote:                                  return WriteMsgStickyNote(message' outputFolder).ToArray();                                case Storage.Message.MessageType.Unknown:                                  throw new MRFileTypeNotSupported("Unsupported message type");                          }                      }                        break;              }
Missing Default,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,ExtractToFolder,The following switch statement is missing a default case: switch (message.Type)                          {                              case Storage.Message.MessageType.Email:                              case Storage.Message.MessageType.EmailSms:                              case Storage.Message.MessageType.EmailNonDeliveryReport:                              case Storage.Message.MessageType.EmailDeliveryReport:                              case Storage.Message.MessageType.EmailDelayedDeliveryReport:                              case Storage.Message.MessageType.EmailReadReceipt:                              case Storage.Message.MessageType.EmailNonReadReceipt:                              case Storage.Message.MessageType.EmailEncryptedAndMaybeSigned:                              case Storage.Message.MessageType.EmailEncryptedAndMaybeSignedNonDelivery:                              case Storage.Message.MessageType.EmailEncryptedAndMaybeSignedDelivery:                              case Storage.Message.MessageType.EmailClearSignedReadReceipt:                              case Storage.Message.MessageType.EmailClearSignedNonDelivery:                              case Storage.Message.MessageType.EmailClearSignedDelivery:                              case Storage.Message.MessageType.EmailBmaStub:                              case Storage.Message.MessageType.CiscoUnityVoiceMessage:                              case Storage.Message.MessageType.EmailClearSigned:                              case Storage.Message.MessageType.RightFaxAdv:                              case Storage.Message.MessageType.SkypeForBusinessMissedMessage:                              case Storage.Message.MessageType.SkypeForBusinessConversation:                                  return WriteMsgEmail(message' outputFolder' hyperlinks).ToArray();                                //case Storage.Message.MessageType.EmailClearSigned:                              //    throw new MRFileTypeNotSupported("A clear signed message is not supported");                                case Storage.Message.MessageType.Appointment:                              case Storage.Message.MessageType.AppointmentNotification:                              case Storage.Message.MessageType.AppointmentSchedule:                              case Storage.Message.MessageType.AppointmentRequest:                              case Storage.Message.MessageType.AppointmentRequestNonDelivery:                              case Storage.Message.MessageType.AppointmentResponse:                              case Storage.Message.MessageType.AppointmentResponsePositive:                              case Storage.Message.MessageType.AppointmentResponsePositiveNonDelivery:                              case Storage.Message.MessageType.AppointmentResponseNegative:                              case Storage.Message.MessageType.AppointmentResponseNegativeNonDelivery:                              case Storage.Message.MessageType.AppointmentResponseTentative:                              case Storage.Message.MessageType.AppointmentResponseTentativeNonDelivery:                                  return WriteMsgAppointment(message' outputFolder' hyperlinks).ToArray();                                case Storage.Message.MessageType.Contact:                                  return WriteMsgContact(message' outputFolder' hyperlinks).ToArray();                                case Storage.Message.MessageType.Task:                              case Storage.Message.MessageType.TaskRequestAccept:                              case Storage.Message.MessageType.TaskRequestDecline:                              case Storage.Message.MessageType.TaskRequestUpdate:                                  return WriteMsgTask(message' outputFolder' hyperlinks).ToArray();                                                                case Storage.Message.MessageType.StickyNote:                                  return WriteMsgStickyNote(message' outputFolder).ToArray();                                case Storage.Message.MessageType.Unknown:                                  throw new MRFileTypeNotSupported("Unsupported message type");                          }
Missing Default,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteEmlStreamEmail,The following switch statement is missing a default case: switch (message.Headers.Importance)              {                  case MailPriority.Low:                      importanceText = LanguageConsts.ImportanceLowText;                      break;                    case MailPriority.Normal:                      importanceText = LanguageConsts.ImportanceNormalText;                      break;                    case MailPriority.High:                      importanceText = LanguageConsts.ImportanceHighText;                      break;              }
Missing Default,MsgReader,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Reader.cs,WriteEmlEmail,The following switch statement is missing a default case: switch (message.Headers.Importance)              {                  case MailPriority.Low:                      importanceText = LanguageConsts.ImportanceLowText;                      break;                    case MailPriority.Normal:                      importanceText = LanguageConsts.ImportanceNormalText;                      break;                    case MailPriority.High:                      importanceText = LanguageConsts.ImportanceHighText;                      break;              }
Missing Default,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteStartParagraph,The following switch statement is missing a default case: switch (info.Align)                  {                      case RtfAlignment.Left:                          Writer.WriteKeyword("ql");                          break;                        case RtfAlignment.Center:                          Writer.WriteKeyword("qc");                          break;                                            case RtfAlignment.Right:                          Writer.WriteKeyword("qr");                          break;                                            case RtfAlignment.Justify:                          Writer.WriteKeyword("qj");                          break;                  }
Missing Default,MsgReader.Rtf,DocumentWriter,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DocumentWriter.cs,WriteStartString,The following switch statement is missing a default case: switch (info.Align)              {                  case RtfAlignment.Left:                      Writer.WriteKeyword("ql");                      break;                                case RtfAlignment.Center:                      Writer.WriteKeyword("qc");                      break;                                    case RtfAlignment.Right:                      Writer.WriteKeyword("qr");                      break;                                   case RtfAlignment.Justify:                      Writer.WriteKeyword("qj");                      break;              }
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,Load,The following switch statement is missing a default case: switch (reader.Keyword)  										{  											case Consts.Sn:  												vName = ReadInnerText(reader' true);  												break;  											case Consts.Sv:  												vValue = ReadInnerText(reader' true);  												break;  										}
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadListOverrideTable,The following switch statement is missing a default case: switch (reader.CurrentToken.Key)  						{  							case Consts.ListId:  								record.ListId = reader.CurrentToken.Param;  								break;    							case Consts.ListOverrideCount:  								record.ListOverrideCount = reader.CurrentToken.Param;  								break;    							case Consts.Ls:  								record.Id = reader.CurrentToken.Param;  								break;  						}
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadListTable,The following switch statement is missing a default case: switch (reader.CurrentToken.Key)  						{  							case "listtemplateid":  								currentList.ListTemplateId = reader.CurrentToken.Param;  								break;    							case "listid":  								currentList.ListId = reader.CurrentToken.Param;  								break;    							case "listhybrid":  								currentList.ListHybrid = true;  								break;    							case "levelfollow":  								currentList.LevelFollow = reader.CurrentToken.Param;  								break;    							case "levelstartat":  								currentList.LevelStartAt = reader.CurrentToken.Param;  								break;    							case "levelnfc":  								if (currentList.LevelNfc == RtfLevelNumberType.None)  									currentList.LevelNfc = (RtfLevelNumberType)reader.CurrentToken.Param;  								break;    							case "levelnfcn":  								if (currentList.LevelNfc == RtfLevelNumberType.None)  									currentList.LevelNfc = (RtfLevelNumberType)reader.CurrentToken.Param;  								break;    							case "leveljc":  								currentList.LevelJc = reader.CurrentToken.Param;  								break;    							case "leveltext":  								if (string.IsNullOrEmpty(currentList.LevelText))  								{  									var text = ReadInnerText(reader' true);  									if (text != null && text.Length > 2)  									{  										int len = text[0];  										len = Math.Min(len' text.Length - 1);  										text = text.Substring(1' len);  									}  									currentList.LevelText = text;  								}  								break;    							case "f":  								currentList.FontName = FontTable.GetFontName(reader.CurrentToken.Param);  								break;  						}
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadColorTable,The following switch statement is missing a default case: switch (reader.Keyword)  				{  					case "red":  						r = reader.Parameter;  						break;  					case "green":  						g = reader.Parameter;  						break;  					case "blue":  						b = reader.Parameter;  						break;  					case ";":  						if (r >= 0 && g >= 0 && b >= 0)  						{  							var c = Color.FromArgb(255' r' g' b);  							ColorTable.Add(c);  							r = -1;  							g = -1;  							b = -1;  						}  						break;  				}
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadDateTime,The following switch statement is missing a default case: switch (reader.Keyword)  				{  					case "yr":  						yr = reader.Parameter;  						break;    					case "mo":  						mo = reader.Parameter;  						break;    					case "dy":  						dy = reader.Parameter;  						break;    					case "hr":  						hr = reader.Parameter;  						break;    					case "min":  						min = reader.Parameter;  						break;    					case "sec":  						sec = reader.Parameter;  						break;  				}
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadDomObject,The following switch statement is missing a default case: switch (reader.Keyword)  				{  					case Consts.Objautlink:  						domObject.Type = RtfObjectType.AutLink;  						break;    					case Consts.Objclass:  						domObject.ClassName = ReadInnerText(reader' true);  						break;    					case Consts.Objdata:  						var data = ReadInnerText(reader' true);  						domObject.Content = HexToBytes(data);  						break;    					case Consts.Objemb:  						domObject.Type = RtfObjectType.Emb;  						break;    					case Consts.Objh:  						domObject.Height = reader.Parameter;  						break;    					case Consts.Objhtml:  						domObject.Type = RtfObjectType.Html;  						break;    					case Consts.Objicemb:  						domObject.Type = RtfObjectType.Icemb;  						break;    					case Consts.Objlink:  						domObject.Type = RtfObjectType.Link;  						break;    					case Consts.Objname:  						domObject.Name = ReadInnerText(reader' true);  						break;    					case Consts.Objocx:  						domObject.Type = RtfObjectType.Ocx;  						break;    					case Consts.Objpub:  						domObject.Type = RtfObjectType.Pub;  						break;    					case Consts.Objsub:  						domObject.Type = RtfObjectType.Sub;  						break;    					case Consts.Objtime:  						break;    					case Consts.Objw:  						domObject.Width = reader.Parameter;  						break;    					case Consts.Objscalex:  						domObject.ScaleX = reader.Parameter;  						break;    					case Consts.Objscaley:  						domObject.ScaleY = reader.Parameter;  						break;    					case Consts.Result:  						var result = new ElementContainer { Name = Consts.Result };  						domObject.AppendChild(result);  						Load(reader' format);  						result.Locked = true;  						break;  				}
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadDomField,The following switch statement is missing a default case: switch (reader.Keyword)  					{  						case Consts.Flddirty:  							field.Method = RtfDomFieldMethod.Dirty;  							break;    						case Consts.Fldedit:  							field.Method = RtfDomFieldMethod.Edit;  							break;    						case Consts.Fldlock:  							field.Method = RtfDomFieldMethod.Lock;  							break;    						case Consts.Fldpriv:  							field.Method = RtfDomFieldMethod.Priv;  							break;    						case Consts.Fldrslt:  							var result = new ElementContainer { Name = Consts.Fldrslt };  							field.AppendChild(result);  							Load(reader' format);  							result.Locked = true;  							break;    						case Consts.Fldinst:  							var inst = new ElementContainer { Name = Consts.Fldinst };  							field.AppendChild(inst);  							Load(reader' format);  							inst.Locked = true;  							var txt = inst.InnerText;  							if (txt != null)  							{  								var index = txt.IndexOf(Consts.Hyperlink' StringComparison.Ordinal);  								if (index >= 0)  								{  									var index1 = txt.IndexOf('\"'' index);  									if (index1 > 0 && txt.Length > index1 + 2)  									{  										var index2 = txt.IndexOf('\"'' index1 + 2);  										if (index2 > index1)  										{  											var link = txt.Substring(index1 + 1' index2 - index1 - 1);  											if (format.Parent != null)  											{  												if (link.StartsWith("_Toc"))  													link = "#" + link;  												format.Parent.Link = link;  											}  										}  									}  								}  							}    							break;  					}
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadHtmlContent,The following switch statement is missing a default case: switch (reader.TokenType)  						{  							case RtfTokenType.Control:  								if (!htmlState)  								{                                      //if (spanTagWritten && reader.Keyword != "'")                                      //{                                      //    stringBuilder.Append("</span>");                                      //    spanTagWritten = false;                                      //    fontIndex = null;                                      //    fontSize = null;                                      //    encoding = _defaultEncoding;                                      //}                                        switch (reader.Keyword)  									{  										case "'":                                                //if (FontTable != null && fontIndex.HasValue && fontIndex <= FontTable.Count)                                              //{                                              //    // <span style = 'font-size:12.0pt;font-family:"Arial"'sans-serif' >                                              //    var font = FontTable[fontIndex.Value];                                              //    if (!spanTagWritten)                                              //    {                                              //        stringBuilder.Append("<span style = 'font-family:\"" + font.Name + "\";");                                              //        if (fontSize.HasValue)                                              //            stringBuilder.Append("font-size:" + fontSize + "pt");                                              //        stringBuilder.Append("'>");                                              //        spanTagWritten = true;                                              //        encoding = font.Encoding ?? _defaultEncoding;                                              //    }                                              //}    									        // Convert HEX value directly when we have a single byte charset  									        if (_defaultEncoding.IsSingleByte )  									        {  									            if (string.IsNullOrEmpty(hexBuffer))  									                hexBuffer = reader.CurrentToken.Hex;                                                    var buff = new[] { byte.Parse(hexBuffer' NumberStyles.HexNumber) };                                                  hexBuffer = string.Empty;                                                  stringBuilder.Append(encoding.GetString(buff));                                              }  									        else  									        {  									            // If we have a double byte charset like chinese then store the value and wait for the next HEX value  									            if (hexBuffer == string.Empty)  									                hexBuffer = reader.CurrentToken.Hex;  									            else  									            {  									                // Append the second HEX value and convert it   									                var buff = new[]  									                {  									                    byte.Parse(hexBuffer' NumberStyles.HexNumber)'  									                    byte.Parse(reader.CurrentToken.Hex' NumberStyles.HexNumber)  									                };    									                stringBuilder.Append(encoding.GetString(buff));    									                // Empty the HEX buffer   									                hexBuffer = string.Empty;  									            }  									        }  									        break;                                                //case "u":                                              //    stringBuilder.Append(HttpUtility.UrlDecode("*"' _defaultEncoding));                                              //    break;                                      }                                  }  								break;    							case RtfTokenType.ExtKeyword:  							case RtfTokenType.Keyword:    								if (!htmlState)  								{  									switch (reader.Keyword)  									{  										case Consts.Par:  											stringBuilder.Append(Environment.NewLine);  											break;    										case Consts.Line:  											stringBuilder.Append(Environment.NewLine);  											break;    										case Consts.Tab:  											stringBuilder.Append("\t");  											break;    										case Consts.Lquote:  											stringBuilder.Append("&lsquo;");  											break;    										case Consts.Rquote:  											stringBuilder.Append("&rsquo;");  											break;    										case Consts.LdblQuote:  											stringBuilder.Append("&ldquo;");  											break;    										case Consts.RdblQuote:  											stringBuilder.Append("&rdquo;");  											break;    										case Consts.Bullet:  											stringBuilder.Append("&bull;");  											break;    										case Consts.Endash:  											stringBuilder.Append("&ndash;");  											break;    										case Consts.Emdash:  											stringBuilder.Append("&mdash;");  											break;    										case Consts.Tilde:  											stringBuilder.Append("&nbsp;");  											break;    										case Consts.Underscore:  											stringBuilder.Append("&shy;");  											break;    										case Consts.U:  											stringBuilder.Append("&#" + reader.Parameter + ";");  											break;  									}  								}  								break;    							case RtfTokenType.Text:  								if (htmlState == false)  									stringBuilder.Append(reader.Keyword);  								break;  						}
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadHtmlContent,The following switch statement is missing a default case: switch (reader.Keyword)  									{  										case "'":                                                //if (FontTable != null && fontIndex.HasValue && fontIndex <= FontTable.Count)                                              //{                                              //    // <span style = 'font-size:12.0pt;font-family:"Arial"'sans-serif' >                                              //    var font = FontTable[fontIndex.Value];                                              //    if (!spanTagWritten)                                              //    {                                              //        stringBuilder.Append("<span style = 'font-family:\"" + font.Name + "\";");                                              //        if (fontSize.HasValue)                                              //            stringBuilder.Append("font-size:" + fontSize + "pt");                                              //        stringBuilder.Append("'>");                                              //        spanTagWritten = true;                                              //        encoding = font.Encoding ?? _defaultEncoding;                                              //    }                                              //}    									        // Convert HEX value directly when we have a single byte charset  									        if (_defaultEncoding.IsSingleByte )  									        {  									            if (string.IsNullOrEmpty(hexBuffer))  									                hexBuffer = reader.CurrentToken.Hex;                                                    var buff = new[] { byte.Parse(hexBuffer' NumberStyles.HexNumber) };                                                  hexBuffer = string.Empty;                                                  stringBuilder.Append(encoding.GetString(buff));                                              }  									        else  									        {  									            // If we have a double byte charset like chinese then store the value and wait for the next HEX value  									            if (hexBuffer == string.Empty)  									                hexBuffer = reader.CurrentToken.Hex;  									            else  									            {  									                // Append the second HEX value and convert it   									                var buff = new[]  									                {  									                    byte.Parse(hexBuffer' NumberStyles.HexNumber)'  									                    byte.Parse(reader.CurrentToken.Hex' NumberStyles.HexNumber)  									                };    									                stringBuilder.Append(encoding.GetString(buff));    									                // Empty the HEX buffer   									                hexBuffer = string.Empty;  									            }  									        }  									        break;                                                //case "u":                                              //    stringBuilder.Append(HttpUtility.UrlDecode("*"' _defaultEncoding));                                              //    break;                                      }
Missing Default,MsgReader.Rtf,DomDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\DomDocument.cs,ReadHtmlContent,The following switch statement is missing a default case: switch (reader.Keyword)  									{  										case Consts.Par:  											stringBuilder.Append(Environment.NewLine);  											break;    										case Consts.Line:  											stringBuilder.Append(Environment.NewLine);  											break;    										case Consts.Tab:  											stringBuilder.Append("\t");  											break;    										case Consts.Lquote:  											stringBuilder.Append("&lsquo;");  											break;    										case Consts.Rquote:  											stringBuilder.Append("&rsquo;");  											break;    										case Consts.LdblQuote:  											stringBuilder.Append("&ldquo;");  											break;    										case Consts.RdblQuote:  											stringBuilder.Append("&rdquo;");  											break;    										case Consts.Bullet:  											stringBuilder.Append("&bull;");  											break;    										case Consts.Endash:  											stringBuilder.Append("&ndash;");  											break;    										case Consts.Emdash:  											stringBuilder.Append("&mdash;");  											break;    										case Consts.Tilde:  											stringBuilder.Append("&nbsp;");  											break;    										case Consts.Underscore:  											stringBuilder.Append("&shy;");  											break;    										case Consts.U:  											stringBuilder.Append("&#" + reader.Parameter + ";");  											break;  									}
Missing Default,MsgReader.Rtf,Node,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Node.cs,Write,The following switch statement is missing a default case: switch (Type)              {                  case RtfNodeType.ExtKeyword:                  case RtfNodeType.Keyword:                  case RtfNodeType.Control:                        if (HasParameter)                          writer.WriteKeyword(InternalKeyword + Parameter' Type == RtfNodeType.ExtKeyword);                      else                          writer.WriteKeyword(InternalKeyword' Type == RtfNodeType.ExtKeyword);                      break;                                    case RtfNodeType.Text:                      writer.WriteText(InternalKeyword);                      break;              }
Missing Default,MsgReader.Rtf,RawDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\RawDocument.cs,Load,The following switch statement is missing a default case: switch (newGroup.Keyword)                          {                              case Consts.Fonttbl:                                  // Read font table                                  ReadFontTable(newGroup);                                  break;                                case Consts.Colortbl:                                  // Read color table                                  ReadColorTable(newGroup);                                  break;                                case Consts.Info:                                  // Read document information                                  ReadDocumentInfo(newGroup);                                  break;                          }
Missing Default,MsgReader.Rtf,RawDocument,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\RawDocument.cs,Load,The following switch statement is missing a default case: switch (newNode.Keyword)                      {                          case Consts.F:                          {                              var font = FontTable[newNode.Parameter];                              _fontChartset = font != null ? font.Encoding : null;                              //myFontChartset = RTFFont.GetRTFEncoding( NewNode.Parameter );                          }                              break;                            case Consts.Af:                          {                              var font = FontTable[newNode.Parameter];                              _associatedFontChartset = font != null ? font.Encoding : null;                          }                              break;                        }
Missing Default,MsgReader.Rtf,Reader,C:\repos\Sicos1977_msgreader\MsgReader\Rtf\Reader.cs,DefaultProcess,The following switch statement is missing a default case: switch (CurrentToken.Key)              {                  case "uc":                      CurrentLayerInfo.UcValue = Parameter;                      break;  				case "u":  		            if (InnerReader.Peek() == '?')  			            InnerReader.Read();  		            break;              }
