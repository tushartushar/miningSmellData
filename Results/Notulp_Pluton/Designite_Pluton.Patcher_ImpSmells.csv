Implementation smell,Namespace,Class,File,Method,Description
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The method has 109 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemantic,The method has 105 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupMerge,The method has 125 lines of code.
Complex Method,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,Main,Cyclomatic complexity of the method is 12
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,Cyclomatic complexity of the method is 12
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemantic,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemanticLossless,Cyclomatic complexity of the method is 9
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupMerge,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,match_bitap,Cyclomatic complexity of the method is 13
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_make,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_splitMax,Cyclomatic complexity of the method is 11
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_fromText,Cyclomatic complexity of the method is 8
Long Parameter List,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisectSplit,The method has 5 parameters. Parameters: text1' text2' x' y' deadline
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,BootstrapAttachPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + initConfig.FriendlyName + ".html"' initConfig.PrintAndLink(attachBootstrap)); " is 135.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,BeingHammeredPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + doAttackShared.FriendlyName + ".html"' doAttackShared.PrintAndLink(beingHammered)); " is 141.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ClientAuthPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + approve.FriendlyName + ".html"' approve.PrintAndLink(onClientAuth)); " is 126.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ClientConsoleCommandPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + onClientCommand.FriendlyName + ".html"' onClientCommand.PrintAndLink(onClientConsoleHook)); " is 149.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,BuildingBlockDemolishedPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + doDemolish.FriendlyName + ".html"' doDemolish.PrintAndLink(bpDemolishedHook)); " is 136.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,BuildingBlockDemolishedPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + doImmediateDemolish.FriendlyName + ".html"' doImmediateDemolish.PrintAndLink(bpDemolishedHook)); " is 154.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,CraftingStartPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + craftItem.FriendlyName + ".html"' craftItem.PrintAndLink(onPlayerStartCraftingHook)); " is 143.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,DoPlacementPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + createConstruction.FriendlyName + ".html"' createConstruction.PrintAndLink(onPlacement)); " is 147.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,DoorCodePatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + unlockWithCode.FriendlyName + ".html"' unlockWithCode.PrintAndLink(ondoorCode)); " is 138.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,DoUpgradeToGradePatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + doupgradetograde.FriendlyName + ".html"' doupgradetograde.PrintAndLink(onbuildingpartgradechange)); " is 157.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,EventTriggeredPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + runevent.FriendlyName + ".html"' runevent.PrintAndLink(oneventtriggered)); " is 132.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,NetworkableKillPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + networkableKill.FriendlyName + ".html"' networkableKill.PrintAndLink(onNetworkableKilled)); " is 149.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,NPCDiedPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + npcKilled.FriendlyName + ".html"' npcKilled.PrintAndLink(onNPCDied)); " is 127.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerConnectedPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + basePlayerInit.FriendlyName + ".html"' basePlayerInit.PrintAndLink(onPlayerConnected)); " is 145.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerDiedPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + basePlayerDie.FriendlyName + ".html"' basePlayerDie.PrintAndLink(onPlayerDied)); " is 138.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerDisconnectedPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + basePlayerDisconnected.FriendlyName + ".html"' basePlayerDisconnected.PrintAndLink(onPlayerDisconnected)); " is 164.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerTakeRadiationPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + updateRadiation.FriendlyName + ".html"' updateRadiation.PrintAndLink(onPlayerTakeRadiation)); " is 151.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerStartLootingPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + plEntity.FriendlyName + ".html"' plEntity.PrintAndLink(lootEntity)); " is 126.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerStartLootingPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + plPlayer.FriendlyName + ".html"' plPlayer.PrintAndLink(lootPlayer)); " is 126.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerStartLootingPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + plItem.FriendlyName + ".html"' plItem.PrintAndLink(lootItem)); " is 120.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,RespawnPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + respawnAt.FriendlyName + ".html"' respawnAt.PrintAndLink(respawn)); " is 125.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ServerConsoleCommandPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + serverCmd.FriendlyName + ".html"' serverCmd.PrintAndLink(onServerConsole)); " is 133.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ShootEvent,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + baseProjCLProject.FriendlyName + ".html"' baseProjCLProject.PrintAndLink(onShoot)); " is 141.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ItemUsed,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + useItem.FriendlyName + ".html"' useItem.PrintAndLink(onItemUsed)); " is 124.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,Mining,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + processResource.FriendlyName + ".html"' processResource.PrintAndLink(processResourceHook)); " is 149.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,WeaponThrown,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + doThrow.FriendlyName + ".html"' doThrow.PrintAndLink(onThrowing)); " is 124.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,RocketShootEvent,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + baseLauncherSVLaunch.FriendlyName + ".html"' baseLauncherSVLaunch.PrintAndLink(onRocketShoot)); " is 153.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ConsumeFuel,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + consumeFuel.FriendlyName + ".html"' consumeFuel.PrintAndLink(onConsumeFuel)); " is 135.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ItemPickup,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + pickupCollectable.FriendlyName + ".html"' pickupCollectable.PrintAndLink(method)); " is 140.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerSleep,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + startSleeping.FriendlyName + ".html"' startSleeping.PrintAndLink(onPlayerSleep)); " is 139.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerWakeUp,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + endSleeping.FriendlyName + ".html"' endSleeping.PrintAndLink(onPlayerWakeUp)); " is 136.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerLoaded,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + enterGame.FriendlyName + ".html"' enterGame.PrintAndLink(onPlayerLoaded)); " is 132.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerWounded,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + basePlayerWound.FriendlyName + ".html"' basePlayerWound.PrintAndLink(onPlayerWounded)); " is 145.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerAssisted,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + woundAssist.FriendlyName + ".html"' woundAssist.PrintAndLink(onPlayerAssisted)); " is 138.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ItemRepaired,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + repairItem.FriendlyName + ".html"' repairItem.PrintAndLink(onItemRepaired)); " is 134.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerSyringeSelf,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + syringeSelf.FriendlyName + ".html"' syringeSelf.PrintAndLink(onPlayerSyringeSelf)); " is 141.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerSyringeOther,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + syringeOther.FriendlyName + ".html"' syringeOther.PrintAndLink(onPlayerSyringeOther)); " is 144.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerHealthChange,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + hpChanged.FriendlyName + ".html"' hpChanged.PrintAndLink(onPlayerhpChanged)); " is 135.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerClothingChanged,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + onClothingChanged.FriendlyName + ".html"' onClothingChanged.PrintAndLink(onPlayerClothingChanged)); " is 157.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ItemLoseCondition,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + loseCondition.FriendlyName + ".html"' loseCondition.PrintAndLink(onItemLoseCondition)); " is 145.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,LandmineArmed,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + armLandmine.FriendlyName + ".html"' armLandmine.PrintAndLink(onLandmineArmed)); " is 137.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,LandmineExploded,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + landmineExplode.FriendlyName + ".html"' landmineExplode.PrintAndLink(onLandmineExploded)); " is 148.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,LandmineTriggered,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + landmineTrigger.FriendlyName + ".html"' landmineTrigger.PrintAndLink(onLandmineTriggered)); " is 149.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ServerInitPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + srvMgrInit.FriendlyName + ".html"' srvMgrInit.PrintAndLink(onServerInit)); " is 132.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ServerSavedPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + doAutomatedSave.FriendlyName + ".html"' doAutomatedSave.PrintAndLink(onServerSaved)); " is 143.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ServerShutdownPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + srvMrgDisable.FriendlyName + ".html"' srvMrgDisable.PrintAndLink(onServerShutdown)); " is 142.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,SetModdedPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + srvMgrUpdateInfo.FriendlyName + ".html"' srvMgrUpdateInfo.PrintAndLink(setModded)); " is 141.
Long Statement,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,GiveItemsPatch,The length of the statement  "                File.WriteAllText("diffs" + Path.DirectorySeparatorChar + giveResFromItem.FriendlyName + ".html"' giveResFromItem.PrintAndLink(onGather)); " is 138.
Long Statement,Pluton.Patcher.Reflection,MethodPatcher,C:\repos\Notulp_Pluton\Pluton.Patcher\Pluton.Patcher\Reflection\MethodPatcher.cs,InsertCallBeforeRet,The length of the statement  "            return InsertBefore(IlProc.Body.Instructions[IlProc.Body.Instructions.Count - 1]' Instruction.Create(OpCodes.Call' rootAssemblyPatcher.ImportMethod(method))); " is 158.
Long Statement,Pluton.Patcher.Reflection,MethodPatcher,C:\repos\Notulp_Pluton\Pluton.Patcher\Pluton.Patcher\Reflection\MethodPatcher.cs,PrintAndLink,The length of the statement  "                otherPrint = other.methodDefinition.PrintCSharp().Replace("\""' "\\'").TrimEnd('\\').Replace("\r\n"' ".enter.").Replace("\t"' ".tab.").Replace("//"' "##"); " is 155.
Long Statement,Pluton.Patcher.Reflection,MethodPatcher,C:\repos\Notulp_Pluton\Pluton.Patcher\Pluton.Patcher\Reflection\MethodPatcher.cs,PrintAndLink,The length of the statement  "                    .Replace(other.FriendlyName' "<a href=\"javascript:void(0);\" onclick=\"hatemlPopUp('" + otherPrint + "')\">" + other.FriendlyName + "</a>") " is 140.
Long Statement,Pluton.Patcher.Reflection,MethodPatcher,C:\repos\Notulp_Pluton\Pluton.Patcher\Pluton.Patcher\Reflection\MethodPatcher.cs,PrintAndLink,The length of the statement  "                    .Replace(other.IlName'       "<a href=\"javascript:void(0);\" onclick=\"hatemlPopUp('" + otherPrint + "')\">" + other.IlName       + "</a>"); " is 141.
Long Statement,Pluton.Patcher.Reflection,AssemblyPatcher,C:\repos\Notulp_Pluton\Pluton.Patcher\Pluton.Patcher\Reflection\AssemblyPatcher.cs,CreateType,The length of the statement  "            TypeDefinition plutonClass = new TypeDefinition(@namespace' name' TypeAttributes.Public' mainModule.Import(typeof(Object))); " is 124.
Complex Conditional,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupEfficiency,The conditional expression  "(lastequality.Length != 0)                          && ((pre_ins && pre_del && post_ins && post_del)                              || ((lastequality.Length < this.Diff_EditCost / 2)                                  && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0)                                      + (post_del ? 1 : 0)) == 3))"  is complex.
Complex Conditional,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_splitMax,The conditional expression  "diff_type == Operation.DELETE && patch.diffs.Count == 1                              && patch.diffs.First().operation == Operation.EQUAL                              && diff_text.Length > 2 * patch_size"  is complex.
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,BeingHammeredPatch,The following statement contains a magic number: doAttackShared.InsertAfter(11' Instruction.Create(OpCodes.Ldarg_1))                  .InsertAfter(12' Instruction.Create(OpCodes.Ldarg_0))                  .InsertCallAfter(13' getOwnerP)                  .InsertCallAfter(14' beingHammered);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,BeingHammeredPatch,The following statement contains a magic number: doAttackShared.InsertAfter(11' Instruction.Create(OpCodes.Ldarg_1))                  .InsertAfter(12' Instruction.Create(OpCodes.Ldarg_0))                  .InsertCallAfter(13' getOwnerP)                  .InsertCallAfter(14' beingHammered);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,BeingHammeredPatch,The following statement contains a magic number: doAttackShared.InsertAfter(11' Instruction.Create(OpCodes.Ldarg_1))                  .InsertAfter(12' Instruction.Create(OpCodes.Ldarg_0))                  .InsertCallAfter(13' getOwnerP)                  .InsertCallAfter(14' beingHammered);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,BeingHammeredPatch,The following statement contains a magic number: doAttackShared.InsertAfter(11' Instruction.Create(OpCodes.Ldarg_1))                  .InsertAfter(12' Instruction.Create(OpCodes.Ldarg_0))                  .InsertCallAfter(13' getOwnerP)                  .InsertCallAfter(14' beingHammered);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ClientConsoleCommandPatch,The following statement contains a magic number: onClientCommand.RemoveRange(14' 19)                  .InsertAfter(10' Instruction.Create(OpCodes.Ldloc_1))                  .InsertAfter(11' Instruction.Create(OpCodes.Ldloc_0))                  .InsertCallAfter(12' onClientConsoleHook);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ClientConsoleCommandPatch,The following statement contains a magic number: onClientCommand.RemoveRange(14' 19)                  .InsertAfter(10' Instruction.Create(OpCodes.Ldloc_1))                  .InsertAfter(11' Instruction.Create(OpCodes.Ldloc_0))                  .InsertCallAfter(12' onClientConsoleHook);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ClientConsoleCommandPatch,The following statement contains a magic number: onClientCommand.RemoveRange(14' 19)                  .InsertAfter(10' Instruction.Create(OpCodes.Ldloc_1))                  .InsertAfter(11' Instruction.Create(OpCodes.Ldloc_0))                  .InsertCallAfter(12' onClientConsoleHook);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ClientConsoleCommandPatch,The following statement contains a magic number: onClientCommand.RemoveRange(14' 19)                  .InsertAfter(10' Instruction.Create(OpCodes.Ldloc_1))                  .InsertAfter(11' Instruction.Create(OpCodes.Ldloc_0))                  .InsertCallAfter(12' onClientConsoleHook);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ClientConsoleCommandPatch,The following statement contains a magic number: onClientCommand.RemoveRange(14' 19)                  .InsertAfter(10' Instruction.Create(OpCodes.Ldloc_1))                  .InsertAfter(11' Instruction.Create(OpCodes.Ldloc_0))                  .InsertCallAfter(12' onClientConsoleHook);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,CraftingStartPatch,The following statement contains a magic number: craftItem.Clear()                  .Append(Instruction.Create(OpCodes.Nop))                  .Append(Instruction.Create(OpCodes.Ldarg_0))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[0]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[1]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[2]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[3]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[4]))                  .AppendCall(onPlayerStartCraftingHook)                  .Append(Instruction.Create(OpCodes.Ret));
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,CraftingStartPatch,The following statement contains a magic number: craftItem.Clear()                  .Append(Instruction.Create(OpCodes.Nop))                  .Append(Instruction.Create(OpCodes.Ldarg_0))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[0]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[1]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[2]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[3]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[4]))                  .AppendCall(onPlayerStartCraftingHook)                  .Append(Instruction.Create(OpCodes.Ret));
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,CraftingStartPatch,The following statement contains a magic number: craftItem.Clear()                  .Append(Instruction.Create(OpCodes.Nop))                  .Append(Instruction.Create(OpCodes.Ldarg_0))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[0]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[1]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[2]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[3]))                  .Append(Instruction.Create(OpCodes.Ldarg' craftItem.IlProc.Body.Method.Parameters[4]))                  .AppendCall(onPlayerStartCraftingHook)                  .Append(Instruction.Create(OpCodes.Ret));
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,NetworkableKillPatch,The following statement contains a magic number: networkableKill.InsertAfter(networkableKill.IlProc.Body.Instructions.Count - 13' Instruction.Create(OpCodes.Ldarg_0))                  .InsertCallAfter(networkableKill.IlProc.Body.Instructions.Count - 13' onNetworkableKilled);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,NetworkableKillPatch,The following statement contains a magic number: networkableKill.InsertAfter(networkableKill.IlProc.Body.Instructions.Count - 13' Instruction.Create(OpCodes.Ldarg_0))                  .InsertCallAfter(networkableKill.IlProc.Body.Instructions.Count - 13' onNetworkableKilled);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,NPCDiedPatch,The following statement contains a magic number: npcKilled.InsertBefore(0' Instruction.Create(OpCodes.Ldarg_0))                  .InsertBefore(1' Instruction.Create(OpCodes.Ldarg_1))                  .InsertCallBefore(2' onNPCDied);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerConnectedPatch,The following statement contains a magic number: basePlayerInit.InsertBefore(basePlayerInit.IlProc.Body.Instructions.Count - 29' Instruction.Create(OpCodes.Ldarg_0))                  .InsertCallBefore(basePlayerInit.IlProc.Body.Instructions.Count - 29' onPlayerConnected);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,PlayerConnectedPatch,The following statement contains a magic number: basePlayerInit.InsertBefore(basePlayerInit.IlProc.Body.Instructions.Count - 29' Instruction.Create(OpCodes.Ldarg_0))                  .InsertCallBefore(basePlayerInit.IlProc.Body.Instructions.Count - 29' onPlayerConnected);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ServerConsoleCommandPatch,The following statement contains a magic number: var serverCmd = consoleSystemRealm.GetMethod(methods => {                  return (from method in methods                      where method.Parameters.Count == 3 && method.Name == "Normal"                      select method).FirstOrDefault();              });
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ServerConsoleCommandPatch,The following statement contains a magic number: serverCmd.InsertAfter(12' Instruction.Create(OpCodes.Ldloc_1));
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ServerConsoleCommandPatch,The following statement contains a magic number: serverCmd.InsertAfter(13' Instruction.Create(OpCodes.Ldarg_2));
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ServerConsoleCommandPatch,The following statement contains a magic number: serverCmd.InsertCallAfter(14' onServerConsole);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,RocketShootEvent,The following statement contains a magic number: baseLauncherSVLaunch.InsertBeforeRet(Instruction.Create(OpCodes.Ldarg_0))                  .InsertBeforeRet(Instruction.Create(OpCodes.Ldarg_1))                  .InsertBeforeRet(Instruction.Create(OpCodes.Ldloc_S' baseLauncherSVLaunch.IlProc.Body.Variables[7]))                  .InsertCallBeforeRet(onRocketShoot);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ItemPickup,The following statement contains a magic number: int Position = pickupCollectable.IlProc.Body.Instructions.Count - 36;
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ItemPickup,The following statement contains a magic number: pickupCollectable.InsertCallBefore(Position' method)                  .InsertBefore(Position' Instruction.Create(OpCodes.Ldloc_S' pickupCollectable.IlProc.Body.Variables[3]))                  .InsertBefore(Position' Instruction.Create(OpCodes.Ldarg_1))                  .InsertBefore(Position' Instruction.Create(OpCodes.Ldarg_0));
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,InventoryModificationPatch,The following statement contains a magic number: int Position = Insert.IlProc.Body.Instructions.Count - 2;
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,InventoryModificationPatch,The following statement contains a magic number: int Position2 = Remove.IlProc.Body.Instructions.Count - 2;
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ItemLoseCondition,The following statement contains a magic number: int Position = loseCondition.IlProc.Body.Instructions.Count - 10;
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,LandmineExploded,The following statement contains a magic number: int Position = landmineExplode.IlProc.Body.Instructions.Count - 7;
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,ServerSavedPatch,The following statement contains a magic number: doAutomatedSave.InsertCallBefore(doAutomatedSave.IlProc.Body.Instructions.Count - 2' onServerSaved);
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,GiveItemsPatch,The following statement contains a magic number: giveResFromItem.Clear()                  .Append(Instruction.Create(OpCodes.Nop))                  .Append(Instruction.Create(OpCodes.Ldarg_0))                  .Append(Instruction.Create(OpCodes.Ldarg' giveResFromItem.IlProc.Body.Method.Parameters[0]))                  .Append(Instruction.Create(OpCodes.Ldarg' giveResFromItem.IlProc.Body.Method.Parameters[1]))                  .Append(Instruction.Create(OpCodes.Ldarg' giveResFromItem.IlProc.Body.Method.Parameters[2]))                  .Append(Instruction.Create(OpCodes.Ldarg' giveResFromItem.IlProc.Body.Method.Parameters[3]))                  .AppendCall(onGather)                  .Append(Instruction.Create(OpCodes.Ret));
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,GiveItemsPatch,The following statement contains a magic number: giveResFromItem.Clear()                  .Append(Instruction.Create(OpCodes.Nop))                  .Append(Instruction.Create(OpCodes.Ldarg_0))                  .Append(Instruction.Create(OpCodes.Ldarg' giveResFromItem.IlProc.Body.Method.Parameters[0]))                  .Append(Instruction.Create(OpCodes.Ldarg' giveResFromItem.IlProc.Body.Method.Parameters[1]))                  .Append(Instruction.Create(OpCodes.Ldarg' giveResFromItem.IlProc.Body.Method.Parameters[2]))                  .Append(Instruction.Create(OpCodes.Ldarg' giveResFromItem.IlProc.Body.Method.Parameters[3]))                  .AppendCall(onGather)                  .Append(Instruction.Create(OpCodes.Ret));
Magic Number,Pluton.Patcher,MainClass,C:\repos\Notulp_Pluton\Pluton.Patcher\Program.cs,Main,The following statement contains a magic number: if (interactive)                  System.Threading.Thread.Sleep(250);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: if (this.Diff_Timeout <= 0) {                  deadline = DateTime.MaxValue;              } else {                  deadline = DateTime.Now +                      new TimeSpan(((long)(Diff_Timeout * 1000)) * 10000);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: if (this.Diff_Timeout <= 0) {                  deadline = DateTime.MaxValue;              } else {                  deadline = DateTime.Now +                      new TimeSpan(((long)(Diff_Timeout * 1000)) * 10000);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null) {                  // A half-match was found' sort out the return data.                  string text1_a = hm[0];                  string text1_b = hm[1];                  string text2_a = hm[2];                  string text2_b = hm[3];                  string mid_common = hm[4];                  // Send both pairs off for separate processing.                  List<Diff> diffs_a = diff_main(text1_a' text2_a' checklines' deadline);                  List<Diff> diffs_b = diff_main(text1_b' text2_b' checklines' deadline);                  // Merge the results.                  diffs = diffs_a;                  diffs.Add(new Diff(Operation.EQUAL' mid_common));                  diffs.AddRange(diffs_b);                  return diffs;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null) {                  // A half-match was found' sort out the return data.                  string text1_a = hm[0];                  string text1_b = hm[1];                  string text2_a = hm[2];                  string text2_b = hm[3];                  string mid_common = hm[4];                  // Send both pairs off for separate processing.                  List<Diff> diffs_a = diff_main(text1_a' text2_a' checklines' deadline);                  List<Diff> diffs_b = diff_main(text1_b' text2_b' checklines' deadline);                  // Merge the results.                  diffs = diffs_a;                  diffs.Add(new Diff(Operation.EQUAL' mid_common));                  diffs.AddRange(diffs_b);                  return diffs;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null) {                  // A half-match was found' sort out the return data.                  string text1_a = hm[0];                  string text1_b = hm[1];                  string text2_a = hm[2];                  string text2_b = hm[3];                  string mid_common = hm[4];                  // Send both pairs off for separate processing.                  List<Diff> diffs_a = diff_main(text1_a' text2_a' checklines' deadline);                  List<Diff> diffs_b = diff_main(text1_b' text2_b' checklines' deadline);                  // Merge the results.                  diffs = diffs_a;                  diffs.Add(new Diff(Operation.EQUAL' mid_common));                  diffs.AddRange(diffs_b);                  return diffs;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (checklines && text1.Length > 100 && text2.Length > 100) {                  return diff_lineMode(text1' text2' deadline);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (checklines && text1.Length > 100 && text2.Length > 100) {                  return diff_lineMode(text1' text2' deadline);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_lineMode,The following statement contains a magic number: List<string> linearray = (List<string>)b[2];
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: int max_d = (text1_length + text2_length + 1) / 2;
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: int v_length = 2 * max_d;
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: bool front = (delta % 2 != 0);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline) {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {                          x1 = v1[k1_offset + 1];                      } else {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length                          && text1[x1] == text2[y1]) {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length) {                          // Ran off the right of the graph.                          k1end += 2;                      } else if (y1 > text2_length) {                          // Ran off the bottom of the graph.                          k1start += 2;                      } else if (front) {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {                          x2 = v2[k2_offset + 1];                      } else {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length                          && text1[text1_length - x2 - 1]                          == text2[text2_length - y2 - 1]) {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length) {                          // Ran off the left of the graph.                          k2end += 2;                      } else if (y2 > text2_length) {                          // Ran off the top of the graph.                          k2start += 2;                      } else if (!front) {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline) {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {                          x1 = v1[k1_offset + 1];                      } else {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length                          && text1[x1] == text2[y1]) {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length) {                          // Ran off the right of the graph.                          k1end += 2;                      } else if (y1 > text2_length) {                          // Ran off the bottom of the graph.                          k1start += 2;                      } else if (front) {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {                          x2 = v2[k2_offset + 1];                      } else {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length                          && text1[text1_length - x2 - 1]                          == text2[text2_length - y2 - 1]) {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length) {                          // Ran off the left of the graph.                          k2end += 2;                      } else if (y2 > text2_length) {                          // Ran off the top of the graph.                          k2start += 2;                      } else if (!front) {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline) {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {                          x1 = v1[k1_offset + 1];                      } else {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length                          && text1[x1] == text2[y1]) {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length) {                          // Ran off the right of the graph.                          k1end += 2;                      } else if (y1 > text2_length) {                          // Ran off the bottom of the graph.                          k1start += 2;                      } else if (front) {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {                          x2 = v2[k2_offset + 1];                      } else {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length                          && text1[text1_length - x2 - 1]                          == text2[text2_length - y2 - 1]) {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length) {                          // Ran off the left of the graph.                          k2end += 2;                      } else if (y2 > text2_length) {                          // Ran off the top of the graph.                          k2start += 2;                      } else if (!front) {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline) {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {                          x1 = v1[k1_offset + 1];                      } else {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length                          && text1[x1] == text2[y1]) {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length) {                          // Ran off the right of the graph.                          k1end += 2;                      } else if (y1 > text2_length) {                          // Ran off the bottom of the graph.                          k1start += 2;                      } else if (front) {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {                          x2 = v2[k2_offset + 1];                      } else {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length                          && text1[text1_length - x2 - 1]                          == text2[text2_length - y2 - 1]) {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length) {                          // Ran off the left of the graph.                          k2end += 2;                      } else if (y2 > text2_length) {                          // Ran off the top of the graph.                          k2start += 2;                      } else if (!front) {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline) {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {                          x1 = v1[k1_offset + 1];                      } else {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length                          && text1[x1] == text2[y1]) {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length) {                          // Ran off the right of the graph.                          k1end += 2;                      } else if (y1 > text2_length) {                          // Ran off the bottom of the graph.                          k1start += 2;                      } else if (front) {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {                          x2 = v2[k2_offset + 1];                      } else {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length                          && text1[text1_length - x2 - 1]                          == text2[text2_length - y2 - 1]) {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length) {                          // Ran off the left of the graph.                          k2end += 2;                      } else if (y2 > text2_length) {                          // Ran off the top of the graph.                          k2start += 2;                      } else if (!front) {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++) {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline) {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {                          x1 = v1[k1_offset + 1];                      } else {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length                          && text1[x1] == text2[y1]) {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length) {                          // Ran off the right of the graph.                          k1end += 2;                      } else if (y1 > text2_length) {                          // Ran off the bottom of the graph.                          k1start += 2;                      } else if (front) {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {                          x2 = v2[k2_offset + 1];                      } else {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length                          && text1[text1_length - x2 - 1]                          == text2[text2_length - y2 - 1]) {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length) {                          // Ran off the left of the graph.                          k2end += 2;                      } else if (y2 > text2_length) {                          // Ran off the top of the graph.                          k2start += 2;                      } else if (!front) {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2) {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (longtext.Length < 4 || shorttext.Length * 2 < longtext.Length) {                  return null;  // Pointless.              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (longtext.Length < 4 || shorttext.Length * 2 < longtext.Length) {                  return null;  // Pointless.              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm1 = diff_halfMatchI(longtext' shorttext'                  (longtext.Length + 3) / 4);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm1 = diff_halfMatchI(longtext' shorttext'                  (longtext.Length + 3) / 4);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm2 = diff_halfMatchI(longtext' shorttext'                  (longtext.Length + 1) / 2);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null && hm2 == null) {                  return null;              } else if (hm2 == null) {                  hm = hm1;              } else if (hm1 == null) {                  hm = hm2;              } else {                  // Both matched.  Select the longest.                  hm = hm1[4].Length > hm2[4].Length ? hm1 : hm2;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null && hm2 == null) {                  return null;              } else if (hm2 == null) {                  hm = hm1;              } else if (hm1 == null) {                  hm = hm2;              } else {                  // Both matched.  Select the longest.                  hm = hm1[4].Length > hm2[4].Length ? hm1 : hm2;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length) {                  return hm;                  //return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};              } else {                  return new string[] { hm[2]' hm[3]' hm[0]' hm[1]' hm[4] };              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length) {                  return hm;                  //return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};              } else {                  return new string[] { hm[2]' hm[3]' hm[0]' hm[1]' hm[4] };              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length) {                  return hm;                  //return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};              } else {                  return new string[] { hm[2]' hm[3]' hm[0]' hm[1]' hm[4] };              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatchI,The following statement contains a magic number: string seed = longtext.Substring(i' longtext.Length / 4);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_halfMatchI,The following statement contains a magic number: if (best_common.Length * 2 >= longtext.Length) {                  return new string[]{best_longtext_a' best_longtext_b'                      best_shorttext_a' best_shorttext_b' best_common};              } else {                  return null;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {                  if (diffs[pointer - 1].operation == Operation.DELETE &&                      diffs[pointer].operation == Operation.INSERT) {                      string deletion = diffs[pointer - 1].text;                      string insertion = diffs[pointer].text;                      int overlap_length1 = diff_commonOverlap(deletion' insertion);                      int overlap_length2 = diff_commonOverlap(insertion' deletion);                      if (overlap_length1 >= overlap_length2) {                          if (overlap_length1 >= deletion.Length / 2.0 ||                              overlap_length1 >= insertion.Length / 2.0) {                              // Overlap found.                              // Insert an equality and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL'                                  insertion.Substring(0' overlap_length1)));                              diffs[pointer - 1].text =                                  deletion.Substring(0' deletion.Length - overlap_length1);                              diffs[pointer + 1].text = insertion.Substring(overlap_length1);                              pointer++;                          }                      } else {                          if (overlap_length2 >= deletion.Length / 2.0 ||                              overlap_length2 >= insertion.Length / 2.0) {                              // Reverse overlap found.                              // Insert an equality and swap and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL'                                  deletion.Substring(0' overlap_length2)));                              diffs[pointer - 1].operation = Operation.INSERT;                              diffs[pointer - 1].text =                                  insertion.Substring(0' insertion.Length - overlap_length2);                              diffs[pointer + 1].operation = Operation.DELETE;                              diffs[pointer + 1].text = deletion.Substring(overlap_length2);                              pointer++;                          }                      }                      pointer++;                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {                  if (diffs[pointer - 1].operation == Operation.DELETE &&                      diffs[pointer].operation == Operation.INSERT) {                      string deletion = diffs[pointer - 1].text;                      string insertion = diffs[pointer].text;                      int overlap_length1 = diff_commonOverlap(deletion' insertion);                      int overlap_length2 = diff_commonOverlap(insertion' deletion);                      if (overlap_length1 >= overlap_length2) {                          if (overlap_length1 >= deletion.Length / 2.0 ||                              overlap_length1 >= insertion.Length / 2.0) {                              // Overlap found.                              // Insert an equality and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL'                                  insertion.Substring(0' overlap_length1)));                              diffs[pointer - 1].text =                                  deletion.Substring(0' deletion.Length - overlap_length1);                              diffs[pointer + 1].text = insertion.Substring(overlap_length1);                              pointer++;                          }                      } else {                          if (overlap_length2 >= deletion.Length / 2.0 ||                              overlap_length2 >= insertion.Length / 2.0) {                              // Reverse overlap found.                              // Insert an equality and swap and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL'                                  deletion.Substring(0' overlap_length2)));                              diffs[pointer - 1].operation = Operation.INSERT;                              diffs[pointer - 1].text =                                  insertion.Substring(0' insertion.Length - overlap_length2);                              diffs[pointer + 1].operation = Operation.DELETE;                              diffs[pointer + 1].text = deletion.Substring(overlap_length2);                              pointer++;                          }                      }                      pointer++;                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {                  if (diffs[pointer - 1].operation == Operation.DELETE &&                      diffs[pointer].operation == Operation.INSERT) {                      string deletion = diffs[pointer - 1].text;                      string insertion = diffs[pointer].text;                      int overlap_length1 = diff_commonOverlap(deletion' insertion);                      int overlap_length2 = diff_commonOverlap(insertion' deletion);                      if (overlap_length1 >= overlap_length2) {                          if (overlap_length1 >= deletion.Length / 2.0 ||                              overlap_length1 >= insertion.Length / 2.0) {                              // Overlap found.                              // Insert an equality and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL'                                  insertion.Substring(0' overlap_length1)));                              diffs[pointer - 1].text =                                  deletion.Substring(0' deletion.Length - overlap_length1);                              diffs[pointer + 1].text = insertion.Substring(overlap_length1);                              pointer++;                          }                      } else {                          if (overlap_length2 >= deletion.Length / 2.0 ||                              overlap_length2 >= insertion.Length / 2.0) {                              // Reverse overlap found.                              // Insert an equality and swap and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL'                                  deletion.Substring(0' overlap_length2)));                              diffs[pointer - 1].operation = Operation.INSERT;                              diffs[pointer - 1].text =                                  insertion.Substring(0' insertion.Length - overlap_length2);                              diffs[pointer + 1].operation = Operation.DELETE;                              diffs[pointer + 1].text = deletion.Substring(overlap_length2);                              pointer++;                          }                      }                      pointer++;                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count) {                  if (diffs[pointer - 1].operation == Operation.DELETE &&                      diffs[pointer].operation == Operation.INSERT) {                      string deletion = diffs[pointer - 1].text;                      string insertion = diffs[pointer].text;                      int overlap_length1 = diff_commonOverlap(deletion' insertion);                      int overlap_length2 = diff_commonOverlap(insertion' deletion);                      if (overlap_length1 >= overlap_length2) {                          if (overlap_length1 >= deletion.Length / 2.0 ||                              overlap_length1 >= insertion.Length / 2.0) {                              // Overlap found.                              // Insert an equality and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL'                                  insertion.Substring(0' overlap_length1)));                              diffs[pointer - 1].text =                                  deletion.Substring(0' deletion.Length - overlap_length1);                              diffs[pointer + 1].text = insertion.Substring(overlap_length1);                              pointer++;                          }                      } else {                          if (overlap_length2 >= deletion.Length / 2.0 ||                              overlap_length2 >= insertion.Length / 2.0) {                              // Reverse overlap found.                              // Insert an equality and swap and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL'                                  deletion.Substring(0' overlap_length2)));                              diffs[pointer - 1].operation = Operation.INSERT;                              diffs[pointer - 1].text =                                  insertion.Substring(0' insertion.Length - overlap_length2);                              diffs[pointer + 1].operation = Operation.DELETE;                              diffs[pointer + 1].text = deletion.Substring(overlap_length2);                              pointer++;                          }                      }                      pointer++;                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (one.Length == 0 || two.Length == 0) {                  // Edges are the best.                  return 6;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {                  // Five points for blank lines.                  return 5;              } else if (lineBreak1 || lineBreak2) {                  // Four points for line breaks.                  return 4;              } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {                  // Three points for end of sentences.                  return 3;              } else if (whitespace1 || whitespace2) {                  // Two points for whitespace.                  return 2;              } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {                  // One point for non-alphanumeric.                  return 1;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {                  // Five points for blank lines.                  return 5;              } else if (lineBreak1 || lineBreak2) {                  // Four points for line breaks.                  return 4;              } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {                  // Three points for end of sentences.                  return 3;              } else if (whitespace1 || whitespace2) {                  // Two points for whitespace.                  return 2;              } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {                  // One point for non-alphanumeric.                  return 1;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {                  // Five points for blank lines.                  return 5;              } else if (lineBreak1 || lineBreak2) {                  // Four points for line breaks.                  return 4;              } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {                  // Three points for end of sentences.                  return 3;              } else if (whitespace1 || whitespace2) {                  // Two points for whitespace.                  return 2;              } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {                  // One point for non-alphanumeric.                  return 1;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2) {                  // Five points for blank lines.                  return 5;              } else if (lineBreak1 || lineBreak2) {                  // Four points for line breaks.                  return 4;              } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {                  // Three points for end of sentences.                  return 3;              } else if (whitespace1 || whitespace2) {                  // Two points for whitespace.                  return 2;              } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {                  // One point for non-alphanumeric.                  return 1;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: while (pointer < diffs.Count) {                  if (diffs[pointer].operation == Operation.EQUAL) {  // Equality found.                      if (diffs[pointer].text.Length < this.Diff_EditCost                          && (post_ins || post_del)) {                          // Candidate found.                          equalities.Push(pointer);                          pre_ins = post_ins;                          pre_del = post_del;                          lastequality = diffs[pointer].text;                      } else {                          // Not a candidate' and can never become one.                          equalities.Clear();                          lastequality = string.Empty;                      }                      post_ins = post_del = false;                  } else {  // An insertion or deletion.                      if (diffs[pointer].operation == Operation.DELETE) {                          post_del = true;                      } else {                          post_ins = true;                      }                      /*             * Five types to be split:             * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>             * <ins>A</ins>X<ins>C</ins><del>D</del>             * <ins>A</ins><del>B</del>X<ins>C</ins>             * <ins>A</del>X<ins>C</ins><del>D</del>             * <ins>A</ins><del>B</del>X<del>C</del>             */                      if ((lastequality.Length != 0)                          && ((pre_ins && pre_del && post_ins && post_del)                              || ((lastequality.Length < this.Diff_EditCost / 2)                                  && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0)                                      + (post_del ? 1 : 0)) == 3))) {                          // Duplicate record.                          diffs.Insert(equalities.Peek()'                              new Diff(Operation.DELETE' lastequality));                          // Change second copy to insert.                          diffs[equalities.Peek() + 1].operation = Operation.INSERT;                          equalities.Pop();  // Throw away the equality we just deleted.                          lastequality = string.Empty;                          if (pre_ins && pre_del) {                              // No changes made which could affect previous entry' keep going.                              post_ins = post_del = true;                              equalities.Clear();                          } else {                              if (equalities.Count > 0) {                                  equalities.Pop();                              }                                pointer = equalities.Count > 0 ? equalities.Peek() : -1;                              post_ins = post_del = false;                          }                          changes = true;                      }                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: while (pointer < diffs.Count) {                  if (diffs[pointer].operation == Operation.EQUAL) {  // Equality found.                      if (diffs[pointer].text.Length < this.Diff_EditCost                          && (post_ins || post_del)) {                          // Candidate found.                          equalities.Push(pointer);                          pre_ins = post_ins;                          pre_del = post_del;                          lastequality = diffs[pointer].text;                      } else {                          // Not a candidate' and can never become one.                          equalities.Clear();                          lastequality = string.Empty;                      }                      post_ins = post_del = false;                  } else {  // An insertion or deletion.                      if (diffs[pointer].operation == Operation.DELETE) {                          post_del = true;                      } else {                          post_ins = true;                      }                      /*             * Five types to be split:             * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>             * <ins>A</ins>X<ins>C</ins><del>D</del>             * <ins>A</ins><del>B</del>X<ins>C</ins>             * <ins>A</del>X<ins>C</ins><del>D</del>             * <ins>A</ins><del>B</del>X<del>C</del>             */                      if ((lastequality.Length != 0)                          && ((pre_ins && pre_del && post_ins && post_del)                              || ((lastequality.Length < this.Diff_EditCost / 2)                                  && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0)                                      + (post_del ? 1 : 0)) == 3))) {                          // Duplicate record.                          diffs.Insert(equalities.Peek()'                              new Diff(Operation.DELETE' lastequality));                          // Change second copy to insert.                          diffs[equalities.Peek() + 1].operation = Operation.INSERT;                          equalities.Pop();  // Throw away the equality we just deleted.                          lastequality = string.Empty;                          if (pre_ins && pre_del) {                              // No changes made which could affect previous entry' keep going.                              post_ins = post_del = true;                              equalities.Clear();                          } else {                              if (equalities.Count > 0) {                                  equalities.Pop();                              }                                pointer = equalities.Count > 0 ? equalities.Peek() : -1;                              post_ins = post_del = false;                          }                          changes = true;                      }                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++) {                  // Scan for the best match; each iteration allows for one more error.                  // Run a binary search to determine how far from 'loc' we can stray at                  // this error level.                  bin_min = 0;                  bin_mid = bin_max;                  while (bin_min < bin_mid) {                      if (match_bitapScore(d' loc + bin_mid' loc' pattern)                          <= score_threshold) {                          bin_min = bin_mid;                      } else {                          bin_max = bin_mid;                      }                      bin_mid = (bin_max - bin_min) / 2 + bin_min;                  }                  // Use the result from this iteration as the maximum for the next.                  bin_max = bin_mid;                  int start = Math.Max(1' loc - bin_mid + 1);                  int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;                    int[] rd = new int[finish + 2];                  rd[finish + 1] = (1 << d) - 1;                  for (int j = finish; j >= start; j--) {                      int charMatch;                      if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1])) {                          // Out of range.                          charMatch = 0;                      } else {                          charMatch = s[text[j - 1]];                      }                      if (d == 0) {                          // First pass: exact match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;                      } else {                          // Subsequent passes: fuzzy match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch                              | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];                      }                      if ((rd[j] & matchmask) != 0) {                          double score = match_bitapScore(d' j - 1' loc' pattern);                          // This match will almost certainly be better than any existing                          // match.  But check anyway.                          if (score <= score_threshold) {                              // Told you so.                              score_threshold = score;                              best_loc = j - 1;                              if (best_loc > loc) {                                  // When passing loc' don't exceed our current distance from loc.                                  start = Math.Max(1' 2 * loc - best_loc);                              } else {                                  // Already passed loc' downhill from here on in.                                  break;                              }                          }                      }                  }                  if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold) {                      // No hope for a (better) match at greater error levels.                      break;                  }                  last_rd = rd;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++) {                  // Scan for the best match; each iteration allows for one more error.                  // Run a binary search to determine how far from 'loc' we can stray at                  // this error level.                  bin_min = 0;                  bin_mid = bin_max;                  while (bin_min < bin_mid) {                      if (match_bitapScore(d' loc + bin_mid' loc' pattern)                          <= score_threshold) {                          bin_min = bin_mid;                      } else {                          bin_max = bin_mid;                      }                      bin_mid = (bin_max - bin_min) / 2 + bin_min;                  }                  // Use the result from this iteration as the maximum for the next.                  bin_max = bin_mid;                  int start = Math.Max(1' loc - bin_mid + 1);                  int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;                    int[] rd = new int[finish + 2];                  rd[finish + 1] = (1 << d) - 1;                  for (int j = finish; j >= start; j--) {                      int charMatch;                      if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1])) {                          // Out of range.                          charMatch = 0;                      } else {                          charMatch = s[text[j - 1]];                      }                      if (d == 0) {                          // First pass: exact match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;                      } else {                          // Subsequent passes: fuzzy match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch                              | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];                      }                      if ((rd[j] & matchmask) != 0) {                          double score = match_bitapScore(d' j - 1' loc' pattern);                          // This match will almost certainly be better than any existing                          // match.  But check anyway.                          if (score <= score_threshold) {                              // Told you so.                              score_threshold = score;                              best_loc = j - 1;                              if (best_loc > loc) {                                  // When passing loc' don't exceed our current distance from loc.                                  start = Math.Max(1' 2 * loc - best_loc);                              } else {                                  // Already passed loc' downhill from here on in.                                  break;                              }                          }                      }                  }                  if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold) {                      // No hope for a (better) match at greater error levels.                      break;                  }                  last_rd = rd;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++) {                  // Scan for the best match; each iteration allows for one more error.                  // Run a binary search to determine how far from 'loc' we can stray at                  // this error level.                  bin_min = 0;                  bin_mid = bin_max;                  while (bin_min < bin_mid) {                      if (match_bitapScore(d' loc + bin_mid' loc' pattern)                          <= score_threshold) {                          bin_min = bin_mid;                      } else {                          bin_max = bin_mid;                      }                      bin_mid = (bin_max - bin_min) / 2 + bin_min;                  }                  // Use the result from this iteration as the maximum for the next.                  bin_max = bin_mid;                  int start = Math.Max(1' loc - bin_mid + 1);                  int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;                    int[] rd = new int[finish + 2];                  rd[finish + 1] = (1 << d) - 1;                  for (int j = finish; j >= start; j--) {                      int charMatch;                      if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1])) {                          // Out of range.                          charMatch = 0;                      } else {                          charMatch = s[text[j - 1]];                      }                      if (d == 0) {                          // First pass: exact match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;                      } else {                          // Subsequent passes: fuzzy match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch                              | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];                      }                      if ((rd[j] & matchmask) != 0) {                          double score = match_bitapScore(d' j - 1' loc' pattern);                          // This match will almost certainly be better than any existing                          // match.  But check anyway.                          if (score <= score_threshold) {                              // Told you so.                              score_threshold = score;                              best_loc = j - 1;                              if (best_loc > loc) {                                  // When passing loc' don't exceed our current distance from loc.                                  start = Math.Max(1' 2 * loc - best_loc);                              } else {                                  // Already passed loc' downhill from here on in.                                  break;                              }                          }                      }                  }                  if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold) {                      // No hope for a (better) match at greater error levels.                      break;                  }                  last_rd = rd;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: if (diffs.Count > 2) {                  diff_cleanupSemantic(diffs);                  diff_cleanupEfficiency(diffs);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: foreach (Diff aDiff in diffs) {                  if (patch.diffs.Count == 0 && aDiff.operation != Operation.EQUAL) {                      // A new patch starts here.                      patch.start1 = char_count1;                      patch.start2 = char_count2;                  }                    switch (aDiff.operation) {                  case Operation.INSERT:                      patch.diffs.Add(aDiff);                      patch.length2 += aDiff.text.Length;                      postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);                      break;                  case Operation.DELETE:                      patch.length1 += aDiff.text.Length;                      patch.diffs.Add(aDiff);                      postpatch_text = postpatch_text.Remove(char_count2'                          aDiff.text.Length);                      break;                  case Operation.EQUAL:                      if (aDiff.text.Length <= 2 * Patch_Margin                          && patch.diffs.Count() != 0 && aDiff != diffs.Last()) {                          // Small equality inside a patch.                          patch.diffs.Add(aDiff);                          patch.length1 += aDiff.text.Length;                          patch.length2 += aDiff.text.Length;                      }                        if (aDiff.text.Length >= 2 * Patch_Margin) {                          // Time for a new patch.                          if (patch.diffs.Count != 0) {                              patch_addContext(patch' prepatch_text);                              patches.Add(patch);                              patch = new Patch();                              // Unlike Unidiff' our patch lists have a rolling context.                              // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                              // Update prepatch text & pos to reflect the application of the                              // just completed patch.                              prepatch_text = postpatch_text;                              char_count1 = char_count2;                          }                      }                      break;                  }                    // Update the current character count.                  if (aDiff.operation != Operation.INSERT) {                      char_count1 += aDiff.text.Length;                  }                  if (aDiff.operation != Operation.DELETE) {                      char_count2 += aDiff.text.Length;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: foreach (Diff aDiff in diffs) {                  if (patch.diffs.Count == 0 && aDiff.operation != Operation.EQUAL) {                      // A new patch starts here.                      patch.start1 = char_count1;                      patch.start2 = char_count2;                  }                    switch (aDiff.operation) {                  case Operation.INSERT:                      patch.diffs.Add(aDiff);                      patch.length2 += aDiff.text.Length;                      postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);                      break;                  case Operation.DELETE:                      patch.length1 += aDiff.text.Length;                      patch.diffs.Add(aDiff);                      postpatch_text = postpatch_text.Remove(char_count2'                          aDiff.text.Length);                      break;                  case Operation.EQUAL:                      if (aDiff.text.Length <= 2 * Patch_Margin                          && patch.diffs.Count() != 0 && aDiff != diffs.Last()) {                          // Small equality inside a patch.                          patch.diffs.Add(aDiff);                          patch.length1 += aDiff.text.Length;                          patch.length2 += aDiff.text.Length;                      }                        if (aDiff.text.Length >= 2 * Patch_Margin) {                          // Time for a new patch.                          if (patch.diffs.Count != 0) {                              patch_addContext(patch' prepatch_text);                              patches.Add(patch);                              patch = new Patch();                              // Unlike Unidiff' our patch lists have a rolling context.                              // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                              // Update prepatch text & pos to reflect the application of the                              // just completed patch.                              prepatch_text = postpatch_text;                              char_count1 = char_count2;                          }                      }                      break;                  }                    // Update the current character count.                  if (aDiff.operation != Operation.INSERT) {                      char_count1 += aDiff.text.Length;                  }                  if (aDiff.operation != Operation.DELETE) {                      char_count2 += aDiff.text.Length;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_apply,The following statement contains a magic number: text = text.Substring(nullPadding.Length' text.Length                  - 2 * nullPadding.Length);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_splitMax,The following statement contains a magic number: for (int x = 0; x < patches.Count; x++) {                  if (patches[x].length1 <= patch_size) {                      continue;                  }                  Patch bigpatch = patches[x];                  // Remove the big old patch.                  patches.Splice(x--' 1);                  int start1 = bigpatch.start1;                  int start2 = bigpatch.start2;                  string precontext = string.Empty;                  while (bigpatch.diffs.Count != 0) {                      // Create one of several smaller patches.                      Patch patch = new Patch();                      bool empty = true;                      patch.start1 = start1 - precontext.Length;                      patch.start2 = start2 - precontext.Length;                      if (precontext.Length != 0) {                          patch.length1 = patch.length2 = precontext.Length;                          patch.diffs.Add(new Diff(Operation.EQUAL' precontext));                      }                      while (bigpatch.diffs.Count != 0                          && patch.length1 < patch_size - this.Patch_Margin) {                          Operation diff_type = bigpatch.diffs[0].operation;                          string diff_text = bigpatch.diffs[0].text;                          if (diff_type == Operation.INSERT) {                              // Insertions are harmless.                              patch.length2 += diff_text.Length;                              start2 += diff_text.Length;                              patch.diffs.Add(bigpatch.diffs.First());                              bigpatch.diffs.RemoveAt(0);                              empty = false;                          } else if (diff_type == Operation.DELETE && patch.diffs.Count == 1                              && patch.diffs.First().operation == Operation.EQUAL                              && diff_text.Length > 2 * patch_size) {                              // This is a large deletion.  Let it pass in one chunk.                              patch.length1 += diff_text.Length;                              start1 += diff_text.Length;                              empty = false;                              patch.diffs.Add(new Diff(diff_type' diff_text));                              bigpatch.diffs.RemoveAt(0);                          } else {                              // Deletion or equality.  Only take as much as we can stomach.                              diff_text = diff_text.Substring(0' Math.Min(diff_text.Length'                                  patch_size - patch.length1 - Patch_Margin));                              patch.length1 += diff_text.Length;                              start1 += diff_text.Length;                              if (diff_type == Operation.EQUAL) {                                  patch.length2 += diff_text.Length;                                  start2 += diff_text.Length;                              } else {                                  empty = false;                              }                              patch.diffs.Add(new Diff(diff_type' diff_text));                              if (diff_text == bigpatch.diffs[0].text) {                                  bigpatch.diffs.RemoveAt(0);                              } else {                                  bigpatch.diffs[0].text =                                      bigpatch.diffs[0].text.Substring(diff_text.Length);                              }                          }                      }                      // Compute the head context for the next patch.                      precontext = this.diff_text2(patch.diffs);                      precontext = precontext.Substring(Math.Max(0'                          precontext.Length - this.Patch_Margin));                        string postcontext = null;                      // Append the end context for this patch.                      if (diff_text1(bigpatch.diffs).Length > Patch_Margin) {                          postcontext = diff_text1(bigpatch.diffs)                              .Substring(0' Patch_Margin);                      } else {                          postcontext = diff_text1(bigpatch.diffs);                      }                        if (postcontext.Length != 0) {                          patch.length1 += postcontext.Length;                          patch.length2 += postcontext.Length;                          if (patch.diffs.Count != 0                              && patch.diffs[patch.diffs.Count - 1].operation                              == Operation.EQUAL) {                              patch.diffs[patch.diffs.Count - 1].text += postcontext;                          } else {                              patch.diffs.Add(new Diff(Operation.EQUAL' postcontext));                          }                      }                      if (!empty) {                          patches.Splice(++x' 0' patch);                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success) {                      throw new ArgumentException("Invalid patch string: "                          + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0) {                      patch.start1--;                      patch.length1 = 1;                  } else if (m.Groups[2].Value == "0") {                      patch.length1 = 0;                  } else {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0) {                      patch.start2--;                      patch.length2 = 1;                  } else if (m.Groups[4].Value == "0") {                      patch.length2 = 0;                  } else {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length) {                      try {                          sign = text[textPointer][0];                      } catch (IndexOutOfRangeException) {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-') {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      } else if (sign == '+') {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      } else if (sign == ' ') {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      } else if (sign == '@') {                          // Start of next patch.                          break;                      } else {                          // WTF?                          throw new ArgumentException(                              "Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success) {                      throw new ArgumentException("Invalid patch string: "                          + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0) {                      patch.start1--;                      patch.length1 = 1;                  } else if (m.Groups[2].Value == "0") {                      patch.length1 = 0;                  } else {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0) {                      patch.start2--;                      patch.length2 = 1;                  } else if (m.Groups[4].Value == "0") {                      patch.length2 = 0;                  } else {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length) {                      try {                          sign = text[textPointer][0];                      } catch (IndexOutOfRangeException) {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-') {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      } else if (sign == '+') {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      } else if (sign == ' ') {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      } else if (sign == '@') {                          // Start of next patch.                          break;                      } else {                          // WTF?                          throw new ArgumentException(                              "Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success) {                      throw new ArgumentException("Invalid patch string: "                          + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0) {                      patch.start1--;                      patch.length1 = 1;                  } else if (m.Groups[2].Value == "0") {                      patch.length1 = 0;                  } else {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0) {                      patch.start2--;                      patch.length2 = 1;                  } else if (m.Groups[4].Value == "0") {                      patch.length2 = 0;                  } else {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length) {                      try {                          sign = text[textPointer][0];                      } catch (IndexOutOfRangeException) {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-') {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      } else if (sign == '+') {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      } else if (sign == ' ') {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      } else if (sign == '@') {                          // Start of next patch.                          break;                      } else {                          // WTF?                          throw new ArgumentException(                              "Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success) {                      throw new ArgumentException("Invalid patch string: "                          + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0) {                      patch.start1--;                      patch.length1 = 1;                  } else if (m.Groups[2].Value == "0") {                      patch.length1 = 0;                  } else {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0) {                      patch.start2--;                      patch.length2 = 1;                  } else if (m.Groups[4].Value == "0") {                      patch.length2 = 0;                  } else {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length) {                      try {                          sign = text[textPointer][0];                      } catch (IndexOutOfRangeException) {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-') {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      } else if (sign == '+') {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      } else if (sign == ' ') {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      } else if (sign == '@') {                          // Start of next patch.                          break;                      } else {                          // WTF?                          throw new ArgumentException(                              "Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success) {                      throw new ArgumentException("Invalid patch string: "                          + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0) {                      patch.start1--;                      patch.length1 = 1;                  } else if (m.Groups[2].Value == "0") {                      patch.length1 = 0;                  } else {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0) {                      patch.start2--;                      patch.length2 = 1;                  } else if (m.Groups[4].Value == "0") {                      patch.length2 = 0;                  } else {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length) {                      try {                          sign = text[textPointer][0];                      } catch (IndexOutOfRangeException) {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-') {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      } else if (sign == '+') {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      } else if (sign == ' ') {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      } else if (sign == '@') {                          // Start of next patch.                          break;                      } else {                          // WTF?                          throw new ArgumentException(                              "Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success) {                      throw new ArgumentException("Invalid patch string: "                          + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0) {                      patch.start1--;                      patch.length1 = 1;                  } else if (m.Groups[2].Value == "0") {                      patch.length1 = 0;                  } else {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0) {                      patch.start2--;                      patch.length2 = 1;                  } else if (m.Groups[4].Value == "0") {                      patch.length2 = 0;                  } else {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length) {                      try {                          sign = text[textPointer][0];                      } catch (IndexOutOfRangeException) {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-') {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      } else if (sign == '+') {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      } else if (sign == ' ') {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      } else if (sign == '@') {                          // Start of next patch.                          break;                      } else {                          // WTF?                          throw new ArgumentException(                              "Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length) {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success) {                      throw new ArgumentException("Invalid patch string: "                          + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0) {                      patch.start1--;                      patch.length1 = 1;                  } else if (m.Groups[2].Value == "0") {                      patch.length1 = 0;                  } else {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0) {                      patch.start2--;                      patch.length2 = 1;                  } else if (m.Groups[4].Value == "0") {                      patch.length2 = 0;                  } else {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length) {                      try {                          sign = text[textPointer][0];                      } catch (IndexOutOfRangeException) {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-') {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      } else if (sign == '+') {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      } else if (sign == ' ') {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      } else if (sign == '@') {                          // Start of next patch.                          break;                      } else {                          // WTF?                          throw new ArgumentException(                              "Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Missing Default,DiffMatchPatch,Patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,ToString,The following switch statement is missing a default case: switch (aDiff.operation) {                  case Operation.INSERT:                      text.Append('+');                      break;                  case Operation.DELETE:                      text.Append('-');                      break;                  case Operation.EQUAL:                      text.Append(' ');                      break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_lineMode,The following switch statement is missing a default case: switch (diffs[pointer].operation) {                  case Operation.INSERT:                      count_insert++;                      text_insert += diffs[pointer].text;                      break;                  case Operation.DELETE:                      count_delete++;                      text_delete += diffs[pointer].text;                      break;                  case Operation.EQUAL:                      // Upon reaching an equality' check for prior redundancies.                      if (count_delete >= 1 && count_insert >= 1) {                          // Delete the offending records and add the merged ones.                          diffs.RemoveRange(pointer - count_delete - count_insert'                              count_delete + count_insert);                          pointer = pointer - count_delete - count_insert;                          List<Diff> a =                              this.diff_main(text_delete' text_insert' false' deadline);                          diffs.InsertRange(pointer' a);                          pointer = pointer + a.Count;                      }                      count_insert = 0;                      count_delete = 0;                      text_delete = string.Empty;                      text_insert = string.Empty;                      break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_cleanupMerge,The following switch statement is missing a default case: switch (diffs[pointer].operation) {                  case Operation.INSERT:                      count_insert++;                      text_insert += diffs[pointer].text;                      pointer++;                      break;                  case Operation.DELETE:                      count_delete++;                      text_delete += diffs[pointer].text;                      pointer++;                      break;                  case Operation.EQUAL:                      // Upon reaching an equality' check for prior redundancies.                      if (count_delete + count_insert > 1) {                          if (count_delete != 0 && count_insert != 0) {                              // Factor out any common prefixies.                              commonlength = this.diff_commonPrefix(text_insert' text_delete);                              if (commonlength != 0) {                                  if ((pointer - count_delete - count_insert) > 0 &&                                      diffs[pointer - count_delete - count_insert - 1].operation                                      == Operation.EQUAL) {                                      diffs[pointer - count_delete - count_insert - 1].text                                      += text_insert.Substring(0' commonlength);                                  } else {                                      diffs.Insert(0' new Diff(Operation.EQUAL'                                          text_insert.Substring(0' commonlength)));                                      pointer++;                                  }                                  text_insert = text_insert.Substring(commonlength);                                  text_delete = text_delete.Substring(commonlength);                              }                              // Factor out any common suffixies.                              commonlength = this.diff_commonSuffix(text_insert' text_delete);                              if (commonlength != 0) {                                  diffs[pointer].text = text_insert.Substring(text_insert.Length                                      - commonlength) + diffs[pointer].text;                                  text_insert = text_insert.Substring(0' text_insert.Length                                      - commonlength);                                  text_delete = text_delete.Substring(0' text_delete.Length                                      - commonlength);                              }                          }                          // Delete the offending records and add the merged ones.                          if (count_delete == 0) {                              diffs.Splice(pointer - count_insert'                                  count_delete + count_insert'                                  new Diff(Operation.INSERT' text_insert));                          } else if (count_insert == 0) {                              diffs.Splice(pointer - count_delete'                                  count_delete + count_insert'                                  new Diff(Operation.DELETE' text_delete));                          } else {                              diffs.Splice(pointer - count_delete - count_insert'                                  count_delete + count_insert'                                  new Diff(Operation.DELETE' text_delete)'                                  new Diff(Operation.INSERT' text_insert));                          }                          pointer = pointer - count_delete - count_insert +                              (count_delete != 0 ? 1 : 0) + (count_insert != 0 ? 1 : 0) + 1;                      } else if (pointer != 0                          && diffs[pointer - 1].operation == Operation.EQUAL) {                          // Merge this equality with the previous one.                          diffs[pointer - 1].text += diffs[pointer].text;                          diffs.RemoveAt(pointer);                      } else {                          pointer++;                      }                      count_insert = 0;                      count_delete = 0;                      text_delete = string.Empty;                      text_insert = string.Empty;                      break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_prettyHtml,The following switch statement is missing a default case: switch (aDiff.operation) {                  case Operation.INSERT:                      html.Append("<ins>").Append(text)                          .Append("</ins>");                      break;                  case Operation.DELETE:                      html.Append("<del>").Append(text)                          .Append("</del>");                      break;                  case Operation.EQUAL:                      html.Append("<span>").Append(text).Append("</span>");                      break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_levenshtein,The following switch statement is missing a default case: switch (aDiff.operation) {                  case Operation.INSERT:                      insertions += aDiff.text.Length;                      break;                  case Operation.DELETE:                      deletions += aDiff.text.Length;                      break;                  case Operation.EQUAL:                      // A deletion and an insertion is one substitution.                      levenshtein += Math.Max(insertions' deletions);                      insertions = 0;                      deletions = 0;                      break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,diff_toDelta,The following switch statement is missing a default case: switch (aDiff.operation) {                  case Operation.INSERT:                      text.Append("+").Append(HttpUtility.UrlEncode(aDiff.text'                          new UTF8Encoding()).Replace('+'' ' ')).Append("\t");                      break;                  case Operation.DELETE:                      text.Append("-").Append(aDiff.text.Length).Append("\t");                      break;                  case Operation.EQUAL:                      text.Append("=").Append(aDiff.text.Length).Append("\t");                      break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\Notulp_Pluton\Pluton.Patcher\DiffMatchPatch.cs,patch_make,The following switch statement is missing a default case: switch (aDiff.operation) {                  case Operation.INSERT:                      patch.diffs.Add(aDiff);                      patch.length2 += aDiff.text.Length;                      postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);                      break;                  case Operation.DELETE:                      patch.length1 += aDiff.text.Length;                      patch.diffs.Add(aDiff);                      postpatch_text = postpatch_text.Remove(char_count2'                          aDiff.text.Length);                      break;                  case Operation.EQUAL:                      if (aDiff.text.Length <= 2 * Patch_Margin                          && patch.diffs.Count() != 0 && aDiff != diffs.Last()) {                          // Small equality inside a patch.                          patch.diffs.Add(aDiff);                          patch.length1 += aDiff.text.Length;                          patch.length2 += aDiff.text.Length;                      }                        if (aDiff.text.Length >= 2 * Patch_Margin) {                          // Time for a new patch.                          if (patch.diffs.Count != 0) {                              patch_addContext(patch' prepatch_text);                              patches.Add(patch);                              patch = new Patch();                              // Unlike Unidiff' our patch lists have a rolling context.                              // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                              // Update prepatch text & pos to reflect the application of the                              // just completed patch.                              prepatch_text = postpatch_text;                              char_count1 = char_count2;                          }                      }                      break;                  }
