Implementation smell,Namespace,Class,File,Method,Description
Long Method,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The method has 207 lines of code.
Long Method,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The method has 141 lines of code.
Long Method,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The method has 125 lines of code.
Long Method,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The method has 107 lines of code.
Long Method,SimsLib.IFF,StringTable,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\StringTable.cs,StringTable,The method has 111 lines of code.
Long Method,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The method has 160 lines of code.
Complex Method,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Mesh.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,Cyclomatic complexity of the method is 26
Complex Method,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,Cyclomatic complexity of the method is 8
Complex Method,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,Cyclomatic complexity of the method is 151
Complex Method,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,Cyclomatic complexity of the method is 8
Complex Method,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,Cyclomatic complexity of the method is 29
Complex Method,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FuckThisShit,Cyclomatic complexity of the method is 8
Complex Method,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,SPR2Parser,Cyclomatic complexity of the method is 12
Complex Method,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,Cyclomatic complexity of the method is 19
Complex Method,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,Cyclomatic complexity of the method is 17
Complex Method,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,Cyclomatic complexity of the method is 26
Complex Method,SimsLib.IFF,StringTable,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\StringTable.cs,StringTable,Cyclomatic complexity of the method is 37
Complex Method,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,Cyclomatic complexity of the method is 14
Complex Method,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,Cyclomatic complexity of the method is 24
Complex Method,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,Cyclomatic complexity of the method is 16
Complex Method,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,LogHeader,Cyclomatic complexity of the method is 9
Complex Method,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,LogEvent,Cyclomatic complexity of the method is 12
Complex Method,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,Cyclomatic complexity of the method is 24
Complex Method,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,SetLogPath,Cyclomatic complexity of the method is 17
Complex Method,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,LogThis,Cyclomatic complexity of the method is 20
Complex Method,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,Cyclomatic complexity of the method is 16
Complex Method,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,Cyclomatic complexity of the method is 13
Long Parameter List,SimsLib.IFF,DrawGroupSprite,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroupSprite.cs,DrawGroupSprite,The method has 5 parameters.
Long Parameter List,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The method has 6 parameters.
Long Parameter List,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,ArrayCopy2,The method has 5 parameters.
Long Statement,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Mesh.cs,TransformVertices,The length of the statement  "			var translatedMatrix = Matrix.CreateTranslation (new Vector3 (relativeVertex.Vertex.Coord.X' relativeVertex.Vertex.Coord.Y' relativeVertex.Vertex.Coord.Z)) * bone.AbsoluteMatrix; " is 178.
Long Statement,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Mesh.cs,TransformVertices,The length of the statement  "			translatedMatrix = Matrix.CreateTranslation (new Vector3 (relativeVertex.Vertex.NormalCoord.X' relativeVertex.Vertex.NormalCoord.Y' relativeVertex.Vertex.NormalCoord.Z)) * bone.AbsoluteMatrix; " is 192.
Long Statement,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Mesh.cs,Clone,The length of the statement  "	/** Because mesh vertex is a struct' copying the array should be enough to clone it **/newMesh.Vertex = this.Vertex.ToArray (); " is 127.
Long Statement,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The length of the statement  "		P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")"); " is 153.
Long Statement,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The length of the statement  "			if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76) " is 131.
Long Statement,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The length of the statement  "				if (StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS") { " is 553.
Long Statement,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FuckThisShit,The length of the statement  "		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76) " is 131.
Long Statement,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The length of the statement  "		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76) " is 131.
Long Statement,SimsLib.IFF,UniqueRandom,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\UniqueRandom.cs,NewRandomNumber,The length of the statement  "		throw new System.InvalidOperationException ("All numbers in the range have now been used." + "Cannot continue selecting random numbers from a list with no members."); " is 166.
Long Statement,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The length of the statement  "				while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) { " is 138.
Long Statement,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetItemByID,The length of the statement  "	//Far3Entry Entry = Array.Find(entries' delegate(Far3Entry entry) { return entry.FileID == FileID && entry.TypeID == TypeID; }); " is 128.
Long Statement,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,LogHeader,The length of the statement  "		sHeader = "======(" + System.AppDomain.CurrentDomain.FriendlyName + ") ====  " + sText + "============ Date:" + dt.ToString ("yyyyMMdd") + " Time:" + dt.ToString ("hh:mm:ss"); " is 175.
Long Statement,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetWeek,The length of the statement  "	//Console.WriteLine( "There are {0} weeks in the current year ({1})."' myCal.GetWeekOfYear( LastDay' myCWR' myFirstDOW )' LastDay.Year ); " is 137.
Long Statement,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The length of the statement  "					Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f; " is 192.
Long Statement,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The length of the statement  "			m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)]; " is 142.
Complex Conditional,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The conditional expression  "P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF"  is complex.
Complex Conditional,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The conditional expression  "StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS""  is complex.
Complex Conditional,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ParseStrings,The conditional expression  "Chunk.Resource == "STR#" || Chunk.Resource == "TTAs" || Chunk.Resource == "CTSS" || Chunk.Resource == "CST""  is complex.
Complex Conditional,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The conditional expression  "m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11"  is complex.
Empty Catch Block,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,AppendToFile,The method has an empty catch block.
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,Anim,The following statement contains a magic number: m_Duration = Reader.ReadSingle () / 1000;  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,Anim,The following statement contains a magic number: Reader.BaseStream.Seek (m_TranslationsTableOffset + 12 * m_NumTranslations' SeekOrigin.Begin);  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,Anim,The following statement contains a magic number: Reader.BaseStream.Seek (m_RotationsTableOffset + 16 * m_NumRotations' SeekOrigin.Begin);  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: Mot.Duration = Reader.ReadSingle () / 1000;  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: if (Mot.HasTranslation != 0) {  	Mot.Translations = new float[Mot.NumFrames' 3];  	long CurrentOffset = Reader.BaseStream.Position;  	Reader.BaseStream.Seek (m_TranslationsTableOffset + 12 * Mot.TranslationsOffset' SeekOrigin.Begin);  	for (int i = 0; i < Mot.NumFrames; i++) {  		Mot.Translations [i' 0] = Reader.ReadSingle ();  		Mot.Translations [i' 1] = Reader.ReadSingle ();  		Mot.Translations [i' 2] = Reader.ReadSingle ();  	}  	Reader.BaseStream.Seek (CurrentOffset' SeekOrigin.Begin);  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: if (Mot.HasTranslation != 0) {  	Mot.Translations = new float[Mot.NumFrames' 3];  	long CurrentOffset = Reader.BaseStream.Position;  	Reader.BaseStream.Seek (m_TranslationsTableOffset + 12 * Mot.TranslationsOffset' SeekOrigin.Begin);  	for (int i = 0; i < Mot.NumFrames; i++) {  		Mot.Translations [i' 0] = Reader.ReadSingle ();  		Mot.Translations [i' 1] = Reader.ReadSingle ();  		Mot.Translations [i' 2] = Reader.ReadSingle ();  	}  	Reader.BaseStream.Seek (CurrentOffset' SeekOrigin.Begin);  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: if (Mot.HasTranslation != 0) {  	Mot.Translations = new float[Mot.NumFrames' 3];  	long CurrentOffset = Reader.BaseStream.Position;  	Reader.BaseStream.Seek (m_TranslationsTableOffset + 12 * Mot.TranslationsOffset' SeekOrigin.Begin);  	for (int i = 0; i < Mot.NumFrames; i++) {  		Mot.Translations [i' 0] = Reader.ReadSingle ();  		Mot.Translations [i' 1] = Reader.ReadSingle ();  		Mot.Translations [i' 2] = Reader.ReadSingle ();  	}  	Reader.BaseStream.Seek (CurrentOffset' SeekOrigin.Begin);  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: Mot.Translations = new float[Mot.NumFrames' 3];  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: Reader.BaseStream.Seek (m_TranslationsTableOffset + 12 * Mot.TranslationsOffset' SeekOrigin.Begin);  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: for (int i = 0; i < Mot.NumFrames; i++) {  	Mot.Translations [i' 0] = Reader.ReadSingle ();  	Mot.Translations [i' 1] = Reader.ReadSingle ();  	Mot.Translations [i' 2] = Reader.ReadSingle ();  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: Mot.Translations [i' 2] = Reader.ReadSingle ();  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: if (Mot.HasRotation != 0) {  	Mot.Rotations = new float[Mot.NumFrames' 4];  	long CurrentOffset = Reader.BaseStream.Position;  	Reader.BaseStream.Seek (m_RotationsTableOffset + 16 * Mot.RotationsOffset' SeekOrigin.Begin);  	for (int i = 0; i < Mot.NumFrames; i++) {  		Mot.Rotations [i' 0] = Reader.ReadSingle ();  		Mot.Rotations [i' 1] = -Reader.ReadSingle ();  		Mot.Rotations [i' 2] = -Reader.ReadSingle ();  		Mot.Rotations [i' 3] = Reader.ReadSingle ();  	}  	Reader.BaseStream.Seek (CurrentOffset' SeekOrigin.Begin);  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: if (Mot.HasRotation != 0) {  	Mot.Rotations = new float[Mot.NumFrames' 4];  	long CurrentOffset = Reader.BaseStream.Position;  	Reader.BaseStream.Seek (m_RotationsTableOffset + 16 * Mot.RotationsOffset' SeekOrigin.Begin);  	for (int i = 0; i < Mot.NumFrames; i++) {  		Mot.Rotations [i' 0] = Reader.ReadSingle ();  		Mot.Rotations [i' 1] = -Reader.ReadSingle ();  		Mot.Rotations [i' 2] = -Reader.ReadSingle ();  		Mot.Rotations [i' 3] = Reader.ReadSingle ();  	}  	Reader.BaseStream.Seek (CurrentOffset' SeekOrigin.Begin);  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: if (Mot.HasRotation != 0) {  	Mot.Rotations = new float[Mot.NumFrames' 4];  	long CurrentOffset = Reader.BaseStream.Position;  	Reader.BaseStream.Seek (m_RotationsTableOffset + 16 * Mot.RotationsOffset' SeekOrigin.Begin);  	for (int i = 0; i < Mot.NumFrames; i++) {  		Mot.Rotations [i' 0] = Reader.ReadSingle ();  		Mot.Rotations [i' 1] = -Reader.ReadSingle ();  		Mot.Rotations [i' 2] = -Reader.ReadSingle ();  		Mot.Rotations [i' 3] = Reader.ReadSingle ();  	}  	Reader.BaseStream.Seek (CurrentOffset' SeekOrigin.Begin);  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: if (Mot.HasRotation != 0) {  	Mot.Rotations = new float[Mot.NumFrames' 4];  	long CurrentOffset = Reader.BaseStream.Position;  	Reader.BaseStream.Seek (m_RotationsTableOffset + 16 * Mot.RotationsOffset' SeekOrigin.Begin);  	for (int i = 0; i < Mot.NumFrames; i++) {  		Mot.Rotations [i' 0] = Reader.ReadSingle ();  		Mot.Rotations [i' 1] = -Reader.ReadSingle ();  		Mot.Rotations [i' 2] = -Reader.ReadSingle ();  		Mot.Rotations [i' 3] = Reader.ReadSingle ();  	}  	Reader.BaseStream.Seek (CurrentOffset' SeekOrigin.Begin);  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: Mot.Rotations = new float[Mot.NumFrames' 4];  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: Reader.BaseStream.Seek (m_RotationsTableOffset + 16 * Mot.RotationsOffset' SeekOrigin.Begin);  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: for (int i = 0; i < Mot.NumFrames; i++) {  	Mot.Rotations [i' 0] = Reader.ReadSingle ();  	Mot.Rotations [i' 1] = -Reader.ReadSingle ();  	Mot.Rotations [i' 2] = -Reader.ReadSingle ();  	Mot.Rotations [i' 3] = Reader.ReadSingle ();  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: for (int i = 0; i < Mot.NumFrames; i++) {  	Mot.Rotations [i' 0] = Reader.ReadSingle ();  	Mot.Rotations [i' 1] = -Reader.ReadSingle ();  	Mot.Rotations [i' 2] = -Reader.ReadSingle ();  	Mot.Rotations [i' 3] = Reader.ReadSingle ();  }  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: Mot.Rotations [i' 2] = -Reader.ReadSingle ();  
Magic Number,SimsLib.ThreeD,Anim,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Anim.cs,ReadMotion,The following statement contains a magic number: Mot.Rotations [i' 3] = Reader.ReadSingle ();  
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Lightmaps.cs,Lightmaps,The following statement contains a magic number: if (Data.Length != 2271104)  	throw new Exception ("Invalid 'lightmap.dat' - Lightmap.cs!");  
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: Writer.Write ((uint)(m_Lights [Index].Width * m_Lights [Index].Height * 3 + 54));  
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: Writer.Write ((uint)(m_Lights [Index].Width * m_Lights [Index].Height * 3 + 54));  
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: Writer.Write ((uint)(m_Lights [Index].Width * m_Lights [Index].Height * 3));  
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: for (int i = 0; i < m_Lights [Index].Width * m_Lights [Index].Height; i++) {  	for (int j = 0; j < 3; j++)  		Writer.Write (Reader.ReadByte ());  }  
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: for (int j = 0; j < 3; j++)  	Writer.Write (Reader.ReadByte ());  
Magic Number,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Mesh.cs,Draw,The following statement contains a magic number: foreach (var face in FaceData) {  	var vertexA = TransformedVertices [face.VertexA];  	var vertexB = TransformedVertices [face.VertexB];  	var vertexC = TransformedVertices [face.VertexC];  	var vertexList = new MeshVertex[3] {  		vertexA.Vertex'  		vertexB.Vertex'  		vertexC.Vertex  	};  	gd.DrawUserPrimitives (PrimitiveType.TriangleList' vertexList' 0' 1);  }  
Magic Number,SimsLib.ThreeD,Outfit,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Outfit.cs,Outfit,The following statement contains a magic number: if (FileID != 0)  	//18 = TypeID of HAG  	m_Handgroup = (ulong)FileID << 32 | 18;  else  	m_Handgroup = 0;  
Magic Number,SimsLib.ThreeD,Outfit,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Outfit.cs,Outfit,The following statement contains a magic number: if (FileID != 0)  	//18 = TypeID of HAG  	m_Handgroup = (ulong)FileID << 32 | 18;  else  	m_Handgroup = 0;  
Magic Number,SimsLib.ThreeD,Outfit,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Outfit.cs,Outfit,The following statement contains a magic number: m_Handgroup = (ulong)FileID << 32 | 18;  
Magic Number,SimsLib.ThreeD,Outfit,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Outfit.cs,Outfit,The following statement contains a magic number: m_Handgroup = (ulong)FileID << 32 | 18;  
Magic Number,SimsLib.HIT,TLO,C:\repos\Afr0_Simslib\src\C#\SimsLib\HIT\TLO.cs,TLO,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,SimsLib.HIT,TLO,C:\repos\Afr0_Simslib\src\C#\SimsLib\HIT\TLO.cs,TLO,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,SimsLib.HIT,Track,C:\repos\Afr0_Simslib\src\C#\SimsLib\HIT\Track.cs,Track,The following statement contains a magic number: m_Label = Values [2];  
Magic Number,SimsLib.HIT,Track,C:\repos\Afr0_Simslib\src\C#\SimsLib\HIT\Track.cs,Track,The following statement contains a magic number: m_TrackID = Values [4];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Signature = (ushort)((Header [1] << 8) | Header [0]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_HeaderLength = 12;  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Params = 4;  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_HeaderLength = 12;  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Type = Header [5];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Params = Header [6];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Locals = (ushort)((Header [7] << 8) | Header [8]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Locals = (ushort)((Header [7] << 8) | Header [8]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Locals = (ushort)((Header [7] << 8) | Header [8]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [9] << 8) | Header [10]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [9] << 8) | Header [10]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [9] << 8) | Header [10]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_HeaderLength = 13;  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Type = Header [3];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Params = Header [4];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Locals = Header [5];  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [8] << 8) | Header [9]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [8] << 8) | Header [9]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [8] << 8) | Header [9]);  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: if (Count <= 0 || Count > 253)  	return;  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: for (int i = 0; i < Count; i++)  	m_Instructions.Add (Reader.ReadBytes (12));  
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following statement contains a magic number: m_Instructions.Add (Reader.ReadBytes (12));  
Magic Number,SimsLib.IFF,IFFDecode,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,Operand,The following statement contains a magic number: return (Instruction [i + 1] << 8) | Instruction [i];  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < 256) {  	DecodePrimitive (P);  	return;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (Name != "\0")  	P.OutStream.Append (Name);  else if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (Name != "\0")  	P.OutStream.Append (Name);  else if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (Name != "\0")  	P.OutStream.Append (Name);  else if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (Name != "\0")  	P.OutStream.Append (Name);  else if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append (m_GlobalSubs [K - 256]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	}  	else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (9' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (9' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr153Len)  	P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  else  	P.OutStream.Append ("WHO=" + (int)(P [4]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr153Len)  	P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  else  	P.OutStream.Append ("WHO=" + (int)(P [4]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr153Len)  	P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  else  	P.OutStream.Append ("WHO=" + (int)(P [4]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("WHO=" + (int)(P [4]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVStr212Len)  	P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  else  	P.OutStream.Append ("WHAT=" + (int)(P [6]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVStr212Len)  	P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  else  	P.OutStream.Append ("WHAT=" + (int)(P [6]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVStr212Len)  	P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  else  	P.OutStream.Append ("WHAT=" + (int)(P [6]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("WHAT=" + (int)(P [6]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [10]' P.Operand (8));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [10]' P.Operand (8));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr231Len)  	P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  else  	P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr231Len)  	P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  else  	P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr231Len)  	P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  else  	P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (8' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (8' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (8);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (10);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [9]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVString224Len) {  	if (P [6] > 0) {  		//cout << " pri=" << BhavStr224[p[6]];  	}  }  else  	P.OutStream.Append (" PRI=" + (int)(P [6]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVString224Len) {  	if (P [6] > 0) {  		//cout << " pri=" << BhavStr224[p[6]];  	}  }  else  	P.OutStream.Append (" PRI=" + (int)(P [6]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVString224Len) {  	if (P [6] > 0) {  		//cout << " pri=" << BhavStr224[p[6]];  	}  }  else  	P.OutStream.Append (" PRI=" + (int)(P [6]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] > 0) {  	//cout << " pri=" << BhavStr224[p[6]];  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (" PRI=" + (int)(P [6]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 1) != 0) {  	P.OutStream.Append (" icon=");  	DoExpressionOperation (25' P.Operand (8));  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 1) != 0) {  	P.OutStream.Append (" icon=");  	DoExpressionOperation (25' P.Operand (8));  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 1) != 0) {  	P.OutStream.Append (" icon=");  	DoExpressionOperation (25' P.Operand (8));  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P.Operand (8));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P.Operand (8));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 0x04) != 0)  	P.OutStream.Append ("' continue as current ");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 0x08) != 0)  	P.OutStream.Append ("' use name ");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (4);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (4);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] != 7 || U == 0) {  	P.OutStream.Append (" if ");  	DoExpressionOperation (P [6]' U);  	P.OutStream.Append (" != 0");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] != 7 || U == 0) {  	P.OutStream.Append (" if ");  	DoExpressionOperation (P [6]' U);  	P.OutStream.Append (" != 0");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] != 7 || U == 0) {  	P.OutStream.Append (" if ");  	DoExpressionOperation (P [6]' U);  	P.OutStream.Append (" != 0");  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' U);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 2) != 0)  	P.OutStream.Append ("empty ");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 2) != 0)  	P.OutStream.Append ("empty ");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr239Len)  	P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  else  	P.OutStream.Append ("LOC=" + (int)(P [4]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr239Len)  	P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  else  	P.OutStream.Append ("LOC=" + (int)(P [4]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr239Len)  	P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  else  	P.OutStream.Append ("LOC=" + (int)(P [4]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("LOC=" + (int)(P [4]));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 1) != 0) {  	P.OutStream.Append (" start at ");  	DoExpressionOperation (25' P [5]);  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 1) != 0) {  	P.OutStream.Append (" start at ");  	DoExpressionOperation (25' P [5]);  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 1) != 0) {  	P.OutStream.Append (" start at ");  	DoExpressionOperation (25' P [5]);  }  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [5]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [5]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 4) != 0)  	P.OutStream.Append (" user-editable");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 4) != 0)  	P.OutStream.Append (" user-editable");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (9' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (9' P.Operand (4));  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (6);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 1) != 0)  	P.OutStream.Append ("' return immediately");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 2) != 0)  	P.OutStream.Append ("' clean up all");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 2) != 0)  	P.OutStream.Append ("' clean up all");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [4]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [4]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [5]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [5]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [6]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [6]);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: T = P.Operand (4);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DecodePrimitive,The following statement contains a magic number: T = (short)P.Operand (6);  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append ("(" + P.Operand (4) + "' " + P.Operand (6) + "' " + P.Operand (8) + "' " + P.Operand (10) + ")");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append ("(" + P.Operand (4) + "' " + P.Operand (6) + "' " + P.Operand (8) + "' " + P.Operand (10) + ")");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append ("(" + P.Operand (4) + "' " + P.Operand (6) + "' " + P.Operand (8) + "' " + P.Operand (10) + ")");  
Magic Number,SimsLib.IFF,BHAVAnalyzer,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append ("(" + P.Operand (4) + "' " + P.Operand (6) + "' " + P.Operand (8) + "' " + P.Operand (10) + ")");  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: m_Version = Reader.ReadUInt16 () - 20000;  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	if (m_Version < 3) {  		SpriteCount = Reader.ReadUInt16 ();  		DirectionFlag = Reader.ReadByte ();  		Zoom = Reader.ReadByte ();  	}  	else {  		DirectionFlag = Reader.ReadUInt32 ();  		Zoom = Reader.ReadUInt32 ();  		SpriteCount = Reader.ReadUInt32 ();  	}  	DrawGroupImg Image = new DrawGroupImg (SpriteCount' DirectionFlag' Zoom);  	for (int j = 0; j < SpriteCount; j++) {  		ushort Tag = 0;  		int PixelX = 0' PixelY = 0;  		uint SprID = 0' SprFrameID = 0' Flags = 0;  		float ZOffset = 0' XOffset = 0' YOffset = 0;  		if (m_Version < 3) {  			Tag = Reader.ReadUInt16 ();  			SprID = Reader.ReadUInt16 ();  			SprFrameID = Reader.ReadUInt16 ();  			Flags = Reader.ReadUInt16 ();  			PixelX = Reader.ReadInt16 ();  			PixelY = Reader.ReadInt16 ();  			if (m_Version == 1)  				ZOffset = Reader.ReadUInt32 ();  		}  		else {  			SprID = Reader.ReadUInt32 ();  			SprFrameID = Reader.ReadUInt32 ();  			PixelX = Reader.ReadInt32 ();  			PixelY = Reader.ReadInt32 ();  			ZOffset = Reader.ReadUInt32 ();  			Flags = Reader.ReadUInt32 ();  			if (m_Version == 4) {  				XOffset = Reader.ReadUInt32 ();  				YOffset = Reader.ReadUInt32 ();  			}  		}  		SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  		if (Frame != null) {  			DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  			Image.Sprites.Insert (0' Sprite);  		}  	}  	m_Images.Add (Image);  }  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	if (m_Version < 3) {  		SpriteCount = Reader.ReadUInt16 ();  		DirectionFlag = Reader.ReadByte ();  		Zoom = Reader.ReadByte ();  	}  	else {  		DirectionFlag = Reader.ReadUInt32 ();  		Zoom = Reader.ReadUInt32 ();  		SpriteCount = Reader.ReadUInt32 ();  	}  	DrawGroupImg Image = new DrawGroupImg (SpriteCount' DirectionFlag' Zoom);  	for (int j = 0; j < SpriteCount; j++) {  		ushort Tag = 0;  		int PixelX = 0' PixelY = 0;  		uint SprID = 0' SprFrameID = 0' Flags = 0;  		float ZOffset = 0' XOffset = 0' YOffset = 0;  		if (m_Version < 3) {  			Tag = Reader.ReadUInt16 ();  			SprID = Reader.ReadUInt16 ();  			SprFrameID = Reader.ReadUInt16 ();  			Flags = Reader.ReadUInt16 ();  			PixelX = Reader.ReadInt16 ();  			PixelY = Reader.ReadInt16 ();  			if (m_Version == 1)  				ZOffset = Reader.ReadUInt32 ();  		}  		else {  			SprID = Reader.ReadUInt32 ();  			SprFrameID = Reader.ReadUInt32 ();  			PixelX = Reader.ReadInt32 ();  			PixelY = Reader.ReadInt32 ();  			ZOffset = Reader.ReadUInt32 ();  			Flags = Reader.ReadUInt32 ();  			if (m_Version == 4) {  				XOffset = Reader.ReadUInt32 ();  				YOffset = Reader.ReadUInt32 ();  			}  		}  		SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  		if (Frame != null) {  			DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  			Image.Sprites.Insert (0' Sprite);  		}  	}  	m_Images.Add (Image);  }  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	if (m_Version < 3) {  		SpriteCount = Reader.ReadUInt16 ();  		DirectionFlag = Reader.ReadByte ();  		Zoom = Reader.ReadByte ();  	}  	else {  		DirectionFlag = Reader.ReadUInt32 ();  		Zoom = Reader.ReadUInt32 ();  		SpriteCount = Reader.ReadUInt32 ();  	}  	DrawGroupImg Image = new DrawGroupImg (SpriteCount' DirectionFlag' Zoom);  	for (int j = 0; j < SpriteCount; j++) {  		ushort Tag = 0;  		int PixelX = 0' PixelY = 0;  		uint SprID = 0' SprFrameID = 0' Flags = 0;  		float ZOffset = 0' XOffset = 0' YOffset = 0;  		if (m_Version < 3) {  			Tag = Reader.ReadUInt16 ();  			SprID = Reader.ReadUInt16 ();  			SprFrameID = Reader.ReadUInt16 ();  			Flags = Reader.ReadUInt16 ();  			PixelX = Reader.ReadInt16 ();  			PixelY = Reader.ReadInt16 ();  			if (m_Version == 1)  				ZOffset = Reader.ReadUInt32 ();  		}  		else {  			SprID = Reader.ReadUInt32 ();  			SprFrameID = Reader.ReadUInt32 ();  			PixelX = Reader.ReadInt32 ();  			PixelY = Reader.ReadInt32 ();  			ZOffset = Reader.ReadUInt32 ();  			Flags = Reader.ReadUInt32 ();  			if (m_Version == 4) {  				XOffset = Reader.ReadUInt32 ();  				YOffset = Reader.ReadUInt32 ();  			}  		}  		SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  		if (Frame != null) {  			DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  			Image.Sprites.Insert (0' Sprite);  		}  	}  	m_Images.Add (Image);  }  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: if (m_Version < 3) {  	SpriteCount = Reader.ReadUInt16 ();  	DirectionFlag = Reader.ReadByte ();  	Zoom = Reader.ReadByte ();  }  else {  	DirectionFlag = Reader.ReadUInt32 ();  	Zoom = Reader.ReadUInt32 ();  	SpriteCount = Reader.ReadUInt32 ();  }  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int j = 0; j < SpriteCount; j++) {  	ushort Tag = 0;  	int PixelX = 0' PixelY = 0;  	uint SprID = 0' SprFrameID = 0' Flags = 0;  	float ZOffset = 0' XOffset = 0' YOffset = 0;  	if (m_Version < 3) {  		Tag = Reader.ReadUInt16 ();  		SprID = Reader.ReadUInt16 ();  		SprFrameID = Reader.ReadUInt16 ();  		Flags = Reader.ReadUInt16 ();  		PixelX = Reader.ReadInt16 ();  		PixelY = Reader.ReadInt16 ();  		if (m_Version == 1)  			ZOffset = Reader.ReadUInt32 ();  	}  	else {  		SprID = Reader.ReadUInt32 ();  		SprFrameID = Reader.ReadUInt32 ();  		PixelX = Reader.ReadInt32 ();  		PixelY = Reader.ReadInt32 ();  		ZOffset = Reader.ReadUInt32 ();  		Flags = Reader.ReadUInt32 ();  		if (m_Version == 4) {  			XOffset = Reader.ReadUInt32 ();  			YOffset = Reader.ReadUInt32 ();  		}  	}  	SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  	if (Frame != null) {  		DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  		Image.Sprites.Insert (0' Sprite);  	}  }  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int j = 0; j < SpriteCount; j++) {  	ushort Tag = 0;  	int PixelX = 0' PixelY = 0;  	uint SprID = 0' SprFrameID = 0' Flags = 0;  	float ZOffset = 0' XOffset = 0' YOffset = 0;  	if (m_Version < 3) {  		Tag = Reader.ReadUInt16 ();  		SprID = Reader.ReadUInt16 ();  		SprFrameID = Reader.ReadUInt16 ();  		Flags = Reader.ReadUInt16 ();  		PixelX = Reader.ReadInt16 ();  		PixelY = Reader.ReadInt16 ();  		if (m_Version == 1)  			ZOffset = Reader.ReadUInt32 ();  	}  	else {  		SprID = Reader.ReadUInt32 ();  		SprFrameID = Reader.ReadUInt32 ();  		PixelX = Reader.ReadInt32 ();  		PixelY = Reader.ReadInt32 ();  		ZOffset = Reader.ReadUInt32 ();  		Flags = Reader.ReadUInt32 ();  		if (m_Version == 4) {  			XOffset = Reader.ReadUInt32 ();  			YOffset = Reader.ReadUInt32 ();  		}  	}  	SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  	if (Frame != null) {  		DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  		Image.Sprites.Insert (0' Sprite);  	}  }  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: if (m_Version < 3) {  	Tag = Reader.ReadUInt16 ();  	SprID = Reader.ReadUInt16 ();  	SprFrameID = Reader.ReadUInt16 ();  	Flags = Reader.ReadUInt16 ();  	PixelX = Reader.ReadInt16 ();  	PixelY = Reader.ReadInt16 ();  	if (m_Version == 1)  		ZOffset = Reader.ReadUInt32 ();  }  else {  	SprID = Reader.ReadUInt32 ();  	SprFrameID = Reader.ReadUInt32 ();  	PixelX = Reader.ReadInt32 ();  	PixelY = Reader.ReadInt32 ();  	ZOffset = Reader.ReadUInt32 ();  	Flags = Reader.ReadUInt32 ();  	if (m_Version == 4) {  		XOffset = Reader.ReadUInt32 ();  		YOffset = Reader.ReadUInt32 ();  	}  }  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: if (m_Version < 3) {  	Tag = Reader.ReadUInt16 ();  	SprID = Reader.ReadUInt16 ();  	SprFrameID = Reader.ReadUInt16 ();  	Flags = Reader.ReadUInt16 ();  	PixelX = Reader.ReadInt16 ();  	PixelY = Reader.ReadInt16 ();  	if (m_Version == 1)  		ZOffset = Reader.ReadUInt32 ();  }  else {  	SprID = Reader.ReadUInt32 ();  	SprFrameID = Reader.ReadUInt32 ();  	PixelX = Reader.ReadInt32 ();  	PixelY = Reader.ReadInt32 ();  	ZOffset = Reader.ReadUInt32 ();  	Flags = Reader.ReadUInt32 ();  	if (m_Version == 4) {  		XOffset = Reader.ReadUInt32 ();  		YOffset = Reader.ReadUInt32 ();  	}  }  
Magic Number,SimsLib.IFF,DrawGroup,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroup.cs,DrawGroup,The following statement contains a magic number: if (m_Version == 4) {  	XOffset = Reader.ReadUInt32 ();  	YOffset = Reader.ReadUInt32 ();  }  
Magic Number,SimsLib.IFF,DrawGroupImg,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: m_CompiledBitmap = new Bitmap (136' 384);  
Magic Number,SimsLib.IFF,DrawGroupImg,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: m_CompiledBitmap = new Bitmap (136' 384);  
Magic Number,SimsLib.IFF,DrawGroupImg,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: foreach (DrawGroupSprite Sprite in Sprites) {  	int xOffset = m_CompiledBitmap.Width / 2 + Sprite.SpriteOffset.X;  	int yOffset = m_CompiledBitmap.Height / 2 + Sprite.SpriteOffset.Y;  	gfx.DrawImageUnscaled (Sprite.Bitmap' Sprite.Sprite.XLocation' Sprite.Sprite.YLocation);  }  
Magic Number,SimsLib.IFF,DrawGroupImg,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: foreach (DrawGroupSprite Sprite in Sprites) {  	int xOffset = m_CompiledBitmap.Width / 2 + Sprite.SpriteOffset.X;  	int yOffset = m_CompiledBitmap.Height / 2 + Sprite.SpriteOffset.Y;  	gfx.DrawImageUnscaled (Sprite.Bitmap' Sprite.Sprite.XLocation' Sprite.Sprite.YLocation);  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Lock,The following statement contains a magic number: if (m_IsAlpha) {  	byte[] Bytes = new byte[(m_Width * m_Height) * 4];  	m_RGBValues = new byte[Bytes.Length];  	Marshal.Copy (m_BMPPtr' m_RGBValues' 0' m_RGBValues.Length);  }  else {  	byte[] Bytes = new byte[(m_Width * m_Height) * 3];  	m_RGBValues = new byte[Bytes.Length];  	Marshal.Copy (m_BMPPtr' m_RGBValues' 0' m_RGBValues.Length);  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Lock,The following statement contains a magic number: if (m_IsAlpha) {  	byte[] Bytes = new byte[(m_Width * m_Height) * 4];  	m_RGBValues = new byte[Bytes.Length];  	Marshal.Copy (m_BMPPtr' m_RGBValues' 0' m_RGBValues.Length);  }  else {  	byte[] Bytes = new byte[(m_Width * m_Height) * 3];  	m_RGBValues = new byte[Bytes.Length];  	Marshal.Copy (m_BMPPtr' m_RGBValues' 0' m_RGBValues.Length);  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  }  else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  }  else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  }  else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  }  else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  }  else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  	m_RGBValues [i + 3] = Clr.A;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  	m_RGBValues [i + 3] = Clr.A;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  	m_RGBValues [i + 3] = Clr.A;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: i = i + 4
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: m_RGBValues [i + 2] = Clr.R;  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: m_RGBValues [i + 3] = Clr.A;  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: i = i + 3
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,Clear,The following statement contains a magic number: m_RGBValues [i + 2] = Clr.R;  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  }  else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  }  else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  }  else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  }  else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  }  else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,SetPixel,The following statement contains a magic number: m_RGBValues [Index + 2] = Clr.R;  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,SetPixel,The following statement contains a magic number: m_RGBValues [Index + 3] = Clr.A;  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,SetPixel,The following statement contains a magic number: m_RGBValues [Index + 2] = Clr.R;  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  }  else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  }  else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  }  else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  }  else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,SimsLib.IFF,FastPixel,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  }  else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,SimsLib.IFF,FCNS,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FCNS.cs,FCNS,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,SimsLib.IFF,FCNS,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FCNS.cs,FCNS,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,SimsLib.IFF,FCNS,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FCNS.cs,FCNS,The following statement contains a magic number: for (int i = 0; i < m_ConstantCount; i++) {  	TuningConstant TConstant = new TuningConstant ();  	if (m_Version == 1) {  		TConstant.Name = ReadZeroPaddedString (Reader);  		byte[] Value = Reader.ReadBytes (4);  		//This should totally not be neccessary' but once again  		//Maxis has introduced the concept of 'half-empty-entries'!  		if (Value.Length == 0) {  			m_TuningConstants.Add (TConstant);  			break;  		}  		TConstant.Value = BitConverter.ToSingle (Value' 0);  		TConstant.Description = ReadZeroPaddedString (Reader);  	}  	else if (m_Version == 2) {  		TConstant.Name = Reader.ReadString ();  		TConstant.Value = Reader.ReadSingle ();  		TConstant.Description = Reader.ReadString ();  	}  	m_TuningConstants.Add (TConstant);  }  
Magic Number,SimsLib.IFF,FCNS,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FCNS.cs,FCNS,The following statement contains a magic number: for (int i = 0; i < m_ConstantCount; i++) {  	TuningConstant TConstant = new TuningConstant ();  	if (m_Version == 1) {  		TConstant.Name = ReadZeroPaddedString (Reader);  		byte[] Value = Reader.ReadBytes (4);  		//This should totally not be neccessary' but once again  		//Maxis has introduced the concept of 'half-empty-entries'!  		if (Value.Length == 0) {  			m_TuningConstants.Add (TConstant);  			break;  		}  		TConstant.Value = BitConverter.ToSingle (Value' 0);  		TConstant.Description = ReadZeroPaddedString (Reader);  	}  	else if (m_Version == 2) {  		TConstant.Name = Reader.ReadString ();  		TConstant.Value = Reader.ReadSingle ();  		TConstant.Description = Reader.ReadString ();  	}  	m_TuningConstants.Add (TConstant);  }  
Magic Number,SimsLib.IFF,FCNS,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FCNS.cs,FCNS,The following statement contains a magic number: if (m_Version == 1) {  	TConstant.Name = ReadZeroPaddedString (Reader);  	byte[] Value = Reader.ReadBytes (4);  	//This should totally not be neccessary' but once again  	//Maxis has introduced the concept of 'half-empty-entries'!  	if (Value.Length == 0) {  		m_TuningConstants.Add (TConstant);  		break;  	}  	TConstant.Value = BitConverter.ToSingle (Value' 0);  	TConstant.Description = ReadZeroPaddedString (Reader);  }  else if (m_Version == 2) {  	TConstant.Name = Reader.ReadString ();  	TConstant.Value = Reader.ReadSingle ();  	TConstant.Description = Reader.ReadString ();  }  
Magic Number,SimsLib.IFF,FCNS,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FCNS.cs,FCNS,The following statement contains a magic number: if (m_Version == 1) {  	TConstant.Name = ReadZeroPaddedString (Reader);  	byte[] Value = Reader.ReadBytes (4);  	//This should totally not be neccessary' but once again  	//Maxis has introduced the concept of 'half-empty-entries'!  	if (Value.Length == 0) {  		m_TuningConstants.Add (TConstant);  		break;  	}  	TConstant.Value = BitConverter.ToSingle (Value' 0);  	TConstant.Description = ReadZeroPaddedString (Reader);  }  else if (m_Version == 2) {  	TConstant.Name = Reader.ReadString ();  	TConstant.Value = Reader.ReadSingle ();  	TConstant.Description = Reader.ReadString ();  }  
Magic Number,SimsLib.IFF,FCNS,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FCNS.cs,FCNS,The following statement contains a magic number: if (m_Version == 2) {  	TConstant.Name = Reader.ReadString ();  	TConstant.Value = Reader.ReadSingle ();  	TConstant.Description = Reader.ReadString ();  }  
Magic Number,SimsLib.IFF,FieldReader,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FieldReader.cs,ReadBits,The following statement contains a magic number: while (FieldData.BitBufferCount < Width) {  	if (FieldData.ReadDataLength >= FieldData.EncodedDataLength)  		return 0;  	FieldData.BitBuffer <<= 8;  	FieldData.BitBuffer |= FieldData.EncodedData [FieldData.FieldDataCounter];  	FieldData.BitBufferCount += 8;  	FieldData.ReadDataLength++;  }  
Magic Number,SimsLib.IFF,FieldReader,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FieldReader.cs,ReadBits,The following statement contains a magic number: while (FieldData.BitBufferCount < Width) {  	if (FieldData.ReadDataLength >= FieldData.EncodedDataLength)  		return 0;  	FieldData.BitBuffer <<= 8;  	FieldData.BitBuffer |= FieldData.EncodedData [FieldData.FieldDataCounter];  	FieldData.BitBufferCount += 8;  	FieldData.ReadDataLength++;  }  
Magic Number,SimsLib.IFF,FieldReader,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FieldReader.cs,ReadBits,The following statement contains a magic number: FieldData.BitBuffer <<= 8;  
Magic Number,SimsLib.IFF,FieldReader,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FieldReader.cs,ReadBits,The following statement contains a magic number: FieldData.BitBufferCount += 8;  
Magic Number,SimsLib.IFF,FieldReader,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FieldReader.cs,DecodeField,The following statement contains a magic number: if (ReadBits (ref Data' 2' ref Prefix) == 0)  	return 0;  
Magic Number,SimsLib.IFF,FieldReader,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\FieldReader.cs,DecodeField,The following statement contains a magic number: Width = Data.FieldWidths [FieldType * 4 + Prefix];  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			}  			else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  }  else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: m_Reader.BaseStream.Position += 76;  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		}  		else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		}  		else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		}  		else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		}  		else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		}  		else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 0) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 13 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  else if (version == 1) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 16 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 0) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 13 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  else if (version == 1) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 16 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  	files.Clear ();  	FuckThisShit (ref files);  	break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 1) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 16 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  	files.Clear ();  	FuckThisShit (ref files);  	break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint j = 0; j < numEntries; j++) {  	if (version == 0) {  		//Empty RSMP...  		//Minimum size for an entry without a label is 9 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	else if (version == 1) {  		//Empty RSMP...  		//Minimum size for an entry without a label is 12 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	uint offset = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt16 ();  	//ChunkID  	if (version == 1) {  		m_Reader.ReadInt16 ();  	}  	//ChunkID  	m_Reader.ReadInt16 ();  	//Flags  	if (version == 1) {  		byte Length = m_Reader.ReadByte ();  		if (Length > 0)  			m_Reader.ReadBytes (Length);  	}  	else {  		GetNameString ();  	}  	offsets.Add (offset);  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint j = 0; j < numEntries; j++) {  	if (version == 0) {  		//Empty RSMP...  		//Minimum size for an entry without a label is 9 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	else if (version == 1) {  		//Empty RSMP...  		//Minimum size for an entry without a label is 12 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	uint offset = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt16 ();  	//ChunkID  	if (version == 1) {  		m_Reader.ReadInt16 ();  	}  	//ChunkID  	m_Reader.ReadInt16 ();  	//Flags  	if (version == 1) {  		byte Length = m_Reader.ReadByte ();  		if (Length > 0)  			m_Reader.ReadBytes (Length);  	}  	else {  		GetNameString ();  	}  	offsets.Add (offset);  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 0) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 9 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  else if (version == 1) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 12 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 0) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 9 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  else if (version == 1) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 12 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  	files.Clear ();  	FuckThisShit (ref files);  	break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 1) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 12 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  	files.Clear ();  	FuckThisShit (ref files);  	break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: m_Reader.BaseStream.Position += (size - 8);  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  	break;  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: foreach (KeyValuePair<string' List<uint>> file in files) {  	foreach (int offset in file.Value) {  		if (offset > 0) {  			m_Reader.BaseStream.Position = offset;  			byte[] Buf = m_Reader.ReadBytes (4);  			string StrResource = Encoding.ASCII.GetString (Buf);  			if (StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS") {  				//MessageBox.Show(StrResource);  				IffChunk Chunk = ToChunk (StrResource' offset);  				//i += (int)Chunk.Length;  				m_Chunks.Add (Chunk);  			}  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: foreach (int offset in file.Value) {  	if (offset > 0) {  		m_Reader.BaseStream.Position = offset;  		byte[] Buf = m_Reader.ReadBytes (4);  		string StrResource = Encoding.ASCII.GetString (Buf);  		if (StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS") {  			//MessageBox.Show(StrResource);  			IffChunk Chunk = ToChunk (StrResource' offset);  			//i += (int)Chunk.Length;  			m_Chunks.Add (Chunk);  		}  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ReadChunks,The following statement contains a magic number: if (offset > 0) {  	m_Reader.BaseStream.Position = offset;  	byte[] Buf = m_Reader.ReadBytes (4);  	string StrResource = Encoding.ASCII.GetString (Buf);  	if (StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS") {  		//MessageBox.Show(StrResource);  		IffChunk Chunk = ToChunk (StrResource' offset);  		//i += (int)Chunk.Length;  		m_Chunks.Add (Chunk);  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FuckThisShit,The following statement contains a magic number: m_Reader.BaseStream.Position = 64;  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FuckThisShit,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//if the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FuckThisShit,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//if the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FuckThisShit,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//if the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FuckThisShit,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//if the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FuckThisShit,The following statement contains a magic number: m_Reader.BaseStream.Position += (size - 8);  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FuckThisShit,The following statement contains a magic number: if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  	break;  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ToChunk,The following statement contains a magic number: Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ToChunk,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) >= Chunk.Length) {  	m_Reader.BaseStream.Position = offset + 76;  	Chunk.Data = m_Reader.ReadBytes ((int)Chunk.Length);  }  else  	Chunk.Data = new byte[Chunk.Length];  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,ToChunk,The following statement contains a magic number: m_Reader.BaseStream.Position = offset + 76;  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,GetNameString,The following statement contains a magic number: for (i = 0; i < 63; i++) {  	Chr = (char)m_Reader.PeekChar ();  	if (Chr == '\0') {  		IsZeroTerminated = true;  		break;  	}  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,GetNameString,The following statement contains a magic number: if (IsZeroTerminated)  	return new string (m_Reader.ReadChars (i));  else  	return Encoding.ASCII.GetString (m_Reader.ReadBytes (64));  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,GetNameString,The following statement contains a magic number: return Encoding.ASCII.GetString (m_Reader.ReadBytes (64));  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position = 64;  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (tag.Equals ("PALT"))  		PALTOffsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (tag.Equals ("PALT"))  		PALTOffsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (tag.Equals ("PALT"))  		PALTOffsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (tag.Equals ("PALT"))  		PALTOffsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position += (size - 8);  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  	break;  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: foreach (KeyValuePair<string' uint> KVP in PALTOffsets) {  	m_Reader.BaseStream.Position = KVP.Value;  	IffChunk Chunk = new IffChunk (KVP.Key);  	Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  	Chunk.ID = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	ushort Flags = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	Chunk.NameString = GetNameString ();  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) >= Chunk.Length) {  		m_Reader.BaseStream.Position = KVP.Value + 76;  		Chunk.Data = m_Reader.ReadBytes ((int)Chunk.Length);  	}  	else  		Chunk.Data = new byte[Chunk.Length];  	m_PMaps.Add (new PaletteMap (Chunk));  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: foreach (KeyValuePair<string' uint> KVP in PALTOffsets) {  	m_Reader.BaseStream.Position = KVP.Value;  	IffChunk Chunk = new IffChunk (KVP.Key);  	Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  	Chunk.ID = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	ushort Flags = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	Chunk.NameString = GetNameString ();  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) >= Chunk.Length) {  		m_Reader.BaseStream.Position = KVP.Value + 76;  		Chunk.Data = m_Reader.ReadBytes ((int)Chunk.Length);  	}  	else  		Chunk.Data = new byte[Chunk.Length];  	m_PMaps.Add (new PaletteMap (Chunk));  }  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) >= Chunk.Length) {  	m_Reader.BaseStream.Position = KVP.Value + 76;  	Chunk.Data = m_Reader.ReadBytes ((int)Chunk.Length);  }  else  	Chunk.Data = new byte[Chunk.Length];  
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position = KVP.Value + 76;  
Magic Number,SimsLib.IFF,IffChunkID,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\IffChunkID.cs,ToChunkID,The following statement contains a magic number: return ((A << 24) | (B << 16) | (C << 8) | D);  
Magic Number,SimsLib.IFF,IffChunkID,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\IffChunkID.cs,ToChunkID,The following statement contains a magic number: return ((A << 24) | (B << 16) | (C << 8) | D);  
Magic Number,SimsLib.IFF,IffChunkID,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\IffChunkID.cs,ToChunkID,The following statement contains a magic number: return ((A << 24) | (B << 16) | (C << 8) | D);  
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\OBJD.cs,OBJD,The following statement contains a magic number: if (m_Version != 138) {  	//Assume log statements will be stored in the client's log...  	Log.LogThis ("Tried loading OBJD chunk version: " + m_Version + " (SimsLib.dll)"' eloglevel.error);  	return;  }  
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\OBJD.cs,OBJD,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,SimsLib.IFF,OBJf,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\OBJf.cs,OBJf,The following statement contains a magic number: Reader.ReadBytes (8);  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors = new Color[256];  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: Reader.BaseStream.Position = 16;  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	byte[] colors = new byte[] {    	};  	if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  		m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  	else  		m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  }  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	byte[] colors = new byte[] {    	};  	if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  		m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  	else  		m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  }  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	byte[] colors = new byte[] {    	};  	if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  		m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  	else  		m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  }  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  	m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  else  	m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  	m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  else  	m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors = new Color[256];  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	m_Colors [i] = Color.FromArgb (255' 0' 0' 0);  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	m_Colors [i] = Color.FromArgb (255' 0' 0' 0);  
Magic Number,SimsLib.IFF,PaletteMap,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors [i] = Color.FromArgb (255' 0' 0' 0);  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,GetFrame,The following statement contains a magic number: if (m_Version == 1000) {  	foreach (SpriteFrame Frame in m_Frames) {  		if (Frame.FrameIndex == Index)  			return Frame;  	}  	return ReadFrame (Index);  }  else  	return m_Frames [Index];  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: if (m_Version == 1000)  	m_ChunkData = Chunk.Data;  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: if (m_Version == 1001) {  	m_PaletteID = Reader.ReadUInt32 ();  	m_FrameCount = Reader.ReadUInt32 ();  }  else {  	m_FrameCount = Reader.ReadUInt32 ();  	m_PaletteID = Reader.ReadUInt32 ();  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: if (m_Version == 1000) {  	for (int i = 0; i < m_FrameCount; i++) {  		offsets [i] = Reader.ReadInt32 ();  		m_FrameOffsets.Add (offsets [i]);  	}  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: if (m_Version == 1001) {  	for (int l = 0; l < m_FrameCount; l++) {  		SpriteFrame Frame = new SpriteFrame ();  		Frame.Version = Reader.ReadUInt32 ();  		Frame.Size = Reader.ReadUInt32 ();  		Frame.Width = Reader.ReadUInt16 ();  		Frame.Height = Reader.ReadUInt16 ();  		Frame.Flag = Reader.ReadUInt32 ();  		Frame.PaletteID = Reader.ReadUInt16 ();  		Frame.TransparentPixel = m_PMap.GetColorAtIndex (Reader.ReadUInt16 ());  		Frame.YLocation = Reader.ReadUInt16 ();  		Frame.XLocation = Reader.ReadUInt16 ();  		if ((SPR2Flags)Frame.Flag == SPR2Flags.HasAlphaChannel)  			Frame.Init (true' true);  		else {  			if ((SPR2Flags)Frame.Flag == SPR2Flags.HasZBufferChannel)  				Frame.Init (false' true);  			else  				Frame.Init (false' false);  		}  		DecompressFrame2 (ref Frame' ref Reader);  		Frame.BitmapData.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		if (Frame.HasZBuffer)  			Frame.ZBuffer.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		m_Frames.Add (Frame);  	}  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= PixelCount * 2;  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Padding = PixelCount % 2;  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= (PixelCount * 3) + Padding;  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	//This is completely transparent regardless of whether the frame  	//supports alpha.  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	//This is completely transparent regardless of whether the frame  	//supports alpha.  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	//This is completely transparent regardless of whether the frame  	//supports alpha.  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	//This is completely transparent regardless of whether the frame  	//supports alpha.  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Padding = PixelCount % 2;  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int i = 0; i < RowHeader [1]; i++) {  	for (int j = 0; j < Frame.Width; j++) {  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		CurrentColumn++;  	}  	CurrentColumn = 0;  	CurrentRow++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int i = 0; i < RowHeader [1]; i++) {  	for (int j = 0; j < Frame.Width; j++) {  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		CurrentColumn++;  	}  	CurrentColumn = 0;  	CurrentRow++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int i = 0; i < RowHeader [1]; i++) {  	for (int j = 0; j < Frame.Width; j++) {  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		CurrentColumn++;  	}  	CurrentColumn = 0;  	CurrentRow++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int i = 0; i < RowHeader [1]; i++) {  	for (int j = 0; j < Frame.Width; j++) {  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		CurrentColumn++;  	}  	CurrentColumn = 0;  	CurrentRow++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int j = 0; j < Frame.Width; j++) {  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int j = 0; j < Frame.Width; j++) {  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int j = 0; j < Frame.Width; j++) {  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int j = 0; j < Frame.Width; j++) {  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	CurrentColumn++;  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,ExportToBitmaps,The following statement contains a magic number: if (m_Version == 1001) {  	foreach (SpriteFrame Frame in m_Frames) {  		string fileLocation = directory + '\\' + m_ID + '_' + Frame.Width + 'x' + Frame.Height + ".bmp";  		if (File.Exists (fileLocation))  			File.Delete (fileLocation);  		Frame.BitmapData.BitMap.Save (fileLocation);  		//This calls FastPixel.Unlock()  		Frame.BitmapData.Lock ();  		//The bitmap should always be locked!  	}  }  
Magic Number,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,GetDecryptedValues,The following statement contains a magic number: return new int[] {  	(P >> 13)'  	// Code  	((P & 0x1FFF))  };  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,GetFrame,The following statement contains a magic number: if (m_Version != 1001) {  	foreach (SpriteFrame Frame in m_Frames) {  		if (Frame.FrameIndex == Index)  			return Frame;  	}  	return ReadFrame (Index);  }  else  	return m_Frames [Index];  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version != 1001)  	m_ChunkData = Chunk.Data;  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_IsBigEndian) {  	if (m_Version != 1001) {  		m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		for (uint i = 0; i < m_FrameCount; i++)  			m_OffsetTable.Add (Endian.SwapUInt32 (Reader.ReadUInt32 ()));  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		}  		else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  	else {  		m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		}  		else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  }  else {  	if (m_Version != 1001) {  		m_FrameCount = Reader.ReadUInt32 ();  		m_PaletteID = Reader.ReadUInt32 ();  		for (uint i = 0; i < m_FrameCount; i++)  			m_OffsetTable.Add (Reader.ReadUInt32 ());  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		}  		else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  	else {  		m_FrameCount = Reader.ReadUInt32 ();  		m_PaletteID = Reader.ReadUInt32 ();  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		}  		else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_IsBigEndian) {  	if (m_Version != 1001) {  		m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		for (uint i = 0; i < m_FrameCount; i++)  			m_OffsetTable.Add (Endian.SwapUInt32 (Reader.ReadUInt32 ()));  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		}  		else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  	else {  		m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		}  		else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  }  else {  	if (m_Version != 1001) {  		m_FrameCount = Reader.ReadUInt32 ();  		m_PaletteID = Reader.ReadUInt32 ();  		for (uint i = 0; i < m_FrameCount; i++)  			m_OffsetTable.Add (Reader.ReadUInt32 ());  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		}  		else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  	else {  		m_FrameCount = Reader.ReadUInt32 ();  		m_PaletteID = Reader.ReadUInt32 ();  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		}  		else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version != 1001) {  	m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  	m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  	for (uint i = 0; i < m_FrameCount; i++)  		m_OffsetTable.Add (Endian.SwapUInt32 (Reader.ReadUInt32 ()));  	//Find and set the correct palettemap...  	if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  		m_PMap = PaletteMaps [0];  	}  	else  		m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  			if (PMap.ID == m_PaletteID) {  				return true;  			}  			return false;  		});  }  else {  	m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  	m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  	//Find and set the correct palettemap...  	if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  		m_PMap = PaletteMaps [0];  	}  	else  		m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  			if (PMap.ID == m_PaletteID) {  				return true;  			}  			return false;  		});  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version != 1001) {  	m_FrameCount = Reader.ReadUInt32 ();  	m_PaletteID = Reader.ReadUInt32 ();  	for (uint i = 0; i < m_FrameCount; i++)  		m_OffsetTable.Add (Reader.ReadUInt32 ());  	//Find and set the correct palettemap...  	if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  		m_PMap = PaletteMaps [0];  	}  	else  		m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  			if (PMap.ID == m_PaletteID) {  				return true;  			}  			return false;  		});  }  else {  	m_FrameCount = Reader.ReadUInt32 ();  	m_PaletteID = Reader.ReadUInt32 ();  	//Find and set the correct palettemap...  	if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  		m_PMap = PaletteMaps [0];  	}  	else  		m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  			if (PMap.ID == m_PaletteID) {  				return true;  			}  			return false;  		});  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version == 1001) {  	//Framecount may be set to -1 and should be ignored...  	while (true) {  		SpriteFrame Frame = new SpriteFrame ();  		Frame.Version = Reader.ReadUInt32 ();  		Frame.Size = Reader.ReadUInt32 ();  		Reader.ReadBytes (4);  		//Reserved.  		Frame.Height = Reader.ReadUInt16 ();  		Frame.Width = Reader.ReadUInt16 ();  		Frame.Init (true' false);  		//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  		DecompressFrame2 (ref Frame' ref Reader);  		Frame.BitmapData.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		m_Frames.Add (Frame);  		if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  			break;  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version == 1001) {  	//Framecount may be set to -1 and should be ignored...  	while (true) {  		SpriteFrame Frame = new SpriteFrame ();  		Frame.Version = Reader.ReadUInt32 ();  		Frame.Size = Reader.ReadUInt32 ();  		Reader.ReadBytes (4);  		//Reserved.  		Frame.Height = Reader.ReadUInt16 ();  		Frame.Width = Reader.ReadUInt16 ();  		Frame.Init (true' false);  		//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  		DecompressFrame2 (ref Frame' ref Reader);  		Frame.BitmapData.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		m_Frames.Add (Frame);  		if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  			break;  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version == 1001) {  	//Framecount may be set to -1 and should be ignored...  	while (true) {  		SpriteFrame Frame = new SpriteFrame ();  		Frame.Version = Reader.ReadUInt32 ();  		Frame.Size = Reader.ReadUInt32 ();  		Reader.ReadBytes (4);  		//Reserved.  		Frame.Height = Reader.ReadUInt16 ();  		Frame.Width = Reader.ReadUInt16 ();  		Frame.Init (true' false);  		//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  		DecompressFrame2 (ref Frame' ref Reader);  		Frame.BitmapData.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		m_Frames.Add (Frame);  		if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  			break;  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: while (true) {  	SpriteFrame Frame = new SpriteFrame ();  	Frame.Version = Reader.ReadUInt32 ();  	Frame.Size = Reader.ReadUInt32 ();  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Reader.ReadUInt16 ();  	Frame.Width = Reader.ReadUInt16 ();  	Frame.Init (true' false);  	//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  	DecompressFrame2 (ref Frame' ref Reader);  	Frame.BitmapData.Unlock (true);  	//The bitmapdata is locked when the frame is created.  	m_Frames.Add (Frame);  	if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  		break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: while (true) {  	SpriteFrame Frame = new SpriteFrame ();  	Frame.Version = Reader.ReadUInt32 ();  	Frame.Size = Reader.ReadUInt32 ();  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Reader.ReadUInt16 ();  	Frame.Width = Reader.ReadUInt16 ();  	Frame.Init (true' false);  	//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  	DecompressFrame2 (ref Frame' ref Reader);  	Frame.BitmapData.Unlock (true);  	//The bitmapdata is locked when the frame is created.  	m_Frames.Add (Frame);  	if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  		break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,SPRParser,The following statement contains a magic number: if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  	break;  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,ReadFrame,The following statement contains a magic number: if (!m_IsBigEndian) {  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Reader.ReadUInt16 ();  	Frame.Width = Reader.ReadUInt16 ();  	Frame.PaletteID = (ushort)m_PaletteID;  }  else {  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Endian.SwapUInt16 (Reader.ReadUInt16 ());  	Frame.Width = Endian.SwapUInt16 (Reader.ReadUInt16 ());  	Frame.PaletteID = (ushort)m_PaletteID;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,ReadFrame,The following statement contains a magic number: if (!m_IsBigEndian) {  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Reader.ReadUInt16 ();  	Frame.Width = Reader.ReadUInt16 ();  	Frame.PaletteID = (ushort)m_PaletteID;  }  else {  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Endian.SwapUInt16 (Reader.ReadUInt16 ());  	Frame.Width = Endian.SwapUInt16 (Reader.ReadUInt16 ());  	Frame.PaletteID = (ushort)m_PaletteID;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,ReadFrame,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,ReadFrame,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: Reader.ReadBytes (2);  
Magic Number,SimsLib.IFF,StringTable,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\StringTable.cs,ReadZeroString,The following statement contains a magic number: while (true) {  	Chrs = Reader.ReadChars (2);  	SB.Append (Chrs);  	if (new string (Chrs) == "\0\0")  		break;  }  
Magic Number,SimsLib.IFF,StringTable,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\StringTable.cs,ReadZeroString,The following statement contains a magic number: Chrs = Reader.ReadChars (2);  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			}  			else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	}  	catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		}  		else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  }  catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	}  	else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  }  else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 10)  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version >= 7)  	Action.AttenuationCode = Reader.ReadUInt32 ();  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (uint j = 0; j < Action.MotiveEntryCount; j++) {  	Motive MotiveEntry = new Motive ();  	if (m_Version >= 7)  		MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  	MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  	if (m_Version >= 7)  		MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  	Action.Motives.Add (MotiveEntry);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: for (uint j = 0; j < Action.MotiveEntryCount; j++) {  	Motive MotiveEntry = new Motive ();  	if (m_Version >= 7)  		MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  	MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  	if (m_Version >= 7)  		MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  	Action.Motives.Add (MotiveEntry);  }  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version >= 7)  	MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version >= 7)  	MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 11)  	Reader.ReadBytes (4);  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 11)  	Reader.ReadBytes (4);  
Magic Number,SimsLib.IFF,TTAB,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\TTAB.cs,TTAB,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,SimsLib,Endian,C:\repos\Afr0_Simslib\src\C#\SimsLib\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,SimsLib,Endian,C:\repos\Afr0_Simslib\src\C#\SimsLib\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,SimsLib,Endian,C:\repos\Afr0_Simslib\src\C#\SimsLib\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,SimsLib,Endian,C:\repos\Afr0_Simslib\src\C#\SimsLib\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		}  		while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		}  		else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			}  			else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	m_Compressed = false;  	if (m_CompressedSize < m_DecompressedSize)  		m_Compressed = true;  	return DataStream.ToArray ();  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	}  	while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	}  	else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		}  		else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: do {  	index++;  	if (index >= Data.Length - 2) {  		end = true;  		break;  	}  	int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  	indexList = cmpmap2 [mapindex];  	if (indexList == null) {  		indexList = new ArrayList ();  		cmpmap2.Add (mapindex' indexList);  	}  	indexList.Add (index);  }  while (index < lastReadIndex);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: do {  	index++;  	if (index >= Data.Length - 2) {  		end = true;  		break;  	}  	int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  	indexList = cmpmap2 [mapindex];  	if (indexList == null) {  		indexList = new ArrayList ();  		cmpmap2.Add (mapindex' indexList);  	}  	indexList.Add (index);  }  while (index < lastReadIndex);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: do {  	index++;  	if (index >= Data.Length - 2) {  		end = true;  		break;  	}  	int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  	indexList = cmpmap2 [mapindex];  	if (indexList == null) {  		indexList = new ArrayList ();  		cmpmap2.Add (mapindex' indexList);  	}  	indexList.Add (index);  }  while (index < lastReadIndex);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: do {  	index++;  	if (index >= Data.Length - 2) {  		end = true;  		break;  	}  	int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  	indexList = cmpmap2 [mapindex];  	if (indexList == null) {  		indexList = new ArrayList ();  		cmpmap2.Add (mapindex' indexList);  	}  	indexList.Add (index);  }  while (index < lastReadIndex);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (index >= Data.Length - 2) {  	end = true;  	break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  	int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  	if ((index - foundindex) >= MAX_OFFSET) {  		break;  	}  	loopcount++;  	copyCount = 3;  	while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  		copyCount++;  	}  	if (copyCount > offsetCopyCount) {  		offsetCopyCount = copyCount;  		copyOffset = index - foundindex;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 3;  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount <= 2) {  	offsetCopyCount = 0;  }  else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  }  else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount <= 2) {  	offsetCopyCount = 0;  }  else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  }  else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount <= 2) {  	offsetCopyCount = 0;  }  else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  }  else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  }  else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  }  else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	}  	else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B) {  		copyCount = 0x1B;  	}  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B) {  		copyCount = 0x1B;  	}  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B) {  		copyCount = 0x1B;  	}  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B) {  		copyCount = 0x1B;  	}  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = (index - lastReadIndex) / 4 - 1;  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  }  else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B)  		copyCount = 0x1B;  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B)  		copyCount = 0x1B;  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B)  		copyCount = 0x1B;  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B)  		copyCount = 0x1B;  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = (index - lastReadIndex) / 4 - 1;  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	m_Compressed = true;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  		else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  	else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  }  else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false) {  	isReadingSomething = true;  	try {  		m_Reader = new BinaryReader (File.Open (Path' FileMode.Open' FileAccess.Read' FileShare.Read));  	}  	catch (Exception e) {  		throw new FAR3Exception ("Could not open the specified archive - " + Path + "! (FAR3Archive())");  	}  	string Header = Encoding.ASCII.GetString (m_Reader.ReadBytes (8));  	uint Version = m_Reader.ReadUInt32 ();  	if ((Header != "FAR!byAZ") || (Version != 3)) {  		throw new FAR3Exception ("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");  	}  	uint ManifestOffset = m_Reader.ReadUInt32 ();  	m_ManifestOffset = ManifestOffset;  	m_Reader.BaseStream.Seek (ManifestOffset' SeekOrigin.Begin);  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		Far3Entry Entry = new Far3Entry ();  		Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		Entry.DataType = m_Reader.ReadByte ();  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Compressed = m_Reader.ReadByte ();  		Entry.AccessNumber = m_Reader.ReadByte ();  		Entry.FilenameLength = m_Reader.ReadUInt16 ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  		if (!m_Entries.ContainsKey (Entry.Filename))  			m_Entries.Add (Entry.Filename' Entry);  		m_EntriesList.Add (Entry);  		m_EntryByID.Add (Entry.FileID' Entry);  	}  	//Keep the stream open' it helps peformance.  	//m_Reader.Close();  	isReadingSomething = false;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false) {  	isReadingSomething = true;  	try {  		m_Reader = new BinaryReader (File.Open (Path' FileMode.Open' FileAccess.Read' FileShare.Read));  	}  	catch (Exception e) {  		throw new FAR3Exception ("Could not open the specified archive - " + Path + "! (FAR3Archive())");  	}  	string Header = Encoding.ASCII.GetString (m_Reader.ReadBytes (8));  	uint Version = m_Reader.ReadUInt32 ();  	if ((Header != "FAR!byAZ") || (Version != 3)) {  		throw new FAR3Exception ("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");  	}  	uint ManifestOffset = m_Reader.ReadUInt32 ();  	m_ManifestOffset = ManifestOffset;  	m_Reader.BaseStream.Seek (ManifestOffset' SeekOrigin.Begin);  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		Far3Entry Entry = new Far3Entry ();  		Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		Entry.DataType = m_Reader.ReadByte ();  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Compressed = m_Reader.ReadByte ();  		Entry.AccessNumber = m_Reader.ReadByte ();  		Entry.FilenameLength = m_Reader.ReadUInt16 ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  		if (!m_Entries.ContainsKey (Entry.Filename))  			m_Entries.Add (Entry.Filename' Entry);  		m_EntriesList.Add (Entry);  		m_EntryByID.Add (Entry.FileID' Entry);  	}  	//Keep the stream open' it helps peformance.  	//m_Reader.Close();  	isReadingSomething = false;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false) {  	isReadingSomething = true;  	try {  		m_Reader = new BinaryReader (File.Open (Path' FileMode.Open' FileAccess.Read' FileShare.Read));  	}  	catch (Exception e) {  		throw new FAR3Exception ("Could not open the specified archive - " + Path + "! (FAR3Archive())");  	}  	string Header = Encoding.ASCII.GetString (m_Reader.ReadBytes (8));  	uint Version = m_Reader.ReadUInt32 ();  	if ((Header != "FAR!byAZ") || (Version != 3)) {  		throw new FAR3Exception ("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");  	}  	uint ManifestOffset = m_Reader.ReadUInt32 ();  	m_ManifestOffset = ManifestOffset;  	m_Reader.BaseStream.Seek (ManifestOffset' SeekOrigin.Begin);  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		Far3Entry Entry = new Far3Entry ();  		Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		Entry.DataType = m_Reader.ReadByte ();  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Compressed = m_Reader.ReadByte ();  		Entry.AccessNumber = m_Reader.ReadByte ();  		Entry.FilenameLength = m_Reader.ReadUInt16 ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  		if (!m_Entries.ContainsKey (Entry.Filename))  			m_Entries.Add (Entry.Filename' Entry);  		m_EntriesList.Add (Entry);  		m_EntryByID.Add (Entry.FileID' Entry);  	}  	//Keep the stream open' it helps peformance.  	//m_Reader.Close();  	isReadingSomething = false;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false) {  	isReadingSomething = true;  	try {  		m_Reader = new BinaryReader (File.Open (Path' FileMode.Open' FileAccess.Read' FileShare.Read));  	}  	catch (Exception e) {  		throw new FAR3Exception ("Could not open the specified archive - " + Path + "! (FAR3Archive())");  	}  	string Header = Encoding.ASCII.GetString (m_Reader.ReadBytes (8));  	uint Version = m_Reader.ReadUInt32 ();  	if ((Header != "FAR!byAZ") || (Version != 3)) {  		throw new FAR3Exception ("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");  	}  	uint ManifestOffset = m_Reader.ReadUInt32 ();  	m_ManifestOffset = ManifestOffset;  	m_Reader.BaseStream.Seek (ManifestOffset' SeekOrigin.Begin);  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		Far3Entry Entry = new Far3Entry ();  		Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		Entry.DataType = m_Reader.ReadByte ();  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Compressed = m_Reader.ReadByte ();  		Entry.AccessNumber = m_Reader.ReadByte ();  		Entry.FilenameLength = m_Reader.ReadUInt16 ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  		if (!m_Entries.ContainsKey (Entry.Filename))  			m_Entries.Add (Entry.Filename' Entry);  		m_EntriesList.Add (Entry);  		m_EntryByID.Add (Entry.FileID' Entry);  	}  	//Keep the stream open' it helps peformance.  	//m_Reader.Close();  	isReadingSomething = false;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false) {  	isReadingSomething = true;  	try {  		m_Reader = new BinaryReader (File.Open (Path' FileMode.Open' FileAccess.Read' FileShare.Read));  	}  	catch (Exception e) {  		throw new FAR3Exception ("Could not open the specified archive - " + Path + "! (FAR3Archive())");  	}  	string Header = Encoding.ASCII.GetString (m_Reader.ReadBytes (8));  	uint Version = m_Reader.ReadUInt32 ();  	if ((Header != "FAR!byAZ") || (Version != 3)) {  		throw new FAR3Exception ("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");  	}  	uint ManifestOffset = m_Reader.ReadUInt32 ();  	m_ManifestOffset = ManifestOffset;  	m_Reader.BaseStream.Seek (ManifestOffset' SeekOrigin.Begin);  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		Far3Entry Entry = new Far3Entry ();  		Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		Entry.DataType = m_Reader.ReadByte ();  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Compressed = m_Reader.ReadByte ();  		Entry.AccessNumber = m_Reader.ReadByte ();  		Entry.FilenameLength = m_Reader.ReadUInt16 ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  		if (!m_Entries.ContainsKey (Entry.Filename))  			m_Entries.Add (Entry.Filename' Entry);  		m_EntriesList.Add (Entry);  		m_EntryByID.Add (Entry.FileID' Entry);  	}  	//Keep the stream open' it helps peformance.  	//m_Reader.Close();  	isReadingSomething = false;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false) {  	isReadingSomething = true;  	try {  		m_Reader = new BinaryReader (File.Open (Path' FileMode.Open' FileAccess.Read' FileShare.Read));  	}  	catch (Exception e) {  		throw new FAR3Exception ("Could not open the specified archive - " + Path + "! (FAR3Archive())");  	}  	string Header = Encoding.ASCII.GetString (m_Reader.ReadBytes (8));  	uint Version = m_Reader.ReadUInt32 ();  	if ((Header != "FAR!byAZ") || (Version != 3)) {  		throw new FAR3Exception ("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");  	}  	uint ManifestOffset = m_Reader.ReadUInt32 ();  	m_ManifestOffset = ManifestOffset;  	m_Reader.BaseStream.Seek (ManifestOffset' SeekOrigin.Begin);  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		Far3Entry Entry = new Far3Entry ();  		Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		Entry.DataType = m_Reader.ReadByte ();  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Compressed = m_Reader.ReadByte ();  		Entry.AccessNumber = m_Reader.ReadByte ();  		Entry.FilenameLength = m_Reader.ReadUInt16 ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  		if (!m_Entries.ContainsKey (Entry.Filename))  			m_Entries.Add (Entry.Filename' Entry);  		m_EntriesList.Add (Entry);  		m_EntryByID.Add (Entry.FileID' Entry);  	}  	//Keep the stream open' it helps peformance.  	//m_Reader.Close();  	isReadingSomething = false;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if ((Header != "FAR!byAZ") || (Version != 3)) {  	throw new FAR3Exception ("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++) {  	Far3Entry Entry = new Far3Entry ();  	Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  	byte[] Dummy = m_Reader.ReadBytes (3);  	Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  	Entry.DataType = m_Reader.ReadByte ();  	Entry.DataOffset = m_Reader.ReadUInt32 ();  	Entry.Compressed = m_Reader.ReadByte ();  	Entry.AccessNumber = m_Reader.ReadByte ();  	Entry.FilenameLength = m_Reader.ReadUInt16 ();  	Entry.TypeID = m_Reader.ReadUInt32 ();  	Entry.FileID = m_Reader.ReadUInt32 ();  	Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  	if (!m_Entries.ContainsKey (Entry.Filename))  		m_Entries.Add (Entry.Filename' Entry);  	m_EntriesList.Add (Entry);  	m_EntryByID.Add (Entry.FileID' Entry);  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++) {  	Far3Entry Entry = new Far3Entry ();  	Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  	byte[] Dummy = m_Reader.ReadBytes (3);  	Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  	Entry.DataType = m_Reader.ReadByte ();  	Entry.DataOffset = m_Reader.ReadUInt32 ();  	Entry.Compressed = m_Reader.ReadByte ();  	Entry.AccessNumber = m_Reader.ReadByte ();  	Entry.FilenameLength = m_Reader.ReadUInt16 ();  	Entry.TypeID = m_Reader.ReadUInt32 ();  	Entry.FileID = m_Reader.ReadUInt32 ();  	Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  	if (!m_Entries.ContainsKey (Entry.Filename))  		m_Entries.Add (Entry.Filename' Entry);  	m_EntriesList.Add (Entry);  	m_EntryByID.Add (Entry.FileID' Entry);  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++) {  	Far3Entry Entry = new Far3Entry ();  	Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  	byte[] Dummy = m_Reader.ReadBytes (3);  	Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  	Entry.DataType = m_Reader.ReadByte ();  	Entry.DataOffset = m_Reader.ReadUInt32 ();  	Entry.Compressed = m_Reader.ReadByte ();  	Entry.AccessNumber = m_Reader.ReadByte ();  	Entry.FilenameLength = m_Reader.ReadUInt16 ();  	Entry.TypeID = m_Reader.ReadUInt32 ();  	Entry.FileID = m_Reader.ReadUInt32 ();  	Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  	if (!m_Entries.ContainsKey (Entry.Filename))  		m_Entries.Add (Entry.Filename' Entry);  	m_EntriesList.Add (Entry);  	m_EntryByID.Add (Entry.FileID' Entry);  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++) {  	Far3Entry Entry = new Far3Entry ();  	Entry.DecompressedFileSize = m_Reader.ReadUInt32 ();  	byte[] Dummy = m_Reader.ReadBytes (3);  	Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  	Entry.DataType = m_Reader.ReadByte ();  	Entry.DataOffset = m_Reader.ReadUInt32 ();  	Entry.Compressed = m_Reader.ReadByte ();  	Entry.AccessNumber = m_Reader.ReadByte ();  	Entry.FilenameLength = m_Reader.ReadUInt16 ();  	Entry.TypeID = m_Reader.ReadUInt32 ();  	Entry.FileID = m_Reader.ReadUInt32 ();  	Entry.Filename = Encoding.ASCII.GetString (m_Reader.ReadBytes (Entry.FilenameLength));  	if (!m_Entries.ContainsKey (Entry.Filename))  		m_Entries.Add (Entry.Filename' Entry);  	m_EntriesList.Add (Entry);  	m_EntryByID.Add (Entry.FileID' Entry);  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: Entry.CompressedFileSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: lock (m_Reader) {  	//m_Reader = new BinaryReader(File.Open(m_ArchivePath' FileMode.Open' FileAccess.Read));  	m_Reader.BaseStream.Seek ((long)Entry.DataOffset' SeekOrigin.Begin);  	isReadingSomething = true;  	if (Entry.Compressed == 0x01) {  		m_Reader.ReadBytes (9);  		uint Filesize = m_Reader.ReadUInt32 ();  		ushort CompressionID = m_Reader.ReadUInt16 ();  		if (CompressionID == 0xFB10) {  			byte[] Dummy = m_Reader.ReadBytes (3);  			uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  			Decompresser Dec = new Decompresser ();  			Dec.CompressedSize = Filesize;  			Dec.DecompressedSize = DecompressedSize;  			byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  			//m_Reader.Close();  			isReadingSomething = false;  			return DecompressedData;  		}  		else {  			m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  			byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  			//m_Reader.Close();  			isReadingSomething = false;  			return Data;  		}  	}  	else {  		byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  		//m_Reader.Close();  		isReadingSomething = false;  		return Data;  	}  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: lock (m_Reader) {  	//m_Reader = new BinaryReader(File.Open(m_ArchivePath' FileMode.Open' FileAccess.Read));  	m_Reader.BaseStream.Seek ((long)Entry.DataOffset' SeekOrigin.Begin);  	isReadingSomething = true;  	if (Entry.Compressed == 0x01) {  		m_Reader.ReadBytes (9);  		uint Filesize = m_Reader.ReadUInt32 ();  		ushort CompressionID = m_Reader.ReadUInt16 ();  		if (CompressionID == 0xFB10) {  			byte[] Dummy = m_Reader.ReadBytes (3);  			uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  			Decompresser Dec = new Decompresser ();  			Dec.CompressedSize = Filesize;  			Dec.DecompressedSize = DecompressedSize;  			byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  			//m_Reader.Close();  			isReadingSomething = false;  			return DecompressedData;  		}  		else {  			m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  			byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  			//m_Reader.Close();  			isReadingSomething = false;  			return Data;  		}  	}  	else {  		byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  		//m_Reader.Close();  		isReadingSomething = false;  		return Data;  	}  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: lock (m_Reader) {  	//m_Reader = new BinaryReader(File.Open(m_ArchivePath' FileMode.Open' FileAccess.Read));  	m_Reader.BaseStream.Seek ((long)Entry.DataOffset' SeekOrigin.Begin);  	isReadingSomething = true;  	if (Entry.Compressed == 0x01) {  		m_Reader.ReadBytes (9);  		uint Filesize = m_Reader.ReadUInt32 ();  		ushort CompressionID = m_Reader.ReadUInt16 ();  		if (CompressionID == 0xFB10) {  			byte[] Dummy = m_Reader.ReadBytes (3);  			uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  			Decompresser Dec = new Decompresser ();  			Dec.CompressedSize = Filesize;  			Dec.DecompressedSize = DecompressedSize;  			byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  			//m_Reader.Close();  			isReadingSomething = false;  			return DecompressedData;  		}  		else {  			m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  			byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  			//m_Reader.Close();  			isReadingSomething = false;  			return Data;  		}  	}  	else {  		byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  		//m_Reader.Close();  		isReadingSomething = false;  		return Data;  	}  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: lock (m_Reader) {  	//m_Reader = new BinaryReader(File.Open(m_ArchivePath' FileMode.Open' FileAccess.Read));  	m_Reader.BaseStream.Seek ((long)Entry.DataOffset' SeekOrigin.Begin);  	isReadingSomething = true;  	if (Entry.Compressed == 0x01) {  		m_Reader.ReadBytes (9);  		uint Filesize = m_Reader.ReadUInt32 ();  		ushort CompressionID = m_Reader.ReadUInt16 ();  		if (CompressionID == 0xFB10) {  			byte[] Dummy = m_Reader.ReadBytes (3);  			uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  			Decompresser Dec = new Decompresser ();  			Dec.CompressedSize = Filesize;  			Dec.DecompressedSize = DecompressedSize;  			byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  			//m_Reader.Close();  			isReadingSomething = false;  			return DecompressedData;  		}  		else {  			m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  			byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  			//m_Reader.Close();  			isReadingSomething = false;  			return Data;  		}  	}  	else {  		byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  		//m_Reader.Close();  		isReadingSomething = false;  		return Data;  	}  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: if (Entry.Compressed == 0x01) {  	m_Reader.ReadBytes (9);  	uint Filesize = m_Reader.ReadUInt32 ();  	ushort CompressionID = m_Reader.ReadUInt16 ();  	if (CompressionID == 0xFB10) {  		byte[] Dummy = m_Reader.ReadBytes (3);  		uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  		Decompresser Dec = new Decompresser ();  		Dec.CompressedSize = Filesize;  		Dec.DecompressedSize = DecompressedSize;  		byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  		//m_Reader.Close();  		isReadingSomething = false;  		return DecompressedData;  	}  	else {  		m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  		byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  		//m_Reader.Close();  		isReadingSomething = false;  		return Data;  	}  }  else {  	byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  	//m_Reader.Close();  	isReadingSomething = false;  	return Data;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: if (Entry.Compressed == 0x01) {  	m_Reader.ReadBytes (9);  	uint Filesize = m_Reader.ReadUInt32 ();  	ushort CompressionID = m_Reader.ReadUInt16 ();  	if (CompressionID == 0xFB10) {  		byte[] Dummy = m_Reader.ReadBytes (3);  		uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  		Decompresser Dec = new Decompresser ();  		Dec.CompressedSize = Filesize;  		Dec.DecompressedSize = DecompressedSize;  		byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  		//m_Reader.Close();  		isReadingSomething = false;  		return DecompressedData;  	}  	else {  		m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  		byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  		//m_Reader.Close();  		isReadingSomething = false;  		return Data;  	}  }  else {  	byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  	//m_Reader.Close();  	isReadingSomething = false;  	return Data;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: if (Entry.Compressed == 0x01) {  	m_Reader.ReadBytes (9);  	uint Filesize = m_Reader.ReadUInt32 ();  	ushort CompressionID = m_Reader.ReadUInt16 ();  	if (CompressionID == 0xFB10) {  		byte[] Dummy = m_Reader.ReadBytes (3);  		uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  		Decompresser Dec = new Decompresser ();  		Dec.CompressedSize = Filesize;  		Dec.DecompressedSize = DecompressedSize;  		byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  		//m_Reader.Close();  		isReadingSomething = false;  		return DecompressedData;  	}  	else {  		m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  		byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  		//m_Reader.Close();  		isReadingSomething = false;  		return Data;  	}  }  else {  	byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  	//m_Reader.Close();  	isReadingSomething = false;  	return Data;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: if (Entry.Compressed == 0x01) {  	m_Reader.ReadBytes (9);  	uint Filesize = m_Reader.ReadUInt32 ();  	ushort CompressionID = m_Reader.ReadUInt16 ();  	if (CompressionID == 0xFB10) {  		byte[] Dummy = m_Reader.ReadBytes (3);  		uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  		Decompresser Dec = new Decompresser ();  		Dec.CompressedSize = Filesize;  		Dec.DecompressedSize = DecompressedSize;  		byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  		//m_Reader.Close();  		isReadingSomething = false;  		return DecompressedData;  	}  	else {  		m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  		byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  		//m_Reader.Close();  		isReadingSomething = false;  		return Data;  	}  }  else {  	byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  	//m_Reader.Close();  	isReadingSomething = false;  	return Data;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: m_Reader.ReadBytes (9);  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: if (CompressionID == 0xFB10) {  	byte[] Dummy = m_Reader.ReadBytes (3);  	uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  	Decompresser Dec = new Decompresser ();  	Dec.CompressedSize = Filesize;  	Dec.DecompressedSize = DecompressedSize;  	byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  	//m_Reader.Close();  	isReadingSomething = false;  	return DecompressedData;  }  else {  	m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  	byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  	//m_Reader.Close();  	isReadingSomething = false;  	return Data;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: if (CompressionID == 0xFB10) {  	byte[] Dummy = m_Reader.ReadBytes (3);  	uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  	Decompresser Dec = new Decompresser ();  	Dec.CompressedSize = Filesize;  	Dec.DecompressedSize = DecompressedSize;  	byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  	//m_Reader.Close();  	isReadingSomething = false;  	return DecompressedData;  }  else {  	m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  	byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  	//m_Reader.Close();  	isReadingSomething = false;  	return Data;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: if (CompressionID == 0xFB10) {  	byte[] Dummy = m_Reader.ReadBytes (3);  	uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  	Decompresser Dec = new Decompresser ();  	Dec.CompressedSize = Filesize;  	Dec.DecompressedSize = DecompressedSize;  	byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)Filesize));  	//m_Reader.Close();  	isReadingSomething = false;  	return DecompressedData;  }  else {  	m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  	byte[] Data = m_Reader.ReadBytes ((int)Entry.DecompressedFileSize);  	//m_Reader.Close();  	isReadingSomething = false;  	return Data;  }  
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Simslib\src\C#\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: m_Reader.BaseStream.Seek ((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,UseSensibleDefaults,The following statement contains a magic number: Log.LogSizeMax = 100;  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: if (a.Length > 1) {  	try {  		baseInfo [2] = a [a.Length - 1];  		baseInfo [1] = baseInfo [1].Remove (baseInfo [1].Length - baseInfo [2].Length - 1' baseInfo [2].Length + 1);  	}  	catch (Exception ex) {  		Debug.Write (ex.Message);  	}  }  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: if (a.Length > 1) {  	try {  		baseInfo [2] = a [a.Length - 1];  		baseInfo [1] = baseInfo [1].Remove (baseInfo [1].Length - baseInfo [2].Length - 1' baseInfo [2].Length + 1);  	}  	catch (Exception ex) {  		Debug.Write (ex.Message);  	}  }  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: if (a.Length > 1) {  	try {  		baseInfo [2] = a [a.Length - 1];  		baseInfo [1] = baseInfo [1].Remove (baseInfo [1].Length - baseInfo [2].Length - 1' baseInfo [2].Length + 1);  	}  	catch (Exception ex) {  		Debug.Write (ex.Message);  	}  }  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: try {  	baseInfo [2] = a [a.Length - 1];  	baseInfo [1] = baseInfo [1].Remove (baseInfo [1].Length - baseInfo [2].Length - 1' baseInfo [2].Length + 1);  }  catch (Exception ex) {  	Debug.Write (ex.Message);  }  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: try {  	baseInfo [2] = a [a.Length - 1];  	baseInfo [1] = baseInfo [1].Remove (baseInfo [1].Length - baseInfo [2].Length - 1' baseInfo [2].Length + 1);  }  catch (Exception ex) {  	Debug.Write (ex.Message);  }  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: try {  	baseInfo [2] = a [a.Length - 1];  	baseInfo [1] = baseInfo [1].Remove (baseInfo [1].Length - baseInfo [2].Length - 1' baseInfo [2].Length + 1);  }  catch (Exception ex) {  	Debug.Write (ex.Message);  }  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: baseInfo [2] = a [a.Length - 1];  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: baseInfo [1] = baseInfo [1].Remove (baseInfo [1].Length - baseInfo [2].Length - 1' baseInfo [2].Length + 1);  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: baseInfo [1] = baseInfo [1].Remove (baseInfo [1].Length - baseInfo [2].Length - 1' baseInfo [2].Length + 1);  
Magic Number,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: for (int i = 0; i < filePath.Length - ((baseInfo [1].Length) + (baseInfo [2].Length + 1)) - 1; i++) {  	baseInfo [0] += filePath [i];  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat) {  case elogquotaformat.kbytes:  	try {  		FileInfo info = new FileInfo (sLogPath);  		nfileSize = info.Length;  	}  	catch (Exception x) {  		System.Console.WriteLine ("Error:" + x.Message);  		nfileSize = 0;  	}  	if (nfileSize < (m_logsizemax * 1024)) {  		return;  	}  	break;  case elogquotaformat.rows:  	using (StreamReader sr = new StreamReader (sLogPath)) {  		String line;  		while ((line = sr.ReadLine ()) != null) {  			i++;  		}  		if (i < m_logsizemax) {  			return;  		}  	}  	break;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: if (nfileSize < (m_logsizemax * 1024)) {  	return;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader (sLogPath)) {  	switch (m_logquotaformat) {  	case elogquotaformat.kbytes:  		char[] c = null;  		long bufsize = 1024;  		//should match streams natural buffer size.  		long kb = 1024;  		j = (long)((m_logsizemax * kb) * .9);  		while (sr.Peek () >= 0) {  			c = new char[bufsize];  			sr.Read (c' 0' c.Length);  			i++;  			if ((i * bufsize) > j) {  				for (i = 0; i < c.Length; i++) {  					if (c [i] == '\r' && c [i + 1] == '\n') {  						//write out the remaining part of the last line.  						char[] c2 = new char[i + 2];  						Array.Copy (c' 0' c2' 0' i + 2);  						SW.Write (c2);  						break;  					}  				}  				break;  			}  			else {  				SW.Write (c);  			}  		}  		break;  	case elogquotaformat.rows:  		String line;  		j = (long)(m_logsizemax * .9);  		//reduce by 10% below max.  		while ((line = sr.ReadLine ()) != null) {  			SW.WriteLine (line);  			i++;  			if (i > j) {  				break;  			}  		}  		break;  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader (sLogPath)) {  	switch (m_logquotaformat) {  	case elogquotaformat.kbytes:  		char[] c = null;  		long bufsize = 1024;  		//should match streams natural buffer size.  		long kb = 1024;  		j = (long)((m_logsizemax * kb) * .9);  		while (sr.Peek () >= 0) {  			c = new char[bufsize];  			sr.Read (c' 0' c.Length);  			i++;  			if ((i * bufsize) > j) {  				for (i = 0; i < c.Length; i++) {  					if (c [i] == '\r' && c [i + 1] == '\n') {  						//write out the remaining part of the last line.  						char[] c2 = new char[i + 2];  						Array.Copy (c' 0' c2' 0' i + 2);  						SW.Write (c2);  						break;  					}  				}  				break;  			}  			else {  				SW.Write (c);  			}  		}  		break;  	case elogquotaformat.rows:  		String line;  		j = (long)(m_logsizemax * .9);  		//reduce by 10% below max.  		while ((line = sr.ReadLine ()) != null) {  			SW.WriteLine (line);  			i++;  			if (i > j) {  				break;  			}  		}  		break;  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader (sLogPath)) {  	switch (m_logquotaformat) {  	case elogquotaformat.kbytes:  		char[] c = null;  		long bufsize = 1024;  		//should match streams natural buffer size.  		long kb = 1024;  		j = (long)((m_logsizemax * kb) * .9);  		while (sr.Peek () >= 0) {  			c = new char[bufsize];  			sr.Read (c' 0' c.Length);  			i++;  			if ((i * bufsize) > j) {  				for (i = 0; i < c.Length; i++) {  					if (c [i] == '\r' && c [i + 1] == '\n') {  						//write out the remaining part of the last line.  						char[] c2 = new char[i + 2];  						Array.Copy (c' 0' c2' 0' i + 2);  						SW.Write (c2);  						break;  					}  				}  				break;  			}  			else {  				SW.Write (c);  			}  		}  		break;  	case elogquotaformat.rows:  		String line;  		j = (long)(m_logsizemax * .9);  		//reduce by 10% below max.  		while ((line = sr.ReadLine ()) != null) {  			SW.WriteLine (line);  			i++;  			if (i > j) {  				break;  			}  		}  		break;  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader (sLogPath)) {  	switch (m_logquotaformat) {  	case elogquotaformat.kbytes:  		char[] c = null;  		long bufsize = 1024;  		//should match streams natural buffer size.  		long kb = 1024;  		j = (long)((m_logsizemax * kb) * .9);  		while (sr.Peek () >= 0) {  			c = new char[bufsize];  			sr.Read (c' 0' c.Length);  			i++;  			if ((i * bufsize) > j) {  				for (i = 0; i < c.Length; i++) {  					if (c [i] == '\r' && c [i + 1] == '\n') {  						//write out the remaining part of the last line.  						char[] c2 = new char[i + 2];  						Array.Copy (c' 0' c2' 0' i + 2);  						SW.Write (c2);  						break;  					}  				}  				break;  			}  			else {  				SW.Write (c);  			}  		}  		break;  	case elogquotaformat.rows:  		String line;  		j = (long)(m_logsizemax * .9);  		//reduce by 10% below max.  		while ((line = sr.ReadLine ()) != null) {  			SW.WriteLine (line);  			i++;  			if (i > j) {  				break;  			}  		}  		break;  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader (sLogPath)) {  	switch (m_logquotaformat) {  	case elogquotaformat.kbytes:  		char[] c = null;  		long bufsize = 1024;  		//should match streams natural buffer size.  		long kb = 1024;  		j = (long)((m_logsizemax * kb) * .9);  		while (sr.Peek () >= 0) {  			c = new char[bufsize];  			sr.Read (c' 0' c.Length);  			i++;  			if ((i * bufsize) > j) {  				for (i = 0; i < c.Length; i++) {  					if (c [i] == '\r' && c [i + 1] == '\n') {  						//write out the remaining part of the last line.  						char[] c2 = new char[i + 2];  						Array.Copy (c' 0' c2' 0' i + 2);  						SW.Write (c2);  						break;  					}  				}  				break;  			}  			else {  				SW.Write (c);  			}  		}  		break;  	case elogquotaformat.rows:  		String line;  		j = (long)(m_logsizemax * .9);  		//reduce by 10% below max.  		while ((line = sr.ReadLine ()) != null) {  			SW.WriteLine (line);  			i++;  			if (i > j) {  				break;  			}  		}  		break;  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader (sLogPath)) {  	switch (m_logquotaformat) {  	case elogquotaformat.kbytes:  		char[] c = null;  		long bufsize = 1024;  		//should match streams natural buffer size.  		long kb = 1024;  		j = (long)((m_logsizemax * kb) * .9);  		while (sr.Peek () >= 0) {  			c = new char[bufsize];  			sr.Read (c' 0' c.Length);  			i++;  			if ((i * bufsize) > j) {  				for (i = 0; i < c.Length; i++) {  					if (c [i] == '\r' && c [i + 1] == '\n') {  						//write out the remaining part of the last line.  						char[] c2 = new char[i + 2];  						Array.Copy (c' 0' c2' 0' i + 2);  						SW.Write (c2);  						break;  					}  				}  				break;  			}  			else {  				SW.Write (c);  			}  		}  		break;  	case elogquotaformat.rows:  		String line;  		j = (long)(m_logsizemax * .9);  		//reduce by 10% below max.  		while ((line = sr.ReadLine ()) != null) {  			SW.WriteLine (line);  			i++;  			if (i > j) {  				break;  			}  		}  		break;  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat) {  case elogquotaformat.kbytes:  	char[] c = null;  	long bufsize = 1024;  	//should match streams natural buffer size.  	long kb = 1024;  	j = (long)((m_logsizemax * kb) * .9);  	while (sr.Peek () >= 0) {  		c = new char[bufsize];  		sr.Read (c' 0' c.Length);  		i++;  		if ((i * bufsize) > j) {  			for (i = 0; i < c.Length; i++) {  				if (c [i] == '\r' && c [i + 1] == '\n') {  					//write out the remaining part of the last line.  					char[] c2 = new char[i + 2];  					Array.Copy (c' 0' c2' 0' i + 2);  					SW.Write (c2);  					break;  				}  			}  			break;  		}  		else {  			SW.Write (c);  		}  	}  	break;  case elogquotaformat.rows:  	String line;  	j = (long)(m_logsizemax * .9);  	//reduce by 10% below max.  	while ((line = sr.ReadLine ()) != null) {  		SW.WriteLine (line);  		i++;  		if (i > j) {  			break;  		}  	}  	break;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat) {  case elogquotaformat.kbytes:  	char[] c = null;  	long bufsize = 1024;  	//should match streams natural buffer size.  	long kb = 1024;  	j = (long)((m_logsizemax * kb) * .9);  	while (sr.Peek () >= 0) {  		c = new char[bufsize];  		sr.Read (c' 0' c.Length);  		i++;  		if ((i * bufsize) > j) {  			for (i = 0; i < c.Length; i++) {  				if (c [i] == '\r' && c [i + 1] == '\n') {  					//write out the remaining part of the last line.  					char[] c2 = new char[i + 2];  					Array.Copy (c' 0' c2' 0' i + 2);  					SW.Write (c2);  					break;  				}  			}  			break;  		}  		else {  			SW.Write (c);  		}  	}  	break;  case elogquotaformat.rows:  	String line;  	j = (long)(m_logsizemax * .9);  	//reduce by 10% below max.  	while ((line = sr.ReadLine ()) != null) {  		SW.WriteLine (line);  		i++;  		if (i > j) {  			break;  		}  	}  	break;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat) {  case elogquotaformat.kbytes:  	char[] c = null;  	long bufsize = 1024;  	//should match streams natural buffer size.  	long kb = 1024;  	j = (long)((m_logsizemax * kb) * .9);  	while (sr.Peek () >= 0) {  		c = new char[bufsize];  		sr.Read (c' 0' c.Length);  		i++;  		if ((i * bufsize) > j) {  			for (i = 0; i < c.Length; i++) {  				if (c [i] == '\r' && c [i + 1] == '\n') {  					//write out the remaining part of the last line.  					char[] c2 = new char[i + 2];  					Array.Copy (c' 0' c2' 0' i + 2);  					SW.Write (c2);  					break;  				}  			}  			break;  		}  		else {  			SW.Write (c);  		}  	}  	break;  case elogquotaformat.rows:  	String line;  	j = (long)(m_logsizemax * .9);  	//reduce by 10% below max.  	while ((line = sr.ReadLine ()) != null) {  		SW.WriteLine (line);  		i++;  		if (i > j) {  			break;  		}  	}  	break;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat) {  case elogquotaformat.kbytes:  	char[] c = null;  	long bufsize = 1024;  	//should match streams natural buffer size.  	long kb = 1024;  	j = (long)((m_logsizemax * kb) * .9);  	while (sr.Peek () >= 0) {  		c = new char[bufsize];  		sr.Read (c' 0' c.Length);  		i++;  		if ((i * bufsize) > j) {  			for (i = 0; i < c.Length; i++) {  				if (c [i] == '\r' && c [i + 1] == '\n') {  					//write out the remaining part of the last line.  					char[] c2 = new char[i + 2];  					Array.Copy (c' 0' c2' 0' i + 2);  					SW.Write (c2);  					break;  				}  			}  			break;  		}  		else {  			SW.Write (c);  		}  	}  	break;  case elogquotaformat.rows:  	String line;  	j = (long)(m_logsizemax * .9);  	//reduce by 10% below max.  	while ((line = sr.ReadLine ()) != null) {  		SW.WriteLine (line);  		i++;  		if (i > j) {  			break;  		}  	}  	break;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat) {  case elogquotaformat.kbytes:  	char[] c = null;  	long bufsize = 1024;  	//should match streams natural buffer size.  	long kb = 1024;  	j = (long)((m_logsizemax * kb) * .9);  	while (sr.Peek () >= 0) {  		c = new char[bufsize];  		sr.Read (c' 0' c.Length);  		i++;  		if ((i * bufsize) > j) {  			for (i = 0; i < c.Length; i++) {  				if (c [i] == '\r' && c [i + 1] == '\n') {  					//write out the remaining part of the last line.  					char[] c2 = new char[i + 2];  					Array.Copy (c' 0' c2' 0' i + 2);  					SW.Write (c2);  					break;  				}  			}  			break;  		}  		else {  			SW.Write (c);  		}  	}  	break;  case elogquotaformat.rows:  	String line;  	j = (long)(m_logsizemax * .9);  	//reduce by 10% below max.  	while ((line = sr.ReadLine ()) != null) {  		SW.WriteLine (line);  		i++;  		if (i > j) {  			break;  		}  	}  	break;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat) {  case elogquotaformat.kbytes:  	char[] c = null;  	long bufsize = 1024;  	//should match streams natural buffer size.  	long kb = 1024;  	j = (long)((m_logsizemax * kb) * .9);  	while (sr.Peek () >= 0) {  		c = new char[bufsize];  		sr.Read (c' 0' c.Length);  		i++;  		if ((i * bufsize) > j) {  			for (i = 0; i < c.Length; i++) {  				if (c [i] == '\r' && c [i + 1] == '\n') {  					//write out the remaining part of the last line.  					char[] c2 = new char[i + 2];  					Array.Copy (c' 0' c2' 0' i + 2);  					SW.Write (c2);  					break;  				}  			}  			break;  		}  		else {  			SW.Write (c);  		}  	}  	break;  case elogquotaformat.rows:  	String line;  	j = (long)(m_logsizemax * .9);  	//reduce by 10% below max.  	while ((line = sr.ReadLine ()) != null) {  		SW.WriteLine (line);  		i++;  		if (i > j) {  			break;  		}  	}  	break;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: j = (long)((m_logsizemax * kb) * .9);  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: while (sr.Peek () >= 0) {  	c = new char[bufsize];  	sr.Read (c' 0' c.Length);  	i++;  	if ((i * bufsize) > j) {  		for (i = 0; i < c.Length; i++) {  			if (c [i] == '\r' && c [i + 1] == '\n') {  				//write out the remaining part of the last line.  				char[] c2 = new char[i + 2];  				Array.Copy (c' 0' c2' 0' i + 2);  				SW.Write (c2);  				break;  			}  		}  		break;  	}  	else {  		SW.Write (c);  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: while (sr.Peek () >= 0) {  	c = new char[bufsize];  	sr.Read (c' 0' c.Length);  	i++;  	if ((i * bufsize) > j) {  		for (i = 0; i < c.Length; i++) {  			if (c [i] == '\r' && c [i + 1] == '\n') {  				//write out the remaining part of the last line.  				char[] c2 = new char[i + 2];  				Array.Copy (c' 0' c2' 0' i + 2);  				SW.Write (c2);  				break;  			}  		}  		break;  	}  	else {  		SW.Write (c);  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: if ((i * bufsize) > j) {  	for (i = 0; i < c.Length; i++) {  		if (c [i] == '\r' && c [i + 1] == '\n') {  			//write out the remaining part of the last line.  			char[] c2 = new char[i + 2];  			Array.Copy (c' 0' c2' 0' i + 2);  			SW.Write (c2);  			break;  		}  	}  	break;  }  else {  	SW.Write (c);  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: if ((i * bufsize) > j) {  	for (i = 0; i < c.Length; i++) {  		if (c [i] == '\r' && c [i + 1] == '\n') {  			//write out the remaining part of the last line.  			char[] c2 = new char[i + 2];  			Array.Copy (c' 0' c2' 0' i + 2);  			SW.Write (c2);  			break;  		}  	}  	break;  }  else {  	SW.Write (c);  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: for (i = 0; i < c.Length; i++) {  	if (c [i] == '\r' && c [i + 1] == '\n') {  		//write out the remaining part of the last line.  		char[] c2 = new char[i + 2];  		Array.Copy (c' 0' c2' 0' i + 2);  		SW.Write (c2);  		break;  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: for (i = 0; i < c.Length; i++) {  	if (c [i] == '\r' && c [i + 1] == '\n') {  		//write out the remaining part of the last line.  		char[] c2 = new char[i + 2];  		Array.Copy (c' 0' c2' 0' i + 2);  		SW.Write (c2);  		break;  	}  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: if (c [i] == '\r' && c [i + 1] == '\n') {  	//write out the remaining part of the last line.  	char[] c2 = new char[i + 2];  	Array.Copy (c' 0' c2' 0' i + 2);  	SW.Write (c2);  	break;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: if (c [i] == '\r' && c [i + 1] == '\n') {  	//write out the remaining part of the last line.  	char[] c2 = new char[i + 2];  	Array.Copy (c' 0' c2' 0' i + 2);  	SW.Write (c2);  	break;  }  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: Array.Copy (c' 0' c2' 0' i + 2);  
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: j = (long)(m_logsizemax * .9);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_ID = new string (m_Reader.ReadChars (4));  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_UnreadBitsCount = 8;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits (4));  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits (4));  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower [0] = (ReadBits (4) + 1) * 8;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower [0] = (ReadBits (4) + 1) * 8;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: for (int i = 1; i < 64; i++)  	m_InnovationPower [i] = m_InnovationPower [i - 1] * Base;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: if ((m_UnreadBitsCount < 8) && (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length)) {  	m_UnreadBitsValue |= m_Reader.ReadByte () << m_UnreadBitsCount;  	m_UnreadBitsCount += 8;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: if ((m_UnreadBitsCount < 8) && (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length)) {  	m_UnreadBitsValue |= m_Reader.ReadByte () << m_UnreadBitsCount;  	m_UnreadBitsCount += 8;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: m_UnreadBitsCount += 8;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0) {  	int BlockSize = Lesser ((int)Frames' 432);  	DecodeFrame ();  	for (int i = 0; i < BlockSize; i++) {  		int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  		Value = Clamp<int> (Value' -32768' 32767);  		m_Writer.Write ((ushort)Value);  	}  	Frames -= (uint)BlockSize;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0) {  	int BlockSize = Lesser ((int)Frames' 432);  	DecodeFrame ();  	for (int i = 0; i < BlockSize; i++) {  		int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  		Value = Clamp<int> (Value' -32768' 32767);  		m_Writer.Write ((ushort)Value);  	}  	Frames -= (uint)BlockSize;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0) {  	int BlockSize = Lesser ((int)Frames' 432);  	DecodeFrame ();  	for (int i = 0; i < BlockSize; i++) {  		int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  		Value = Clamp<int> (Value' -32768' 32767);  		m_Writer.Write ((ushort)Value);  	}  	Frames -= (uint)BlockSize;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0) {  	int BlockSize = Lesser ((int)Frames' 432);  	DecodeFrame ();  	for (int i = 0; i < BlockSize; i++) {  		int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  		Value = Clamp<int> (Value' -32768' 32767);  		m_Writer.Write ((ushort)Value);  	}  	Frames -= (uint)BlockSize;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: for (int i = 0; i < BlockSize; i++) {  	int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  	Value = Clamp<int> (Value' -32768' 32767);  	m_Writer.Write ((ushort)Value);  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: for (int i = 0; i < BlockSize; i++) {  	int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  	Value = Clamp<int> (Value' -32768' 32767);  	m_Writer.Write ((ushort)Value);  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: for (int i = 0; i < BlockSize; i++) {  	int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  	Value = Clamp<int> (Value' -32768' 32767);  	m_Writer.Write ((ushort)Value);  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: Value = Clamp<int> (Value' -32768' 32767);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: Value = Clamp<int> (Value' -32768' 32767);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	}  	else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		}  		else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (i == 0 && Phase > 216)  	Phase = 216;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (i == 0 && Phase > 216)  	Phase = 216;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Phase = 216;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  }  else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	}  	else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: GenerateExcitation (5' ref Excitation' Voiced' 1);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  }  else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  }  else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  }  else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  }  else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  }  else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  }  else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  }  else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  }  else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = 0.0f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = 0.0f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: j += 2
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: j += 2
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy (m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy (m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy (m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 12; j++)  	m_RC [j] += RCDelta [j];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize (i * 12' (i != 3) ? 12 : 396);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize (i * 12' (i != 3) ? 12 : 396);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize (i * 12' (i != 3) ? 12 : 396);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize (i * 12' (i != 3) ? 12 : 396);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  		else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		}  		else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  }  else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  	else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	}  	else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: Table = (code < 2 || code > 8) ? 1 : 0;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: Table = (code < 2 || code > 8) ? 1 : 0;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: Excitation [i] = (code - 1) / 4;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  }  else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: x = Lesser (x' (Offset + 108 - i) / Interval);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: for (int i = Offset; i < Offset + 108; i += Interval) {  	if (ReadBits (1) == 0)  		Excitation [i] = 0.0f;  	else if (ReadBits (1) == 0)  		Excitation [i] = -2.0f;  	else  		Excitation [i] = 2.0f;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0) {  	for (int i = 0; i < 12; i++) {  		if (++offset == 12)  			offset = 0;  		m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  	}  	m_History [offset--] = m_DecompressedFrame [324 + Sample++];  	Samples--;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0) {  	for (int i = 0; i < 12; i++) {  		if (++offset == 12)  			offset = 0;  		m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  	}  	m_History [offset--] = m_DecompressedFrame [324 + Sample++];  	Samples--;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0) {  	for (int i = 0; i < 12; i++) {  		if (++offset == 12)  			offset = 0;  		m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  	}  	m_History [offset--] = m_DecompressedFrame [324 + Sample++];  	Samples--;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0) {  	for (int i = 0; i < 12; i++) {  		if (++offset == 12)  			offset = 0;  		m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  	}  	m_History [offset--] = m_DecompressedFrame [324 + Sample++];  	Samples--;  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	if (++offset == 12)  		offset = 0;  	m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	if (++offset == 12)  		offset = 0;  	m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	if (++offset == 12)  		offset = 0;  	m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: if (++offset == 12)  	offset = 0;  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: m_History [offset--] = m_DecompressedFrame [324 + Sample++];  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: Array.Copy (RC' 0' RCTemp' 1' 11);  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++) {  	LPC [i] = 0.0f;  	for (j = 11; j >= 0; j--) {  		LPC [i] -= RC [j] * RCTemp [j];  		if (j != 11)  			RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  	}  	RCTemp [0] = LPCTemp [i] = LPC [i];  	for (j = 0; j < i; j++)  		LPC [i] -= LPCTemp [i - j - 1] * LPC [j];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++) {  	LPC [i] = 0.0f;  	for (j = 11; j >= 0; j--) {  		LPC [i] -= RC [j] * RCTemp [j];  		if (j != 11)  			RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  	}  	RCTemp [0] = LPCTemp [i] = LPC [i];  	for (j = 0; j < i; j++)  		LPC [i] -= LPCTemp [i - j - 1] * LPC [j];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++) {  	LPC [i] = 0.0f;  	for (j = 11; j >= 0; j--) {  		LPC [i] -= RC [j] * RCTemp [j];  		if (j != 11)  			RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  	}  	RCTemp [0] = LPCTemp [i] = LPC [i];  	for (j = 0; j < i; j++)  		LPC [i] -= LPCTemp [i - j - 1] * LPC [j];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (j = 11; j >= 0; j--) {  	LPC [i] -= RC [j] * RCTemp [j];  	if (j != 11)  		RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (j = 11; j >= 0; j--) {  	LPC [i] -= RC [j] * RCTemp [j];  	if (j != 11)  		RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  }  
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: j = 11
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Simslib\src\C#\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: if (j != 11)  	RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = new string (m_Reader.ReadChars (4));  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = new string (m_Reader.ReadChars (4));  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: if (m_Channels == 1)//Mono   {  	while (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length) {  		DecompressMono (m_Reader.ReadBytes (0xF));  	}  }  else if (m_Channels == 2)//Stereo   {  	while (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length) {  		DecompressStereo (m_Reader.ReadBytes (0x1E));  	}  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: if (m_Channels == 2)//Stereo   {  	while (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length) {  		DecompressStereo (m_Reader.ReadBytes (0x1E));  	}  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2left = (int)EATable [HINIBBLE (bInput) + 4];  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: dleft = (byte)(LONIBBLE (bInput) + 8);  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2right = (int)EATable [HINIBBLE (bInput) + 4];  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: dright = (byte)(LONIBBLE (bInput) + 8);  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleLeft;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleLeft;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleLeft;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleLeft;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleLeft;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleLeft;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: i = 2
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: i += 2
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: d = (byte)(LONIBBLE (bInput) + 8);  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: c2left = (int)EATable [HINIBBLE (bInput) + 4];  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: dleft = (byte)(LONIBBLE (bInput) + 8);  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: for (i = 1; i < 0xF; i++) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	// Now we've got lCurSampleLeft which is one mono sample and all is set  	// for the next input nibble...  	//Output((SHORT)lCurSampleLeft); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	// Now we've got lCurSampleLeft which is one mono sample and all is set  	// for the next input byte...  	//Output((SHORT)lCurSampleLeft); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: for (i = 1; i < 0xF; i++) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	// Now we've got lCurSampleLeft which is one mono sample and all is set  	// for the next input nibble...  	//Output((SHORT)lCurSampleLeft); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	// Now we've got lCurSampleLeft which is one mono sample and all is set  	// for the next input byte...  	//Output((SHORT)lCurSampleLeft); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  }  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)  	return 32767;  else if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)  	return 32767;  else if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)  	return 32767;  else if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)  	return 32767;  else if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: return 32767;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: return (-32768);  
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Simslib\src\C#\SimsLib\XA\XAFile.cs,HINIBBLE,The following statement contains a magic number: return (byte)(((B) >> 4) & 0x0F);  
Missing Default,SimsLib.ThreeD,Outfit,C:\repos\Afr0_Simslib\src\C#\SimsLib\3D\Outfit.cs,GetAppearance,The following switch statement is missing a default case: switch (type) {  case AppearanceType.Light:  	return LightAppearanceID;  case AppearanceType.Medium:  	return MediumAppearanceID;  case AppearanceType.Dark:  	return DarkAppearanceID;  }  
Missing Default,SimsLib.IFF,BHAV,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\BHAV.cs,BHAV,The following switch statement is missing a default case: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Missing Default,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Missing Default,SimsLib.IFF,SPR2Parser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPR2Parser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Missing Default,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Missing Default,SimsLib.IFF,SPRParser,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\SPRParser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Missing Default,SimsLib.IFF,StringTable,C:\repos\Afr0_Simslib\src\C#\SimsLib\IFF\StringTable.cs,StringTable,The following switch statement is missing a default case: switch (m_FormatCode) {  case 0:  	//Some tables are empty... LITERALLY!  	if (Reader.BaseStream.Position < Reader.BaseStream.Length) {  		m_NumEntries = Reader.ReadUInt16 ();  		for (int i = 0; i < m_NumEntries; i++) {  			StringTableString Str = new StringTableString ();  			Str.Str = ReadPascalString (Reader);  			m_Strings.Add (Str);  		}  	}  	break;  case 0xFFFF:  	m_NumEntries = Reader.ReadUInt16 ();  	for (int i = 0; i < m_NumEntries; i++) {  		StringTableString Str = new StringTableString ();  		char C;  		StringBuilder SB = new StringBuilder ();  		while (true) {  			C = Reader.ReadChar ();  			SB.Append (C);  			if (C == '\0')  				break;  		}  		Str.Str = SB.ToString ();  		m_Strings.Add (Str);  	}  	break;  case 0xFEFF:  	m_NumEntries = Reader.ReadUInt16 ();  	for (int i = 0; i < m_NumEntries; i++) {  		StringTableString Str = new StringTableString ();  		char C;  		StringBuilder SB = new StringBuilder ();  		//String  		while (true) {  			C = Reader.ReadChar ();  			SB.Append (C);  			if (C == '\0')  				break;  		}  		Str.Str = SB.ToString ();  		m_Strings.Add (Str);  		SB = new StringBuilder ();  		//Comment  		while (true) {  			C = Reader.ReadChar ();  			SB.Append (C);  			if (C == '\0')  				break;  		}  	}  	break;  case 0xFDFF:  	m_NumEntries = Reader.ReadUInt16 ();  	for (int i = 0; i < m_NumEntries; i++) {  		StringTableString Str = new StringTableString ();  		Str.LanguageCode = Reader.ReadByte ();  		char C;  		StringBuilder SB = new StringBuilder ();  		while (true) {  			C = (char)Reader.ReadByte ();  			if (C == '\0')  				break;  			SB.Append (C);  		}  		Str.Str = SB.ToString ();  		C = new char ();  		SB = new StringBuilder ();  		while (true) {  			C = (char)Reader.ReadByte ();  			if (C == '\0')  				break;  			SB.Append (C);  		}  		Str.Str2 = SB.ToString ();  		m_Strings.Add (Str);  	}  	break;  case 0xFCFF:  	//Only found in TSO-files!  	m_NumSets = Reader.ReadByte ();  	if (m_NumSets >= 1) {  		for (int i = 0; i < m_NumSets; i++) {  			StringSet Set = new StringSet ();  			Set.NumEntries = Reader.ReadInt16 ();  			for (int j = 0; j < Set.NumEntries; j++) {  				// string code' then two specially-counted strings  				// for some reason' the language code is one below the  				// documented values.  we adjust this here' which  				// unfortunately makes non-translated strings strange.  				StringTableString Str = new StringTableString ();  				Str.LanguageCode = (byte)(Reader.ReadByte () + 1);  				Str.Str = ReadPascalString1 (Reader);  				Str.Str2 = ReadPascalString1 (Reader);  				Set.Strings.Add (Str);  			}  			m_StringSets.Add (Set);  		}  	}  	break;  }  
Missing Default,LogThis,Log,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,LogHeader,The following switch statement is missing a default case: switch (logheaderlevel) {  case elogheaderlevel.Level_1:  	sHeader = "======(" + System.AppDomain.CurrentDomain.FriendlyName + ") ====  " + sText + "============ Date:" + dt.ToString ("yyyyMMdd") + " Time:" + dt.ToString ("hh:mm:ss");  	break;  case elogheaderlevel.Level_2:  	sHeader = "------" + sText + " ============ Time:" + dt.ToString ("hh:mm:ss");  	break;  case elogheaderlevel.Level_3:  	sHeader = "---" + sText + " --- Time:" + dt.ToString ("hh:mm:ss");  	break;  }  
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following switch statement is missing a default case: switch (m_logquotaformat) {  case elogquotaformat.kbytes:  	try {  		FileInfo info = new FileInfo (sLogPath);  		nfileSize = info.Length;  	}  	catch (Exception x) {  		System.Console.WriteLine ("Error:" + x.Message);  		nfileSize = 0;  	}  	if (nfileSize < (m_logsizemax * 1024)) {  		return;  	}  	break;  case elogquotaformat.rows:  	using (StreamReader sr = new StreamReader (sLogPath)) {  		String line;  		while ((line = sr.ReadLine ()) != null) {  			i++;  		}  		if (i < m_logsizemax) {  			return;  		}  	}  	break;  }  
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,TruncateLogFile,The following switch statement is missing a default case: switch (m_logquotaformat) {  case elogquotaformat.kbytes:  	char[] c = null;  	long bufsize = 1024;  	//should match streams natural buffer size.  	long kb = 1024;  	j = (long)((m_logsizemax * kb) * .9);  	while (sr.Peek () >= 0) {  		c = new char[bufsize];  		sr.Read (c' 0' c.Length);  		i++;  		if ((i * bufsize) > j) {  			for (i = 0; i < c.Length; i++) {  				if (c [i] == '\r' && c [i + 1] == '\n') {  					//write out the remaining part of the last line.  					char[] c2 = new char[i + 2];  					Array.Copy (c' 0' c2' 0' i + 2);  					SW.Write (c2);  					break;  				}  			}  			break;  		}  		else {  			SW.Write (c);  		}  	}  	break;  case elogquotaformat.rows:  	String line;  	j = (long)(m_logsizemax * .9);  	//reduce by 10% below max.  	while ((line = sr.ReadLine ()) != null) {  		SW.WriteLine (line);  		i++;  		if (i > j) {  			break;  		}  	}  	break;  }  
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,SetLogPath,The following switch statement is missing a default case: switch (m_logperiod) {  case elogperiod.day:  	sPeriod = dt.ToString ("yyyyMMdd");  	break;  case elogperiod.week:  	string week = GetWeek ();  	sPeriod = dt.ToString ("yyyyweek" + week);  	break;  case elogperiod.month:  	sPeriod = dt.ToString ("yyyyMM");  	break;  }  
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,SetLogPath,The following switch statement is missing a default case: switch (m_lognameformat) {  case elognameformat.date_name:  	sLogName = sPeriod + "_" + m_logfilename;  	break;  case elognameformat.name_date:  	sLogName = m_logfilename + "_" + sPeriod;  	break;  }  
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,LogThis,The following switch statement is missing a default case: switch (logprefix) {  case elogprefix.dt:  	logtext = dt.ToString ("yyyy.MM.dd") + "-" + dt.ToString ("hh.mm.ss") + ": " + logtext;  	break;  case elogprefix.loglevel:  	logtext = loglevel.ToString () + ": " + logtext;  	break;  case elogprefix.dt_loglevel:  	logtext = dt.ToString ("yyyy.MM.dd") + "-" + dt.ToString ("hh.mm.ss") + ":" + loglevel + ": " + logtext;  	break;  }  
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Simslib\src\C#\SimsLib\Log.cs,LogThis,The following switch statement is missing a default case: switch (m_logwhere) {  case elogwhere.file:  	AppendToFile (sFilePath' logtext);  	break;  case elogwhere.eventlog:  	LogEvent (logtext' loglevel);  	break;  case elogwhere.eventlog_and_file:  	AppendToFile (sFilePath' logtext);  	LogEvent (logtext' loglevel);  	break;  }  
