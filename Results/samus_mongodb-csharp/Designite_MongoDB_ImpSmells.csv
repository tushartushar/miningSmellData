Implementation smell,Namespace,Class,File,Method,Description
Long Method,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The method has 108 lines of code.
Complex Method,MongoDB,MongoConnectionStringBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoConnectionStringBuilder.cs,ParseUri,Cyclomatic complexity of the method is 9
Complex Method,MongoDB,MongoConnectionStringBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoConnectionStringBuilder.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,TranslateToBsonType,Cyclomatic complexity of the method is 28
Complex Method,MongoDB.Linq.Translators,RedundantFieldRemover,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\RedundantFieldRemover.cs,VisitSelect,Cyclomatic complexity of the method is 8
Complex Method,MongoDB.Linq.Translators,OrderByRewriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\OrderByRewriter.cs,RebindOrderings,Cyclomatic complexity of the method is 8
Complex Method,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,BindAggregate,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Linq.Translators,RedundantSubqueryRemover,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\RedundantSubqueryRemover.cs,CanMergeWithFrom,Cyclomatic complexity of the method is 10
Complex Method,MongoDB.Linq.Translators,MongoQueryObjectBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\MongoQueryObjectBuilder.cs,VisitSelect,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Serialization.Descriptors,ClassMapPropertyDescriptorBase,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\ClassMapPropertyDescriptorBase.cs,GetAliasFromMemberName,Cyclomatic complexity of the method is 9
Complex Method,MongoDB.Util,TypeHelper,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\TypeHelper.cs,FindIEnumerable,Cyclomatic complexity of the method is 9
Long Parameter List,MongoDB,LinqExtensions,C:\repos\samus_mongodb-csharp\source\MongoDB\LinqExtensions.cs,Update,The method has 5 parameters. Parameters: collection' document' selector' flags' safeMode
Long Parameter List,MongoDB,IMongoCollection,C:\repos\samus_mongodb-csharp\source\MongoDB\Obsolete\IMongoCollection.cs,FindAndModify,The method has 7 parameters. Parameters: document' spec' sort' fields' remove' returnNew' upsert
Long Parameter List,MongoDB,IMongoCollection,C:\repos\samus_mongodb-csharp\source\MongoDB\Obsolete\IMongoCollection.cs,FindAndModify,The method has 7 parameters. Parameters: document' selector' sort' fields' remove' returnNew' upsert
Long Parameter List,MongoDB,MongoCollection,C:\repos\samus_mongodb-csharp\source\MongoDB\Obsolete\MongoCollection.cs,FindAndModify,The method has 7 parameters. Parameters: document' spec' sort' fields' remove' returnNew' upsert
Long Parameter List,MongoDB,MongoCollection<T>,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoCollection_1.cs,FindAndModify,The method has 7 parameters. Parameters: document' spec' sort' fields' remove' returnNew' upsert
Long Parameter List,MongoDB,Cursor<T>,C:\repos\samus_mongodb-csharp\source\MongoDB\Cursor_1.cs,Cursor,The method has 5 parameters. Parameters: serializationFactory' mappingStore' connection' databaseName' collectionName
Long Parameter List,MongoDB,Cursor<T>,C:\repos\samus_mongodb-csharp\source\MongoDB\Cursor_1.cs,Cursor,The method has 9 parameters. Parameters: serializationFactory' mappingStore' connection' databaseName' collectionName' spec' limit' skip' fields
Long Parameter List,MongoDB.Configuration.Mapping.Auto,OverridableAutoMappingProfile,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Mapping\Auto\OverridableAutoMappingProfile.cs,GetMemberOverrideValue,The method has 5 parameters. Parameters: classType' member' overrides' accept' defaultValue
Long Parameter List,MongoDB.Linq.Expressions,SelectExpression,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Expressions\SelectExpression.cs,SelectExpression,The method has 6 parameters. Parameters: alias' fields' from' where' orderBy' groupBy
Long Parameter List,MongoDB.Linq.Expressions,SelectExpression,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Expressions\SelectExpression.cs,SelectExpression,The method has 9 parameters. Parameters: alias' fields' from' where' orderBy' groupBy' isDistinct' skip' take
Long Parameter List,MongoDB.Configuration.Mapping.Model,CollectionMemberMap,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Mapping\Model\CollectionMemberMap.cs,CollectionMemberMap,The method has 8 parameters. Parameters: memberName' memberReturnType' getter' setter' alias' persistDefaultValue' collectionAdapter' elementType
Long Parameter List,MongoDB.Configuration.Mapping.Model,DictionaryMemberMap,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Mapping\Model\DictionaryMemberMap.cs,DictionaryMemberMap,The method has 6 parameters. Parameters: memberName' getter' setter' alias' persistDefaultValue' dictionaryAdapter
Long Parameter List,MongoDB.Configuration.Mapping.Model,IdMap,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Mapping\Model\IdMap.cs,IdMap,The method has 6 parameters. Parameters: memberName' memberType' getter' setter' generator' unsavedValue
Long Parameter List,MongoDB.Configuration.Mapping.Model,PersistentMemberMap,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Mapping\Model\PersistentMemberMap.cs,PersistentMemberMap,The method has 7 parameters. Parameters: memberName' memberReturnType' getter' setter' defaultValue' alias' persistDefaultValue
Long Parameter List,MongoDB.Protocol,QueryMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\QueryMessage.cs,QueryMessage,The method has 5 parameters. Parameters: bsonWriterSettings' query' fullCollectionName' numberToReturn' numberToSkip
Long Parameter List,MongoDB.Protocol,QueryMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\QueryMessage.cs,QueryMessage,The method has 6 parameters. Parameters: bsonWriterSettings' query' fullCollectionName' numberToReturn' numberToSkip' returnFieldSelector
Long Identifier,MongoDB.Configuration.Mapping.Model,ClassMapBase,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Mapping\Model\ClassMapBase.cs,,The length of the parameter _hasProtectedOrPublicConstructor is 32.
Long Statement,MongoDB,DBRef,C:\repos\samus_mongodb-csharp\source\MongoDB\DBRef.cs,Equals,The length of the statement  "            return Equals(other._document' _document) && Equals(other._collectionName' _collectionName) && Equals(other._id' _id) && Equals(other._metadata' _metadata); " is 156.
Long Statement,MongoDB,Document,C:\repos\samus_mongodb-csharp\source\MongoDB\Document.cs,GetEnumerator,The length of the statement  "            return _orderedKeys.Select(orderedKey => new KeyValuePair<string' object>(orderedKey' _dictionary[orderedKey])).GetEnumerator(); " is 128.
Long Statement,MongoDB,Mongo,C:\repos\samus_mongodb-csharp\source\MongoDB\Mongo.cs,GetDatabases,The length of the statement  "            var result = _connection.SendCommand(_configuration.SerializationFactory' "admin"' typeof(Document)' new Document("listDatabases"' 1)); " is 135.
Long Statement,MongoDB,MongoCollection<T>,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoCollection_1.cs,Find,The length of the statement  "            return new Cursor<T>(_configuration.SerializationFactory' _configuration.MappingStore' _connection' DatabaseName' Name' spec' limit' skip' fields); " is 147.
Long Statement,MongoDB,Cursor<T>,C:\repos\samus_mongodb-csharp\source\MongoDB\Cursor_1.cs,ConvertFieldSelectorToDocument,The length of the statement  "                throw new NotSupportedException("An entity type is not supported in field selection. Use either a document or an anonymous type."); " is 131.
Long Statement,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,TranslateToBsonType,The length of the statement  "                throw new ArgumentOutOfRangeException("Decimal is not supported in the BSON spec. So it is also not supported in MongoDB. " + " is 125.
Long Statement,MongoDB.Configuration.Builders,AutoMappingProfileBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Builders\AutoMappingProfileBuilder.cs,CollectionNamesAreCamelCased,The length of the statement  "            _profile.Conventions.CollectionNameConvention = new DelegateCollectionNameConvention(t => Inflector.ToCamelCase(t.Name)); " is 121.
Long Statement,MongoDB.Configuration.Builders,AutoMappingProfileBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Builders\AutoMappingProfileBuilder.cs,CollectionNamesAreCamelCasedAndPlural,The length of the statement  "            _profile.Conventions.CollectionNameConvention = new DelegateCollectionNameConvention(t => Inflector.MakePlural(Inflector.ToCamelCase(t.Name))); " is 143.
Long Statement,MongoDB.Configuration.Builders,AutoMappingProfileBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Builders\AutoMappingProfileBuilder.cs,ExtendedPropertiesAre,The length of the statement  "            _profile.Conventions.ExtendedPropertiesConvention = new DelegateExtendedPropertiesConvention(extendedProperty' memberTypes' bindingFlags); " is 138.
Long Statement,MongoDB.Configuration.Builders,AutoMappingProfileBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Builders\AutoMappingProfileBuilder.cs,ExtendedPropertiesAreNamed,The length of the statement  "            _profile.Conventions.ExtendedPropertiesConvention = new DelegateExtendedPropertiesConvention(m => m.Name == name' memberTypes' bindingFlags); " is 141.
Long Statement,MongoDB.Configuration.Builders,ClassOverridesBuilder<T>,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Builders\ClassOverridesBuilder.cs,Id,The length of the statement  "            var members = typeof(T).GetMember(name' MemberTypes.Field | MemberTypes.Property' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 152.
Long Statement,MongoDB.Configuration.Builders,ClassOverridesBuilder<T>,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Builders\ClassOverridesBuilder.cs,Member,The length of the statement  "            var members = typeof(T).GetMember(name' MemberTypes.Field | MemberTypes.Property' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 152.
Long Statement,MongoDB.Linq,ExecutionBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\ExecutionBuilder.cs,VisitProjection,The length of the statement  "            queryObject.Projector = new ProjectionBuilder().Build(projection.Projector' queryObject.DocumentType' "document"' queryObject.IsMapReduce); " is 139.
Long Statement,MongoDB.Linq,MongoQueryProvider,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\MongoQueryProvider.cs,CreateQuery,The length of the statement  "                return (IQueryable)Activator.CreateInstance(typeof(MongoQuery<>).MakeGenericType(elementType)' new object[] { this' expression }); " is 130.
Long Statement,MongoDB.Linq,MongoQueryProvider,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\MongoQueryProvider.cs,CanBeEvaluatedLocally,The length of the statement  "            if (mc != null && (mc.Method.DeclaringType == typeof(Enumerable) || mc.Method.DeclaringType == typeof(Queryable) || mc.Method.DeclaringType == typeof(MongoQueryable))) " is 167.
Long Statement,MongoDB.Linq,MongoQueryProvider,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\MongoQueryProvider.cs,ExecuteCount,The length of the statement  "            var miGetCollection = typeof(IMongoDatabase).GetMethods().Where(m => m.Name == "GetCollection" && m.GetGenericArguments().Length == 1 && m.GetParameters().Length == 1).Single().MakeGenericMethod(queryObject.DocumentType); " is 221.
Long Statement,MongoDB.Linq,MongoQueryProvider,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\MongoQueryProvider.cs,ExecuteCount,The length of the statement  "            return Convert.ToInt32(collection.GetType().GetMethod("Count"' new[] { typeof(object) }).Invoke(collection' new[] { queryObject.Query })); " is 138.
Long Statement,MongoDB.Linq,MongoQueryProvider,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\MongoQueryProvider.cs,ExecuteFind,The length of the statement  "            var miGetCollection = typeof(IMongoDatabase).GetMethods().Where(m => m.Name == "GetCollection" && m.GetGenericArguments().Length == 1 && m.GetParameters().Length == 1).Single().MakeGenericMethod(queryObject.DocumentType); " is 221.
Long Statement,MongoDB.Linq,MongoQueryProvider,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\MongoQueryProvider.cs,ExecuteMapReduce,The length of the statement  "            var miGetCollection = typeof(IMongoDatabase).GetMethods().Where(m => m.Name == "GetCollection" && m.GetGenericArguments().Length == 1 && m.GetParameters().Length == 1).Single().MakeGenericMethod(queryObject.DocumentType); " is 221.
Long Statement,MongoDB.Linq.Expressions,MongoExpressionVisitor,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Expressions\MongoExpressionVisitor.cs,VisitAggregateSubquery,The length of the statement  "                return new AggregateSubqueryExpression(aggregateSubquery.GroupByAlias' aggregateSubquery.AggregateInGroupSelect' subquery); " is 123.
Long Statement,MongoDB.Linq.Expressions,MongoExpressionVisitor,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Expressions\MongoExpressionVisitor.cs,VisitSelect,The length of the statement  "            if (from != select.From || where != select.Where || orderBy != select.OrderBy || groupBy != select.GroupBy || skip != select.Skip || take != select.Take || fields != select.Fields) " is 180.
Long Statement,MongoDB.Linq.Translators,AggregateRewriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\AggregateRewriter.cs,VisitSelect,The length of the statement  "                return new SelectExpression(select.Alias' fields' select.From' select.Where' select.OrderBy' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 154.
Long Statement,MongoDB.Linq.Translators,MapReduceFinalizerFunctionBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\MapReduceFinalizerFunctionBuilder.cs,VisitAggregate,The length of the statement  "                    _returnValues.Add(new KeyValuePair<string' string>(_currentAggregateName' string.Format("value.{0}Sum/value.{0}Cnt"' _currentAggregateName))); " is 142.
Long Statement,MongoDB.Linq.Translators,QueryDuplicator,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryDuplicator.cs,VisitSelect,The length of the statement  "            return new SelectExpression(newAlias' select.Fields' select.From' select.Where' select.OrderBy' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 157.
Long Statement,MongoDB.Linq.Translators,FieldFinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\FieldBinder.cs,VisitMethodCall,The length of the statement  "                else if (typeof(IList<>).IsOpenTypeAssignableFrom(m.Method.DeclaringType) || typeof(IList).IsAssignableFrom(m.Method.DeclaringType)) " is 132.
Long Statement,MongoDB.Linq.Translators,JavascriptFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\JavascriptFormatter.cs,VisitMethodCall,The length of the statement  "                    throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name)); " is 138.
Long Statement,MongoDB.Linq.Translators,JavascriptFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\JavascriptFormatter.cs,VisitMethodCall,The length of the statement  "                        throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name)); " is 138.
Long Statement,MongoDB.Linq.Translators,OrderByRewriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\OrderByRewriter.cs,VisitSelect,The length of the statement  "                    select = new SelectExpression(select.Alias' fields' select.From' select.Where' orderings' select.GroupBy' select.IsDistinct' select.Skip' select.Take); " is 151.
Long Statement,MongoDB.Linq.Translators,OrderByRewriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\OrderByRewriter.cs,RebindOrderings,The length of the statement  "                    if (fieldDecl.Expression == ordering.Expression || (field != null && fieldDeclExpression != null && field.Alias == fieldDeclExpression.Alias && field.Name == fieldDeclExpression.Name)) " is 184.
Long Statement,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The length of the statement  "                                return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null); " is 135.
Long Statement,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The length of the statement  "                                return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3])); " is 176.
Long Statement,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,BindAggregate,The length of the statement  "                    && (methodCallExpression.Method.DeclaringType == typeof(Queryable) || methodCallExpression.Method.DeclaringType == typeof(Enumerable))) " is 135.
Long Statement,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,BindAggregate,The length of the statement  "            var select = new SelectExpression(alias' new[] { new FieldDeclaration(fieldName' aggregateExpression) }' projection.Source' null); " is 130.
Long Statement,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,BindAggregate,The length of the statement  "                var lambda = Expression.Lambda(Expression.Call(typeof(Enumerable)' "Single"' new[] { returnType }' parameter)' parameter); " is 122.
Long Statement,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,BindOrderBy,The length of the statement  "                new SelectExpression(alias' fieldProjection.Fields' projection.Source' null' orderings.AsReadOnly()' null' false' null' null)' " is 126.
Long Statement,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,GetCollectionProjection,The length of the statement  "                new SelectExpression(selectAlias' fields' new CollectionExpression(collectionAlias' collection.Database' collection.CollectionName' collection.ElementType)' null)' " is 163.
Long Statement,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitBinary,The length of the statement  "            bool hasPredicate = b.NodeType != ExpressionType.And && b.NodeType != ExpressionType.AndAlso && b.NodeType != ExpressionType.Or && b.NodeType != ExpressionType.OrElse; " is 167.
Long Statement,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The length of the statement  "            else if(typeof(ICollection<>).IsOpenTypeAssignableFrom(m.Method.DeclaringType) || typeof(IList).IsAssignableFrom(m.Method.DeclaringType)) " is 137.
Long Statement,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The length of the statement  "                    throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name)); " is 138.
Long Statement,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The length of the statement  "                        throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name)); " is 138.
Long Statement,MongoDB.Linq.Translators,RedundantSubqueryRemover,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\RedundantSubqueryRemover.cs,CanMergeWithFrom,The length of the statement  "            if(fromSelect.Take != null && (select.Take != null || select.Skip != null || select.IsDistinct || selectHasAggregates || selectHasGroupBy)) " is 139.
Long Statement,MongoDB.Linq.Translators,RedundantSubqueryRemover,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\RedundantSubqueryRemover.cs,CanMergeWithFrom,The length of the statement  "            if (fromSelect.IsDistinct && (select.Take != null || select.Skip != null || !selectIsNameMapProjection || selectHasGroupBy || selectHasAggregates || (selectHasOrderBy && !isTopLevel))) " is 184.
Long Statement,MongoDB.Linq.Translators,QueryAttributesGatherer,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\MongoQueryObjectBuilder.cs,VisitSelect,The length of the statement  "                    throw new InvalidQueryException("The query is too complex to be processed by MongoDB. Try building a map-reduce query by hand or simplifying the query and using Linq-to-Objects."); " is 180.
Long Statement,MongoDB.Serialization.Descriptors,ClassMapPropertyDescriptor,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\ClassMapPropertyDescriptor.cs,GetProperties,The length of the statement  "                yield return CreateProperty(ClassMap.DiscriminatorAlias' ClassMap.Discriminator.GetType()' ClassMap.Discriminator' false); " is 122.
Long Statement,MongoDB.Serialization.Descriptors,JavascriptMemberNameReplacer,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\ClassMapPropertyDescriptorBase.cs,Read,The length of the statement  "                if (ReadChar(true) == 't' && ReadChar(true) == 'h' && ReadChar(true) == 'i' && ReadChar(true) == 's' && ReadChar(true) == '.') " is 126.
Long Statement,MongoDB.Serialization.Descriptors,DocumentClassMapPropertyDescriptor,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\DocumentClassMapPropertyDescriptor.cs,GetProperties,The length of the statement  "                    yield return CreateProperty(ClassMap.DiscriminatorAlias' ClassMap.Discriminator.GetType()' ClassMap.Discriminator' false); " is 122.
Long Statement,MongoDB.Serialization.Descriptors,DocumentClassMapPropertyDescriptor,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\DocumentClassMapPropertyDescriptor.cs,GetProperties,The length of the statement  "                if (alias.MemberMap != null && !alias.MemberMap.PersistDefaultValue && object.Equals(alias.MemberMap.DefaultValue' valueAndType.Value)) " is 135.
Long Statement,MongoDB.Serialization.Descriptors,DocumentClassMapPropertyDescriptor,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\DocumentClassMapPropertyDescriptor.cs,GetValue,The length of the statement  "            else if (name.StartsWith("$") || name == "query" || name == "orderby") //we are a modifier' a special case of querying' or order fields " is 135.
Long Statement,MongoDB.Serialization.Descriptors,ExampleClassMapPropertyDescriptor,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\ExampleClassMapPropertyDescriptor.cs,GetProperties,The length of the statement  "                yield return CreateProperty(ClassMap.DiscriminatorAlias' ClassMap.Discriminator.GetType()' ClassMap.Discriminator' false); " is 122.
Long Statement,MongoDB.Serialization.Descriptors,ExampleClassMapPropertyDescriptor,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\ExampleClassMapPropertyDescriptor.cs,GetProperties,The length of the statement  "                if (alias.MemberMap != null && !alias.MemberMap.PersistDefaultValue && object.Equals(alias.MemberMap.DefaultValue' value)) " is 122.
Long Statement,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,GenerateTime,The length of the statement  "            //DateTime nowtime = new DateTime(epoch.Year' epoch.Month' epoch.Day' now.Hour' now.Minute' now.Second' now.Millisecond); " is 121.
Long Statement,MongoDB.Util,JsonFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\JsonFormatter.cs,SerializeForServerSide,The length of the statement  "                sb.AppendFormat("new Date({0}'{1}'{2}'{3}'{4}'{5}'{6})"' d.Year' d.Month - 1' d.Day' d.Hour' d.Minute' d.Second' d.Millisecond); " is 128.
Long Statement,MongoDB.Serialization,ClassMapObjectDescriptorAdapter,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\ClassMapObjectDescriptorAdapter.cs,SetPropertyValue,The length of the statement  "            if (!_classMap.HasId && mongoName == "_id") //there is nothing for us to set and we'll let the database do the id generation... " is 127.
Long Statement,MongoDB.Configuration.IdGenerators,AssignedIdGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\IdGenerators\AssignedIdGenerator.cs,Generate,The length of the statement  "                throw new IdGenerationException(string.Format("Ids for {0} must be manually assigned before saving."' entity.GetType())); " is 121.
Long Statement,MongoDB.Connections,PooledConnectionFactory,C:\repos\samus_mongodb-csharp\source\MongoDB\Connections\PooledConnectionFactory.cs,Open,The length of the statement  "                        throw new MongoException("Timeout expired. The timeout period elapsed prior to obtaining a connection from pool. This may have occured because all pooled connections were in use and max poolsize was reached."); " is 210.
Complex Conditional,MongoDB.Linq,MongoQueryProvider,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\MongoQueryProvider.cs,CanBeEvaluatedLocally,The conditional expression  "mc != null && (mc.Method.DeclaringType == typeof(Enumerable) || mc.Method.DeclaringType == typeof(Queryable) || mc.Method.DeclaringType == typeof(MongoQueryable))"  is complex.
Complex Conditional,MongoDB.Linq.Expressions,MongoExpressionVisitor,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Expressions\MongoExpressionVisitor.cs,VisitSelect,The conditional expression  "from != select.From || where != select.Where || orderBy != select.OrderBy || groupBy != select.GroupBy || skip != select.Skip || take != select.Take || fields != select.Fields"  is complex.
Complex Conditional,MongoDB.Linq.Translators,OrderByRewriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\OrderByRewriter.cs,RebindOrderings,The conditional expression  "fieldDecl.Expression == ordering.Expression || (field != null && fieldDeclExpression != null && field.Alias == fieldDeclExpression.Alias && field.Name == fieldDeclExpression.Name)"  is complex.
Complex Conditional,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,BindAggregate,The conditional expression  "methodCallExpression.Method.Name == "Distinct" && methodCallExpression.Arguments.Count == 1                      && (methodCallExpression.Method.DeclaringType == typeof(Queryable) || methodCallExpression.Method.DeclaringType == typeof(Enumerable))"  is complex.
Complex Conditional,MongoDB.Linq.Translators,RedundantSubqueryRemover,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\RedundantSubqueryRemover.cs,VisitSelect,The conditional expression  "where != select.Where                      || orderBy != select.OrderBy                      || groupBy != select.GroupBy                      || distinct != select.IsDistinct                      || skip != select.Skip                      || take != select.Take                      || fields != select.Fields"  is complex.
Complex Conditional,MongoDB.Linq.Translators,RedundantSubqueryRemover,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\RedundantSubqueryRemover.cs,CanMergeWithFrom,The conditional expression  "fromHasOrderBy && (selectHasGroupBy || selectHasAggregates || select.IsDistinct)"  is complex.
Complex Conditional,MongoDB.Linq.Translators,RedundantSubqueryRemover,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\RedundantSubqueryRemover.cs,CanMergeWithFrom,The conditional expression  "fromSelect.Take != null && (select.Take != null || select.Skip != null || select.IsDistinct || selectHasAggregates || selectHasGroupBy)"  is complex.
Complex Conditional,MongoDB.Linq.Translators,RedundantSubqueryRemover,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\RedundantSubqueryRemover.cs,CanMergeWithFrom,The conditional expression  "fromSelect.Skip != null && (select.Skip != null || select.IsDistinct || selectHasAggregates || selectHasGroupBy)"  is complex.
Complex Conditional,MongoDB.Linq.Translators,RedundantSubqueryRemover,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\RedundantSubqueryRemover.cs,CanMergeWithFrom,The conditional expression  "fromSelect.IsDistinct && (select.Take != null || select.Skip != null || !selectIsNameMapProjection || selectHasGroupBy || selectHasAggregates || (selectHasOrderBy && !isTopLevel))"  is complex.
Complex Conditional,MongoDB.Serialization.Descriptors,JavascriptMemberNameReplacer,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\ClassMapPropertyDescriptorBase.cs,Read,The conditional expression  "ReadChar(true) == 't' && ReadChar(true) == 'h' && ReadChar(true) == 'i' && ReadChar(true) == 's' && ReadChar(true) == '.'"  is complex.
Complex Conditional,MongoDB.Util,JsonFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\JsonFormatter.cs,SerializeType,The conditional expression  "value is Document ||                      value is Binary ||                      value is DBRef ||                      value is MongoMinKey ||                      value is MongoMaxKey ||                      value is Code ||                      value is CodeWScope"  is complex.
Complex Conditional,MongoDB.Util,JsonFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\JsonFormatter.cs,SerializeType,The conditional expression  "value is int ||                      value is long ||                      value is float ||                      value is double"  is complex.
Virtual Method Call from Constructor,MongoDB,Mongo,C:\repos\samus_mongodb-csharp\source\MongoDB\Mongo.cs,Mongo,The constructor "Mongo" calls a virtual method "ValidateAndSeal".
Virtual Method Call from Constructor,MongoDB.Serialization.Builders,ConcreteClassMapBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Builders\ConcreteClassMapBuilder.cs,ConcreteClassMapBuilder,The constructor "ConcreteClassMapBuilder" calls a virtual method "SetValue".
Virtual Method Call from Constructor,MongoDB.Serialization.Descriptors,ClassMapPropertyDescriptor,C:\repos\samus_mongodb-csharp\source\MongoDB\Serialization\Descriptors\ClassMapPropertyDescriptor.cs,ClassMapPropertyDescriptor,The constructor "ClassMapPropertyDescriptor" calls a virtual method "GetValue".
Magic Number,MongoDB,DBRef,C:\repos\samus_mongodb-csharp\source\MongoDB\DBRef.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var result = (_document != null ? _document.GetHashCode() : 0);                  result = (result*397) ^ (_collectionName != null ? _collectionName.GetHashCode() : 0);                  result = (result*397) ^ (_id != null ? _id.GetHashCode() : 0);                  result = (result*397) ^ (_metadata != null ? _metadata.GetHashCode() : 0);                  return result;              }
Magic Number,MongoDB,DBRef,C:\repos\samus_mongodb-csharp\source\MongoDB\DBRef.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var result = (_document != null ? _document.GetHashCode() : 0);                  result = (result*397) ^ (_collectionName != null ? _collectionName.GetHashCode() : 0);                  result = (result*397) ^ (_id != null ? _id.GetHashCode() : 0);                  result = (result*397) ^ (_metadata != null ? _metadata.GetHashCode() : 0);                  return result;              }
Magic Number,MongoDB,DBRef,C:\repos\samus_mongodb-csharp\source\MongoDB\DBRef.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var result = (_document != null ? _document.GetHashCode() : 0);                  result = (result*397) ^ (_collectionName != null ? _collectionName.GetHashCode() : 0);                  result = (result*397) ^ (_id != null ? _id.GetHashCode() : 0);                  result = (result*397) ^ (_metadata != null ? _metadata.GetHashCode() : 0);                  return result;              }
Magic Number,MongoDB,Document,C:\repos\samus_mongodb-csharp\source\MongoDB\Document.cs,GetHashCode,The following statement contains a magic number: var hash = 27;
Magic Number,MongoDB,Document,C:\repos\samus_mongodb-csharp\source\MongoDB\Document.cs,GetHashCode,The following statement contains a magic number: foreach(var key in _orderedKeys){                  var valueHashCode = GetValueHashCode(this[key]);                  unchecked{                      hash = (13*hash) + key.GetHashCode();                      hash = (13*hash) + valueHashCode;                  }              }
Magic Number,MongoDB,Document,C:\repos\samus_mongodb-csharp\source\MongoDB\Document.cs,GetHashCode,The following statement contains a magic number: foreach(var key in _orderedKeys){                  var valueHashCode = GetValueHashCode(this[key]);                  unchecked{                      hash = (13*hash) + key.GetHashCode();                      hash = (13*hash) + valueHashCode;                  }              }
Magic Number,MongoDB,Document,C:\repos\samus_mongodb-csharp\source\MongoDB\Document.cs,GetArrayHashcode,The following statement contains a magic number: foreach(var value in array){                  var valueHashCode = GetValueHashCode(value);                  unchecked{                      hash = (13*hash) + valueHashCode;                  }              }
Magic Number,MongoDB,MongoConnectionStringBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoConnectionStringBuilder.cs,ParseUri,The following statement contains a magic number: var password = uriMatch.Groups[2].Value;
Magic Number,MongoDB,MongoConnectionStringBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoConnectionStringBuilder.cs,ParseUri,The following statement contains a magic number: var servers = uriMatch.Groups[3].Value;
Magic Number,MongoDB,MongoConnectionStringBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoConnectionStringBuilder.cs,ParseUri,The following statement contains a magic number: var database = uriMatch.Groups[4].Value;
Magic Number,MongoDB,MongoConnectionStringBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoConnectionStringBuilder.cs,ParseUri,The following statement contains a magic number: var values = uriMatch.Groups[5].Value;
Magic Number,MongoDB,MongoConnectionStringBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoConnectionStringBuilder.cs,ParseValuePair,The following statement contains a magic number: var value = pairMatch.Groups[2].Value;
Magic Number,MongoDB,MongoConnectionStringBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoConnectionStringBuilder.cs,ParseServers,The following statement contains a magic number: foreach(var serverMatch in servers.Select(server => ServerRegex.Match(server)))              {                  if(!serverMatch.Success)                      throw new FormatException(string.Format("Invalid server in connection string: {0}"' serverMatch.Value));                    var serverHost = serverMatch.Groups[1].Value;                    int port;                  if(int.TryParse(serverMatch.Groups[2].Value' out port))                      AddServer(serverHost' port);                  else                      AddServer(serverHost);              }
Magic Number,MongoDB,MongoServerEndPoint,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoServerEndPoint.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return ((Host != null ? Host.GetHashCode() : 0)*397) ^ Port;              }
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,Oid,The following statement contains a magic number: _bytes = new byte[12];
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,Oid,The following statement contains a magic number: Array.Copy(value' _bytes' 12);
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,ToByteArray,The following statement contains a magic number: var ret = new byte[12];
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,ToByteArray,The following statement contains a magic number: Array.Copy(_bytes' ret' 12);
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,ValidateHex,The following statement contains a magic number: if(value == null || value.Length != 24)                  throw new ArgumentException("Oid strings should be 24 characters");
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,DecodeHex,The following statement contains a magic number: var bytes = new byte[numberChars/2];
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,DecodeHex,The following statement contains a magic number: for(var i = 0; i < numberChars; i += 2)                  try                  {                      bytes[i/2] = Convert.ToByte(value.Substring(i' 2)' 16);                  }                  catch                  {                      //failed to convert these 2 chars' they may contain illegal charracters                      bytes[i/2] = 0;                  }
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,DecodeHex,The following statement contains a magic number: for(var i = 0; i < numberChars; i += 2)                  try                  {                      bytes[i/2] = Convert.ToByte(value.Substring(i' 2)' 16);                  }                  catch                  {                      //failed to convert these 2 chars' they may contain illegal charracters                      bytes[i/2] = 0;                  }
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,DecodeHex,The following statement contains a magic number: for(var i = 0; i < numberChars; i += 2)                  try                  {                      bytes[i/2] = Convert.ToByte(value.Substring(i' 2)' 16);                  }                  catch                  {                      //failed to convert these 2 chars' they may contain illegal charracters                      bytes[i/2] = 0;                  }
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,DecodeHex,The following statement contains a magic number: for(var i = 0; i < numberChars; i += 2)                  try                  {                      bytes[i/2] = Convert.ToByte(value.Substring(i' 2)' 16);                  }                  catch                  {                      //failed to convert these 2 chars' they may contain illegal charracters                      bytes[i/2] = 0;                  }
Magic Number,MongoDB,Oid,C:\repos\samus_mongodb-csharp\source\MongoDB\Oid.cs,DecodeHex,The following statement contains a magic number: for(var i = 0; i < numberChars; i += 2)                  try                  {                      bytes[i/2] = Convert.ToByte(value.Substring(i' 2)' 16);                  }                  catch                  {                      //failed to convert these 2 chars' they may contain illegal charracters                      bytes[i/2] = 0;                  }
Magic Number,MongoDB,MongoRegex,C:\repos\samus_mongodb-csharp\source\MongoDB\MongoRegex.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return ((Expression != null ? Expression.GetHashCode() : 0)*397) ^ (RawOptions != null ? RawOptions.GetHashCode() : 0);              }
Magic Number,MongoDB,CodeWScope,C:\repos\samus_mongodb-csharp\source\MongoDB\CodeWScope.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return ((Value != null ? Value.GetHashCode() : 0)*397) ^ (Scope != null ? Scope.GetHashCode() : 0);              }
Magic Number,MongoDB,Binary,C:\repos\samus_mongodb-csharp\source\MongoDB\Binary.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return ((Bytes != null ? Bytes.GetHashCode() : 0)*397) ^ Subtype.GetHashCode();              }
Magic Number,MongoDB.Bson,BsonInfo,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonInfo.cs,BsonInfo,The following statement contains a magic number: Epoch = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,MongoDB.Bson,BsonInfo,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonInfo.cs,BsonInfo,The following statement contains a magic number: MaxDocumentSize = 1024 * 1024 * 4;
Magic Number,MongoDB.Bson,BsonInfo,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonInfo.cs,BsonInfo,The following statement contains a magic number: MaxDocumentSize = 1024 * 1024 * 4;
Magic Number,MongoDB.Bson,BsonInfo,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonInfo.cs,BsonInfo,The following statement contains a magic number: MaxDocumentSize = 1024 * 1024 * 4;
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,Write,The following statement contains a magic number: if(binary.Subtype == BinarySubtype.General)              {                  _writer.Write(binary.Bytes.Length + 4);                  _writer.Write((byte)binary.Subtype);                  _writer.Write(binary.Bytes.Length);              }              else              {                  _writer.Write(binary.Bytes.Length);                  _writer.Write((byte)binary.Subtype);              }
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,Write,The following statement contains a magic number: _writer.Write(16);
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,Write,The following statement contains a magic number: _writer.Write((byte)3);
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSize,The following statement contains a magic number: switch(TranslateToBsonType(obj))              {                  case BsonType.MinKey:                  case BsonType.MaxKey:                  case BsonType.Null:                      return 0;                  case BsonType.Boolean:                      return 1;                  case BsonType.Integer:                      return 4;                  case BsonType.Long:                  case BsonType.Date:                      return 8;                  case BsonType.Oid:                      return 12;                  case BsonType.Number:                      return sizeof(Double);                  case BsonType.String:                      if(obj is string)                          return CalculateSize((string)obj);                      return CalculateSize(obj.ToString());                  case BsonType.Obj:                      return obj.GetType() == typeof(DBRef) ? CalculateSize((DBRef)obj) : CalculateSizeObject(obj);                  case BsonType.Array:                      return CalculateSize((IEnumerable)obj);                  case BsonType.Regex:                      if(obj is Regex)                          return CalculateSize(new MongoRegex((Regex)obj));                      return CalculateSize((MongoRegex)obj);                  case BsonType.Code:                      return CalculateSize((Code)obj);                  case BsonType.CodeWScope:                      return CalculateSize((CodeWScope)obj);                  case BsonType.Binary:                  {                      if(obj is Guid)                          return CalculateSize((Guid)obj);                      if(obj is byte[])                          return CalculateSize((byte[])obj);                        return CalculateSize((Binary)obj);                  }                  case BsonType.Symbol:                      return CalculateSize(((MongoSymbol)obj).Value' true);              }
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSize,The following statement contains a magic number: switch(TranslateToBsonType(obj))              {                  case BsonType.MinKey:                  case BsonType.MaxKey:                  case BsonType.Null:                      return 0;                  case BsonType.Boolean:                      return 1;                  case BsonType.Integer:                      return 4;                  case BsonType.Long:                  case BsonType.Date:                      return 8;                  case BsonType.Oid:                      return 12;                  case BsonType.Number:                      return sizeof(Double);                  case BsonType.String:                      if(obj is string)                          return CalculateSize((string)obj);                      return CalculateSize(obj.ToString());                  case BsonType.Obj:                      return obj.GetType() == typeof(DBRef) ? CalculateSize((DBRef)obj) : CalculateSizeObject(obj);                  case BsonType.Array:                      return CalculateSize((IEnumerable)obj);                  case BsonType.Regex:                      if(obj is Regex)                          return CalculateSize(new MongoRegex((Regex)obj));                      return CalculateSize((MongoRegex)obj);                  case BsonType.Code:                      return CalculateSize((Code)obj);                  case BsonType.CodeWScope:                      return CalculateSize((CodeWScope)obj);                  case BsonType.Binary:                  {                      if(obj is Guid)                          return CalculateSize((Guid)obj);                      if(obj is byte[])                          return CalculateSize((byte[])obj);                        return CalculateSize((Binary)obj);                  }                  case BsonType.Symbol:                      return CalculateSize(((MongoSymbol)obj).Value' true);              }
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSize,The following statement contains a magic number: switch(TranslateToBsonType(obj))              {                  case BsonType.MinKey:                  case BsonType.MaxKey:                  case BsonType.Null:                      return 0;                  case BsonType.Boolean:                      return 1;                  case BsonType.Integer:                      return 4;                  case BsonType.Long:                  case BsonType.Date:                      return 8;                  case BsonType.Oid:                      return 12;                  case BsonType.Number:                      return sizeof(Double);                  case BsonType.String:                      if(obj is string)                          return CalculateSize((string)obj);                      return CalculateSize(obj.ToString());                  case BsonType.Obj:                      return obj.GetType() == typeof(DBRef) ? CalculateSize((DBRef)obj) : CalculateSizeObject(obj);                  case BsonType.Array:                      return CalculateSize((IEnumerable)obj);                  case BsonType.Regex:                      if(obj is Regex)                          return CalculateSize(new MongoRegex((Regex)obj));                      return CalculateSize((MongoRegex)obj);                  case BsonType.Code:                      return CalculateSize((Code)obj);                  case BsonType.CodeWScope:                      return CalculateSize((CodeWScope)obj);                  case BsonType.Binary:                  {                      if(obj is Guid)                          return CalculateSize((Guid)obj);                      if(obj is byte[])                          return CalculateSize((byte[])obj);                        return CalculateSize((Binary)obj);                  }                  case BsonType.Symbol:                      return CalculateSize(((MongoSymbol)obj).Value' true);              }
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSize,The following statement contains a magic number: var size = 4;
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSize,The following statement contains a magic number: var size = 4;
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSize,The following statement contains a magic number: if(binary.Subtype == BinarySubtype.General)                  size += 4;
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSize,The following statement contains a magic number: return 21;
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSizeObject,The following statement contains a magic number: var size = 4;
Magic Number,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSize,The following statement contains a magic number: if(includeLength)                  size += 4;
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadElements,The following statement contains a magic number: Position += 4;
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadElementType,The following statement contains a magic number: switch((BsonType)typeNumber){                  case BsonType.Null:                  case BsonType.Undefined:                      return null;                  case BsonType.MinKey:                      return MongoMinKey.Value;                  case BsonType.MaxKey:                      return MongoMaxKey.Value;                  case BsonType.Boolean:                      Position++;                      return _reader.ReadBoolean();                  case BsonType.Integer:                      Position += 4;                      return _reader.ReadInt32();                  case BsonType.Long:                      Position += 8;                      return _reader.ReadInt64();                  case BsonType.Date:                      return ReadDateTime();                  case BsonType.Oid:                      Position += 12;                      return new Oid(_reader.ReadBytes(12));                  case BsonType.Number:                      Position += 8;                      return _reader.ReadDouble();                  case BsonType.String:                      return ReadLengthString();                  case BsonType.Symbol:                      return new MongoSymbol(ReadLengthString());                  case BsonType.Obj:                      return ReadObject();                  case BsonType.Array:                      return ReadArray();                  case BsonType.Regex:                      return ReadRegex();                  case BsonType.Code:                      return ReadCode();                  case BsonType.CodeWScope:                      return ReadScope();                  case BsonType.Binary:                      return ReadBinary();                  default:                      throw new ArgumentOutOfRangeException(String.Format("Type Number: {0} not recognized"' typeNumber));              }
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadElementType,The following statement contains a magic number: switch((BsonType)typeNumber){                  case BsonType.Null:                  case BsonType.Undefined:                      return null;                  case BsonType.MinKey:                      return MongoMinKey.Value;                  case BsonType.MaxKey:                      return MongoMaxKey.Value;                  case BsonType.Boolean:                      Position++;                      return _reader.ReadBoolean();                  case BsonType.Integer:                      Position += 4;                      return _reader.ReadInt32();                  case BsonType.Long:                      Position += 8;                      return _reader.ReadInt64();                  case BsonType.Date:                      return ReadDateTime();                  case BsonType.Oid:                      Position += 12;                      return new Oid(_reader.ReadBytes(12));                  case BsonType.Number:                      Position += 8;                      return _reader.ReadDouble();                  case BsonType.String:                      return ReadLengthString();                  case BsonType.Symbol:                      return new MongoSymbol(ReadLengthString());                  case BsonType.Obj:                      return ReadObject();                  case BsonType.Array:                      return ReadArray();                  case BsonType.Regex:                      return ReadRegex();                  case BsonType.Code:                      return ReadCode();                  case BsonType.CodeWScope:                      return ReadScope();                  case BsonType.Binary:                      return ReadBinary();                  default:                      throw new ArgumentOutOfRangeException(String.Format("Type Number: {0} not recognized"' typeNumber));              }
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadElementType,The following statement contains a magic number: switch((BsonType)typeNumber){                  case BsonType.Null:                  case BsonType.Undefined:                      return null;                  case BsonType.MinKey:                      return MongoMinKey.Value;                  case BsonType.MaxKey:                      return MongoMaxKey.Value;                  case BsonType.Boolean:                      Position++;                      return _reader.ReadBoolean();                  case BsonType.Integer:                      Position += 4;                      return _reader.ReadInt32();                  case BsonType.Long:                      Position += 8;                      return _reader.ReadInt64();                  case BsonType.Date:                      return ReadDateTime();                  case BsonType.Oid:                      Position += 12;                      return new Oid(_reader.ReadBytes(12));                  case BsonType.Number:                      Position += 8;                      return _reader.ReadDouble();                  case BsonType.String:                      return ReadLengthString();                  case BsonType.Symbol:                      return new MongoSymbol(ReadLengthString());                  case BsonType.Obj:                      return ReadObject();                  case BsonType.Array:                      return ReadArray();                  case BsonType.Regex:                      return ReadRegex();                  case BsonType.Code:                      return ReadCode();                  case BsonType.CodeWScope:                      return ReadScope();                  case BsonType.Binary:                      return ReadBinary();                  default:                      throw new ArgumentOutOfRangeException(String.Format("Type Number: {0} not recognized"' typeNumber));              }
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadElementType,The following statement contains a magic number: switch((BsonType)typeNumber){                  case BsonType.Null:                  case BsonType.Undefined:                      return null;                  case BsonType.MinKey:                      return MongoMinKey.Value;                  case BsonType.MaxKey:                      return MongoMaxKey.Value;                  case BsonType.Boolean:                      Position++;                      return _reader.ReadBoolean();                  case BsonType.Integer:                      Position += 4;                      return _reader.ReadInt32();                  case BsonType.Long:                      Position += 8;                      return _reader.ReadInt64();                  case BsonType.Date:                      return ReadDateTime();                  case BsonType.Oid:                      Position += 12;                      return new Oid(_reader.ReadBytes(12));                  case BsonType.Number:                      Position += 8;                      return _reader.ReadDouble();                  case BsonType.String:                      return ReadLengthString();                  case BsonType.Symbol:                      return new MongoSymbol(ReadLengthString());                  case BsonType.Obj:                      return ReadObject();                  case BsonType.Array:                      return ReadArray();                  case BsonType.Regex:                      return ReadRegex();                  case BsonType.Code:                      return ReadCode();                  case BsonType.CodeWScope:                      return ReadScope();                  case BsonType.Binary:                      return ReadBinary();                  default:                      throw new ArgumentOutOfRangeException(String.Format("Type Number: {0} not recognized"' typeNumber));              }
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadElementType,The following statement contains a magic number: switch((BsonType)typeNumber){                  case BsonType.Null:                  case BsonType.Undefined:                      return null;                  case BsonType.MinKey:                      return MongoMinKey.Value;                  case BsonType.MaxKey:                      return MongoMaxKey.Value;                  case BsonType.Boolean:                      Position++;                      return _reader.ReadBoolean();                  case BsonType.Integer:                      Position += 4;                      return _reader.ReadInt32();                  case BsonType.Long:                      Position += 8;                      return _reader.ReadInt64();                  case BsonType.Date:                      return ReadDateTime();                  case BsonType.Oid:                      Position += 12;                      return new Oid(_reader.ReadBytes(12));                  case BsonType.Number:                      Position += 8;                      return _reader.ReadDouble();                  case BsonType.String:                      return ReadLengthString();                  case BsonType.Symbol:                      return new MongoSymbol(ReadLengthString());                  case BsonType.Obj:                      return ReadObject();                  case BsonType.Array:                      return ReadArray();                  case BsonType.Regex:                      return ReadRegex();                  case BsonType.Code:                      return ReadCode();                  case BsonType.CodeWScope:                      return ReadScope();                  case BsonType.Binary:                      return ReadBinary();                  default:                      throw new ArgumentOutOfRangeException(String.Format("Type Number: {0} not recognized"' typeNumber));              }
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadDateTime,The following statement contains a magic number: Position += 8;
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadLengthString,The following statement contains a magic number: Position += (4 + 1);
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadScope,The following statement contains a magic number: Position += 4;
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadBinary,The following statement contains a magic number: Position += 4;
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadBinary,The following statement contains a magic number: if(subtype == (byte)BinarySubtype.General){                  size = _reader.ReadInt32();                  Position += 4;              }
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadBinary,The following statement contains a magic number: if(subtype == 3 && 16 == size)                  return new Guid(bytes);
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,ReadBinary,The following statement contains a magic number: if(subtype == 3 && 16 == size)                  return new Guid(bytes);
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,BytesInSequence,The following statement contains a magic number: if(b >= _seqRange2[0] && b <= _seqRange2[1])                  return 2;
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,BytesInSequence,The following statement contains a magic number: if(b >= _seqRange3[0] && b <= _seqRange3[1])                  return 3;
Magic Number,MongoDB.Bson,BsonReader,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonReader.cs,BytesInSequence,The following statement contains a magic number: if(b >= _seqRange4[0] && b <= _seqRange4[1])                  return 4;
Magic Number,MongoDB.Configuration.Mapping.Auto,AutoMapper,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\Mapping\Auto\AutoMapper.cs,CreateSubClassMap,The following statement contains a magic number: if(parentDiscriminator == null)                  subClassMap.Discriminator = discriminator;              else              {                  Array array;                  if(parentDiscriminator.GetType().IsArray)                      array = Array.CreateInstance(typeof(object)' ((Array)parentDiscriminator).Length + 1);                  else                  {                      array = Array.CreateInstance(typeof(object)' 2);                      array.SetValue(parentDiscriminator' 0);                  }                    array.SetValue(discriminator' array.Length - 1);                  subClassMap.Discriminator = array;              }
Magic Number,MongoDB.Linq.Translators,JavascriptFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\JavascriptFormatter.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  switch (m.Method.Name)                  {                      case "Count":                          if (m.Arguments.Count == 1)                          {                              Visit(m.Arguments[0]);                              _js.Append(".length");                              return m;                          }                          throw new NotSupportedException("The method Count with a predicate is not supported for field.");                  }              }              else if (m.Method.DeclaringType == typeof(string))              {                  field = m.Object as FieldExpression;                  if (field == null)                      throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                  Visit(field);                    switch (m.Method.Name)                  {                      case "StartsWith":                          _js.AppendFormat("/^{0}/"' EvaluateConstant<string>(m.Arguments[0]));                          break;                      case "EndsWith":                          _js.AppendFormat("/{0}$/"' EvaluateConstant<string>(m.Arguments[0]));                          break;                      case "Contains":                          _js.AppendFormat("/{0}/"' EvaluateConstant<string>(m.Arguments[0]));                          break;                      case "SubString":                          switch(m.Arguments.Count)                          {                              case 1:                                  _js.AppendFormat(".substr({0})"' EvaluateConstant<int>(m.Arguments[0]));                                  break;                              case 2:                                  _js.AppendFormat(".substr({0})"' EvaluateConstant<int>(m.Arguments[0])' EvaluateConstant<int>(m.Arguments[1]));                                  break;                          }                          break;                      case "ToLower":                          _js.Append(".toLowerCase()");                          break;                      case "ToUpper":                          _js.Append(".toUpperCase()");                          break;                      case "get_Chars":                          _js.AppendFormat("[{0}]"' EvaluateConstant<int>(m.Arguments[0]));                          break;                      default:                          throw new NotSupportedException(string.Format("The string method {0} is not supported."' m.Method.Name));                  }                    return m;              }              else if (m.Method.DeclaringType == typeof(Regex))              {                  if (m.Method.Name == "IsMatch")                  {                      field = m.Arguments[0] as FieldExpression;                      if (field == null)                          throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                        Visit(field);                      string value;                      if (m.Object == null)                          value = EvaluateConstant<string>(m.Arguments[1]);                      else                          throw new InvalidQueryException(string.Format("Only the static Regex.IsMatch is supported."' m.Method.Name));                        _js.AppendFormat("/{0}/"' value);                      return m;                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  //if we are running off a field expression' things get handled in the QueryFormatter                  if (!IsOperationOnAField(m))                  {                      switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }                      throw new NotSupportedException(string.Format("The method '{0}' is not supported"' m.Method.Name));                  }              }
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,BindAny,The following statement contains a magic number: MethodInfo method = typeof(Queryable)                  .GetMethods(BindingFlags.Public | BindingFlags.Static)                  .Where(m => m.Name == "Count")                  .Single(m => m.GetParameters().Length == (predicate == null ? 1 : 2))                  .GetGenericMethodDefinition().MakeGenericMethod(sourceType);
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,BindFirstOrSingle,The following statement contains a magic number: if (take == null & kind.StartsWith("Single"))                  take = Expression.Constant(2);
Magic Number,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,IsOperationOnAField,The following statement contains a magic number: return _inField                  || m.Arguments[0].NodeType == (ExpressionType)MongoExpressionType.Field                  || (m.Arguments.Count == 2 && m.Arguments[1].NodeType == (ExpressionType)MongoExpressionType.Field);
Magic Number,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  switch (m.Method.Name)                  {                      case "Any":                          if(m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Any method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          PushConditionScope("$elemMatch");                          VisitPredicate(m.Arguments[1]' true);                          PopConditionScope(); //elemMatch                          PopConditionScope(); //field                          return m;                        case "Contains":                          if (m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Contains method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field != null)                          {                              VisitPredicate(field' true);                              AddCondition(EvaluateConstant<object>(m.Arguments[1]));                              PopConditionScope();                              return m;                          }                            field = m.Arguments[1] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Arguments[0]));                          PopConditionScope();                          return m;                      case "Count":                          if (m.Arguments.Count == 1)                          {                              Visit(m.Arguments[0]);                              PushConditionScope("$size");                              return m;                          }                          throw new NotSupportedException("The method Count with a predicate is not supported for field.");                  }              }              else if(typeof(ICollection<>).IsOpenTypeAssignableFrom(m.Method.DeclaringType) || typeof(IList).IsAssignableFrom(m.Method.DeclaringType))              {                  switch(m.Method.Name)                  {                      case "Contains":                          field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException(string.Format("The mongo field must be the argument in method {0}."' m.Method.Name));                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Object).OfType<object>().ToArray());                          PopConditionScope();                          return m;                  }              }              else if (m.Method.DeclaringType == typeof(string))              {                  field = m.Object as FieldExpression;                  if (field == null)                      throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                  VisitPredicate(field' true);                    var value = EvaluateConstant<string>(m.Arguments[0]);                                    switch(m.Method.Name)                  {                      case "StartsWith":                          AddCondition(new MongoRegex(string.Format("^{0}"' value)));                          break;                      case "EndsWith":                          AddCondition(new MongoRegex(string.Format("{0}$"' value)));                          break;                      case "Contains":                          AddCondition(new MongoRegex(string.Format("{0}"' value)));                          break;                      default:                          throw new NotSupportedException(string.Format("The string method {0} is not supported."' m.Method.Name));                  }                    PopConditionScope();                  return m;              }              else if (m.Method.DeclaringType == typeof(Regex))              {                  if (m.Method.Name == "IsMatch")                  {                      field = m.Arguments[0] as FieldExpression;                      if (field == null)                          throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                        VisitPredicate(field' true);                      string value;                      if (m.Object == null)                          value = EvaluateConstant<string>(m.Arguments[1]);                      else                          throw new InvalidQueryException(string.Format("Only the static Regex.IsMatch is supported."' m.Method.Name));                        var regexOptions = RegexOptions.None;                      if (m.Arguments.Count > 2)                          regexOptions = EvaluateConstant<RegexOptions>(m.Arguments[2]);                        AddCondition(new MongoRegex(value' regexOptions));                      PopConditionScope();                      return m;                  }              }
Magic Number,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  switch (m.Method.Name)                  {                      case "Any":                          if(m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Any method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          PushConditionScope("$elemMatch");                          VisitPredicate(m.Arguments[1]' true);                          PopConditionScope(); //elemMatch                          PopConditionScope(); //field                          return m;                        case "Contains":                          if (m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Contains method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field != null)                          {                              VisitPredicate(field' true);                              AddCondition(EvaluateConstant<object>(m.Arguments[1]));                              PopConditionScope();                              return m;                          }                            field = m.Arguments[1] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Arguments[0]));                          PopConditionScope();                          return m;                      case "Count":                          if (m.Arguments.Count == 1)                          {                              Visit(m.Arguments[0]);                              PushConditionScope("$size");                              return m;                          }                          throw new NotSupportedException("The method Count with a predicate is not supported for field.");                  }              }              else if(typeof(ICollection<>).IsOpenTypeAssignableFrom(m.Method.DeclaringType) || typeof(IList).IsAssignableFrom(m.Method.DeclaringType))              {                  switch(m.Method.Name)                  {                      case "Contains":                          field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException(string.Format("The mongo field must be the argument in method {0}."' m.Method.Name));                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Object).OfType<object>().ToArray());                          PopConditionScope();                          return m;                  }              }              else if (m.Method.DeclaringType == typeof(string))              {                  field = m.Object as FieldExpression;                  if (field == null)                      throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                  VisitPredicate(field' true);                    var value = EvaluateConstant<string>(m.Arguments[0]);                                    switch(m.Method.Name)                  {                      case "StartsWith":                          AddCondition(new MongoRegex(string.Format("^{0}"' value)));                          break;                      case "EndsWith":                          AddCondition(new MongoRegex(string.Format("{0}$"' value)));                          break;                      case "Contains":                          AddCondition(new MongoRegex(string.Format("{0}"' value)));                          break;                      default:                          throw new NotSupportedException(string.Format("The string method {0} is not supported."' m.Method.Name));                  }                    PopConditionScope();                  return m;              }              else if (m.Method.DeclaringType == typeof(Regex))              {                  if (m.Method.Name == "IsMatch")                  {                      field = m.Arguments[0] as FieldExpression;                      if (field == null)                          throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                        VisitPredicate(field' true);                      string value;                      if (m.Object == null)                          value = EvaluateConstant<string>(m.Arguments[1]);                      else                          throw new InvalidQueryException(string.Format("Only the static Regex.IsMatch is supported."' m.Method.Name));                        var regexOptions = RegexOptions.None;                      if (m.Arguments.Count > 2)                          regexOptions = EvaluateConstant<RegexOptions>(m.Arguments[2]);                        AddCondition(new MongoRegex(value' regexOptions));                      PopConditionScope();                      return m;                  }              }
Magic Number,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  switch (m.Method.Name)                  {                      case "Any":                          if(m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Any method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          PushConditionScope("$elemMatch");                          VisitPredicate(m.Arguments[1]' true);                          PopConditionScope(); //elemMatch                          PopConditionScope(); //field                          return m;                        case "Contains":                          if (m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Contains method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field != null)                          {                              VisitPredicate(field' true);                              AddCondition(EvaluateConstant<object>(m.Arguments[1]));                              PopConditionScope();                              return m;                          }                            field = m.Arguments[1] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Arguments[0]));                          PopConditionScope();                          return m;                      case "Count":                          if (m.Arguments.Count == 1)                          {                              Visit(m.Arguments[0]);                              PushConditionScope("$size");                              return m;                          }                          throw new NotSupportedException("The method Count with a predicate is not supported for field.");                  }              }              else if(typeof(ICollection<>).IsOpenTypeAssignableFrom(m.Method.DeclaringType) || typeof(IList).IsAssignableFrom(m.Method.DeclaringType))              {                  switch(m.Method.Name)                  {                      case "Contains":                          field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException(string.Format("The mongo field must be the argument in method {0}."' m.Method.Name));                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Object).OfType<object>().ToArray());                          PopConditionScope();                          return m;                  }              }              else if (m.Method.DeclaringType == typeof(string))              {                  field = m.Object as FieldExpression;                  if (field == null)                      throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                  VisitPredicate(field' true);                    var value = EvaluateConstant<string>(m.Arguments[0]);                                    switch(m.Method.Name)                  {                      case "StartsWith":                          AddCondition(new MongoRegex(string.Format("^{0}"' value)));                          break;                      case "EndsWith":                          AddCondition(new MongoRegex(string.Format("{0}$"' value)));                          break;                      case "Contains":                          AddCondition(new MongoRegex(string.Format("{0}"' value)));                          break;                      default:                          throw new NotSupportedException(string.Format("The string method {0} is not supported."' m.Method.Name));                  }                    PopConditionScope();                  return m;              }              else if (m.Method.DeclaringType == typeof(Regex))              {                  if (m.Method.Name == "IsMatch")                  {                      field = m.Arguments[0] as FieldExpression;                      if (field == null)                          throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                        VisitPredicate(field' true);                      string value;                      if (m.Object == null)                          value = EvaluateConstant<string>(m.Arguments[1]);                      else                          throw new InvalidQueryException(string.Format("Only the static Regex.IsMatch is supported."' m.Method.Name));                        var regexOptions = RegexOptions.None;                      if (m.Arguments.Count > 2)                          regexOptions = EvaluateConstant<RegexOptions>(m.Arguments[2]);                        AddCondition(new MongoRegex(value' regexOptions));                      PopConditionScope();                      return m;                  }              }
Magic Number,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The following statement contains a magic number: if (m.Method.DeclaringType == typeof(Queryable) || m.Method.DeclaringType == typeof(Enumerable))              {                  switch (m.Method.Name)                  {                      case "Any":                          if(m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Any method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          PushConditionScope("$elemMatch");                          VisitPredicate(m.Arguments[1]' true);                          PopConditionScope(); //elemMatch                          PopConditionScope(); //field                          return m;                        case "Contains":                          if (m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Contains method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field != null)                          {                              VisitPredicate(field' true);                              AddCondition(EvaluateConstant<object>(m.Arguments[1]));                              PopConditionScope();                              return m;                          }                            field = m.Arguments[1] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Arguments[0]));                          PopConditionScope();                          return m;                      case "Count":                          if (m.Arguments.Count == 1)                          {                              Visit(m.Arguments[0]);                              PushConditionScope("$size");                              return m;                          }                          throw new NotSupportedException("The method Count with a predicate is not supported for field.");                  }              }              else if(typeof(ICollection<>).IsOpenTypeAssignableFrom(m.Method.DeclaringType) || typeof(IList).IsAssignableFrom(m.Method.DeclaringType))              {                  switch(m.Method.Name)                  {                      case "Contains":                          field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException(string.Format("The mongo field must be the argument in method {0}."' m.Method.Name));                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Object).OfType<object>().ToArray());                          PopConditionScope();                          return m;                  }              }              else if (m.Method.DeclaringType == typeof(string))              {                  field = m.Object as FieldExpression;                  if (field == null)                      throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                  VisitPredicate(field' true);                    var value = EvaluateConstant<string>(m.Arguments[0]);                                    switch(m.Method.Name)                  {                      case "StartsWith":                          AddCondition(new MongoRegex(string.Format("^{0}"' value)));                          break;                      case "EndsWith":                          AddCondition(new MongoRegex(string.Format("{0}$"' value)));                          break;                      case "Contains":                          AddCondition(new MongoRegex(string.Format("{0}"' value)));                          break;                      default:                          throw new NotSupportedException(string.Format("The string method {0} is not supported."' m.Method.Name));                  }                    PopConditionScope();                  return m;              }              else if (m.Method.DeclaringType == typeof(Regex))              {                  if (m.Method.Name == "IsMatch")                  {                      field = m.Arguments[0] as FieldExpression;                      if (field == null)                          throw new InvalidQueryException(string.Format("The mongo field must be the operator for a string operation of type {0}."' m.Method.Name));                        VisitPredicate(field' true);                      string value;                      if (m.Object == null)                          value = EvaluateConstant<string>(m.Arguments[1]);                      else                          throw new InvalidQueryException(string.Format("Only the static Regex.IsMatch is supported."' m.Method.Name));                        var regexOptions = RegexOptions.None;                      if (m.Arguments.Count > 2)                          regexOptions = EvaluateConstant<RegexOptions>(m.Arguments[2]);                        AddCondition(new MongoRegex(value' regexOptions));                      PopConditionScope();                      return m;                  }              }
Magic Number,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,Generate,The following statement contains a magic number: var oid = new byte[12];
Magic Number,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(time' 0' oid' copyidx' 4);
Magic Number,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,Generate,The following statement contains a magic number: copyidx += 4;
Magic Number,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(_machineHash' 0' oid' copyidx' 3);
Magic Number,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,Generate,The following statement contains a magic number: copyidx += 3;
Magic Number,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(_procId' 2' oid' copyidx' 2);
Magic Number,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(_procId' 2' oid' copyidx' 2);
Magic Number,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,Generate,The following statement contains a magic number: copyidx += 2;
Magic Number,MongoDB.Util,OidGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\OidGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(inc' 1' oid' copyidx' 3);
Magic Number,MongoDB.Util,ErrorTranslator,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\ErrorTranslator.cs,GetErrorNumber,The following statement contains a magic number: if(message.StartsWith("E"))                  return message.Substring(1' 5);
Magic Number,MongoDB.Configuration.IdGenerators,GuidCombGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\IdGenerators\GuidCombGenerator.cs,Generate,The following statement contains a magic number: var baseDate = new DateTime(1900' 1' 1);
Magic Number,MongoDB.Configuration.IdGenerators,GuidCombGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\IdGenerators\GuidCombGenerator.cs,Generate,The following statement contains a magic number: var msecsArray = BitConverter.GetBytes((long)(msecs.TotalMilliseconds / 3.333333));
Magic Number,MongoDB.Configuration.IdGenerators,GuidCombGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\IdGenerators\GuidCombGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(daysArray' daysArray.Length - 2' guidArray' guidArray.Length - 6' 2);
Magic Number,MongoDB.Configuration.IdGenerators,GuidCombGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\IdGenerators\GuidCombGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(daysArray' daysArray.Length - 2' guidArray' guidArray.Length - 6' 2);
Magic Number,MongoDB.Configuration.IdGenerators,GuidCombGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\IdGenerators\GuidCombGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(daysArray' daysArray.Length - 2' guidArray' guidArray.Length - 6' 2);
Magic Number,MongoDB.Configuration.IdGenerators,GuidCombGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\IdGenerators\GuidCombGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(msecsArray' msecsArray.Length - 4' guidArray' guidArray.Length - 4' 4);
Magic Number,MongoDB.Configuration.IdGenerators,GuidCombGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\IdGenerators\GuidCombGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(msecsArray' msecsArray.Length - 4' guidArray' guidArray.Length - 4' 4);
Magic Number,MongoDB.Configuration.IdGenerators,GuidCombGenerator,C:\repos\samus_mongodb-csharp\source\MongoDB\Configuration\IdGenerators\GuidCombGenerator.cs,Generate,The following statement contains a magic number: Array.Copy(msecsArray' msecsArray.Length - 4' guidArray' guidArray.Length - 4' 4);
Magic Number,MongoDB.Protocol,DeleteMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\DeleteMessage.cs,CalculateBodySize,The following statement contains a magic number: var size = 8;
Magic Number,MongoDB.Protocol,GetMoreMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\GetMoreMessage.cs,CalculateBodySize,The following statement contains a magic number: var size = 4;
Magic Number,MongoDB.Protocol,GetMoreMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\GetMoreMessage.cs,CalculateBodySize,The following statement contains a magic number: size += 12;
Magic Number,MongoDB.Protocol,InsertMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\InsertMessage.cs,CalculateBaseSize,The following statement contains a magic number: var size = 4;
Magic Number,MongoDB.Protocol,KillCursorsMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\KillCursorsMessage.cs,CalculateBodySize,The following statement contains a magic number: var size = 8;
Magic Number,MongoDB.Protocol,KillCursorsMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\KillCursorsMessage.cs,CalculateBodySize,The following statement contains a magic number: size += (CursorIds.Length*8);
Magic Number,MongoDB.Protocol,MessageHeader,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\MessageHeader.cs,MessageHeader,The following statement contains a magic number: MessageLength = 16;
Magic Number,MongoDB.Protocol,QueryMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\QueryMessage.cs,CalculateBodySize,The following statement contains a magic number: var size = 12;
Magic Number,MongoDB.Protocol,ReplyMessage<T>,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\ReplyMessage.cs,Read,The following statement contains a magic number: stream = new BufferedStream(stream' 256);
Magic Number,MongoDB.Protocol,UpdateMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\UpdateMessage.cs,CalculateBodySize,The following statement contains a magic number: var size = 4;
Magic Number,MongoDB.Protocol,UpdateMessage,C:\repos\samus_mongodb-csharp\source\MongoDB\Protocol\UpdateMessage.cs,CalculateBodySize,The following statement contains a magic number: size += 4;
Missing Default,MongoDB.Bson,BsonWriter,C:\repos\samus_mongodb-csharp\source\MongoDB\Bson\BsonWriter.cs,CalculateSize,The following switch statement is missing a default case: switch(TranslateToBsonType(obj))              {                  case BsonType.MinKey:                  case BsonType.MaxKey:                  case BsonType.Null:                      return 0;                  case BsonType.Boolean:                      return 1;                  case BsonType.Integer:                      return 4;                  case BsonType.Long:                  case BsonType.Date:                      return 8;                  case BsonType.Oid:                      return 12;                  case BsonType.Number:                      return sizeof(Double);                  case BsonType.String:                      if(obj is string)                          return CalculateSize((string)obj);                      return CalculateSize(obj.ToString());                  case BsonType.Obj:                      return obj.GetType() == typeof(DBRef) ? CalculateSize((DBRef)obj) : CalculateSizeObject(obj);                  case BsonType.Array:                      return CalculateSize((IEnumerable)obj);                  case BsonType.Regex:                      if(obj is Regex)                          return CalculateSize(new MongoRegex((Regex)obj));                      return CalculateSize((MongoRegex)obj);                  case BsonType.Code:                      return CalculateSize((Code)obj);                  case BsonType.CodeWScope:                      return CalculateSize((CodeWScope)obj);                  case BsonType.Binary:                  {                      if(obj is Guid)                          return CalculateSize((Guid)obj);                      if(obj is byte[])                          return CalculateSize((byte[])obj);                        return CalculateSize((Binary)obj);                  }                  case BsonType.Symbol:                      return CalculateSize(((MongoSymbol)obj).Value' true);              }
Missing Default,MongoDB.Linq.Expressions,MongoExpressionComparer,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Expressions\MongoExpressionComparer.cs,CompareSubquery,The following switch statement is missing a default case: switch ((MongoExpressionType)a.NodeType)              {                  case MongoExpressionType.Scalar:                      return CompareScalar((ScalarExpression)a' (ScalarExpression)b);              }
Missing Default,MongoDB.Linq.Expressions,MongoExpressionVisitor,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Expressions\MongoExpressionVisitor.cs,VisitSubquery,The following switch statement is missing a default case: switch ((MongoExpressionType)subquery.NodeType)              {                  case MongoExpressionType.Scalar:                      return VisitScalar((ScalarExpression)subquery);              }
Missing Default,MongoDB.Linq.Translators,MapReduceFinalizerFunctionBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\MapReduceFinalizerFunctionBuilder.cs,VisitAggregate,The following switch statement is missing a default case: switch (aggregate.AggregateType)              {                  case AggregateType.Average:                      _returnValues.Add(new KeyValuePair<string' string>(_currentAggregateName' string.Format("value.{0}Sum/value.{0}Cnt"' _currentAggregateName)));                      break;                  case AggregateType.Count:                  case AggregateType.Max:                  case AggregateType.Min:                  case AggregateType.Sum:                      _returnValues.Add(new KeyValuePair<string' string>(_currentAggregateName' "value." + _currentAggregateName));                      break;              }
Missing Default,MongoDB.Linq.Translators,MapReduceReduceFunctionBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\MapReduceReduceFunctionBuilder.cs,VisitAggregate,The following switch statement is missing a default case: switch (aggregate.AggregateType)              {                  case AggregateType.Average:                      AverageAggregate(aggregate);                      break;                  case AggregateType.Count:                      CountAggregate(aggregate);                      break;                  case AggregateType.Max:                      MaxAggregate(aggregate);                      break;                  case AggregateType.Min:                      MinAggregate(aggregate);                      break;                  case AggregateType.Sum:                      SumAggregate(aggregate);                      break;              }
Missing Default,MongoDB.Linq.Translators,JavascriptFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\JavascriptFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name)                  {                      case "Count":                          if (m.Arguments.Count == 1)                          {                              Visit(m.Arguments[0]);                              _js.Append(".length");                              return m;                          }                          throw new NotSupportedException("The method Count with a predicate is not supported for field.");                  }
Missing Default,MongoDB.Linq.Translators,JavascriptFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\JavascriptFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch(m.Arguments.Count)                          {                              case 1:                                  _js.AppendFormat(".substr({0})"' EvaluateConstant<int>(m.Arguments[0]));                                  break;                              case 2:                                  _js.AppendFormat(".substr({0})"' EvaluateConstant<int>(m.Arguments[0])' EvaluateConstant<int>(m.Arguments[1]));                                  break;                          }
Missing Default,MongoDB.Linq.Translators,MapReduceMapFunctionBuilder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\MapReduceMapFunctionBuilder.cs,VisitAggregate,The following switch statement is missing a default case: switch (aggregate.AggregateType)              {                  case AggregateType.Average:                      _initMap[_currentAggregateName + "Sum"] = _formatter.FormatJavascript(aggregate.Argument);                      _initMap[_currentAggregateName + "Cnt"] = "1";                      break;                  case AggregateType.Count:                      _initMap[_currentAggregateName] = "1";                      break;                  case AggregateType.Max:                  case AggregateType.Min:                  case AggregateType.Sum:                      _initMap[_currentAggregateName] = _formatter.FormatJavascript(aggregate.Argument);                      break;              }
Missing Default,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitBinary,The following switch statement is missing a default case: switch (nodeType)              {                  case ExpressionType.LessThan:                      nodeType = ExpressionType.GreaterThanOrEqual;                      shouldFlip = true;                      break;                  case ExpressionType.LessThanOrEqual:                      nodeType = ExpressionType.GreaterThan;                      shouldFlip = true;                      break;                  case ExpressionType.GreaterThan:                      nodeType = ExpressionType.LessThanOrEqual;                      shouldFlip = true;                      break;                  case ExpressionType.GreaterThanOrEqual:                      nodeType = ExpressionType.LessThan;                      shouldFlip = true;                      break;                  case ExpressionType.NotEqual:                      shouldFlip = true;                      break;                  case ExpressionType.Equal:                      shouldFlip = true;                      break;              }
Missing Default,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMemberAccess,The following switch statement is missing a default case: switch (source.NodeType)              {                  case ExpressionType.MemberInit:                      var init = (MemberInitExpression)source;                      for (int i = 0' n = init.Bindings.Count; i < n; i++)                      {                          var ma = init.Bindings[i] as MemberAssignment;                          if (ma != null && MembersMatch(ma.Member' m.Member))                              return ma.Expression;                      }                      break;                  case ExpressionType.New:                      var nex = (NewExpression)source;                      if (nex.Members != null)                      {                          for (int i = 0' n = nex.Members.Count; i < n; i++)                          {                              if (MembersMatch(nex.Members[i]' m.Member))                                  return nex.Arguments[i];                          }                      }                      break;              }
Missing Default,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name)                      {                          case "Any":                              if (m.Arguments.Count == 1)                                  return BindAny(m.Arguments[0]' null' m == _root);                              else                                  return BindAny(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' m == _root);                          case "Where":                              return BindWhere(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "Select":                              return BindSelect(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1]));                          case "OrderBy":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "OrderByDescending":                              return BindOrderBy(m.Type' m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "ThenBy":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Ascending);                          case "ThenByDescending":                              return BindThenBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' OrderType.Descending);                          case "Take":                              if (m.Arguments.Count == 2)                                  return this.BindTake(m.Arguments[0]' m.Arguments[1]);                              break;                          case "Skip":                              if (m.Arguments.Count == 2)                                  return this.BindSkip(m.Arguments[0]' m.Arguments[1]);                              break;                          case "First":                          case "FirstOrDefault":                          case "Single":                          case "SingleOrDefault":                              if (m.Arguments.Count == 1)                                  return BindFirstOrSingle(m.Arguments[0]' null' m.Method.Name' m == _root);                              if (m.Arguments.Count == 2)                              {                                  var predicate = (LambdaExpression)StripQuotes(m.Arguments[1]);                                  return BindFirstOrSingle(m.Arguments[0]' predicate' m.Method.Name' m == _root);                              }                              break;                          case "Count":                          case "Sum":                          case "Average":                          case "Min":                          case "Max":                              switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }                              break;                          case "GroupBy":                              if (m.Arguments.Count == 2)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' null' null);                              if (m.Arguments.Count == 3)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' null);                              if (m.Arguments.Count == 4)                                  return BindGroupBy(m.Arguments[0]' (LambdaExpression)StripQuotes(m.Arguments[1])' (LambdaExpression)StripQuotes(m.Arguments[2])' (LambdaExpression)StripQuotes(m.Arguments[3]));                              break;                      }
Missing Default,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,VisitMethodCall,The following switch statement is missing a default case: switch(m.Arguments.Count)                              {                                  case 1:                                      return BindAggregate(m.Arguments[0]' m.Method' null' m == _root);                                  case 2:                                  {                                      var argument = (LambdaExpression)StripQuotes(m.Arguments[1]);                                      return BindAggregate(m.Arguments[0]' m.Method' argument' m == _root);                                  }                              }
Missing Default,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,ConvertToSequence,The following switch statement is missing a default case: switch (expression.NodeType)              {                  case (ExpressionType)MongoExpressionType.Projection:                      return (ProjectionExpression)expression;                  case ExpressionType.New:                      var newExpression = (NewExpression)expression;                      if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition() == typeof(Grouping<'>))                          return (ProjectionExpression)newExpression.Arguments[1];                      break;              }
Missing Default,MongoDB.Linq.Translators,QueryBinder,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\QueryBinder.cs,GetAggregateType,The following switch statement is missing a default case: switch (methodName)              {                  case "Count":                      return AggregateType.Count;                  case "Sum":                      return AggregateType.Sum;                  case "Average":                      return AggregateType.Average;                  case "Min":                      return AggregateType.Min;                  case "Max":                      return AggregateType.Max;              }
Missing Default,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch (m.Method.Name)                  {                      case "Any":                          if(m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Any method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          PushConditionScope("$elemMatch");                          VisitPredicate(m.Arguments[1]' true);                          PopConditionScope(); //elemMatch                          PopConditionScope(); //field                          return m;                        case "Contains":                          if (m.Arguments.Count != 2)                              throw new NotSupportedException("Only the Contains method with 2 arguments is supported.");                            field = m.Arguments[0] as FieldExpression;                          if (field != null)                          {                              VisitPredicate(field' true);                              AddCondition(EvaluateConstant<object>(m.Arguments[1]));                              PopConditionScope();                              return m;                          }                            field = m.Arguments[1] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException("A mongo field must be a part of the Contains method.");                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Arguments[0]));                          PopConditionScope();                          return m;                      case "Count":                          if (m.Arguments.Count == 1)                          {                              Visit(m.Arguments[0]);                              PushConditionScope("$size");                              return m;                          }                          throw new NotSupportedException("The method Count with a predicate is not supported for field.");                  }
Missing Default,MongoDB.Linq.Translators,DocumentFormatter,C:\repos\samus_mongodb-csharp\source\MongoDB\Linq\Translators\DocumentFormatter.cs,VisitMethodCall,The following switch statement is missing a default case: switch(m.Method.Name)                  {                      case "Contains":                          field = m.Arguments[0] as FieldExpression;                          if (field == null)                              throw new InvalidQueryException(string.Format("The mongo field must be the argument in method {0}."' m.Method.Name));                          VisitPredicate(field' true);                          AddCondition("$in"' EvaluateConstant<IEnumerable>(m.Object).OfType<object>().ToArray());                          PopConditionScope();                          return m;                  }
Missing Default,MongoDB.Util,ReflectionExtensions,C:\repos\samus_mongodb-csharp\source\MongoDB\Util\ReflectionExtensions.cs,GetReturnType,The following switch statement is missing a default case: switch (member.MemberType)              {                  case MemberTypes.Field:                      return ((FieldInfo)member).FieldType;                  case MemberTypes.Property:                      return ((PropertyInfo)member).PropertyType;                  case MemberTypes.Method:                      return ((MethodInfo)member).ReturnType;              }
